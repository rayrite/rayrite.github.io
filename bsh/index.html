<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>BSH Game - Physics Puzzle Game v14 - Unified PixiJS System</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }

        html {
            overflow: hidden; /* Prevent scrolling on the game */
            height: 100%;
        }

        @import url('https://fonts.googleapis.com/css2?family=Fredoka:wght@400;500;600;700&display=swap');
        
        body {
            font-family: 'Fredoka', sans-serif;
            background: linear-gradient(135deg, #87CEEB 0%, #98FB98 100%);
            height: 100vh;
            height: 100dvh; /* Dynamic viewport height for mobile */
            overflow: hidden; /* Prevent scrolling */
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* New Responsive Game Viewport */
        .game-viewport {
            width: 100vw;
            height: 100vh;
            height: 100dvh;
            display: flex;
            flex-direction: column;
            max-width: min(100vw, 500px); /* Cap width at 500px on desktop */
            max-height: min(100vh, 889px); /* 500 * 16/9 for aspect ratio */
            margin: 0 auto;
            background: linear-gradient(135deg, #FF6B6B 0%, #4ECDC4 100%);
            position: relative;
            aspect-ratio: 9/16;
            overflow: visible; /* Allow dragged elements to extend beyond viewport */
            box-shadow: 0 0 50px rgba(0,0,0,0.3);
        }

        /* Border system for larger screens */
        @media (min-width: 501px) {
            body {
                background: linear-gradient(135deg, #87CEEB 0%, #98FB98 100%);
                padding: 20px;
            }
            
            .game-viewport {
                border-radius: 20px;
                box-shadow: 0 10px 50px rgba(0,0,0,0.4);
            }
        }

        /* Game HUD - Top Section */
        .game-hud {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: clamp(70px, 12vh, 90px); /* Responsive height */
            background: linear-gradient(135deg, #FF6B6B 0%, #4ECDC4 100%);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: clamp(6px, 2vw, 15px); /* Responsive padding */
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 100;
        }

        /* Left Section - Score and Star Meter */
        .left-section {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            color: white;
            font-weight: bold;
            justify-content: space-between;
            height: 100%;
            min-width: 0; /* Prevent flex overflow */
        }

        .score-display {
            display: flex;
            align-items: center;
            gap: clamp(4px, 1.5vw, 8px); /* Responsive gap */
            margin-bottom: 3px;
        }

        .trophy-icon {
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
            width: clamp(18px, 4vw, 24px); /* Responsive icon size */
            height: clamp(18px, 4vw, 24px);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(8px, 2vw, 12px); /* Responsive font */
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            border: 2px solid #B8860B;
            flex-shrink: 0; /* Prevent shrinking */
        }

        .score-text {
            font-size: clamp(14px, 4vw, 18px); /* Responsive font size */
            font-weight: 700;
            color: #FFE4B5;
            text-shadow: 0 2px 4px rgba(0,0,0,0.4);
            white-space: nowrap; /* Prevent text wrapping */
        }

        .star-progress-container {
            position: relative;
            width: clamp(100px, 25vw, 140px); /* Responsive width */
            height: clamp(14px, 3vw, 18px); /* Responsive height */
            background: rgba(255,255,255,0.25);
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.3);
            overflow: hidden;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.3);
            cursor: pointer; /* Indicate interactivity */
        }

        .progress-area {
            position: relative;
            width: clamp(100px, 25vw, 140px); /* Match container width */
            height: clamp(28px, 6vw, 36px); /* Responsive height for better touch */
        }

        .star-progress-container {
            margin-top: clamp(12px, 3vw, 18px); /* Responsive margin */
        }

        .star-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #8B5CF6 0%, #A855F7 50%, #C084FC 100%);
            border-radius: 7px;
            transition: width 0.8s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            box-shadow: 0 0 6px rgba(139, 92, 246, 0.6);
        }

        /* White progress markers inside the bar */
        .progress-markers {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 100%;
            pointer-events: none;
            z-index: 2;
        }

        .progress-marker {
            position: absolute;
            top: 0;
            width: 2px;
            height: 100%;
            background: rgba(255,255,255,0.8);
            border-radius: 1px;
        }

        .progress-marker:nth-child(1) {
            left: 33.33%;
            transform: translateX(-50%);
        }

        .progress-marker:nth-child(2) {
            left: 66.66%;
            transform: translateX(-50%);
        }

        .progress-marker:nth-child(3) {
            left: 90%;
            transform: translateX(-50%);
        }

        .star-markers {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 16px;
            width: 120px;
            pointer-events: none;
            z-index: 10;
        }

        .star {
            width: 14px;
            height: 14px;
            background: rgba(255,255,255,0.3);
            clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%);
            box-shadow: 0 2px 6px rgba(0,0,0,0.5);
            border: 1px solid rgba(255,255,255,0.6);
            transition: all 0.5s ease;
            position: absolute;
        }

        /* Position stars directly above the white markers */
        .star:nth-child(1) {
            left: 33.33%;
            transform: translateX(-50%);
        }

        .star:nth-child(2) {
            left: 66.66%;
            transform: translateX(-50%);
        }

        .star:nth-child(3) {
            left: 90%;
            transform: translateX(-50%);
        }

        .star.filled {
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
            border: 2px solid #B8860B;
            transform: translateX(-50%) scale(1.3);
            box-shadow: 0 0 20px rgba(255, 215, 0, 1), 0 2px 6px rgba(0,0,0,0.6);
            animation: starPulse 0.5s ease-out;
            z-index: 15;
        }

        /* Middle Section - Timer */
        .middle-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            gap: clamp(3px, 1vw, 6px); /* Responsive gap */
            min-width: 0; /* Prevent overflow */
        }

        /* Level Display */
        .level-display {
            font-size: clamp(11px, 3vw, 14px); /* Responsive font size */
            font-weight: 600;
            color: #FFE4B5;
            text-shadow: 0 1px 2px rgba(0,0,0,0.4);
            background: rgba(0,0,0,0.15);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            padding: clamp(3px, 1vw, 6px) clamp(6px, 2vw, 10px); /* Responsive padding */
            min-width: clamp(50px, 12vw, 70px); /* Responsive min-width */
            text-align: center;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
            white-space: nowrap;
        }

        .timer-container {
            background: rgba(0,0,0,0.2);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 12px;
            padding: clamp(6px, 2vw, 10px) clamp(8px, 3vw, 14px); /* Responsive padding */
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: clamp(60px, 15vw, 80px); /* Responsive min-width */
            min-height: 44px; /* Minimum touch target */
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }

        .timer-container:hover {
            background: rgba(0,0,0,0.3);
            transform: translateY(-1px);
        }

        .timer-text {
            font-size: clamp(12px, 3.5vw, 16px); /* Responsive font size */
            font-weight: 600;
            color: #FFE4B5;
            text-shadow: 0 1px 2px rgba(0,0,0,0.4);
            font-variant-numeric: tabular-nums;
            transition: all 0.3s ease;
            white-space: nowrap;
        }

        .timer-text.timer-warning {
            color: #FFA500;
            text-shadow: 0 0 10px rgba(255, 165, 0, 0.6);
        }

        .timer-text.timer-critical {
            color: #FF4444;
            text-shadow: 0 0 15px rgba(255, 68, 68, 0.8);
            animation: timerPulse 1s infinite;
        }

        @keyframes timerPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        /* Right Section - Settings, Reset, and Coins */
        .right-section {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            justify-content: space-between;
            height: 100%;
            min-width: 0; /* Prevent overflow */
        }

        .top-buttons {
            display: flex;
            gap: clamp(6px, 2vw, 10px); /* Responsive gap */
            align-items: center;
            flex-wrap: wrap; /* Allow wrapping on very small screens */
        }

        .settings-button, .reset-button {
            width: clamp(32px, 8vw, 44px); /* Responsive size with 44px max for touch */
            height: clamp(32px, 8vw, 44px);
            min-width: 44px; /* Minimum touch target */
            min-height: 44px;
            background: rgba(0,0,0,0.2);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            color: #FFE4B5;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            position: relative;
        }

        /* Theme cycling button */
        .theme-button {
            width: clamp(32px, 8vw, 44px);
            height: clamp(32px, 8vw, 44px);
            min-width: 44px;
            min-height: 44px;
            background: linear-gradient(135deg, #4ECDC4 0%, #44A08D 100%);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            color: white;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            position: relative;
            font-size: clamp(16px, 4vw, 20px);
        }

        .theme-button:hover {
            background: linear-gradient(135deg, #44A08D 0%, #4ECDC4 100%);
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(0,0,0,0.4);
        }

        .theme-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }

        .settings-button:hover, .reset-button:hover {
            background: rgba(0,0,0,0.3);
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(0,0,0,0.4);
        }

        .settings-button:active, .reset-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }

        .reset-icon {
            width: clamp(12px, 3vw, 16px); /* Responsive icon size */
            height: clamp(12px, 3vw, 16px);
            color: #FFE4B5;
            font-size: clamp(10px, 3vw, 14px); /* Responsive font */
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .pause-icon {
            width: clamp(12px, 3vw, 16px);
            height: clamp(12px, 3vw, 16px);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 2px;
        }

        .pause-bar {
            width: 3px;
            height: clamp(10px, 3vw, 14px); /* Responsive height */
            background: #FFE4B5;
            border-radius: 1px;
        }

        .coin-counter {
            display: flex;
            align-items: center;
            gap: clamp(4px, 1.5vw, 7px); /* Responsive gap */
            background: rgba(0,0,0,0.2);
            padding: clamp(4px, 1.5vw, 7px) clamp(8px, 2.5vw, 12px); /* Responsive padding */
            border-radius: 10px;
            border: 1px solid rgba(255,255,255,0.2);
            cursor: pointer;
            transition: all 0.3s ease;
            min-height: 44px; /* Minimum touch target */
            min-width: 60px; /* Minimum width for readability */
        }

        .coin-counter:hover {
            background: rgba(0,0,0,0.3);
            transform: translateY(-1px);
        }

        .coin-icon {
            width: clamp(14px, 4vw, 18px); /* Responsive icon size */
            height: clamp(14px, 4vw, 18px);
            font-size: clamp(10px, 3vw, 14px); /* Responsive font */
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .coin-amount {
            font-size: clamp(12px, 3.5vw, 16px); /* Responsive font size */
            font-weight: 600;
            color: #FFE4B5;
            text-shadow: 0 1px 2px rgba(0,0,0,0.4);
            white-space: nowrap; /* Prevent text wrapping */
        }

        /* Timer Mode Indicator */
        .timer-mode-indicator {
            position: absolute;
            top: -5px;
            right: -5px;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            font-size: 8px;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            border: 1px solid rgba(255,255,255,0.3);
        }

        .timer-mode-elapsed {
            background: linear-gradient(135deg, #8B5CF6 0%, #7C3AED 100%);
        }

        .timer-mode-countdown {
            background: linear-gradient(135deg, #EF4444 0%, #DC2626 100%);
        }

        .timer-mode-endlevel {
            background: linear-gradient(135deg, #10B981 0%, #059669 100%);
        }

        /* Docking Area - Shape Selection */
        .docking-area {
            position: absolute;
            top: clamp(70px, 12vh, 90px); /* Match HUD height */
            left: 0;
            right: 0;
            height: clamp(120px, 20vh, 160px); /* Responsive height */
            background: #34495e;
            display: grid;
            grid-template-columns: repeat(5, 1fr); /* Equal column distribution */
            grid-template-rows: repeat(2, 1fr); /* Equal row distribution */
            gap: clamp(4px, 1.5vw, 10px); /* Responsive gap */
            padding: clamp(4px, 2vw, 8px); /* Responsive padding */
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            z-index: 50;
            align-items: center;
            justify-items: center;
            overflow: visible; /* Allow shapes to extend beyond docking area */
        }

        .shape-slot {
            width: 100%;
            height: 100%;
            min-width: clamp(50px, 12vw, 70px); /* Responsive minimum size */
            min-height: clamp(50px, 12vw, 70px);
            max-width: 80px; /* Prevent too large on desktop */
            max-height: 80px;
            background: rgba(255,255,255,0.1);
            border: 2px dashed rgba(255,255,255,0.3);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            transition: all 0.3s ease;
            padding: 0;
            margin: 0;
            overflow: visible;
            box-sizing: border-box;
            cursor: pointer; /* Indicate interactivity */
        }

        .shape-slot:hover {
            background: rgba(255,255,255,0.15);
            border-color: rgba(255,255,255,0.5);
            transform: scale(1.05);
        }

        .shape-slot.empty {
            border-color: rgba(255,255,255,0.1);
            background: rgba(255,255,255,0.05);
        }

        .shape-slot.empty:hover {
            border-color: rgba(255,255,255,0.2);
            background: rgba(255,255,255,0.1);
        }

        .game-shape {
            cursor: grab;
            transition: all 0.3s ease;
            position: relative;
            z-index: 60;
            width: 100%; /* Fill slot */
            height: 100%;
            min-width: 44px; /* Minimum touch target */
            min-height: 44px;
        }

        .game-shape:active {
            cursor: grabbing;
            transform: scale(1.15); /* Slightly larger feedback on touch */
            filter: drop-shadow(0 5px 15px rgba(0,0,0,0.4));
            transition: all 0.1s ease; /* Quick response for touch */
        }

        .game-shape:hover {
            transform: scale(1.1);
            filter: drop-shadow(0 3px 10px rgba(0,0,0,0.3));
        }

        .game-shape.dragging {
            z-index: 1000;
            transform: scale(1.2); /* Slightly larger when dragging */
            filter: drop-shadow(0 8px 20px rgba(0,0,0,0.4));
        }

        /* Enhanced touch feedback for mobile */
        @media (pointer: coarse) {
            .game-shape {
                transition: all 0.2s ease; /* Longer transitions on touch devices */
            }
            
            .game-shape:active {
                transform: scale(1.2); /* Larger feedback on touch devices */
                transition: all 0.05s ease; /* Very quick response */
            }
            
            .shape-slot:active {
                background: rgba(255,255,255,0.2);
                border-color: rgba(255,255,255,0.7);
                transform: scale(1.02);
                transition: all 0.05s ease;
            }
        }
        
        /* End Level Countdown - 3 Dot Display */
        .countdown-dots {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            padding: 8px 12px;
        }

        .countdown-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: rgba(255,255,255,0.3);
            transition: all 0.3s ease;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }

        .countdown-dot.active {
            background: linear-gradient(135deg, #10B981 0%, #059669 100%);
            transform: scale(1.7);
            box-shadow: 0 0 12px rgba(16, 185, 129, 0.8);
            animation: dotPulse 0.6s ease-in-out;
        }

        .countdown-dot.completed {
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
            transform: scale(1.8);
            box-shadow: 0 0 8px rgba(255, 215, 0, 0.6);
        }

        @keyframes dotPulse {
            0%, 100% { transform: scale(1.3); }
            50% { transform: scale(1.6); }
        }

        /* Particle Effects */
        .particle {
            position: fixed;
            pointer-events: none;
            z-index: 9999;
            font-size: 14px;
            font-weight: bold;
            opacity: 1;
            animation: particleFloat 2s ease-out forwards;
        }

        @keyframes particleFloat {
            0% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
            100% {
                opacity: 0;
                transform: translateY(-40px) scale(0);
            }
        }

        @keyframes starBurst {
            0% {
                opacity: 1;
                transform: scale(0) rotate(0deg);
            }
            50% {
                opacity: 0.8;
                transform: scale(1.5) rotate(180deg);
            }
            100% {
                opacity: 0;
                transform: scale(2) rotate(360deg);
            }
        }

        .progress-animate {
            animation: progressPulse 0.8s ease-out;
        }

        @keyframes progressPulse {
            0% { transform: scaleY(1); }
            50% { transform: scaleY(1.1); box-shadow: 0 0 15px rgba(255, 215, 0, 0.6); }
            100% { transform: scaleY(1); }
        }

        /* Enhanced Star Animations */
        .star.filled {
            animation: starFill 0.5s ease-out;
        }

        @keyframes starFill {
            0% { transform: scale(0) rotate(0deg); opacity: 0; }
            50% { transform: scale(1.3) rotate(180deg); opacity: 1; }
            100% { transform: scale(1) rotate(360deg); opacity: 1; }
        }

        /* Score Text Animation */
        .score-text {
            transition: all 0.3s ease;
        }

        .score-text.score-increase {
            animation: scoreBoost 0.6s ease-out;
        }

        @keyframes scoreBoost {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); color: #FFD700; }
            100% { transform: scale(1); }
        }

        /* Coin Animation */
        .coin-amount {
            transition: all 0.3s ease;
        }

        .coin-amount.coin-increase {
            animation: coinBoost 0.6s ease-out;
        }

        @keyframes coinBoost {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); color: #FFD700; text-shadow: 0 0 10px #FFD700; }
            100% { transform: scale(1); }
        }

        /* Enhanced Coin Animations */
        @keyframes coinShower {
            0% { 
                transform: translateY(0) rotate(0deg); 
                opacity: 1; 
            }
            50% { 
                transform: translateY(-50px) rotate(180deg); 
                opacity: 0.8; 
            }
            100% { 
                transform: translateY(100px) rotate(360deg); 
                opacity: 0; 
            }
        }

        @keyframes coinPulse {
            0%, 100% { 
                transform: scale(1); 
                box-shadow: 0 0 5px rgba(255, 215, 0, 0.3); 
            }
            50% { 
                transform: scale(1.3); 
                box-shadow: 0 0 25px rgba(255, 215, 0, 0.8); 
            }
        }

        @keyframes coinShake {
            0%, 100% { transform: translateX(0); }
            10% { transform: translateX(-2px) rotate(-1deg); }
            20% { transform: translateX(2px) rotate(1deg); }
            30% { transform: translateX(-3px) rotate(-1deg); }
            40% { transform: translateX(3px) rotate(1deg); }
            50% { transform: translateX(-2px) rotate(-1deg); }
            60% { transform: translateX(2px) rotate(1deg); }
            70% { transform: translateX(-1px) rotate(-1deg); }
            80% { transform: translateX(1px) rotate(1deg); }
            90% { transform: translateX(-1px) rotate(-1deg); }
        }

        /* Particle Effects */
        .particle {
            position: fixed;
            pointer-events: none;
            font-size: 18px;
            font-weight: bold;
            z-index: 9999;
            animation: floatUp 2s ease-out forwards;
        }

        /* Level Complete Effects */
        @keyframes levelCompleteFlash {
            0%, 100% { filter: brightness(1); }
            25% { filter: brightness(1.3) saturate(1.2); }
            50% { filter: brightness(1.1) saturate(1.1); }
            75% { filter: brightness(1.2) saturate(1.15); }
        }

        /* Level Cleared Popup Modal */
        .level-cleared-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            opacity: 0;
            animation: modalFadeIn 0.5s ease-out forwards;
        }

        .level-cleared-content {
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
            transform: scale(0.5);
            animation: modalPopIn 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55) forwards;
        }

        .level-cleared-title {
            font-size: 48px;
            font-weight: bold;
            color: #8B4513;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            animation: titlePulse 1s ease-in-out infinite alternate;
        }

        .level-cleared-subtitle {
            font-size: 24px;
            color: #654321;
            margin-bottom: 30px;
            font-weight: 600;
        }

        .level-cleared-stars {
            font-size: 60px;
            margin: 20px 0;
            animation: starsSparkle 2s ease-in-out infinite;
        }

        .level-cleared-button {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            margin: 10px;
        }

        .level-cleared-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
        }

        @keyframes modalFadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes modalPopIn {
            from { 
                transform: scale(0.5) rotate(-10deg);
                opacity: 0;
            }
            to { 
                transform: scale(1) rotate(0deg);
                opacity: 1;
            }
        }

        @keyframes titlePulse {
            from { transform: scale(1); }
            to { transform: scale(1.05); }
        }

        @keyframes starsSparkle {
            0%, 100% { 
                transform: scale(1) rotate(0deg);
                filter: brightness(1);
            }
            50% { 
                transform: scale(1.1) rotate(5deg);
                filter: brightness(1.3);
            }
        }

        /* Global Drag Overlay - Ensure dragging works across entire viewport */
        #dragOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 9998;
            overflow: visible;
        }

        .ghost-shape {
            position: fixed !important;
            pointer-events: none !important;
            z-index: 10000 !important; /* Increased z-index */
            visibility: visible !important;
            opacity: 0.9 !important;
            display: block !important;
            transition: transform 0.2s ease-out !important;
        }

        /* Rotation Visual Feedback */
        /* Enhanced Mobile Touch Interactions */
        .game-shape {
            touch-action: none;
            cursor: grab;
            transition: transform 0.2s ease;
        }

        .game-shape:hover {
            transform: scale(1.05);
        }

        .game-shape:active {
            cursor: grabbing;
            transform: scale(1.1);
        }

        .game-shape.ghost-active {
            opacity: 0.3;
            transform: scale(0.9);
            transition: all 0.3s ease;
        }

        /* Touch Feedback */
        .touch-ripple {
            position: fixed;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.6);
            pointer-events: none;
            z-index: 9998;
            animation: rippleEffect 0.6s ease-out forwards;
        }

        @keyframes rippleEffect {
            0% { transform: scale(0); opacity: 1; }
            100% { transform: scale(4); opacity: 0; }
        }

        .rotation-indicator {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: bold;
            z-index: 10000;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .rotation-indicator.show {
            opacity: 1;
        }

        /* Enhanced Drag Feedback */
        .game-shape.ghost-active {
            opacity: 0.3;
            transform: scale(0.9);
            transition: all 0.3s ease;
        }

        /* Shape Visual Designs - REMOVED: Now using unified canvas-based system */
        /* All shape appearances now handled by PhysicsShapeRenderer and SHAPE_CONFIG */

        /* Canvas preview styling for dock */
        .shape-preview {
            width: 46px;
            height: 46px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .shape-preview:hover {
            filter: brightness(1.1);
            transform: scale(1.05);
        }

        /* Ghost effect for dragged shapes */
        .shape-preview.ghost-active {
            opacity: 0.3;
            transform: scale(0.9);
            transition: all 0.3s ease;
        }

        /* Game shape base styles for drag/drop functionality */
        .game-shape {
            display: block;
            position: relative;
        }

        .game-shape.ghost-active {
            opacity: 0.3;
        }

        /* Mode Toggle Inside HUD */
        .mode-toggle-switch {
            position: relative;
            width: 60px;
            height: 28px;
            background: rgba(52, 73, 94, 0.8);
            border-radius: 14px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .mode-toggle-switch.design-active {
            background: rgba(52, 152, 219, 0.8);
            border-color: #3498db;
        }

        .mode-toggle-slider {
            position: absolute;
            top: 2px;
            left: 2px;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
        }

        .mode-toggle-switch.design-active .mode-toggle-slider {
            transform: translateX(28px);
        }

        .mode-toggle-labels {
            position: absolute;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            white-space: nowrap;
            color: rgba(255, 255, 255, 0.8);
        }

        /* Design Mode Sidebar */
        .design-sidebar {
            position: fixed;
            top: 0;
            left: -350px;
            width: 350px;
            height: 100vh;
            background: linear-gradient(180deg, #2c3e50 0%, #34495e 100%);
            box-shadow: 5px 0 20px rgba(0,0,0,0.3);
            transition: left 0.4s ease;
            z-index: 999;
            overflow-y: auto;
            color: white;
        }

        .design-sidebar.active {
            left: 0;
        }

        .design-mode .game-viewport {
            margin-left: 350px;
            transition: margin-left 0.4s ease;
        }

        .sidebar-header {
            padding: 20px;
            background: rgba(0,0,0,0.2);
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .sidebar-title {
            font-size: 16px;
            font-weight: bold;
            color: #3498db;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .sidebar-section {
            padding: 15px 20px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .config-group {
            margin-bottom: 12px;
        }

        .config-label {
            display: block;
            font-size: 13px;
            font-weight: 500;
            margin-bottom: 5px;
            color: #bdc3c7;
        }

        .config-input, .config-select {
            width: 100%;
            padding: 8px 12px;
            background: rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 6px;
            color: white;
            font-size: 14px;
        }

        .config-input:focus, .config-select:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 5px rgba(52, 152, 219, 0.3);
        }

        .config-sub-group {
            margin-left: 20px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .config-sub-group .config-label {
            min-width: 100px;
            margin-bottom: 0;
            font-size: 12px;
        }

        .config-sub-group input[type="range"] {
            flex: 1;
            margin: 0;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
        }

        .range-value {
            min-width: 50px;
            text-align: right;
            font-size: 12px;
            color: #FFE4B5;
            font-weight: 600;
            background: rgba(0,0,0,0.2);
            padding: 2px 6px;
            border-radius: 4px;
        }

        .config-btn {
            width: 100%;
            padding: 10px;
            background: linear-gradient(135deg, #27ae60 0%, #229954 100%);
            color: white;
            border: none;
            border-radius: 6px;
            font-weight: bold;
            cursor: pointer;
            margin-top: 8px;
            transition: all 0.3s ease;
        }

        .config-btn:hover {
            background: linear-gradient(135deg, #229954 0%, #1e8449 100%);
            transform: translateY(-1px);
        }

        /* v9: Theme Selector Styles */
        .checkbox-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 8px;
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            color: #ecf0f1;
            cursor: pointer;
        }

        .checkbox-label input[type="checkbox"] {
            width: 16px;
            height: 16px;
            accent-color: #27ae60;
        }

        .theme-preview {
            width: 100%;
            height: 40px;
            border-radius: 4px;
            margin: 4px 0 8px 0;
            background: linear-gradient(135deg, #87CEEB 0%, #4ECDC4 50%, #90EE90 100%);
            border: 2px solid transparent;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .theme-preview:hover {
            border-color: #27ae60;
            transform: scale(1.02);
        }

        .theme-preview.active {
            border-color: #27ae60;
            box-shadow: 0 0 10px rgba(39, 174, 96, 0.5);
        }

        .dock-slot-config {
            background: rgba(0,0,0,0.2);
            padding: 8px;
            border-radius: 6px;
            margin-bottom: 8px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .game-canvas-container {
            position: absolute;
            top: calc(clamp(70px, 12vh, 90px) + clamp(120px, 20vh, 160px)); /* HUD + Docking height */
            left: 0;
            right: 0;
            bottom: 0; /* Use full available space */
            background: linear-gradient(135deg, #87CEEB 0%, #98FB98 100%);
            border-radius: 0;
            overflow: visible; /* Allow dragged shapes to extend beyond canvas boundaries */
        }

        #gameCanvas {
            width: 100%;
            height: 100%;
            display: block;
            background: transparent;
            cursor: crosshair;
        }

        /* Debug Info */
        .debug-info {
            position: absolute;
            bottom: clamp(5px, 2vh, 15px); /* Responsive bottom position */
            left: clamp(5px, 2vw, 15px); /* Responsive left position */
            color: white;
            font-size: clamp(10px, 2.5vw, 12px); /* Responsive font size */
            opacity: 0.7;
            font-family: monospace;
            background: rgba(0,0,0,0.7);
            padding: clamp(4px, 1.5vw, 8px); /* Responsive padding */
            border-radius: 6px;
            z-index: 100;
            max-width: 70vw; /* Prevent overflow */
            word-break: break-word;
        }

        /* Event Notifications */
        .event-notification {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: clamp(12px, 3vw, 20px) clamp(16px, 4vw, 24px); /* Responsive padding */
            border-radius: 12px;
            font-size: clamp(14px, 4vw, 18px); /* Responsive font size */
            font-weight: bold;
            z-index: 1000;
            opacity: 0;
            transition: all 0.3s ease;
            pointer-events: none;
            max-width: 80vw; /* Prevent overflow on small screens */
            min-width: 200px; /* Minimum readable width */
            text-align: center;
        }

        .event-notification.show {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1.1);
        }

        .event-notification.fall {
            background: rgba(231, 76, 60, 0.9);
            border: 2px solid #e74c3c;
        }

        .event-notification.collision {
            background: rgba(46, 204, 113, 0.9);
            border: 2px solid #2ecc71;
        }

        .event-notification.balance {
            background: rgba(52, 152, 219, 0.9);
            border: 2px solid #3498db;
        }

        /* Animations */
        @keyframes starPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.3); }
            100% { transform: scale(1.2); }
        }

        /* Test Controls (REMOVED - Debug squares eliminated) */

        /* Responsive Design - Mobile First */
        @media (max-width: 500px) {
            body {
                padding: 0;
            }
            
            .game-viewport {
                width: 100vw;
                height: 100vh;
                height: 100dvh;
                border-radius: 0;
                box-shadow: none;
                max-width: none;
                max-height: none;
                aspect-ratio: unset; /* Allow full screen on mobile */
                padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
            }
            
            .game-hud {
                height: clamp(60px, 10vh, 70px); /* Slightly smaller on mobile */
                padding: clamp(4px, 1.5vw, 8px);
            }
            
            .docking-area {
                height: clamp(100px, 18vh, 140px); /* Adjust for mobile */
                gap: clamp(3px, 1vw, 6px);
                padding: clamp(3px, 1vw, 6px);
            }
            
            .shape-slot {
                min-width: clamp(45px, 15vw, 60px); /* Optimize for mobile touch */
                min-height: clamp(45px, 15vw, 60px);
            }
            
            .game-canvas-container {
                border-radius: 0;
                top: calc(clamp(60px, 10vh, 70px) + clamp(100px, 18vh, 140px)); /* Updated for mobile HUD + docking */
            }
            
            /* Enhanced touch targets on mobile */
            .settings-button, .reset-button, .theme-button {
                min-width: 48px; /* Larger touch targets */
                min-height: 48px;
            }
            
            .timer-container {
                min-height: 48px; /* Better touch target */
            }
            
            .coin-counter {
                min-height: 48px; /* Better touch target */
                padding: 6px 10px;
            }
            
            /* Hide design mode on mobile */
            .design-sidebar {
                display: none;
            }
        }

        /* Tablet Portrait */
        @media (min-width: 501px) and (max-width: 1024px) and (orientation: portrait) {
            .game-viewport {
                max-width: 600px;
                max-height: 1067px; /* 600 * 16/9 */
            }
        }

        /* Desktop and Large Screens */
        @media (min-width: 1025px) {
            body {
                padding: 40px 20px;
            }
            
            .game-viewport {
                max-width: 500px;
                max-height: 889px; /* 500 * 16/9 */
                border-radius: 25px;
            }
        }

        /* Rotation Zones - Mobile Enhancement */
        .rotation-zone {
            position: absolute;
            width: 80px;
            height: 100%;
            top: 0;
            border: 2px dashed rgba(74, 144, 226, 0.4);
            border-radius: 10px;
            transition: all 0.3s ease;
            pointer-events: none;
            opacity: 0.3; /* Make visible for testing */
            z-index: 1000;
            display: block; /* Always visible for testing */
        }

        .rotation-zone.left {
            left: 0;
            background: linear-gradient(to right, rgba(229, 115, 115, 0.2), transparent);
            border-color: rgba(229, 115, 115, 0.4);
        }

        .rotation-zone.right {
            right: 0;
            background: linear-gradient(to left, rgba(129, 199, 132, 0.2), transparent);
            border-color: rgba(129, 199, 132, 0.4);
        }

        .rotation-zone.visible {
            display: block;
            opacity: 1;
        }

        .rotation-zone.active {
            border-color: rgba(74, 144, 226, 1);
            box-shadow: 0 0 20px rgba(74, 144, 226, 0.4);
        }

        .rotation-zone.left.active {
            background: linear-gradient(to right, rgba(229, 115, 115, 0.4), transparent);
            border-color: rgba(229, 115, 115, 1);
            box-shadow: 0 0 20px rgba(229, 115, 115, 0.4);
        }

        .rotation-zone.right.active {
            background: linear-gradient(to left, rgba(129, 199, 132, 0.4), transparent);
            border-color: rgba(129, 199, 132, 1);
            box-shadow: 0 0 20px rgba(129, 199, 132, 0.4);
        }

        .rotation-zone::before {
            content: "↺";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2rem;
            color: rgba(255, 255, 255, 0.8);
            animation: zonePulse 2s infinite;
        }

        .rotation-zone.right::before {
            content: "↻";
        }

        .rotation-zone.active::before {
            animation: zoneRotate 1s linear infinite;
            color: rgba(255, 255, 255, 1);
        }

        @keyframes zonePulse {
            0%, 100% { opacity: 0.6; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
        }

        @keyframes zoneRotate {
            from { transform: translate(-50%, -50%) rotate(0deg); }
            to { transform: translate(-50%, -50%) rotate(360deg); }
        }
        
    </style>
</head>
<body>
    <!-- Global drag overlay to prevent clipping -->
    <div id="dragOverlay"></div>
    
    <div class="game-viewport" id="gameContainer">
        <!-- Mobile Rotation Zones -->
        <div id="leftRotationZone" class="rotation-zone left"></div>
        <div id="rightRotationZone" class="rotation-zone right"></div>
            
            <!-- Game HUD -->
            <div class="game-hud">
                <div class="left-section">
                    <div class="score-display">
                        <div class="trophy-icon">🏆</div>
                        <span class="score-text" id="scoreText">0</span>
                    </div>
                    <div class="progress-area">
                        <div class="star-progress-container" onclick="initializeProgressBarInteraction()">
                            <div class="star-progress-bar" id="starProgressBar" style="width: 0%;"></div>
                            <div class="progress-markers">
                                <div class="progress-marker"></div>
                                <div class="progress-marker"></div>
                                <div class="progress-marker"></div>
                            </div>
                        </div>
                        <div class="star-markers">
                            <div class="star"></div>
                            <div class="star"></div>
                            <div class="star"></div>
                        </div>
                    </div>
                </div>

                <div class="middle-section">
                    <div class="level-display" id="levelDisplay">World 1-1</div>
                    <div class="timer-container" id="timerContainer" onclick="switchTimerMode()">
                        <span class="timer-text" id="gameTimer">0:00</span>
                        <div class="timer-mode-indicator timer-mode-elapsed" id="timerModeIndicator">⏱</div>
                    </div>
                </div>

                <div class="right-section">
                    <div class="top-buttons">
                        <!-- Commented out pause button for mode toggle -->
                        <!-- <div class="settings-button" id="pauseButton">
                            <div class="pause-icon">
                                <div class="pause-bar"></div>
                                <div class="pause-bar"></div>
                            </div>
                        </div> -->
                        
                        <!-- Theme cycling button -->
                        <div class="theme-button" id="themeButton" onclick="cycleThemes()" title="Cycle Theme">
                            <div class="theme-icon">🎨</div>
                        </div>
                        
                        <!-- Phase 2: Mode Toggle Switch -->
                        <div class="mode-toggle-switch" id="modeToggleSwitch" onclick="toggleModeSwitch()">
                            <div class="mode-toggle-slider">🎮</div>
                            <div class="mode-toggle-labels">Play/Design</div>
                        </div>
                        
                        <div class="reset-button" id="resetButton" onclick="resetLevel()">
                            <div class="reset-icon">⟲</div>
                        </div>
                        
                        <div class="reset-button" id="mobileDebugButton" onclick="toggleMobileDebug()" style="background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%);">
                            <div class="reset-icon">📱</div>
                        </div>
                    </div>
                    <div class="coin-counter" id="coinCounter" onclick="animateCoin()">
                        <div class="coin-icon">💰</div>
                        <span class="coin-amount" id="coinAmount">0</span>
                    </div>
                </div>
            </div>

            <!-- Docking Area -->
            <div class="docking-area" id="dockingArea">
                <div class="shape-slot" id="slot-square">
                    <div class="game-shape shape-square" data-shape="square" id="shape-square"></div>
                </div>
                <div class="shape-slot" id="slot-triangle">
                    <div class="game-shape shape-triangle" data-shape="triangle" id="shape-triangle"></div>
                </div>
                <div class="shape-slot" id="slot-circle">
                    <div class="game-shape shape-circle" data-shape="circle" id="shape-circle"></div>
                </div>
                <div class="shape-slot" id="slot-cross2">
                    <div class="game-shape shape-cross2" data-shape="cross2" id="shape-cross2"></div>
                </div>
                <div class="shape-slot" id="slot-l">
                    <div class="game-shape shape-l" data-shape="l" id="shape-l"></div>
                </div>
                <div class="shape-slot" id="slot-cross">
                    <div class="game-shape shape-cross" data-shape="cross" id="shape-cross"></div>
                </div>
                <div class="shape-slot" id="slot-barbell-one">
                    <div class="game-shape shape-barbell-one" data-shape="barbell-one" id="shape-barbell-one"></div>
                </div>
                <div class="shape-slot" id="slot-barbell-two">
                    <div class="game-shape shape-barbell-two" data-shape="barbell-two" id="shape-barbell-two"></div>
                </div>
                <div class="shape-slot" id="slot-diamond-barbell">
                    <div class="game-shape shape-diamond-barbell" data-shape="diamond-barbell" id="shape-diamond-barbell"></div>
                </div>
            </div>

            <!-- Game Canvas Area -->
            <div class="game-canvas-container">
                <canvas id="gameCanvas"></canvas>
            </div>

            <!-- Event Notification System -->
            <div class="event-notification" id="eventNotification"></div>

            <!-- Debug Info -->
            <div class="debug-info" id="debugInfo">
                Shapes: 0/9 | Events: 0 | Collisions: 0 | FPS: 60
            </div>

            <!-- Rotation Indicator -->
            <div class="rotation-indicator" id="rotationIndicator">
                🔄 R/E or ←/→ to rotate
            </div>
    </div>

    <!-- Phase 2: Design Mode Sidebar -->
    <div class="design-sidebar" id="designSidebar">
        <div class="sidebar-header">
            <h2>🔧 Level Editor</h2>
            <p>Configure level settings and dock layout</p>
        </div>

        <!-- Level Configuration -->
        <div class="sidebar-section">
            <div class="sidebar-title">📋 Level Configuration</div>
            
            <div class="config-group">
                <label class="config-label">World-Level</label>
                <input type="text" class="config-input" id="levelNumber" value="1-1" placeholder="1-1">
            </div>

            <div class="config-group">
                <label class="config-label">Timer Mode</label>
                <select class="config-select" id="timerMode" onchange="updateTimerModeConfig()">
                    <option value="none">No Timer</option>
                    <option value="elapsed" selected>Count-Up Timer</option>
                    <option value="countdown">Count-Down Timer</option>
                </select>
            </div>
            
            <div class="config-group">
                <label class="config-label">Starting Timer Value</label>
                <input type="number" class="config-input" id="timerStart" value="60" min="0" max="3600" placeholder="Seconds">
            </div>
            
            <div class="config-group">
                <label class="config-label">End-Level Countdown</label>
                <input type="number" class="config-input" id="endLevelDuration" value="5" min="3" max="15" placeholder="Seconds">
            </div>
        </div>

        <!-- v9: Theme Selection -->
        <div class="sidebar-section">
            <div class="sidebar-title">🎨 Theme Selection</div>
            
            <div class="config-group">
                <label class="config-label">Visual Theme</label>
                <select class="config-select" id="themeSelector" onchange="changeTheme()">
                    <option value="classic" selected>Classic Puzzle</option>
                    <option value="wood">Wood</option>
                    <option value="stone">Stone</option>
                    <option value="metal">Metal</option>
                </select>
            </div>

            <div class="config-group">
                <label class="config-label">Canvas Enhancements</label>
                <div class="checkbox-group">
                    <label class="checkbox-label">
                        <input type="checkbox" id="enableCanvas" checked onchange="toggleCanvasEnhancements()">
                        Enable Advanced Graphics
                    </label>
                    <label class="checkbox-label">
                        <input type="checkbox" id="enableParticles" checked onchange="toggleParticleEffects()">
                        Particle Effects
                    </label>
                    <label class="checkbox-label">
                        <input type="checkbox" id="enableAnimations" checked onchange="toggleAnimations()">
                        Shape Animations
                    </label>
                </div>
            </div>

            <div class="config-group">
                <label class="config-label">PixiJS Integration (Phase 2)</label>
                <div class="checkbox-group">
                    <label class="checkbox-label">
                        <input type="checkbox" id="enablePixi" onchange="togglePixiSystem()">
                        Enable PixiJS System
                    </label>
                    <label class="checkbox-label">
                        <input type="checkbox" id="enablePixiShapes" onchange="togglePixiShapeRendering()">
                        PixiJS Shape Rendering
                    </label>
                    <!-- Phase 3: Advanced Animation Controls -->
                    <label class="checkbox-label">
                        <input type="checkbox" id="enablePixiAnimations" onchange="togglePixiAnimations()" checked>
                        PixiJS Animations
                    </label>
                </div>
                <div class="config-sub-group">
                    <label class="config-label">Enhanced Theme Selection</label>
                    <select id="enhancedThemeSelect" onchange="applyEnhancedTheme()">
                        <option value="classic" selected>Classic</option>
                        <option value="wood">Wood</option>
                        <option value="stone">Stone</option>
                        <option value="metal">Metal</option>
                    </select>
                </div>
                <div class="config-sub-group">
                    <label class="config-label">Renderer Selection</label>
                    <select id="rendererSelect" onchange="switchRenderer()">
                        <option value="auto">Auto Select</option>
                        <option value="canvas">Canvas Only</option>
                        <option value="pixi">PixiJS Only</option>
                    </select>
                </div>
                <div class="checkbox-group">
                    <label class="checkbox-label">
                        <input type="checkbox" id="pixiDebug" onchange="togglePixiDebug()">
                        Debug Mode
                    </label>
                    <label class="checkbox-label">
                        <input type="checkbox" id="pixiShowFPS" onchange="togglePixiFPS()">
                        Show FPS Counter
                    </label>
                </div>
            </div>

            <div class="config-group">
                <label class="config-label">Mobile Touch Offset</label>
                <div class="checkbox-group">
                    <label class="checkbox-label">
                        <input type="checkbox" id="enableTouchOffset" checked onchange="toggleTouchOffset()">
                        Enable Touch Offset
                    </label>
                </div>
                <div class="config-sub-group">
                    <label class="config-label">X Offset (Horizontal)</label>
                    <input type="range" id="touchOffsetX" min="-100" max="100" value="0" 
                           onchange="updateTouchOffset()" oninput="updateTouchOffsetDisplay()">
                    <span class="range-value" id="touchOffsetXValue">0px</span>
                </div>
                <div class="config-sub-group">
                    <label class="config-label">Y Offset (Vertical)</label>
                    <input type="range" id="touchOffsetY" min="-150" max="50" value="-80" 
                           onchange="updateTouchOffset()" oninput="updateTouchOffsetDisplay()">
                    <span class="range-value" id="touchOffsetYValue">-80px</span>
                </div>
            </div>
        </div>

        <!-- Dock Configuration -->
        <div class="sidebar-section">
            <div class="sidebar-title">🔧 Dock Configuration</div>
            
            <div class="config-group">
                <label class="config-label">Number of Dock Slots</label>
                <input type="number" class="config-input" id="dockSlotCount" value="9" min="3" max="12" onchange="generateDockSlots()">
            </div>
            
            <div class="config-group">
                <label class="config-label">Barbell Orientation in Dock</label>
                <select class="config-select" id="barbellOrientation" onchange="updateBarbellOrientation()">
                    <option value="vertical" selected>Vertical (90°)</option>
                    <option value="horizontal">Horizontal (0°)</option>
                </select>
            </div>
            
            <div class="config-group">
                <label class="config-label">Shape Assignment</label>
                <div id="dockSlotsContainer">
                    <!-- Dynamic dock slots will be generated here -->
                </div>
            </div>
        </div>

        <!-- Actions -->
        <div class="sidebar-section">
            <div class="sidebar-title">⚡ Actions</div>
            
            <button class="config-btn" id="applyChangesBtn" onclick="applyLevelChanges()">
                Apply Level Changes
            </button>
            
            <button class="config-btn" onclick="resetLevel()" style="background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);">
                Reset Level
            </button>
            
            <button class="config-btn" onclick="syncDockToDesign()" style="background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);">
                Sync Current Dock
            </button>
        </div>
    </div>



    <!-- Matter.js Physics Engine -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    
    <!-- PixiJS v7.x for Advanced Graphics -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.4.2/pixi.min.js"></script>
    
    <script>
        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ CANVAS ENHANCEMENT CONFIGURATION v9
          ║ Feature flags and settings for texture, theme, and visual enhancement system
          ╚═══════════════════════════════════════════════════════════════════════════*/
        const CANVAS_CONFIG = {
            // Feature flags
            enabled: true,                    // Master switch for canvas enhancements
            useTextures: true,               // Enable texture system for shapes
            useThemes: true,                 // Enable theme switching
            useParticles: true,              // Enable particle effects
            useAnimations: true,             // Enable shape animations
            useBackgroundTextures: true,     // Enable background textures
            usePlatformTextures: true,       // Enable platform textures
            
            // Performance settings
            maxParticles: 50,                // Maximum particles on screen
            textureQuality: 'high',          // 'low', 'medium', 'high'
            enableLOD: true,                 // Level of detail for small shapes
            cacheTextures: true,             // Cache rendered textures
            
            // Default theme and fallback behavior
            defaultTheme: 'classic',
            fallbackToSolid: true,           // Use solid colors if textures fail
            showLoadingProgress: true,       // Show loading indicators
            
            // Debug options
            debugMode: false,                // Show texture loading info
            showBounds: false,               // Show texture boundaries
            logAssetLoading: true            // Console logging for asset loading
        };

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ PIXIJS INTEGRATION CONFIGURATION v1
          ║ Feature flags and settings for PixiJS advanced graphics system
          ║ Phase 1: Foundation & Setup - Non-breaking integration alongside Canvas
          ╚═══════════════════════════════════════════════════════════════════════════*/
        const PIXI_CONFIG = {
            // Master control - PixiJS system activation
            enabled: false,                   // Start disabled for gradual activation
            
            // Renderer settings
            renderer: 'auto',                // 'canvas', 'pixi', 'auto'
            fallbackToCanvas: true,          // Fallback to Canvas if PixiJS fails
            
            // Feature flags for gradual activation  
            features: {
                shapeRendering: false,       // Phase 2: Shape rendering migration
                animations: true,            // Phase 3: Advanced animations (enabled by default)
                tweening: false,             // Phase 4: Advanced tweening system
                enhancedText: false,         // Phase 5: Enhanced text system
                particles: false             // Phase 6: Advanced particle systems
            },
            
            // Performance settings
            performance: {
                resolution: 'auto',          // 'auto', 1, 2 (for high DPI)
                antialias: true,             // Anti-aliasing
                transparent: true,           // Transparent background
                backgroundAlpha: 0,          // Background transparency
                powerPreference: 'default'   // 'high-performance', 'low-power', 'default'
            },
            
            // Animation settings
            animations: {
                enabled: true,
                quality: 'high',             // 'low', 'medium', 'high'
                reduceMotion: false,         // Accessibility - respect user preference
                fps: 60,                     // Target framerate
                easing: 'default'            // Default easing function
            },
            
            // Particle system settings
            particles: {
                enabled: true,
                maxCount: 100,               // Maximum particles on screen
                quality: 'high',             // 'low', 'medium', 'high'
                poolSize: 200,               // Object pool size for performance
                culling: true                // Cull off-screen particles
            },
            
            // Text rendering settings
            text: {
                enhanced: true,
                animations: true,
                quality: 'high',
                fontLoading: 'async',        // 'sync', 'async'
                fallbackFont: 'Arial'
            },
            
            // Device optimization
            mobile: {
                reducedEffects: true,        // Reduce effects on mobile
                lowerParticleCounts: true,   // Fewer particles on mobile
                simplifiedAnimations: false   // Keep animations on mobile
            },
            
            // Debug options
            debug: {
                enabled: false,              // Debug mode
                showFPS: false,              // Show FPS counter
                showDrawCalls: false,        // Show draw call count
                logPerformance: false,       // Log performance metrics
                wireframe: false             // Show wireframes
            }
        };

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ V14 UNIFIED GAME CONFIGURATION
          ║ Single source of truth for V14 unified PixiJS system
          ║ Consolidates Canvas and PixiJS configs into one unified system
          ║ No toggles, no complexity - PixiJS handles everything by default
          ╚═══════════════════════════════════════════════════════════════════════════*/
        const UNIFIED_GAME_CONFIG = {
            // Core engine - PixiJS only, no Canvas2D fallbacks for new features
            renderer: {
                engine: 'pixi',                    // Always PixiJS for new features
                fallbackEnabled: true,             // Keep Canvas2D fallback for compatibility
                width: 800,
                height: 500,
                antialias: true,
                transparent: false,
                resolution: Math.min(window.devicePixelRatio || 1, 2), // Cap for performance
                autoDensity: true,
                powerPreference: 'high-performance',
                backgroundColor: 0x87CEEB         // Sky blue as hex
            },
            
            // Theme system configuration
            theme: {
                enabled: true,
                defaultTheme: 'classic',          // Default theme for initialization
                transitions: true,                // Enable theme transitions
                caching: true                     // Cache theme resources
            },
            
            // Always-enabled features (no toggles in V14)
            features: {
                shapeAnimations: true,           // No toggle - always on
                particleEffects: true,           // No toggle - always on  
                advancedGraphics: true,          // No toggle - always on
                themeTextures: true,             // No toggle - always on
                smoothTransitions: true,         // No toggle - always on
                cameraShake: true,               // No toggle - always on
                shapeRendering: true,            // PixiJS shape rendering
                enhancedText: true,              // Better text rendering
                tweening: true                   // Advanced tweening
            },
            
            // Playable ad optimizations
            performance: {
                targetFPS: 60,
                maxMemoryMB: 120,
                textureCompression: true,
                assetPreloading: true,
                renderCaching: true,
                maxParticles: 75,               // Balanced for performance
                cullOffscreen: true,            // Cull off-screen objects
                objectPooling: true             // Reuse objects for performance
            },
            
            // Mobile optimization
            mobile: {
                autoDetect: true,
                reducedParticles: true,         // 50% fewer particles on mobile
                optimizedTextures: true,       // Lower res textures on mobile
                touchOptimization: true        // Touch-specific optimizations
            },
            
            // Debug settings (for development only)
            debug: {
                enabled: false,
                showFPS: false,
                showLayers: false,
                logPerformance: false,
                wireframe: false
            },
            
            // Legacy compatibility (maintain existing functionality)
            legacy: {
                preserveCanvasConfig: true,     // Keep CANVAS_CONFIG active
                preservePixiConfig: true,       // Keep PIXI_CONFIG active
                supportOldUI: true,             // Support existing UI system
                gradualMigration: true          // Enable gradual migration
            }
        };

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ THEME DEFINITIONS - VISUAL THEMES FOR THE GAME
          ║ Each theme defines complete visual styling for all game elements
          ╚═══════════════════════════════════════════════════════════════════════════*/
        const THEME_DEFINITIONS = {
            classic: {
                name: "Classic Puzzle",
                description: "Clean, geometric shapes with simple colors",
                background: {
                    type: "gradient",
                    colors: ["#87CEEB", "#4ECDC4", "#90EE90"],
                    texture: null,
                    // Image background support
                    image: {
                        url: null,          // "path/to/background.jpg"
                        repeat: "no-repeat", // "repeat", "repeat-x", "repeat-y", "no-repeat"
                        position: "center",  // "center", "top", "bottom", "left", "right"
                        size: "cover"        // "cover", "contain", "auto", "100% 100%"
                    }
                },
                platform: {
                    texture: null,  // Will use solid color initially
                    color: "#8B4513",
                    material: "wood",
                    pattern: "solid",
                    // Platform image texture support
                    image: {
                        url: null,          // "path/to/platform-texture.jpg"
                        repeat: "repeat",    // How to repeat the texture
                        blend: "multiply",   // How to blend with base color
                        opacity: 0.8        // Texture opacity (0-1)
                    }
                },
                shapes: {
                    useTextures: false,      // Start with solid colors
                    baseTexturePath: null,
                    specialEffects: ["shadow"],
                    animations: ["bounce"],
                    // Shape texture mapping
                    textures: {
                        square: { url: null, repeat: "repeat", blend: "multiply", opacity: 0.7 },
                        circle: { url: null, repeat: "repeat", blend: "multiply", opacity: 0.7 },
                        triangle: { url: null, repeat: "repeat", blend: "multiply", opacity: 0.7 },
                        cross: { url: null, repeat: "repeat", blend: "multiply", opacity: 0.7 },
                        cross2: { url: null, repeat: "repeat", blend: "multiply", opacity: 0.7 },
                        l: { url: null, repeat: "repeat", blend: "multiply", opacity: 0.7 },
                        "barbell-one": { url: null, repeat: "repeat", blend: "multiply", opacity: 0.7 },
                        "barbell-two": { url: null, repeat: "repeat", blend: "multiply", opacity: 0.7 },
                        "diamond-barbell": { url: null, repeat: "repeat", blend: "multiply", opacity: 0.7 }
                    }
                },
                particles: {
                    style: "geometric",
                    colors: ["#FFD700", "#FF6B6B", "#4ECDC4"]
                }
            },
            
            wood: {
                name: "Wood", 
                description: "Natural wood textures and warm earth tones",
                background: {
                    type: "gradient",
                    colors: ["#8B4513", "#A0522D", "#CD853F"],
                    texture: "wood_grain",
                    // Wood background image support
                    image: {
                        url: null,          // "assets/textures/wood/background.jpg"
                        repeat: "no-repeat",
                        position: "center", 
                        size: "cover"
                    }
                },
                platform: {
                    texture: "wood_grain",
                    color: "#8B4513",
                    material: "wood",
                    pattern: "grain",
                    // Wood platform texture
                    image: {
                        url: null,          // "assets/textures/wood/platform.jpg"
                        repeat: "repeat-x",
                        blend: "multiply",
                        opacity: 0.8
                    }
                },
                shapes: {
                    useTextures: true,
                    baseTexturePath: "textures/wood/",
                    specialEffects: ["grain", "knot"],
                    animations: ["creak", "sway"],
                    textures: {
                        square: { url: null, repeat: "repeat", blend: "multiply", opacity: 0.7 },
                        circle: { url: null, repeat: "repeat", blend: "multiply", opacity: 0.7 },
                        triangle: { url: null, repeat: "repeat", blend: "multiply", opacity: 0.7 },
                        cross: { url: null, repeat: "repeat", blend: "multiply", opacity: 0.7 },
                        cross2: { url: null, repeat: "repeat", blend: "multiply", opacity: 0.7 },
                        l: { url: null, repeat: "repeat", blend: "multiply", opacity: 0.7 },
                        "barbell-one": { url: null, repeat: "repeat", blend: "multiply", opacity: 0.7 },
                        "barbell-two": { url: null, repeat: "repeat", blend: "multiply", opacity: 0.7 },
                        "diamond-barbell": { url: null, repeat: "repeat", blend: "multiply", opacity: 0.7 }
                    }
                },
                particles: {
                    style: "sawdust",
                    colors: ["#D2B48C", "#DEB887", "#F4A460"]
                }
            },
            
            stone: {
                name: "Stone",
                description: "Ancient stone structures with granite and marble textures", 
                background: {
                    type: "gradient",
                    colors: ["#2F4F4F", "#708090", "#778899"],
                    texture: null,
                    // Stone background image support
                    image: {
                        url: null,          // "textures/stone-background.jpg"
                        repeat: "no-repeat",
                        position: "center",
                        size: "cover"
                    }
                },
                platform: {
                    texture: null,
                    color: "#696969",
                    material: "granite",
                    pattern: "rough",
                    // Stone platform texture
                    image: {
                        url: null,          // "textures/granite-platform.jpg"
                        repeat: "repeat",
                        blend: "hard-light",
                        opacity: 0.9
                    }
                },
                shapes: {
                    useTextures: true,
                    baseTexturePath: "textures/stone/",
                    specialEffects: ["dust", "crack"],
                    animations: ["settle", "crumble"],
                    textures: {
                        square: { url: null, repeat: "repeat", blend: "multiply", opacity: 0.8 },
                        circle: { url: null, repeat: "repeat", blend: "multiply", opacity: 0.8 },
                        triangle: { url: null, repeat: "repeat", blend: "multiply", opacity: 0.8 },
                        cross: { url: null, repeat: "repeat", blend: "multiply", opacity: 0.8 },
                        cross2: { url: null, repeat: "repeat", blend: "multiply", opacity: 0.8 },
                        l: { url: null, repeat: "repeat", blend: "multiply", opacity: 0.8 },
                        "barbell-one": { url: null, repeat: "repeat", blend: "multiply", opacity: 0.8 },
                        "barbell-two": { url: null, repeat: "repeat", blend: "multiply", opacity: 0.8 },
                        "diamond-barbell": { url: null, repeat: "repeat", blend: "multiply", opacity: 0.8 }
                    }
                },
                particles: {
                    style: "dust", 
                    colors: ["#A9A9A9", "#D3D3D3", "#C0C0C0"]
                }
            },
            
            metal: {
                name: "Metal",
                description: "Industrial metal structures with steel and iron textures",
                background: {
                    type: "gradient",
                    colors: ["#2F4F4F", "#696969", "#708090"],
                    texture: null,
                    // Metal background image support
                    image: {
                        url: null,          // "textures/metal-background.jpg"
                        repeat: "no-repeat",
                        position: "center",
                        size: "cover"
                    }
                },
                platform: {
                    texture: null,
                    color: "#696969", 
                    material: "steel",
                    pattern: "industrial",
                    // Steel platform texture
                    image: {
                        url: null,          // "textures/steel-platform.jpg"
                        repeat: "repeat",
                        blend: "hard-light",
                        opacity: 0.9
                    }
                },
                shapes: {
                    useTextures: true,
                    baseTexturePath: "textures/metal/",
                    specialEffects: ["spark", "gleam"],
                    animations: ["clang", "shine"],
                    textures: {
                        square: { url: null, repeat: "repeat", blend: "overlay", opacity: 0.9 },
                        circle: { url: null, repeat: "repeat", blend: "overlay", opacity: 0.9 },
                        triangle: { url: null, repeat: "repeat", blend: "overlay", opacity: 0.9 },
                        cross: { url: null, repeat: "repeat", blend: "overlay", opacity: 0.9 },
                        cross2: { url: null, repeat: "repeat", blend: "overlay", opacity: 0.9 },
                        l: { url: null, repeat: "repeat", blend: "overlay", opacity: 0.9 },
                        "barbell-one": { url: null, repeat: "repeat", blend: "overlay", opacity: 0.9 },
                        "barbell-two": { url: null, repeat: "repeat", blend: "overlay", opacity: 0.9 },
                        "diamond-barbell": { url: null, repeat: "repeat", blend: "overlay", opacity: 0.9 }
                    }
                },
                particles: {
                    style: "sparks",
                    colors: ["#C0C0C0", "#FFD700", "#FF4500"]
                }
            }
        };

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ UNIFIED SHAPE CONFIGURATION - PHYSICS-FIRST APPROACH
          ║ Single source of truth for ALL shape appearances and properties
          ║ Eliminates dual CSS/Canvas systems in favor of physics-based rendering
          ╚═══════════════════════════════════════════════════════════════════════════*/
        const SHAPE_CONFIG = {
            square: {
                // Visual properties
                color: '#F39C12',
                stroke: '#E67E22',
                strokeWidth: 2,

                // Physical properties  
                width: 35,
                height: 35,
                density: 0.5,
                friction: 0.7,
                restitution: 0.2,

                // Rendering properties
                type: 'rectangle',
                borderRadius: 3
            },

            triangle: {
                color: '#9B59B6',
                stroke: '#8E44AD', 
                strokeWidth: 2,

                // Triangle vertices (relative to center)
                vertices: [
                    { x: 0, y: -15 },      // Top point
                    { x: -17.5, y: 15 },   // Bottom left
                    { x: 17.5, y: 15 }     // Bottom right
                ],
                density: 0.5,
                friction: 0.7,
                restitution: 0.2,

                type: 'polygon'
            },

            circle: {
                color: '#1ABC9C',
                stroke: '#16A085',
                strokeWidth: 2,

                radius: 17.5,
                density: 0.5,
                friction: 0.7,
                restitution: 0.2,

                type: 'circle'
            },

            cross: {
                color: '#E74C3C',         // Changed from green to red for better contrast
                stroke: '#C0392B',
                strokeWidth: 2,

                // Cross consists of two overlapping rectangles
                parts: [
                    {
                        type: 'rectangle',
                        width: 15,
                        height: 35,
                        offsetX: 0,
                        offsetY: 0
                    },
                    {
                        type: 'rectangle', 
                        width: 35,
                        height: 15,
                        offsetX: 0,
                        offsetY: 0
                    }
                ],
                density: 0.5,
                friction: 0.7,
                restitution: 0.2,

                type: 'compound'
            },

            cross2: {
                color: '#3498DB',         // Changed from pink to blue for better contrast
                stroke: '#2980B9',
                strokeWidth: 2,

                parts: [
                    {
                        type: 'rectangle',
                        width: 15,
                        height: 35,
                        offsetX: 0,
                        offsetY: 0
                    },
                    {
                        type: 'rectangle',
                        width: 35, 
                        height: 15,
                        offsetX: 0,
                        offsetY: 0
                    }
                ],
                density: 0.5,
                friction: 0.7,
                restitution: 0.2,

                type: 'compound'
            },

            l: {
                color: '#8E44AD',         // Changed from orange to purple for variety
                stroke: '#732D91',
                strokeWidth: 2,

                // L-shape consists of two rectangles
                parts: [
                    {
                        type: 'rectangle',
                        width: 15,
                        height: 35,
                        offsetX: -7.5,      // Left side
                        offsetY: 0
                    },
                    {
                        type: 'rectangle',
                        width: 15,
                        height: 15, 
                        offsetX: 7.5,       // Right extension
                        offsetY: 10         // Bottom alignment
                    }
                ],
                density: 0.5,
                friction: 0.7,
                restitution: 0.2,

                type: 'compound'
            },

            'barbell-one': {
                color: '#16A085',
                stroke: '#138D75',
                strokeWidth: 2,

                parts: [
                    {
                        type: 'rectangle',
                        width: 31,
                        height: 5,
                        offsetX: -12,
                        offsetY: 0
                    },
                    {
                        type: 'circle',
                        radius: 8,
                        offsetX: 12,
                        offsetY: 0
                    }
                ],
                density: 0.5,
                friction: 0.7,
                restitution: 0.2,

                type: 'compound'
            },

            'barbell-two': {
                color: '#D35400',
                stroke: '#BA4A00',
                strokeWidth: 2,

                parts: [
                    {
                        type: 'rectangle',
                        width: 26,
                        height: 5,
                        offsetX: 0,
                        offsetY: 0
                    },
                    {
                        type: 'circle',
                        radius: 9,
                        offsetX: -17,
                        offsetY: 0
                    },
                    {
                        type: 'circle',
                        radius: 9,
                        offsetX: 17,
                        offsetY: 0
                    }
                ],
                density: 0.5,
                friction: 0.7,
                restitution: 0.2,

                type: 'compound'
            },

            'diamond-barbell': {
                color: '#C0392B',
                stroke: '#A93226',
                strokeWidth: 2,

                parts: [
                    {
                        type: 'rectangle',
                        width: 26,
                        height: 5,
                        offsetX: -13,
                        offsetY: 0
                    },
                    {
                        type: 'diamond',
                        width: 12,
                        height: 12,
                        offsetX: 13,
                        offsetY: 0
                    }
                ],
                density: 0.5,
                friction: 0.7,
                restitution: 0.2,

                type: 'compound'
            }
        };

        // Utility functions for shape configuration
        function getShapeConfig(shapeType) {
            // V14: Commented out verbose debugging
            // console.log(`🔍 Getting shape config for: ${shapeType}`);
            // console.log(`🔍 window.currentTheme:`, window.currentTheme);
            // console.log(`🔍 window.currentTheme?.shapes?.textures:`, window.currentTheme?.shapes?.textures);
            
            // First check if there's an active theme with shape overrides
            if (window.gameManager && 
                window.gameManager.physicsManager.rendererManager.pixiManager.themeManager) {
                
                const themeManager = window.gameManager.physicsManager.rendererManager.pixiManager.themeManager;
                const currentTheme = themeManager.themes[themeManager.currentTheme];
                
                if (currentTheme && currentTheme.shapeOverrides && currentTheme.shapeOverrides[shapeType]) {
                    // Create a copy of the base config and override with theme colors
                    const baseConfig = {...(SHAPE_CONFIG[shapeType] || {})};
                    const themeOverride = currentTheme.shapeOverrides[shapeType];
                    
                    const themedConfig = {
                        ...baseConfig,
                        color: themeOverride.color || baseConfig.color,
                        stroke: themeOverride.stroke || baseConfig.stroke
                    };
                    
                    // Check for texture information
                    if (window.currentTheme?.shapes?.textures && window.currentTheme.shapes.textures[shapeType]) {
                        themedConfig.texture = window.currentTheme.shapes.textures[shapeType];
                        console.log(`🎨 Added texture to ${shapeType} config:`, themedConfig.texture);
                    }
                    
                    console.log(`🎨 Using themed config for ${shapeType}:`, themedConfig);
                    return themedConfig;
                }
            }
            
            // Also check for textures in fallback case
            const baseConfig = {...(SHAPE_CONFIG[shapeType] || {})};
            if (window.currentTheme?.shapes?.textures && window.currentTheme.shapes.textures[shapeType]) {
                baseConfig.texture = window.currentTheme.shapes.textures[shapeType];
                console.log(`🎨 Added texture to default ${shapeType} config:`, baseConfig.texture);
            }
            
            // Fallback to original config
            // V14: Commented out verbose config logging
            // console.log(`📦 Using config for ${shapeType}:`, baseConfig);
            return baseConfig;
        }

        function getAllShapeTypes() {
            return Object.keys(SHAPE_CONFIG);
        }

        function validateShapeConfig() {
            // Validation logic can be added here
            return true;
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ ASSET MANAGER - HANDLES TEXTURE LOADING AND THEME ASSETS
          ║ Provides centralized asset management with fallbacks and caching
          ╚═══════════════════════════════════════════════════════════════════════════*/
        class AssetManager {
            constructor() {
                this.themes = {};
                this.currentTheme = CANVAS_CONFIG.defaultTheme;
                this.loadingProgress = 0;
                this.isLoaded = false;
                this.textureCache = new Map();
                this.loadingCallbacks = [];
                this.imageCache = new Map(); // Cache for loaded images
                this.loadingPromises = new Map(); // Track loading promises
            }

            async loadTheme(themeName) {
                if (!CANVAS_CONFIG.enabled || !CANVAS_CONFIG.useThemes) {
                    console.log('📦 Asset Manager: Canvas enhancements disabled');
                    return;
                }

                console.log(`📦 Loading theme: ${themeName}`);
                
                try {
                    const themeConfig = THEME_DEFINITIONS[themeName];
                    if (!themeConfig) {
                        console.error(`❌ Theme not found: ${themeName}`);
                        return;
                    }

                    // Initialize theme structure
                    this.themes[themeName] = {
                        config: themeConfig,
                        assets: {
                            backgroundImage: null,
                            platformImage: null,
                            shapeTextures: {}
                        },
                        loaded: false
                    };

                    // Load all images for this theme
                    await this.loadThemeImages(themeName, themeConfig);
                    
                    this.themes[themeName].loaded = true;
                    this.loadingProgress = 100;
                    this.isLoaded = true;
                    
                    console.log(`✅ Theme loaded: ${themeName}`);
                    this.notifyLoadingComplete(themeName);
                    
                } catch (error) {
                    console.error(`❌ Failed to load theme ${themeName}:`, error);
                    this.loadingProgress = 0;
                }
            }

            async loadThemeImages(themeName, themeConfig) {
                const loadPromises = [];
                const theme = this.themes[themeName];

                // Load background image
                if (themeConfig.background.image && themeConfig.background.image.url) {
                    const bgPromise = this.loadImage(themeConfig.background.image.url)
                        .then(img => {
                            theme.assets.backgroundImage = img;
                            console.log(`🖼️ Background image loaded for ${themeName}`);
                        })
                        .catch(err => {
                            console.warn(`⚠️ Background image failed for ${themeName}:`, err.message);
                        });
                    loadPromises.push(bgPromise);
                }

                // Load platform image
                if (themeConfig.platform.image && themeConfig.platform.image.url) {
                    const platformPromise = this.loadImage(themeConfig.platform.image.url)
                        .then(img => {
                            theme.assets.platformImage = img;
                            console.log(`🏗️ Platform image loaded for ${themeName}`);
                        })
                        .catch(err => {
                            console.warn(`⚠️ Platform image failed for ${themeName}:`, err.message);
                        });
                    loadPromises.push(platformPromise);
                }

                // Load shape textures
                if (themeConfig.shapes.textures) {
                    Object.keys(themeConfig.shapes.textures).forEach(shapeType => {
                        const textureConfig = themeConfig.shapes.textures[shapeType];
                        if (textureConfig.url) {
                            const shapePromise = this.loadImage(textureConfig.url)
                                .then(img => {
                                    theme.assets.shapeTextures[shapeType] = img;
                                    console.log(`🔶 Shape texture loaded for ${shapeType} in ${themeName}`);
                                })
                                .catch(err => {
                                    console.warn(`⚠️ Shape texture failed for ${shapeType} in ${themeName}:`, err.message);
                                });
                            loadPromises.push(shapePromise);
                        }
                    });
                }

                // Wait for all images to load (or fail)
                await Promise.allSettled(loadPromises);
                
                const successCount = loadPromises.length;
                console.log(`📦 Theme ${themeName}: Attempted to load ${successCount} images`);
            }

            async loadImage(url) {
                // Check cache first
                if (this.imageCache.has(url)) {
                    return this.imageCache.get(url);
                }

                // Check if already loading
                if (this.loadingPromises.has(url)) {
                    return this.loadingPromises.get(url);
                }

                // Create loading promise
                const loadPromise = new Promise((resolve, reject) => {
                    const img = new Image();
                    img.crossOrigin = 'anonymous'; // Enable CORS for external images
                    
                    img.onload = () => {
                        this.imageCache.set(url, img);
                        this.loadingPromises.delete(url);
                        resolve(img);
                    };
                    
                    img.onerror = () => {
                        this.loadingPromises.delete(url);
                        reject(new Error(`Failed to load image: ${url}`));
                    };
                    
                    img.src = url;
                    
                    // Set timeout for image loading
                    setTimeout(() => {
                        if (!img.complete) {
                            this.loadingPromises.delete(url);
                            reject(new Error(`Image load timeout: ${url}`));
                        }
                    }, 10000); // 10 second timeout
                });

                this.loadingPromises.set(url, loadPromise);
                return loadPromise;
            }

            // Get loaded image assets
            getBackgroundImage(themeName = null) {
                const theme = themeName ? this.getTheme(themeName) : this.getCurrentTheme();
                return theme?.assets?.backgroundImage || null;
            }

            getPlatformImage(themeName = null) {
                const theme = themeName ? this.getTheme(themeName) : this.getCurrentTheme();
                return theme?.assets?.platformImage || null;
            }

            getShapeTexture(shapeType, themeName = null) {
                const theme = themeName ? this.getTheme(themeName) : this.getCurrentTheme();
                return theme?.assets?.shapeTextures?.[shapeType] || null;
            }

            // Clear cache (useful for development)
            clearImageCache() {
                this.imageCache.clear();
                this.loadingPromises.clear();
                console.log('🧹 Image cache cleared');
            }
            
            clearThemeImages(themeName) {
                console.log(`🧹 ImageAssetManager: Clearing images for theme: ${themeName}`);
                
                // Get theme configuration
                const themeConfig = THEME_DEFINITIONS[themeName];
                if (!themeConfig) return;
                
                const themeUrls = new Set();
                
                // Add background image URL
                if (themeConfig.background?.image?.url) {
                    themeUrls.add(themeConfig.background.image.url);
                }
                
                // Add platform image URL
                if (themeConfig.platform?.image?.url) {
                    themeUrls.add(themeConfig.platform.image.url);
                }
                
                // Add shape texture URLs
                if (themeConfig.shapes?.textures) {
                    Object.values(themeConfig.shapes.textures).forEach(textureData => {
                        if (textureData?.url) {
                            themeUrls.add(textureData.url);
                        }
                    });
                }
                
                // Remove theme images from cache
                let removedCount = 0;
                for (const url of themeUrls) {
                    if (this.imageCache.has(url)) {
                        this.imageCache.delete(url);
                        removedCount++;
                    }
                    if (this.loadingPromises.has(url)) {
                        this.loadingPromises.delete(url);
                    }
                }
                
                // Clear the theme data as well
                if (this.themes[themeName]) {
                    delete this.themes[themeName];
                }
                
                console.log(`🧹 ImageAssetManager: Removed ${removedCount} images for theme: ${themeName}`);
            }

            getTheme(themeName) {
                return this.themes[themeName] || null;
            }

            getCurrentTheme() {
                return this.getTheme(this.currentTheme);
            }

            getBackgroundStyle(themeName = null) {
                const theme = themeName ? this.getTheme(themeName) : this.getCurrentTheme();
                if (!theme) return null;
                
                const bgConfig = theme.config.background;
                const bgImage = this.getBackgroundImage(themeName);
                
                return {
                    type: bgConfig.type,
                    colors: bgConfig.colors,
                    image: bgImage,
                    imageConfig: bgConfig.image || null
                };
            }

            getPlatformStyle(themeName = null) {
                const theme = themeName ? this.getTheme(themeName) : this.getCurrentTheme();
                if (!theme) return null;
                
                const platformConfig = theme.config.platform;
                const platformImage = this.getPlatformImage(themeName);
                
                return {
                    ...platformConfig,
                    image: platformImage,
                    imageConfig: platformConfig.image || null
                };
            }

            getShapeStyle(shapeType, themeName = null) {
                const theme = themeName ? this.getTheme(themeName) : this.getCurrentTheme();
                if (!theme) return null;
                
                const shapeConfig = theme.config.shapes;
                const shapeTexture = this.getShapeTexture(shapeType, themeName);
                
                if (shapeConfig.textures && shapeConfig.textures[shapeType]) {
                    return {
                        useTextures: shapeConfig.useTextures,
                        texture: shapeTexture,
                        textureConfig: shapeConfig.textures[shapeType]
                    };
                }
                
                return {
                    useTextures: false,
                    texture: null,
                    textureConfig: null
                };
            }

            getParticleStyle(themeName = null) {
                const theme = themeName ? this.getTheme(themeName) : this.getCurrentTheme();
                if (!theme) return null;
                
                return theme.config.particles;
            }

            notifyLoadingComplete(themeName) {
                this.loadingCallbacks.forEach(callback => {
                    try {
                        callback(themeName);
                    } catch (error) {
                        console.error('❌ Error in loading callback:', error);
                    }
                });
            }

            onThemeLoaded(callback) {
                this.loadingCallbacks.push(callback);
            }
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ PIXIJS CORE SYSTEM - PHASE 1: FOUNDATION & SETUP
          ║ Non-breaking integration of PixiJS alongside existing Canvas system
          ║ Provides dual-renderer architecture with automatic fallback
          ╚═══════════════════════════════════════════════════════════════════════════*/
        class PixiManager {
            constructor(canvas) {
                this.canvas = canvas;
                this.app = null;
                this.isInitialized = false;
                this.isActive = false;
                this.containers = new Map();
                this.errorCount = 0;
                this.maxErrors = 3;
                
                // Phase 3: Animation and Theme managers
                this.animationManager = null;
                this.themeManager = null;
                
                // Feature availability flags
                this.featuresAvailable = {
                    webgl: false,
                    canvas: false,
                    basic: false
                };
                
                console.log('🎨 PixiJS Manager created (inactive)');
            }

            async initialize() {
                if (this.isInitialized) return true;
                
                console.log('🔧 Starting PixiJS initialization...');
                
                try {
                    // Detect PixiJS availability
                    if (typeof PIXI === 'undefined') {
                        console.warn('⚠️ PixiJS not available, falling back to Canvas');
                        return false;
                    }
                    
                    console.log('✅ PixiJS library detected, version:', PIXI.VERSION);

                    // Create PIXI Application with detailed logging
                    console.log('🔧 Creating PIXI Application with config:', {
                        width: this.canvas.width,
                        height: this.canvas.height,
                        backgroundColor: PIXI_CONFIG.performance.backgroundAlpha,
                        transparent: PIXI_CONFIG.performance.transparent,
                        antialias: PIXI_CONFIG.performance.antialias,
                        powerPreference: PIXI_CONFIG.performance.powerPreference
                    });
                    
                    // Try Canvas renderer explicitly if WebGL fails
                    let appConfig = {
                        view: this.canvas,
                        width: this.canvas.width,
                        height: this.canvas.height,
                        backgroundColor: PIXI_CONFIG.performance.backgroundAlpha,
                        transparent: PIXI_CONFIG.performance.transparent,
                        antialias: PIXI_CONFIG.performance.antialias,
                        resolution: this.getOptimalResolution(),
                        powerPreference: PIXI_CONFIG.performance.powerPreference
                    };

                    // Try WebGL first, fall back to Canvas
                    try {
                        this.app = new PIXI.Application(appConfig);
                        console.log('✅ PIXI Application created with WebGL renderer');
                    } catch (webglError) {
                        console.log('⚠️ WebGL failed, trying Canvas renderer:', webglError.message);
                        
                        // Force Canvas renderer
                        appConfig.forceCanvas = true;
                        try {
                            this.app = new PIXI.Application(appConfig);
                            console.log('✅ PIXI Application created with Canvas renderer');
                        } catch (canvasError) {
                            console.log('❌ Both WebGL and Canvas failed, trying basic renderer...');
                            
                            // Last resort - create minimal renderer
                            this.app = {
                                renderer: {
                                    type: 'canvas',
                                    width: this.canvas.width,
                                    height: this.canvas.height,
                                    resolution: 1
                                },
                                stage: new PIXI.Container(),
                                view: this.canvas,
                                ticker: new PIXI.Ticker()
                            };
                            console.log('⚠️ Using minimal PixiJS compatibility mode');
                        }
                    }
                    
                    console.log('🔧 PIXI Application created successfully');

                    // Check renderer capabilities (handle fallback cases)
                    if (this.app.renderer) {
                        this.featuresAvailable.webgl = this.app.renderer.type === PIXI.RENDERER_TYPE.WEBGL;
                        this.featuresAvailable.canvas = this.app.renderer.type === PIXI.RENDERER_TYPE.CANVAS || this.app.renderer.type === 'canvas';
                        this.featuresAvailable.basic = true;
                    } else {
                        // Minimal compatibility mode
                        this.featuresAvailable.webgl = false;
                        this.featuresAvailable.canvas = true;
                        this.featuresAvailable.basic = true;
                    }
                    
                    console.log('🔧 Renderer capabilities detected:', this.featuresAvailable);

                    // Create base containers
                    this.createBaseContainers();
                    
                    // Handle resize
                    this.setupResizeHandling();

                    this.isInitialized = true;
                    console.log('✅ PixiJS initialized successfully', {
                        renderer: this.featuresAvailable.webgl ? 'WebGL' : 'Canvas',
                        resolution: this.app.renderer.resolution,
                        size: `${this.app.renderer.width}x${this.app.renderer.height}`
                    });
                    
                    // Phase 3: Initialize Animation and Theme managers
                    this.animationManager = new PixiAnimationManager(this);
                    this.themeManager = new PixiThemeManager(this);
                    
                    // Update enhanced theme selector with available themes
                    this.updateEnhancedThemeSelector();
                    
                    // Enable animations if configured
                    if (PIXI_CONFIG.animations.enabled) {
                        this.animationManager.enable();
                    }
                    
                    console.log('✅ Phase 3 managers initialized: Animation & Theme');
                    
                    return true;
                } catch (error) {
                    console.error('❌ PixiJS initialization failed:', error);
                    this.handleError(error);
                    return false;
                }
            }

            getOptimalResolution() {
                if (PIXI_CONFIG.performance.resolution === 'auto') {
                    // Use device pixel ratio but cap at 2 for performance
                    return Math.min(window.devicePixelRatio || 1, 2);
                }
                return PIXI_CONFIG.performance.resolution;
            }

            createBaseContainers() {
                // Background layer (behind physics objects)
                this.containers.set('background', new PIXI.Container());
                
                // Main game layer (physics objects)
                this.containers.set('game', new PIXI.Container());
                
                // Particle layer (effects)
                this.containers.set('particles', new PIXI.Container());
                
                // UI layer (front-most)
                this.containers.set('ui', new PIXI.Container());

                // Add containers to stage in order
                ['background', 'game', 'particles', 'ui'].forEach(name => {
                    this.app.stage.addChild(this.containers.get(name));
                });

                console.log('📦 PixiJS containers created: background, game, particles, ui');
            }

            setupResizeHandling() {
                const resizeObserver = new ResizeObserver(() => {
                    if (this.isActive) {
                        this.resize();
                    }
                });
                
                resizeObserver.observe(this.canvas);
                this.resizeObserver = resizeObserver;
            }

            resize() {
                if (!this.app || !this.isActive) return;
                
                try {
                    const rect = this.canvas.getBoundingClientRect();
                    
                    // Check if resize function exists (full PixiJS vs minimal mode)
                    if (this.app.renderer && typeof this.app.renderer.resize === 'function') {
                        this.app.renderer.resize(rect.width, rect.height);
                        console.log('🔄 PixiJS resized:', rect.width, 'x', rect.height);
                    } else {
                        // Minimal compatibility mode - just update dimensions
                        if (this.app.renderer) {
                            this.app.renderer.width = rect.width;
                            this.app.renderer.height = rect.height;
                        }
                        console.log('🔄 PixiJS compatibility mode - dimensions updated:', rect.width, 'x', rect.height);
                    }
                } catch (error) {
                    console.error('❌ PixiJS resize error:', error);
                    this.handleError(error);
                }
            }

            activate() {
                if (!this.isInitialized || this.isActive) return false;
                
                try {
                    // Clear canvas to let PixiJS take over
                    const ctx = this.canvas.getContext('2d');
                    if (ctx) {
                        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    }
                    
                    this.isActive = true;
                    console.log('✅ PixiJS renderer activated');
                    return true;
                } catch (error) {
                    console.error('❌ PixiJS activation failed:', error);
                    this.handleError(error);
                    return false;
                }
            }

            deactivate() {
                if (!this.isActive) return;
                
                this.isActive = false;
                
                // Clear PixiJS stage
                if (this.app) {
                    this.app.stage.removeChildren();
                    // Recreate containers for next activation
                    this.createBaseContainers();
                }
                
                console.log('🔄 PixiJS renderer deactivated - Canvas fallback active');
            }

            getContainer(name) {
                return this.containers.get(name);
            }

            updateEnhancedThemeSelector() {
                try {
                    const enhancedThemeSelect = document.getElementById('enhancedThemeSelect');
                    if (enhancedThemeSelect && this.themeManager) {
                        // Clear existing options
                        enhancedThemeSelect.innerHTML = '';
                        
                        // Define the allowed themes in the desired order - using material names
                        const allowedThemes = [
                            { key: 'classic', name: 'Classic' },
                            { key: 'wood', name: 'Wood' },
                            { key: 'stone', name: 'Stone' },
                            { key: 'metal', name: 'Metal' }
                        ];
                        
                        // Add only the allowed theme options
                        allowedThemes.forEach(({ key, name }) => {
                            const option = document.createElement('option');
                            option.value = key;
                            option.textContent = name;
                            if (key === 'classic') {
                                option.selected = true; // Make Classic the default
                            }
                            enhancedThemeSelect.appendChild(option);
                        });
                        
                        console.log(`🎨 Updated enhanced theme selector with ${allowedThemes.length} filtered themes`);
                    }
                } catch (error) {
                    console.warn('⚠️ Failed to update enhanced theme selector:', error);
                }
            }

            handleError(error) {
                this.errorCount++;
                console.error(`❌ PixiJS Error ${this.errorCount}/${this.maxErrors}:`, error);
                
                if (this.errorCount >= this.maxErrors) {
                    console.warn('⚠️ Too many PixiJS errors, forcing Canvas fallback');
                    this.forceCanvasFallback();
                }
            }

            forceCanvasFallback() {
                this.deactivate();
                PIXI_CONFIG.enabled = false;
                
                // Notify any listeners that we've fallen back to Canvas
                if (window.gameManager && window.gameManager.onPixiFallback) {
                    window.gameManager.onPixiFallback();
                }
                
                console.log('🔄 Forced Canvas fallback due to PixiJS errors');
            }

            destroy() {
                if (this.resizeObserver) {
                    this.resizeObserver.disconnect();
                }
                
                if (this.app) {
                    this.app.destroy(true);
                    this.app = null;
                }
                
                this.isInitialized = false;
                this.isActive = false;
                console.log('🗑️ PixiJS Manager destroyed');
            }
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ RENDERER MANAGER - DUAL RENDERER SYSTEM
          ║ Manages Canvas and PixiJS renderers with automatic switching
          ║ Provides unified interface for both rendering systems
          ╚═══════════════════════════════════════════════════════════════════════════*/
        class RendererManager {
            constructor(canvas) {
                this.canvas = canvas;
                this.currentRenderer = 'canvas'; // Start with canvas
                this.pixiManager = new PixiManager(canvas);
                this.canvasContext = canvas.getContext('2d');
                
                // Performance tracking
                this.performanceMetrics = {
                    fps: 60,
                    drawCalls: 0,
                    lastFrameTime: performance.now()
                };
                
                console.log('🎨 Dual Renderer Manager initialized (Canvas active)');
            }

            async initialize() {
                // Always initialize Canvas (it's our fallback)
                this.initializeCanvas();
                
                // Always try to initialize PixiJS (so it's available when enabled)
                console.log('🔧 RendererManager: Initializing PixiJS...');
                const pixiSuccess = await this.pixiManager.initialize();
                console.log(`🔧 RendererManager: PixiJS init result: ${pixiSuccess}`);
                
                if (pixiSuccess) {
                    console.log('✅ Dual renderer system ready (Canvas + PixiJS)');
                    // Start with the configured renderer
                    if (PIXI_CONFIG.enabled) {
                        this.switchRenderer('pixi');
                    }
                    return true;
                } else {
                    console.log('⚠️ PixiJS initialization failed, using Canvas only');
                    PIXI_CONFIG.enabled = false; // Disable if init failed
                }
                
                console.log('✅ Canvas renderer ready');
                return true;
            }

            initializeCanvas() {
                // Canvas is already initialized, just ensure it's ready
                if (!this.canvasContext) {
                    this.canvasContext = this.canvas.getContext('2d');
                }
                console.log('✅ Canvas renderer initialized');
            }

            switchRenderer(targetRenderer) {
                if (!this.canSwitchTo(targetRenderer)) {
                    console.warn(`⚠️ Cannot switch to ${targetRenderer}, staying with ${this.currentRenderer}`);
                    return false;
                }

                const previousRenderer = this.currentRenderer;

                try {
                    // Deactivate current renderer
                    if (this.currentRenderer === 'pixi') {
                        this.pixiManager.deactivate();
                    }

                    // Activate new renderer
                    if (targetRenderer === 'pixi') {
                        const success = this.pixiManager.activate();
                        if (!success) {
                            throw new Error('PixiJS activation failed');
                        }
                    }

                    this.currentRenderer = targetRenderer;
                    console.log(`🔄 Switched renderer: ${previousRenderer} → ${targetRenderer}`);
                    return true;

                } catch (error) {
                    console.error('❌ Renderer switch failed:', error);
                    
                    // Fallback to canvas
                    if (targetRenderer !== 'canvas') {
                        console.log('🔄 Falling back to Canvas renderer');
                        this.currentRenderer = 'canvas';
                        this.pixiManager.deactivate();
                    }
                    return false;
                }
            }

            canSwitchTo(renderer) {
                switch (renderer) {
                    case 'canvas':
                        return true; // Canvas is always available
                    case 'pixi':
                        const canSwitch = PIXI_CONFIG.enabled && this.pixiManager.isInitialized;
                        if (!canSwitch) {
                            console.log(`🔍 PixiJS switch check: enabled=${PIXI_CONFIG.enabled}, initialized=${this.pixiManager.isInitialized}`);
                        }
                        return canSwitch;
                    case 'auto':
                        return true; // Auto-selection is always valid
                    default:
                        return false;
                }
            }

            autoSelectRenderer() {
                if (PIXI_CONFIG.renderer === 'canvas') {
                    return this.switchRenderer('canvas');
                }
                
                if (PIXI_CONFIG.renderer === 'pixi') {
                    return this.switchRenderer('pixi');
                }
                
                // Auto mode: prefer PixiJS if available, fallback to Canvas
                if (this.canSwitchTo('pixi') && PIXI_CONFIG.enabled) {
                    return this.switchRenderer('pixi');
                } else {
                    return this.switchRenderer('canvas');
                }
            }

            getCurrentRenderer() {
                return this.currentRenderer;
            }

            isPixiActive() {
                return this.currentRenderer === 'pixi' && this.pixiManager.isActive;
            }

            getPixiContainer(name) {
                if (this.isPixiActive()) {
                    return this.pixiManager.getContainer(name);
                }
                return null;
            }

            updatePerformanceMetrics() {
                const now = performance.now();
                const deltaTime = now - this.performanceMetrics.lastFrameTime;
                this.performanceMetrics.fps = 1000 / deltaTime;
                this.performanceMetrics.lastFrameTime = now;
                
                if (PIXI_CONFIG.debug.logPerformance) {
                    console.log('📊 Performance:', {
                        renderer: this.currentRenderer,
                        fps: Math.round(this.performanceMetrics.fps),
                        drawCalls: this.performanceMetrics.drawCalls
                    });
                }
            }

            destroy() {
                this.pixiManager.destroy();
                console.log('🗑️ Renderer Manager destroyed');
            }
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ PIXIJS SHAPE SYSTEM - PHASE 2: SHAPE RENDERING MIGRATION
          ║ Creates PixiJS equivalents for all existing Canvas shapes
          ║ Maintains visual parity while enabling advanced graphics features
          ╚═══════════════════════════════════════════════════════════════════════════*/
        class PixiShapeFactory {
            static createSquare(config) {
                const graphics = new PIXI.Graphics();
                
                // Use configuration from SHAPE_CONFIG
                const { color, stroke, strokeWidth, width, height, borderRadius, texture } = config;
                
                // Check if texture is available and valid
                if (texture && texture.url) {
                    try {
                        // Create sprite with texture
                        const sprite = PIXI.Sprite.from(texture.url);
                        sprite.anchor.set(0.5);
                        sprite.width = width;
                        sprite.height = height;
                        sprite.tint = this.parseColor(color);
                        
                        // Apply texture properties
                        if (texture.opacity !== undefined) {
                            sprite.alpha = texture.opacity;
                        }
                        
                        console.log(`✅ Applied texture to square: ${texture.url}`);
                        return sprite;
                    } catch (error) {
                        console.warn(`⚠️ Failed to load texture ${texture.url}, using color fallback:`, error);
                        // Fall through to regular graphics creation
                    }
                }
                
                // Regular graphics creation (fallback or no texture)
                graphics.lineStyle(strokeWidth, this.parseColor(stroke));
                graphics.beginFill(this.parseColor(color));
                
                if (borderRadius > 0) {
                    graphics.drawRoundedRect(-width/2, -height/2, width, height, borderRadius);
                } else {
                    graphics.drawRect(-width/2, -height/2, width, height);
                }
                
                graphics.endFill();
                return graphics;
            }

            static createCircle(config) {
                const graphics = new PIXI.Graphics();
                const { color, stroke, strokeWidth, radius, texture } = config;
                
                // Check if texture is available and valid
                if (texture && texture.url) {
                    try {
                        // Create sprite with texture
                        const sprite = PIXI.Sprite.from(texture.url);
                        sprite.anchor.set(0.5);
                        sprite.width = sprite.height = radius * 2;
                        sprite.tint = this.parseColor(color);
                        
                        // Apply texture properties
                        if (texture.opacity !== undefined) {
                            sprite.alpha = texture.opacity;
                        }
                        
                        // Make it circular using a mask
                        const mask = new PIXI.Graphics();
                        mask.beginFill(0xFFFFFF);
                        mask.drawCircle(0, 0, radius);
                        mask.endFill();
                        sprite.mask = mask;
                        
                        // Create container to hold both sprite and mask
                        const container = new PIXI.Container();
                        container.addChild(sprite);
                        container.addChild(mask);
                        
                        console.log(`✅ Applied texture to circle: ${texture.url}`);
                        return container;
                    } catch (error) {
                        console.warn(`⚠️ Failed to load texture ${texture.url}, using color fallback:`, error);
                        // Fall through to regular graphics creation
                    }
                }
                
                // Regular graphics creation (fallback or no texture)
                graphics.lineStyle(strokeWidth, this.parseColor(stroke));
                graphics.beginFill(this.parseColor(color));
                graphics.drawCircle(0, 0, radius);
                graphics.endFill();
                
                return graphics;
            }

            static createTriangle(config) {
                const graphics = new PIXI.Graphics();
                const { color, stroke, strokeWidth, vertices, texture } = config;
                
                // Check if texture is available and valid
                if (texture && texture.url && vertices && vertices.length >= 3) {
                    try {
                        // Calculate triangle bounds for sprite sizing
                        let minX = Math.min(...vertices.map(v => v.x));
                        let maxX = Math.max(...vertices.map(v => v.x));
                        let minY = Math.min(...vertices.map(v => v.y));
                        let maxY = Math.max(...vertices.map(v => v.y));
                        
                        // Create sprite with texture
                        const sprite = PIXI.Sprite.from(texture.url);
                        sprite.anchor.set(0.5);
                        sprite.width = maxX - minX;
                        sprite.height = maxY - minY;
                        sprite.tint = this.parseColor(color);
                        
                        // Apply texture properties
                        if (texture.opacity !== undefined) {
                            sprite.alpha = texture.opacity;
                        }
                        
                        // Create triangular mask
                        const mask = new PIXI.Graphics();
                        mask.beginFill(0xFFFFFF);
                        mask.moveTo(vertices[0].x, vertices[0].y);
                        for (let i = 1; i < vertices.length; i++) {
                            mask.lineTo(vertices[i].x, vertices[i].y);
                        }
                        mask.closePath();
                        mask.endFill();
                        sprite.mask = mask;
                        
                        // Create container to hold both sprite and mask
                        const container = new PIXI.Container();
                        container.addChild(sprite);
                        container.addChild(mask);
                        
                        console.log(`✅ Applied texture to triangle: ${texture.url}`);
                        return container;
                    } catch (error) {
                        console.warn(`⚠️ Failed to load texture ${texture.url}, using color fallback:`, error);
                        // Fall through to regular graphics creation
                    }
                }
                
                // Regular graphics creation (fallback or no texture)
                graphics.lineStyle(strokeWidth, this.parseColor(stroke));
                graphics.beginFill(this.parseColor(color));
                
                // Draw triangle using vertices from config
                if (vertices && vertices.length >= 3) {
                    graphics.moveTo(vertices[0].x, vertices[0].y);
                    for (let i = 1; i < vertices.length; i++) {
                        graphics.lineTo(vertices[i].x, vertices[i].y);
                    }
                    graphics.closePath();
                }
                
                graphics.endFill();
                return graphics;
            }

            static createCross(config) {
                const graphics = new PIXI.Graphics();
                const { color, stroke, strokeWidth, parts } = config;
                
                graphics.lineStyle(strokeWidth, this.parseColor(stroke));
                graphics.beginFill(this.parseColor(color));
                
                // Draw cross as two overlapping rectangles
                if (parts && parts.length >= 2) {
                    parts.forEach(part => {
                        const { width, height, offsetX = 0, offsetY = 0 } = part;
                        graphics.drawRect(
                            offsetX - width/2, 
                            offsetY - height/2, 
                            width, 
                            height
                        );
                    });
                }
                
                graphics.endFill();
                return graphics;
            }

            static createCross2(config) {
                // Cross2 uses same structure as cross but different dimensions
                return this.createCross(config);
            }

            static createL(config) {
                const graphics = new PIXI.Graphics();
                const { color, stroke, strokeWidth, parts } = config;
                
                // CRITICAL FIX: Set tint to white and use beginFill for proper color rendering
                graphics.tint = 0xFFFFFF; // Reset tint to white so colors render correctly
                // THEME FIX: Use only the main theme colors, ignore part-specific colors
                graphics.lineStyle(strokeWidth, this.parseColor(stroke));
                graphics.beginFill(this.parseColor(color));
                
                // Draw L-shape as multiple rectangles
                if (parts && parts.length > 0) {
                    parts.forEach(part => {
                        // THEME FIX: Remove any part-specific colors to ensure main theme colors are used
                        const cleanPart = { ...part };
                        delete cleanPart.color;
                        delete cleanPart.stroke;
                        
                        const { width, height, offsetX = 0, offsetY = 0 } = cleanPart;
                        graphics.drawRect(
                            offsetX - width/2, 
                            offsetY - height/2, 
                            width, 
                            height
                        );
                    });
                }
                
                graphics.endFill();
                return graphics;
            }

            static createBarbellOne(config) {
                const graphics = new PIXI.Graphics();
                const { color, stroke, strokeWidth, parts } = config;
                
                console.log(`🔍 BarbellOne Debug:`, {
                    color, 
                    stroke, 
                    parsedColor: this.parseColor(color),
                    parsedStroke: this.parseColor(stroke)
                });
                
                // THEME FIX: Use only the main theme colors, ignore part-specific colors  
                const lineColor = this.parseColor(stroke);
                const fillColor = this.parseColor(color);
                
                console.log(`🔍 Setting PixiJS colors:`, { lineColor, fillColor });
                
                // CRITICAL FIX: Set tint to white and use beginFill for proper color rendering
                graphics.tint = 0xFFFFFF; // Reset tint to white so colors render correctly
                graphics.lineStyle(strokeWidth, lineColor);
                graphics.beginFill(fillColor);
                
                // Draw barbell as combination of rectangles and circles
                if (parts && parts.length > 0) {
                    parts.forEach((part, index) => {
                        console.log(`🔍 Drawing part ${index}:`, part.type);
                        // THEME FIX: Remove any part-specific colors to ensure main theme colors are used
                        const cleanPart = { ...part };
                        delete cleanPart.color;
                        delete cleanPart.stroke;
                        
                        if (cleanPart.type === 'rectangle') {
                            const { width, height, offsetX = 0, offsetY = 0 } = cleanPart;
                            graphics.drawRect(
                                offsetX - width/2, 
                                offsetY - height/2, 
                                width, 
                                height
                            );
                        } else if (cleanPart.type === 'circle') {
                            const { radius, offsetX = 0, offsetY = 0 } = cleanPart;
                            graphics.drawCircle(offsetX, offsetY, radius);
                        }
                    });
                }
                
                graphics.endFill();
                console.log(`🔍 PixiJS graphics after endFill:`, {
                    tint: graphics.tint,
                    alpha: graphics.alpha,
                    visible: graphics.visible
                });
                return graphics;
            }

            static createBarbellTwo(config) {
                // Barbell-two uses same structure as barbell-one but different dimensions
                return this.createBarbellOne(config);
            }

            static createDiamondBarbell(config) {
                const graphics = new PIXI.Graphics();
                const { color, stroke, strokeWidth, parts } = config;
                
                console.log(`🔍 DiamondBarbell Debug:`, {
                    color, 
                    stroke, 
                    parsedColor: this.parseColor(color),
                    parsedStroke: this.parseColor(stroke)
                });
                
                // CRITICAL FIX: Set tint to white and use beginFill for proper color rendering
                graphics.tint = 0xFFFFFF; // Reset tint to white so colors render correctly
                // THEME FIX: Use only the main theme colors, ignore part-specific colors
                graphics.lineStyle(strokeWidth, this.parseColor(stroke));
                graphics.beginFill(this.parseColor(color));
                
                // Draw diamond barbell with custom shape parts
                if (parts && parts.length > 0) {
                    parts.forEach(part => {
                        // THEME FIX: Remove any part-specific colors to ensure main theme colors are used
                        const cleanPart = { ...part };
                        delete cleanPart.color;
                        delete cleanPart.stroke;
                        
                        if (cleanPart.type === 'rectangle') {
                            const { width, height, offsetX = 0, offsetY = 0 } = cleanPart;
                            graphics.drawRect(
                                offsetX - width/2, 
                                offsetY - height/2, 
                                width, 
                                height
                            );
                        } else if (cleanPart.type === 'diamond' && cleanPart.vertices) {
                            // Draw diamond shapes
                            graphics.moveTo(cleanPart.vertices[0].x, cleanPart.vertices[0].y);
                            for (let i = 1; i < cleanPart.vertices.length; i++) {
                                graphics.lineTo(cleanPart.vertices[i].x, cleanPart.vertices[i].y);
                            }
                            graphics.closePath();
                        } else if (cleanPart.type === 'polygon' && cleanPart.vertices) {
                            // Draw diamond shapes using polygon vertices
                            graphics.moveTo(cleanPart.vertices[0].x, cleanPart.vertices[0].y);
                            for (let i = 1; i < cleanPart.vertices.length; i++) {
                                graphics.lineTo(cleanPart.vertices[i].x, cleanPart.vertices[i].y);
                            }
                            graphics.closePath();
                        }
                    });
                }
                
                graphics.endFill();
                return graphics;
            }

            // Helper method to parse color strings to hex values
            static parseColor(colorString) {
                if (typeof colorString === 'number') return colorString;
                if (colorString.startsWith('#')) {
                    return parseInt(colorString.replace('#', '0x'), 16);
                }
                // Handle other color formats if needed
                return 0x000000; // Default to black
            }

            // Main factory method
            static createShape(shapeType, config) {
                switch (shapeType) {
                    case 'square': return this.createSquare(config);
                    case 'circle': return this.createCircle(config);
                    case 'triangle': return this.createTriangle(config);
                    case 'cross': return this.createCross(config);
                    case 'cross2': return this.createCross2(config);
                    case 'l': return this.createL(config);
                    case 'barbell-one': return this.createBarbellOne(config);
                    case 'barbell-two': return this.createBarbellTwo(config);
                    case 'diamond-barbell': return this.createDiamondBarbell(config);
                    default:
                        console.warn(`⚠️ Unknown shape type: ${shapeType}`);
                        return this.createSquare(config); // Fallback to square
                }
            }
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ PIXIJS SHAPE RENDERER - SYNCS PIXI GRAPHICS WITH MATTER.JS PHYSICS
          ║ Manages PixiJS shape graphics and keeps them synchronized with physics bodies
          ╚═══════════════════════════════════════════════════════════════════════════*/
        class PixiShapeRenderer {
            constructor(rendererManager) {
                this.rendererManager = rendererManager;
                this.shapes = new Map(); // Matter.js body ID -> PIXI Graphics
                this.isEnabled = false;
                
                console.log('🎨 PixiJS Shape Renderer created');
            }

            enable() {
                if (!this.rendererManager.isPixiActive()) {
                    console.warn('⚠️ Cannot enable PixiJS shapes - PixiJS renderer not active');
                    return false;
                }
                
                this.isEnabled = true;
                console.log('✅ PixiJS shape rendering enabled');
                return true;
            }

            disable() {
                this.isEnabled = false;
                this.clearAllShapes();
                console.log('🔄 PixiJS shape rendering disabled');
            }

            createShape(body, shapeType) {
                if (!this.isEnabled || !this.rendererManager.isPixiActive()) {
                    return null;
                }

                try {
                    // Get shape configuration from SHAPE_CONFIG
                    const config = getShapeConfig(shapeType);
                    if (!config) {
                        console.warn(`⚠️ No configuration found for shape: ${shapeType}`);
                        return null;
                    }

                    // Create PixiJS graphics object
                    const pixiShape = PixiShapeFactory.createShape(shapeType, config);
                    
                    console.log(`🎨 PixiJS shape created for ${shapeType}, checking colors...`);
                    console.log(`🎨 Graphics tint:`, pixiShape.tint);
                    console.log(`🎨 Graphics children:`, pixiShape.children?.length || 0);
                    
                    // Position the shape according to the physics body
                    pixiShape.x = body.position.x;
                    pixiShape.y = body.position.y;
                    pixiShape.rotation = body.angle;

                    // Add to game container
                    const gameContainer = this.rendererManager.getPixiContainer('game');
                    if (gameContainer) {
                        gameContainer.addChild(pixiShape);
                    }

                    // Store reference
                    this.shapes.set(body.id, {
                        graphics: pixiShape,
                        body: body,
                        shapeType: shapeType,
                        config: config
                    });

                    console.log(`🎨 Created PixiJS shape: ${shapeType} (body ID: ${body.id})`);
                    
                    // Phase 3: Animate shape creation
                    if (this.rendererManager.pixiManager.animationManager) {
                        this.rendererManager.pixiManager.animationManager.animateShapeCreation(pixiShape);
                    }
                    
                    return pixiShape;

                } catch (error) {
                    console.error('❌ Error creating PixiJS shape:', error);
                    return null;
                }
            }

            updateShapes() {
                if (!this.isEnabled || !this.rendererManager.isPixiActive()) {
                    return;
                }

                // Update all shape positions and rotations to match physics bodies
                this.shapes.forEach((shapeData, bodyId) => {
                    const { graphics, body } = shapeData;
                    
                    if (graphics && body) {
                        graphics.x = body.position.x;
                        graphics.y = body.position.y;
                        graphics.rotation = body.angle;
                    }
                });
            }

            removeShape(bodyId) {
                const shapeData = this.shapes.get(bodyId);
                if (shapeData) {
                    console.log(`🗑️ Removing PixiJS shape (body ID: ${bodyId})`);
                    
                    // Phase 3: Animate destruction before removal
                    const animationManager = this.rendererManager.pixiManager.animationManager;
                    if (animationManager && animationManager.isEnabled) {
                        animationManager.animateShapeDestruction(shapeData.graphics, () => {
                            // Remove after animation completes
                            this.completeShapeRemoval(shapeData, bodyId);
                        });
                    } else {
                        // No animation, remove immediately
                        this.completeShapeRemoval(shapeData, bodyId);
                    }
                }
            }

            completeShapeRemoval(shapeData, bodyId) {
                // Remove from PixiJS container
                if (shapeData.graphics.parent) {
                    shapeData.graphics.parent.removeChild(shapeData.graphics);
                }
                
                // Destroy PixiJS graphics
                shapeData.graphics.destroy();
                
                // Remove from our tracking
                this.shapes.delete(bodyId);
                
                console.log(`✅ PixiJS shape removal completed (body ID: ${bodyId})`);
            }

            clearAllShapes() {
                this.shapes.forEach((shapeData, bodyId) => {
                    this.removeShape(bodyId);
                });
                console.log('🧹 Cleared all PixiJS shapes');
            }

            // Apply theme changes to existing shapes
            applyTheme(themeName) {
                if (!this.isEnabled) return;
                
                console.log(`🎨 Applying enhanced theme to PixiJS shapes: ${themeName}`);
                
                // Phase 3: Use enhanced theme manager if available
                const themeManager = this.rendererManager.pixiManager.themeManager;
                if (themeManager) {
                    themeManager.applyTheme(themeName, this);
                } else {
                    // Fallback to original theme application
                    this.legacyThemeApplication(themeName);
                }
            }

            legacyThemeApplication(themeName) {
                this.shapes.forEach((shapeData, bodyId) => {
                    const { graphics, shapeType } = shapeData;
                    
                    // Get updated configuration for theme
                    const config = getShapeConfig(shapeType);
                    if (config) {
                        // Recreate shape with new theme colors
                        const newGraphics = PixiShapeFactory.createShape(shapeType, config);
                        newGraphics.x = graphics.x;
                        newGraphics.y = graphics.y;
                        newGraphics.rotation = graphics.rotation;
                        
                        // Replace in container
                        if (graphics.parent) {
                            const container = graphics.parent;
                            container.removeChild(graphics);
                            container.addChild(newGraphics);
                        }
                        
                        // Clean up old graphics
                        graphics.destroy();
                        
                        // Update our reference
                        shapeData.graphics = newGraphics;
                        shapeData.config = config;
                    }
                });
            }

            getShapeCount() {
                return this.shapes.size;
            }

            isShapeTracked(bodyId) {
                return this.shapes.has(bodyId);
            }
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ PIXIJS ANIMATION MANAGER - Phase 3
          ║ Advanced animations, tweening, and visual effects system
          ║ Features: Shape creation/destruction animations, collision effects, tweening
          ╚═══════════════════════════════════════════════════════════════════════════*/
        class PixiAnimationManager {
            constructor(pixiManager) {
                this.pixiManager = pixiManager;
                this.app = pixiManager.app;
                this.isEnabled = false;
                
                // Animation tracking
                this.activeAnimations = new Map();
                this.animationCounter = 0;
                
                // Tween configuration
                this.tweenConfig = {
                    shapeCreation: {
                        duration: 300,        // milliseconds
                        easing: 'easeOutBounce'
                    },
                    shapeDestruction: {
                        duration: 200,
                        easing: 'easeInQuart'
                    },
                    collision: {
                        duration: 100,
                        easing: 'easeOutQuad'
                    },
                    platform: {
                        duration: 150,
                        easing: 'easeOutBack'
                    }
                };
                
                console.log('🎬 PixiJS Animation Manager created');
            }

            enable() {
                this.isEnabled = true;
                console.log('✅ PixiJS animations enabled');
                return true;
            }

            disable() {
                this.isEnabled = false;
                // Stop all active animations
                this.stopAllAnimations();
                console.log('🔄 PixiJS animations disabled');
            }

            // Shape Creation Animation - Scale up with bounce
            animateShapeCreation(graphics, callback = null) {
                if (!this.isEnabled || !graphics) return;

                // Start from scale 0
                graphics.scale.set(0, 0);
                graphics.alpha = 0.8;

                const animationId = ++this.animationCounter;
                const startTime = performance.now();
                const config = this.tweenConfig.shapeCreation;

                const animate = (currentTime) => {
                    const elapsed = currentTime - startTime;
                    const progress = Math.min(elapsed / config.duration, 1);

                    // Bounce easing
                    const easedProgress = this.easeOutBounce(progress);
                    
                    graphics.scale.set(easedProgress, easedProgress);
                    graphics.alpha = 0.8 + (0.2 * progress);

                    if (progress < 1) {
                        this.activeAnimations.set(animationId, requestAnimationFrame(animate));
                    } else {
                        graphics.scale.set(1, 1);
                        graphics.alpha = 1;
                        this.activeAnimations.delete(animationId);
                        if (callback) callback();
                    }
                };

                this.activeAnimations.set(animationId, requestAnimationFrame(animate));
                console.log('🎬 Started shape creation animation');
            }

            // Shape Destruction Animation - Scale down with fade
            animateShapeDestruction(graphics, callback = null) {
                if (!this.isEnabled || !graphics) {
                    if (callback) callback();
                    return;
                }

                const animationId = ++this.animationCounter;
                const startTime = performance.now();
                const config = this.tweenConfig.shapeDestruction;
                const initialScale = graphics.scale.x;

                const animate = (currentTime) => {
                    const elapsed = currentTime - startTime;
                    const progress = Math.min(elapsed / config.duration, 1);

                    // Quad easing in
                    const easedProgress = this.easeInQuart(progress);
                    
                    const scale = initialScale * (1 - easedProgress);
                    graphics.scale.set(scale, scale);
                    graphics.alpha = 1 - easedProgress;

                    if (progress < 1) {
                        this.activeAnimations.set(animationId, requestAnimationFrame(animate));
                    } else {
                        this.activeAnimations.delete(animationId);
                        if (callback) callback();
                    }
                };

                this.activeAnimations.set(animationId, requestAnimationFrame(animate));
                console.log('🎬 Started shape destruction animation');
            }

            // Collision Flash Animation - Brief color/scale change
            animateCollisionFlash(graphics) {
                if (!this.isEnabled || !graphics) return;

                const animationId = ++this.animationCounter;
                const startTime = performance.now();
                const config = this.tweenConfig.collision;
                const originalTint = graphics.tint;
                const originalScale = graphics.scale.x;

                const animate = (currentTime) => {
                    const elapsed = currentTime - startTime;
                    const progress = Math.min(elapsed / config.duration, 1);

                    // Quad easing out
                    const easedProgress = this.easeOutQuad(progress);
                    
                    // Flash white and scale slightly
                    const tintMix = 1 - easedProgress;
                    graphics.tint = this.lerpColor(originalTint, 0xFFFFFF, tintMix * 0.5);
                    
                    const scaleBoost = 1 + (0.1 * (1 - easedProgress));
                    graphics.scale.set(originalScale * scaleBoost, originalScale * scaleBoost);

                    if (progress < 1) {
                        this.activeAnimations.set(animationId, requestAnimationFrame(animate));
                    } else {
                        graphics.tint = originalTint;
                        graphics.scale.set(originalScale, originalScale);
                        this.activeAnimations.delete(animationId);
                    }
                };

                this.activeAnimations.set(animationId, requestAnimationFrame(animate));
                console.log('⚡ Started collision flash animation');
            }

            // Platform Landing Animation - Satisfying bounce
            animatePlatformLanding(graphics) {
                if (!this.isEnabled || !graphics) return;

                const animationId = ++this.animationCounter;
                const startTime = performance.now();
                const config = this.tweenConfig.platform;
                const originalScale = graphics.scale.x;

                const animate = (currentTime) => {
                    const elapsed = currentTime - startTime;
                    const progress = Math.min(elapsed / config.duration, 1);

                    // Back easing out (overshoot)
                    const easedProgress = this.easeOutBack(progress);
                    
                    // Squash and stretch effect
                    const scaleY = originalScale * (0.8 + 0.2 * easedProgress);
                    const scaleX = originalScale * (1.1 - 0.1 * easedProgress);
                    graphics.scale.set(scaleX, scaleY);

                    if (progress < 1) {
                        this.activeAnimations.set(animationId, requestAnimationFrame(animate));
                    } else {
                        graphics.scale.set(originalScale, originalScale);
                        this.activeAnimations.delete(animationId);
                    }
                };

                this.activeAnimations.set(animationId, requestAnimationFrame(animate));
                console.log('🏟️ Started platform landing animation');
            }

            // Stop all animations
            stopAllAnimations() {
                this.activeAnimations.forEach((animationFrame, id) => {
                    cancelAnimationFrame(animationFrame);
                });
                this.activeAnimations.clear();
                console.log('🛑 Stopped all PixiJS animations');
            }

            // Easing functions
            easeOutBounce(t) {
                if (t < 1 / 2.75) {
                    return 7.5625 * t * t;
                } else if (t < 2 / 2.75) {
                    return 7.5625 * (t -= 1.5 / 2.75) * t + 0.75;
                } else if (t < 2.5 / 2.75) {
                    return 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375;
                } else {
                    return 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
                }
            }

            easeInQuart(t) {
                return t * t * t * t;
            }

            easeOutQuad(t) {
                return 1 - (1 - t) * (1 - t);
            }

            easeOutBack(t) {
                const c1 = 1.70158;
                const c3 = c1 + 1;
                return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
            }

            // Utility function for color interpolation
            lerpColor(color1, color2, t) {
                const r1 = (color1 >> 16) & 0xFF;
                const g1 = (color1 >> 8) & 0xFF;
                const b1 = color1 & 0xFF;
                
                const r2 = (color2 >> 16) & 0xFF;
                const g2 = (color2 >> 8) & 0xFF;
                const b2 = color2 & 0xFF;
                
                const r = Math.round(r1 + (r2 - r1) * t);
                const g = Math.round(g1 + (g2 - g1) * t);
                const b = Math.round(b1 + (b2 - b1) * t);
                
                return (r << 16) | (g << 8) | b;
            }

            getActiveAnimationCount() {
                return this.activeAnimations.size;
            }
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ ENHANCED THEME INTEGRATION - Phase 3 Extension  
          ║ Advanced theme support with patterns, effects, and dynamic appearance
          ║ Features: Color schemes, patterns, visual effects per theme
          ╚═══════════════════════════════════════════════════════════════════════════*/
        class PixiThemeManager {
            constructor(pixiManager) {
                this.pixiManager = pixiManager;
                this.currentTheme = 'classic';
                this.themeEffects = new Map();
                
                // Load themes dynamically from existing system
                this.loadExistingThemes();
                
                console.log('🎨 Enhanced PixiJS Theme Manager created with dynamic themes');
            }

            loadExistingThemes() {
                this.themes = {};
                
                // Check if we have access to the existing theme system
                console.log('🎨 Checking for existing theme system...', {
                    themeManager: !!window.themeManager,
                    themes: window.themeManager?.themes ? Object.keys(window.themeManager.themes) : 'none'
                });
                
                if (window.themeManager && window.themeManager.themes) {
                    const existingThemes = window.themeManager.themes;
                    
                    // Convert existing themes to enhanced theme format
                    Object.keys(existingThemes).forEach(themeKey => {
                        const existingTheme = existingThemes[themeKey];
                        const convertedTheme = this.convertToEnhancedTheme(themeKey, existingTheme);
                        this.themes[themeKey] = convertedTheme;
                        
                        console.log(`🎨 Converted theme '${themeKey}':`, convertedTheme);
                    });
                    
                    console.log(`🎨 Loaded ${Object.keys(this.themes).length} dynamic themes:`, Object.keys(this.themes));
                } else {
                    // Fallback to predefined themes if existing system not available
                    this.loadFallbackThemes();
                    console.log('🎨 Using fallback themes - existing system not available');
                }
                
                // Always ensure we have fallback themes merged in
                this.ensureFallbackThemes();
            }

            convertToEnhancedTheme(themeKey, existingTheme) {
                const enhancedTheme = {
                    name: existingTheme.name || themeKey,
                    effects: {
                        glow: false,
                        shadow: false,
                        pattern: 'solid'
                    },
                    shapeOverrides: this.generateShapeColorsFromTheme(existingTheme)
                };

                // Add special effects for certain themes
                if (themeKey.includes('neon') || themeKey.includes('glow')) {
                    enhancedTheme.effects.glow = true;
                    enhancedTheme.effects.glowColor = 0x00FFFF;
                    enhancedTheme.effects.glowStrength = 2;
                }

                if (themeKey.includes('retro') || themeKey.includes('vintage')) {
                    enhancedTheme.effects.shadow = true;
                    enhancedTheme.effects.shadowOffset = 3;
                    enhancedTheme.effects.pattern = 'pixelated';
                }

                return enhancedTheme;
            }

            generateShapeColorsFromTheme(existingTheme) {
                const shapeOverrides = {};
                
                // Use theme background colors as a base palette
                if (existingTheme.background && existingTheme.background.colors) {
                    const colors = existingTheme.background.colors;
                    const shapes = ['square', 'triangle', 'circle', 'cross2', 'l', 'cross', 'barbell-one', 'barbell-two', 'diamond-barbell'];
                    
                    shapes.forEach((shape, index) => {
                        const colorIndex = index % colors.length;
                        const baseColor = colors[colorIndex];
                        const strokeColor = this.darkenHex(baseColor, 20);
                        
                        shapeOverrides[shape] = {
                            color: baseColor,
                            stroke: strokeColor
                        };
                    });
                }
                
                return shapeOverrides;
            }

            darkenHex(hex, percent) {
                // Convert hex to RGB, darken, convert back
                const num = parseInt(hex.replace('#', ''), 16);
                const amt = Math.round(2.55 * percent);
                const R = (num >> 16) - amt;
                const G = (num >> 8 & 0x00FF) - amt;
                const B = (num & 0x0000FF) - amt;
                
                return '#' + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
                        (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
                        (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
            }

            loadFallbackThemes() {
                const fallbackThemes = {
                    classic: {
                        name: 'Classic',
                        effects: {
                            glow: false,
                            shadow: false,
                            pattern: 'solid'
                        },
                        shapeOverrides: {
                            // Uses default SHAPE_CONFIG colors
                        }
                    },
                    neon: {
                        name: 'Neon Glow',
                        effects: {
                            glow: true,
                            glowColor: 0x00FFFF,
                            glowStrength: 2,
                            shadow: false,
                            pattern: 'solid'
                        },
                        shapeOverrides: {
                            square: { color: '#FF1493', stroke: '#FF69B4' },
                            triangle: { color: '#00FFFF', stroke: '#40E0D0' },
                            circle: { color: '#FFFF00', stroke: '#FFD700' },
                            cross2: { color: '#FF4500', stroke: '#FF6347' },
                            l: { color: '#9370DB', stroke: '#BA55D3' },
                            cross: { color: '#00FF00', stroke: '#32CD32' },
                            'barbell-one': { color: '#FF1493', stroke: '#FF69B4' },
                            'barbell-two': { color: '#00BFFF', stroke: '#87CEEB' },
                            'diamond-barbell': { color: '#FFD700', stroke: '#FFA500' }
                        }
                    },
                    retro: {
                        name: 'Retro Pixel',
                        effects: {
                            glow: false,
                            shadow: true,
                            shadowOffset: 3,
                            pattern: 'pixelated'
                        },
                        shapeOverrides: {
                            square: { color: '#8B4513', stroke: '#A0522D' },
                            triangle: { color: '#556B2F', stroke: '#6B8E23' },
                            circle: { color: '#2F4F4F', stroke: '#708090' },
                            cross2: { color: '#800080', stroke: '#9932CC' },
                            l: { color: '#B22222', stroke: '#DC143C' },
                            cross: { color: '#4682B4', stroke: '#5F9EA0' },
                            'barbell-one': { color: '#DAA520', stroke: '#FFD700' },
                            'barbell-two': { color: '#CD853F', stroke: '#D2B48C' },
                            'diamond-barbell': { color: '#8B0000', stroke: '#A52A2A' }
                        }
                    },
                    wood: {
                        name: 'Wood',
                        effects: {
                            glow: true,
                            glowColor: 0xA0522D,
                            glowStrength: 1.5,
                            shadow: false,
                            pattern: 'gradient'
                        },
                        shapeOverrides: {
                            square: { color: '#8B4513', stroke: '#A0522D' },
                            triangle: { color: '#D2B48C', stroke: '#DEB887' },
                            circle: { color: '#CD853F', stroke: '#DAA520' },
                            cross2: { color: '#8B4513', stroke: '#A0522D' },
                            l: { color: '#D2691E', stroke: '#F4A460' },
                            cross: { color: '#B8860B', stroke: '#DAA520' },
                            'barbell-one': { color: '#8B4513', stroke: '#A0522D' },
                            'barbell-two': { color: '#CD853F', stroke: '#D2B48C' },
                            'diamond-barbell': { color: '#DEB887', stroke: '#F5DEB3' }
                        }
                    },
                    stone: {
                        name: 'Stone',
                        effects: {
                            glow: false,
                            shadow: true,
                            shadowOffset: 2,
                            pattern: 'solid'
                        },
                        shapeOverrides: {
                            square: { color: '#708090', stroke: '#2F4F4F' },
                            triangle: { color: '#696969', stroke: '#778899' },
                            circle: { color: '#D3D3D3', stroke: '#A9A9A9' },
                            cross2: { color: '#708090', stroke: '#2F4F4F' },
                            l: { color: '#696969', stroke: '#778899' },
                            cross: { color: '#D3D3D3', stroke: '#A9A9A9' },
                            'barbell-one': { color: '#708090', stroke: '#2F4F4F' },
                            'barbell-two': { color: '#696969', stroke: '#778899' },
                            'diamond-barbell': { color: '#D3D3D3', stroke: '#A9A9A9' }
                        }
                    },
                    metal: {
                        name: 'Metal',
                        effects: {
                            glow: true,
                            glowColor: 0xC0C0C0,
                            glowStrength: 2.0,
                            shadow: false,
                            pattern: 'metallic'
                        },
                        shapeOverrides: {
                            square: { color: '#696969', stroke: '#C0C0C0' },
                            triangle: { color: '#CD7F32', stroke: '#DAA520' },
                            circle: { color: '#FFD700', stroke: '#FFA500' },
                            cross2: { color: '#696969', stroke: '#C0C0C0' },
                            l: { color: '#8B4513', stroke: '#A0522D' },
                            cross: { color: '#CD7F32', stroke: '#DAA520' },
                            'barbell-one': { color: '#696969', stroke: '#C0C0C0' },
                            'barbell-two': { color: '#696969', stroke: '#C0C0C0' },
                            'diamond-barbell': { color: '#FFD700', stroke: '#FFA500' }
                        }
                    }
                };
                
                // Add fallback themes to current themes
                Object.assign(this.themes, fallbackThemes);
            }

            ensureFallbackThemes() {
                // Always make sure we have classic themes available
                if (!this.themes.classic) {
                    this.themes.classic = {
                        name: 'Classic',
                        effects: {
                            glow: false,
                            shadow: false,
                            pattern: 'solid'
                        },
                        shapeOverrides: {}
                    };
                }

                // Add missing common themes with generated colors - using new material names
                const commonThemes = ['metal', 'stone', 'retro', 'modern'];
                commonThemes.forEach(themeName => {
                    if (!this.themes[themeName]) {
                        this.themes[themeName] = this.generateFallbackTheme(themeName);
                        console.log(`🎨 Generated fallback theme: ${themeName}`);
                    }
                });
            }

            generateFallbackTheme(themeName) {
                // Direct material theme mapping (no conversion needed for material names)
                const themeMapping = {
                    'metal': 'metal',
                    'stone': 'stone', 
                    'retro': 'classic',
                    'modern': 'classic'
                };
                
                const enhancedThemeName = themeMapping[themeName] || themeName;
                
                const themeColors = {
                    metal: ['#696969', '#C0C0C0', '#808080', '#A9A9A9', '#778899'], // Metal colors
                    stone: ['#708090', '#2F4F4F', '#696969', '#778899', '#D3D3D3'], // Stone colors  
                    retro: ['#FF6347', '#FFD700', '#DA70D6', '#98FB98', '#F0E68C'],
                    modern: ['#2E8B57', '#4682B4', '#DC143C', '#FF8C00', '#9932CC']
                };

                const colors = themeColors[themeName] || themeColors.modern;
                const shapes = ['square', 'triangle', 'circle', 'cross2', 'l', 'cross', 'barbell-one', 'barbell-two', 'diamond-barbell'];
                const shapeOverrides = {};

                shapes.forEach((shape, index) => {
                    const colorIndex = index % colors.length;
                    const baseColor = colors[colorIndex];
                    const strokeColor = this.darkenHex(baseColor, 20);
                    
                    shapeOverrides[shape] = {
                        color: baseColor,
                        stroke: strokeColor
                    };
                });

                const themeDisplayNames = {
                    'forest': 'Metal',
                    'space': 'Stone',
                    'retro': 'Classic',
                    'modern': 'Classic'
                };

                return {
                    name: themeDisplayNames[themeName] || themeName.charAt(0).toUpperCase() + themeName.slice(1),
                    effects: {
                        glow: themeName === 'space',
                        shadow: themeName === 'retro',
                        pattern: 'solid'
                    },
                    shapeOverrides
                };
            }

            applyTheme(themeName, pixiShapeRenderer = null) {
                if (!this.themes[themeName]) {
                    console.warn(`⚠️ Theme not found: ${themeName}`);
                    return false;
                }

                this.currentTheme = themeName;
                const theme = this.themes[themeName];
                
                console.log(`🎨 Applying enhanced theme: ${theme.name}`, theme.shapeOverrides);

                // Apply to existing PixiJS shapes if renderer provided
                if (pixiShapeRenderer) {
                    this.updateExistingShapes(pixiShapeRenderer, theme);
                }

                // Refresh dock shapes with new theme colors
                this.refreshDockWithTheme();

                console.log(`✅ Enhanced theme applied: ${theme.name}`);
                return true;
            }

            updateExistingShapes(pixiShapeRenderer, theme) {
                if (!pixiShapeRenderer.shapes || pixiShapeRenderer.shapes.size === 0) {
                    console.log('🎨 No existing PixiJS shapes to update');
                    return;
                }

                console.log(`🎨 Updating ${pixiShapeRenderer.shapes.size} existing shapes with theme: ${theme.name}`);

                pixiShapeRenderer.shapes.forEach((shapeData, bodyId) => {
                    const { graphics, shapeType } = shapeData;
                    
                    if (!graphics || !graphics.parent) {
                        console.warn(`⚠️ Invalid shape data for body ${bodyId}`);
                        return;
                    }
                    
                    // Get fresh configuration with theme overrides
                    const freshConfig = getShapeConfig(shapeType);
                    
                    if (!freshConfig) {
                        console.warn(`⚠️ No configuration found for shape type: ${shapeType}`);
                        return;
                    }
                    
                    console.log(`🎨 Updating ${shapeType} with colors:`, freshConfig);
                    
                    // Preserve position and physics properties
                    const preserveData = {
                        x: graphics.x,
                        y: graphics.y,
                        rotation: graphics.rotation,
                        scale: graphics.scale.clone(),
                        alpha: graphics.alpha,
                        parent: graphics.parent
                    };
                    
                    // Create new graphics with updated theme
                    const newGraphics = PixiShapeFactory.createShape(shapeType, freshConfig);
                    
                    if (!newGraphics) {
                        console.warn(`⚠️ Failed to create new graphics for ${shapeType}`);
                        return;
                    }
                    
                    // Apply theme effects
                    this.applyThemeEffects(newGraphics, theme);
                    
                    // Restore preserved properties
                    newGraphics.x = preserveData.x;
                    newGraphics.y = preserveData.y;
                    newGraphics.rotation = preserveData.rotation;
                    newGraphics.scale.copyFrom(preserveData.scale);
                    newGraphics.alpha = preserveData.alpha;
                    
                    // Replace in container
                    preserveData.parent.removeChild(graphics);
                    preserveData.parent.addChild(newGraphics);
                    
                    // Update the shape reference in renderer
                    shapeData.graphics = newGraphics;
                });

                console.log(`✅ Updated ${pixiShapeRenderer.shapes.size} shapes with theme colors`);
            }

            refreshDockWithTheme() {
                // Force rebuild the visual dock with new theme colors
                if (typeof rebuildGameDock === 'function') {
                    console.log('🎨 Refreshing dock with new theme colors...');
                    rebuildGameDock();
                } else {
                    console.warn('⚠️ rebuildGameDock function not available for dock refresh');
                }
            }

            applyThemeEffects(graphics, theme) {
                const effects = theme.effects;
                
                // Apply glow effect
                if (effects.glow && this.pixiManager.app.renderer) {
                    try {
                        // Simple glow simulation using filters if available
                        if (PIXI.filters && PIXI.filters.GlowFilter) {
                            const glowFilter = new PIXI.filters.GlowFilter({
                                color: effects.glowColor || 0xFFFFFF,
                                distance: 10,
                                outerStrength: effects.glowStrength || 1,
                                innerStrength: 0
                            });
                            graphics.filters = [glowFilter];
                        } else {
                            // Fallback: adjust tint for glow effect
                            graphics.tint = effects.glowColor || 0xFFFFFF;
                            graphics.alpha = 0.9;
                        }
                    } catch (error) {
                        console.warn('⚠️ Glow effect not available, using fallback');
                    }
                }

                // Apply shadow effect (simple offset)
                if (effects.shadow) {
                    // This would require duplicating the graphics with offset
                    // For now, we'll just add a subtle dark tint
                    graphics.tint = this.darkenColor(graphics.tint || 0xFFFFFF, 0.1);
                }
            }

            darkenColor(color, amount) {
                const r = Math.max(0, ((color >> 16) & 0xFF) * (1 - amount));
                const g = Math.max(0, ((color >> 8) & 0xFF) * (1 - amount));
                const b = Math.max(0, (color & 0xFF) * (1 - amount));
                return (Math.round(r) << 16) | (Math.round(g) << 8) | Math.round(b);
            }

            getCurrentTheme() {
                return this.currentTheme;
            }

            getAvailableThemes() {
                return Object.keys(this.themes);
            }

            getThemeInfo(themeName) {
                return this.themes[themeName] || null;
            }
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ THEME MANAGER - HANDLES THEME SWITCHING AND VISUAL UPDATES
          ║ Coordinates theme changes across all game systems
          ╚═══════════════════════════════════════════════════════════════════════════*/
        class ThemeManager {
            constructor(assetManager, gameManager) {
                this.assetManager = assetManager;
                this.gameManager = gameManager;
                
                // V14: Support both unified and legacy configuration
                this.currentTheme = this.getDefaultTheme();
                this.isTransitioning = false;
                this.transitionCallbacks = [];
                
                // V14: Track configuration source
                this.useUnifiedConfig = typeof UNIFIED_GAME_CONFIG !== 'undefined';
                
                console.log(`🎨 ThemeManager: Initialized with ${this.useUnifiedConfig ? 'unified' : 'legacy'} config, default theme: ${this.currentTheme}`);
            }
            
            // V14: Smart default theme resolution
            getDefaultTheme() {
                if (typeof UNIFIED_GAME_CONFIG !== 'undefined' && UNIFIED_GAME_CONFIG.theme) {
                    return UNIFIED_GAME_CONFIG.theme.defaultTheme;
                }
                return CANVAS_CONFIG.defaultTheme;
            }
            
            // V14: Smart theme enabled check
            isThemeSystemEnabled() {
                if (this.useUnifiedConfig && UNIFIED_GAME_CONFIG.theme) {
                    return UNIFIED_GAME_CONFIG.theme.enabled;
                }
                return CANVAS_CONFIG.enabled && CANVAS_CONFIG.useThemes;
            }

            async switchTheme(themeName, animated = true) {
                if (!this.isThemeSystemEnabled()) {
                    console.log('🎨 Theme Manager: Theme switching disabled');
                    return;
                }

                if (this.isTransitioning || !THEME_DEFINITIONS[themeName]) {
                    console.log(`🎨 Cannot switch to theme: ${themeName}`);
                    return;
                }

                console.log(`🎨 Switching theme from ${this.currentTheme} to ${themeName}`);
                this.isTransitioning = true;

                try {
                    // Clear old theme textures before loading new ones
                    if (this.currentTheme && this.currentTheme !== themeName) {
                        console.log(`🧹 Clearing textures for old theme: ${this.currentTheme}`);
                        this.assetManager.clearThemeImages(this.currentTheme);
                        
                        // Also clear from UnifiedTextureManager if available
                        if (typeof gameManager !== 'undefined' && 
                            gameManager.physicsManager?.unifiedPixiManager?.textureManager) {
                            gameManager.physicsManager.unifiedPixiManager.textureManager.clearThemeTextures(this.currentTheme);
                        }
                    }
                    
                    // Load the new theme
                    await this.assetManager.loadTheme(themeName);
                    
                    // Update visual elements
                    this.updateBackgroundStyle(themeName);
                    this.updatePlatformStyle(themeName);
                    
                    // Phase 2: Update PixiJS shapes with new theme
                    if (PIXI_CONFIG.features.shapeRendering && this.gameManager.physicsManager.pixiShapeRenderer.isEnabled) {
                        this.gameManager.physicsManager.pixiShapeRenderer.applyTheme(themeName);
                    }
                    
                    // Refresh dock shapes with new theme colors
                    if (typeof rebuildGameDock === 'function') {
                        console.log('🎨 Refreshing dock with new theme colors...');
                        rebuildGameDock();
                    }
                    
                    // Update current theme
                    this.currentTheme = themeName;
                    this.assetManager.currentTheme = themeName;
                    
                    // Notify listeners
                    this.notifyThemeChanged(themeName);
                    
                    console.log(`✅ Theme switched to: ${themeName}`);
                    
                } catch (error) {
                    console.error(`❌ Failed to switch theme to ${themeName}:`, error);
                } finally {
                    this.isTransitioning = false;
                }
            }

            updateBackgroundStyle(themeName) {
                const bgStyle = this.assetManager.getBackgroundStyle(themeName);
                if (!bgStyle || !this.gameManager?.physicsManager) return;

                // Update the physics manager's background rendering
                if (bgStyle.type === 'gradient') {
                    this.gameManager.physicsManager.backgroundGradient = bgStyle.colors;
                    console.log(`🎨 Updated background gradient for ${themeName}:`, bgStyle.colors);
                }
            }

            updatePlatformStyle(themeName) {
                const platformStyle = this.assetManager.getPlatformStyle(themeName);
                if (!platformStyle || !this.gameManager?.physicsManager) return;

                // Update platform color
                this.gameManager.physicsManager.platformColor = platformStyle.color;
                console.log(`🎨 Updated platform color for ${themeName}:`, platformStyle.color);
            }

            getAvailableThemes() {
                return Object.keys(THEME_DEFINITIONS);
            }

            getCurrentTheme() {
                return this.currentTheme;
            }

            onThemeChanged(callback) {
                this.transitionCallbacks.push(callback);
            }

            notifyThemeChanged(themeName) {
                this.transitionCallbacks.forEach(callback => {
                    try {
                        callback(themeName);
                    } catch (error) {
                        console.error('❌ Error in theme change callback:', error);
                    }
                });
            }
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ PARTICLE SYSTEM - THEME-BASED VISUAL EFFECTS
          ║ Creates and manages particle effects based on current theme
          ╚═══════════════════════════════════════════════════════════════════════════*/
        class ParticleSystem {
            constructor(canvas, assetManager) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.assetManager = assetManager;
                this.particles = [];
                this.maxParticles = CANVAS_CONFIG.maxParticles;
                this.ambientParticleTimer = 0;
                this.ambientParticleInterval = 1000; // Spawn ambient particle every 1 second
            }

            createThemeParticles(type, x, y, count = 5) {
                if (!CANVAS_CONFIG.enabled || !CANVAS_CONFIG.useParticles) return;

                const particleStyle = this.assetManager.getParticleStyle();
                if (!particleStyle) return;

                for (let i = 0; i < Math.min(count, this.maxParticles - this.particles.length); i++) {
                    this.particles.push(this.createParticle(particleStyle, x, y, type));
                }
            }

            createParticle(style, x, y, type) {
                const colors = style.colors;
                const color = colors[Math.floor(Math.random() * colors.length)];
                
                return {
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4 - 2,
                    life: 1.0,
                    decay: 0.02 + Math.random() * 0.02,
                    size: 2 + Math.random() * 3,
                    color: color,
                    style: style.style
                };
            }

            createAmbientParticle() {
                if (!CANVAS_CONFIG.enabled || !CANVAS_CONFIG.useParticles) return;
                if (this.particles.length >= this.maxParticles) return;

                const particleStyle = this.assetManager.getParticleStyle();
                if (!particleStyle) return;

                // Create particles from random positions around the canvas edges
                const side = Math.floor(Math.random() * 4); // 0=top, 1=right, 2=bottom, 3=left
                let x, y, vx, vy;

                switch(side) {
                    case 0: // Top
                        x = Math.random() * this.canvas.width;
                        y = -10;
                        vx = (Math.random() - 0.5) * 2;
                        vy = Math.random() * 2 + 1;
                        break;
                    case 1: // Right  
                        x = this.canvas.width + 10;
                        y = Math.random() * this.canvas.height;
                        vx = -Math.random() * 2 - 1;
                        vy = (Math.random() - 0.5) * 2;
                        break;
                    case 2: // Bottom
                        x = Math.random() * this.canvas.width;
                        y = this.canvas.height + 10;
                        vx = (Math.random() - 0.5) * 2;
                        vy = -Math.random() * 2 - 1;
                        break;
                    case 3: // Left
                        x = -10;
                        y = Math.random() * this.canvas.height;
                        vx = Math.random() * 2 + 1;
                        vy = (Math.random() - 0.5) * 2;
                        break;
                }

                const colors = particleStyle.colors;
                const color = colors[Math.floor(Math.random() * colors.length)];
                
                this.particles.push({
                    x: x,
                    y: y,
                    vx: vx,
                    vy: vy,
                    life: 1.0,
                    decay: 0.01 + Math.random() * 0.01, // Slower decay for ambient particles
                    size: 1 + Math.random() * 2, // Smaller ambient particles
                    color: color,
                    style: particleStyle.style,
                    isAmbient: true
                });
            }

            update(deltaTime) {
                if (!CANVAS_CONFIG.useParticles) return;

                // Spawn ambient background particles periodically
                this.ambientParticleTimer += deltaTime;
                if (this.ambientParticleTimer >= this.ambientParticleInterval) {
                    this.createAmbientParticle();
                    this.ambientParticleTimer = 0;
                }

                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const particle = this.particles[i];
                    
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.vy += 0.1; // Gravity
                    particle.life -= particle.decay;
                    
                    if (particle.life <= 0) {
                        this.particles.splice(i, 1);
                    }
                }
            }

            render() {
                if (!CANVAS_CONFIG.useParticles) return;

                this.particles.forEach(particle => {
                    this.ctx.save();
                    this.ctx.globalAlpha = particle.life;
                    this.ctx.fillStyle = particle.color;
                    
                    if (particle.style === 'bubbles') {
                        this.ctx.strokeStyle = particle.color;
                        this.ctx.lineWidth = 1;
                        this.ctx.beginPath();
                        this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        this.ctx.stroke();
                    } else {
                        this.ctx.beginPath();
                        this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                    
                    this.ctx.restore();
                });
            }
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ PHYSICS-BASED SHAPE RENDERER
          ║ Renders shapes consistently using physics configuration
          ║ Used for both dock previews and physics simulation
          ╚═══════════════════════════════════════════════════════════════════════════*/
        class PhysicsShapeRenderer {
            renderShapeOnCanvas(ctx, shapeType, x, y, rotation = 0, scale = 1) {
                // V14: Commented out verbose rendering logging
                // console.log(`🎨 renderShapeOnCanvas: ${shapeType} at (${x},${y})`);
                const config = getShapeConfig(shapeType);
                if (!config) {
                    console.error(`❌ No config found for renderShapeOnCanvas: ${shapeType}`);
                    return;
                }

                // V14: Commented out verbose config logging
                // console.log(`📐 Config for ${shapeType}:`, config);

                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.scale(scale, scale);

                switch (config.type) {
                    case 'rectangle':
                        console.log(`📦 Drawing rectangle for ${shapeType}`);
                        this.drawRectangle(ctx, config);
                        break;
                    case 'circle':
                        console.log(`⭕ Drawing circle for ${shapeType}`);
                        this.drawCircle(ctx, config);
                        break;
                    case 'polygon':
                        console.log(`🔷 Drawing polygon for ${shapeType}`);
                        this.drawPolygon(ctx, config);
                        break;
                    case 'compound':
                        console.log(`🔗 Drawing compound shape for ${shapeType}`);
                        this.drawCompoundShape(ctx, config);
                        break;
                    default:
                        console.error(`❌ Unknown shape type: ${config.type} for ${shapeType}`);
                }

                ctx.restore();
                console.log(`✅ Rendered ${shapeType}`);
            }

            createDockPreview(shapeType, size = 90) {
                // V14: Commented out verbose dock preview logging
                // console.log(`🎨 createDockPreview called for: ${shapeType}, size: ${size}`);
                const config = getShapeConfig(shapeType);
                if (!config) {
                    console.error(`❌ No config found for shape: ${shapeType}`);
                    return null;
                }
                
                console.log(`🔍 Shape config for ${shapeType}:`, config);
                
                // Use texture registry as primary source for texture detection
                const textureConfig = window.textureRegistry.getTextureConfig(shapeType);
                console.log(`🔍 Texture registry config for ${shapeType}:`, textureConfig);
                
                // Check if texture is available from registry
                const hasTextureFromRegistry = textureConfig && textureConfig.hasTexture;
                
                // Fallback check for legacy system
                const hasTextureFromLegacy = config.texture && window.currentTheme?.shapes?.textures && 
                                           window.currentTheme.shapes.textures[shapeType];
                
                const hasTexture = hasTextureFromRegistry || hasTextureFromLegacy;
                
                console.log(`🔍 Texture availability:`, {
                    fromRegistry: hasTextureFromRegistry,
                    fromLegacy: hasTextureFromLegacy,
                    finalDecision: hasTexture,
                    registryReady: window.textureRegistry.ready,
                    currentTheme: window.textureRegistry.currentTheme
                });
                
                if (hasTexture) {
                    console.log(`🎨 Creating PixiJS preview for ${shapeType} with texture`);
                    return this.createPixiDockPreview(shapeType, config, size);
                } else {
                    console.log(`🎨 Creating Canvas preview for ${shapeType} (no texture available)`);
                    return this.createCanvasDockPreview(shapeType, config, size);
                }
            }

            createPixiDockPreview(shapeType, config, size = 90) {
                // Create a canvas element to hold the PixiJS view
                const container = document.createElement('div');
                container.className = 'shape-preview pixi-preview';
                container.dataset.shape = shapeType;
                container.style.width = `${size}px`;
                container.style.height = `${size}px`;
                container.style.position = 'relative';
                container.style.border = '2px solid #DAA520';
                container.style.boxShadow = '0 0 8px rgba(218, 165, 32, 0.5)';
                container.style.borderRadius = '4px';
                container.style.overflow = 'hidden';
                container.title = `${shapeType} - Textured (${config.texture})`;

                try {
                    // Create a mini PixiJS application for this preview
                    const previewApp = new PIXI.Application({
                        width: size,
                        height: size,
                        backgroundColor: 0xf8f9fa,
                        antialias: true,
                        resolution: window.devicePixelRatio || 1,
                        autoDensity: true
                    });

                    // Create the textured shape
                    const pixiShape = PixiShapeFactory.createShape(shapeType, config);
                    if (pixiShape) {
                        // Position in center and scale appropriately
                        pixiShape.x = size / 2;
                        pixiShape.y = size / 2;
                        
                        // Scale down to fit in preview
                        const scale = 1.9;
                        pixiShape.scale.set(scale);

                        // Handle barbell rotation
                        if (shapeType && shapeType.includes('barbell')) {
                            const barbellOrientationSelect = document.getElementById('barbellOrientation');
                            if (barbellOrientationSelect && barbellOrientationSelect.value === 'vertical') {
                                pixiShape.rotation = Math.PI / 2;
                                console.log(`🔄 Applied vertical rotation to PixiJS preview: ${shapeType}`);
                            }
                        }

                        previewApp.stage.addChild(pixiShape);
                        console.log(`✅ PixiJS textured preview created for: ${shapeType}`);
                    } else {
                        console.warn(`⚠️ Failed to create PixiJS shape for: ${shapeType}`);
                        // Fallback to canvas rendering
                        return this.createCanvasDockPreview(shapeType, config, size);
                    }

                    // Add the PixiJS canvas to our container
                    container.appendChild(previewApp.view);
                    
                    // Store reference for cleanup
                    container._pixiApp = previewApp;
                    
                    return container;
                    
                } catch (error) {
                    console.error(`❌ Error creating PixiJS preview for ${shapeType}:`, error);
                    // Fallback to canvas rendering
                    return this.createCanvasDockPreview(shapeType, config, size);
                }
            }

            createCanvasDockPreview(shapeType, config, size = 90) {
                // Use larger canvas to accommodate full-size shape rendering
                const canvas = document.createElement('canvas');
                canvas.width = size;
                canvas.height = size;
                canvas.className = `shape-preview`;
                canvas.dataset.shape = shapeType;

                const ctx = canvas.getContext('2d');
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';

                // Use texture registry for consistent texture detection
                const textureConfig = window.textureRegistry.getTextureConfig(shapeType);
                const hasTextureFromRegistry = textureConfig && textureConfig.hasTexture;
                
                // Fallback check for legacy system
                const hasTextureFromLegacy = config.texture && window.currentTheme?.shapes?.textures && 
                                           window.currentTheme.shapes.textures[shapeType];
                
                const hasTexture = hasTextureFromRegistry || hasTextureFromLegacy;
                
                if (hasTexture) {
                    console.log(`🎨 Canvas preview for ${shapeType} - texture available via ${hasTextureFromRegistry ? 'registry' : 'legacy'}`);
                    // Add a subtle texture indicator border
                    canvas.style.border = '2px solid #DAA520';
                    canvas.style.boxShadow = '0 0 8px rgba(218, 165, 32, 0.5)';
                    canvas.title = `${shapeType} - Textured`;
                } else {
                    console.log(`🎨 Canvas preview for ${shapeType} - using themed colors only`);
                    canvas.style.border = '1px solid #ccc';
                    canvas.title = `${shapeType} - Themed colors`;
                }

                // Use 2x scale for full-size display, matching 2x physics scale (30→60)
                const scale = 1.9;
                console.log(`📐 Shape ${shapeType}: using enlarged scale=${scale} for full-size display`);
                
                // Check barbell orientation setting for dock preview rotation
                let rotation = 0;
                if (shapeType && shapeType.includes('barbell')) {
                    const barbellOrientationSelect = document.getElementById('barbellOrientation');
                    if (barbellOrientationSelect && barbellOrientationSelect.value === 'vertical') {
                        rotation = Math.PI / 2; // 90 degrees for vertical orientation
                        console.log(`🔄 Applying vertical rotation (90°) to ${shapeType}`);
                    }
                }
                
                // Render the shape in the center of the preview canvas
                this.renderShapeOnCanvas(ctx, shapeType, size / 2, size / 2, rotation, scale);
                
                console.log(`✅ Canvas preview created for: ${shapeType} with scale ${scale}, rotation ${(rotation * 180 / Math.PI).toFixed(0)}°`);
                return canvas;
            }

            drawRectangle(ctx, config) {
                const { width, height, color, stroke, strokeWidth } = config;
                
                // Check if texture is available from config
                if (config.hasTexture && config.texture) {
                    // Try to render with texture if available
                    this.drawWithTexture(ctx, config, () => {
                        ctx.fillRect(-width / 2, -height / 2, width, height);
                    });
                    
                    // Add stroke
                    ctx.strokeStyle = stroke;
                    ctx.lineWidth = strokeWidth;
                    ctx.strokeRect(-width / 2, -height / 2, width, height);
                } else {
                    // Fallback to color-based rendering
                    ctx.fillStyle = color;
                    ctx.strokeStyle = stroke;
                    ctx.lineWidth = strokeWidth;

                    ctx.fillRect(-width / 2, -height / 2, width, height);
                    ctx.strokeRect(-width / 2, -height / 2, width, height);
                }
            }

            drawCircle(ctx, config) {
                const { radius, color, stroke, strokeWidth } = config;
                
                // Check if texture is available from config
                if (config.hasTexture && config.texture) {
                    // Try to render with texture if available
                    this.drawWithTexture(ctx, config, () => {
                        ctx.beginPath();
                        ctx.arc(0, 0, radius, 0, Math.PI * 2);
                        ctx.fill();
                    });
                    
                    // Add stroke
                    ctx.strokeStyle = stroke;
                    ctx.lineWidth = strokeWidth;
                    ctx.beginPath();
                    ctx.arc(0, 0, radius, 0, Math.PI * 2);
                    ctx.stroke();
                } else {
                    // Fallback to color-based rendering
                    ctx.fillStyle = color;
                    ctx.strokeStyle = stroke;
                    ctx.lineWidth = strokeWidth;

                    ctx.beginPath();
                    ctx.arc(0, 0, radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                }
            }

            drawPolygon(ctx, config) {
                const { vertices, color, stroke, strokeWidth } = config;
                
                // Check if texture is available from config
                if (config.hasTexture && config.texture) {
                    // Try to render with texture if available
                    this.drawWithTexture(ctx, config, () => {
                        ctx.beginPath();
                        ctx.moveTo(vertices[0].x, vertices[0].y);
                        for (let i = 1; i < vertices.length; i++) {
                            ctx.lineTo(vertices[i].x, vertices[i].y);
                        }
                        ctx.closePath();
                        ctx.fill();
                    });
                    
                    // Add stroke
                    ctx.strokeStyle = stroke;
                    ctx.lineWidth = strokeWidth;
                    ctx.beginPath();
                    ctx.moveTo(vertices[0].x, vertices[0].y);
                    for (let i = 1; i < vertices.length; i++) {
                        ctx.lineTo(vertices[i].x, vertices[i].y);
                    }
                    ctx.closePath();
                    ctx.stroke();
                } else {
                    // Fallback to color-based rendering
                    ctx.fillStyle = color;
                    ctx.strokeStyle = stroke;
                    ctx.lineWidth = strokeWidth;

                    ctx.beginPath();
                    ctx.moveTo(vertices[0].x, vertices[0].y);
                    for (let i = 1; i < vertices.length; i++) {
                        ctx.lineTo(vertices[i].x, vertices[i].y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                }
            }

            drawCompoundShape(ctx, config) {
                for (const part of config.parts) {
                    ctx.save();
                    ctx.translate(part.offsetX || 0, part.offsetY || 0);

                    // THEME FIX: Use theme colors from main config instead of part-specific colors
                    // This ensures compound shapes inherit theme colors properly
                    const partConfig = {
                        ...config,
                        ...part,
                        // Override part colors with theme-aware colors from main config
                        color: config.color,      // Use theme color instead of part.color
                        stroke: config.stroke     // Use theme stroke instead of part.stroke
                    };

                    switch (part.type) {
                        case 'rectangle':
                            this.drawRectangle(ctx, partConfig);
                            break;
                        case 'circle':
                            this.drawCircle(ctx, partConfig);
                            break;
                        case 'diamond':
                            this.drawDiamond(ctx, partConfig);
                            break;
                    }
                    ctx.restore();
                }
            }

            drawDiamond(ctx, config) {
                // For dock preview consistency, render diamond exactly as physics will:
                // as a rotated rectangle to match the planck.Box(..., Math.PI/4) creation
                const { width, height, color, stroke, strokeWidth } = config;
                
                ctx.save();
                // Apply the same rotation that's used in physics fixture creation
                ctx.rotate(Math.PI / 4);
                
                // Check if texture is available from config
                if (config.hasTexture && config.texture) {
                    // Try to render with texture if available
                    this.drawWithTexture(ctx, config, () => {
                        ctx.fillRect(-width / 2, -height / 2, width, height);
                    });
                    
                    // Add stroke
                    ctx.strokeStyle = stroke;
                    ctx.lineWidth = strokeWidth;
                    ctx.strokeRect(-width / 2, -height / 2, width, height);
                } else {
                    // Fallback to color-based rendering
                    ctx.fillStyle = color;
                    ctx.strokeStyle = stroke;
                    ctx.lineWidth = strokeWidth;

                    ctx.fillRect(-width / 2, -height / 2, width, height);
                    ctx.strokeRect(-width / 2, -height / 2, width, height);
                }
                
                ctx.restore();
            }

            // Helper method for texture-aware drawing
            drawWithTexture(ctx, config, drawCallback) {
                // For now, use color-based rendering as fallback
                // TODO: Implement actual texture rendering when texture system is ready
                ctx.fillStyle = config.color;
                
                // Apply texture-like visual effect for textured shapes
                if (config.hasTexture) {
                    // Create a subtle pattern or visual indicator for textured shapes
                    ctx.save();
                    ctx.globalAlpha = 0.8; // Slight transparency to indicate texture
                    drawCallback();
                    ctx.restore();
                    
                    // Add subtle texture indicator
                    ctx.save();
                    ctx.fillStyle = '#DAA520'; // Gold color to indicate texture
                    ctx.globalAlpha = 0.2;
                    drawCallback();
                    ctx.restore();
                } else {
                    drawCallback();
                }
            }
        }

        // Global shape renderer instance
        const shapeRenderer = new PhysicsShapeRenderer();

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ UNIFIED DOCK SYSTEM
          ║ Replaces CSS-based dock with canvas-rendered previews matching physics
          ║ Maintains existing functionality while implementing unified appearance
          ╚═══════════════════════════════════════════════════════════════════════════*/
        function rebuildGameDock() {
            console.log('🔧 rebuildGameDock() called');
            const dockingArea = document.getElementById('dockingArea');
            if (!dockingArea) {
                console.error('❌ dockingArea not found!');
                return;
            }

            // Get current dock shapes from level config or fallback to all shapes
            const dockShapes = window.currentLevelConfig ? window.currentLevelConfig.dockShapes : getAllShapeTypes();
            console.log('📦 Building dock with shapes:', dockShapes);
            console.log('📦 Current level config exists:', !!window.currentLevelConfig);
            console.log('📦 Shape renderer available:', !!shapeRenderer);
            
            // Clear and rebuild dock with canvas previews
            // First cleanup any existing PixiJS applications
            const existingPreviews = dockingArea.querySelectorAll('.pixi-preview');
            existingPreviews.forEach(preview => {
                if (preview._pixiApp) {
                    console.log('🧹 Cleaning up PixiJS preview application');
                    preview._pixiApp.destroy(true);
                    preview._pixiApp = null;
                }
            });
            
            dockingArea.innerHTML = '';
            console.log('🧹 Cleared existing dock content');
            
            dockShapes.forEach((shapeType, index) => {
                // V14: Commented out verbose dock creation logging
                // console.log(`🏗️ Creating slot ${index + 1} for: ${shapeType}`);
                const slotDiv = document.createElement('div');
                slotDiv.className = 'shape-slot'; // Ensure no 'empty' class on fresh slots
                slotDiv.id = `slot-${shapeType}`;

                if (shapeType && shapeRenderer) {
                    // Create full-size canvas preview using unified renderer
                    const canvasPreview = shapeRenderer.createDockPreview(shapeType, 90);
                    if (canvasPreview) {
                        canvasPreview.id = `shape-${shapeType}`;
                        canvasPreview.dataset.shape = shapeType;
                        canvasPreview.className = 'game-shape shape-preview';
                        canvasPreview.style.visibility = 'visible'; // Ensure visibility is reset
                        slotDiv.appendChild(canvasPreview);
                        console.log(`✅ Created canvas preview for: ${shapeType}`);
                    } else {
                        console.error(`❌ Failed to create canvas preview for: ${shapeType}`);
                        // Create a temporary colored div fallback
                        const fallback = document.createElement('div');
                        fallback.className = 'game-shape shape-preview';
                        fallback.dataset.shape = shapeType;
                        fallback.id = `shape-${shapeType}`;
                        fallback.style.width = '50px';
                        fallback.style.height = '50px';
                        fallback.style.backgroundColor = getShapeConfig(shapeType)?.color || '#95A5A6';
                        fallback.style.border = '2px solid #7F8C8D';
                        fallback.style.borderRadius = '4px';
                        fallback.style.visibility = 'visible';
                        fallback.textContent = shapeType.charAt(0).toUpperCase();
                        slotDiv.appendChild(fallback);
                        console.log(`⚠️ Created fallback preview for: ${shapeType}`);
                    }
                } else {
                    console.warn(`⚠️ Empty slot or no renderer for: ${shapeType}`);
                    slotDiv.classList.add('empty');
                }
                
                dockingArea.appendChild(slotDiv);
                console.log(`📍 Added slot for ${shapeType} to dock`);
            });

            console.log(`✅ Game dock rebuilt with ${dockShapes.length} slots total`);
        }

        // Initialize unified dock system (called after level config is ready)
        function initializeUnifiedDockSystem() {
            console.log('� Initializing Unified Dock System...');
            rebuildGameDock();
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ ENHANCED PHYSICS MANAGER WITH EVENT SYSTEM
          ║ Phase 4.1: Implements collision detection, fall detection, and physics events
          ║ Integrates physics events with game state for advanced game mechanics.
          ╚═══════════════════════════════════════════════════════════════════════════*/
        class PhysicsManager {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                
                // Matter.js aliases for cleaner code
                this.Engine = Matter.Engine;
                this.World = Matter.World;
                this.Bodies = Matter.Bodies;
                this.Body = Matter.Body;
                this.Events = Matter.Events;
                
                // Event tracking
                this.eventCount = 0;
                this.collisionCount = 0;
                this.fallCount = 0;
                
                // Canvas Enhancement System v9
                this.assetManager = new AssetManager();
                this.particleSystem = new ParticleSystem(canvas, this.assetManager);
                
                // Phase 1: PixiJS Integration - Dual Renderer System
                this.rendererManager = new RendererManager(canvas);
                
                // Phase 2: PixiJS Shape Rendering System
                this.pixiShapeRenderer = new PixiShapeRenderer(this.rendererManager);
                
                console.log('🎮 PhysicsManager with dual renderer support initialized');
                
                // Theme-based rendering properties
                this.backgroundGradient = null;
                this.platformColor = '#8B4513';
                
                console.log('🎨 Canvas Enhancement System initialized');
                
                // Initialize with default theme
                this.initializeDefaultTheme();
                
                // Phase 1: Initialize dual renderer system
                this.initializeRenderers();
                
                // Resize canvas to container
                this.resizeCanvas();
                
                // Create Matter.js world with physics engine
                this.engine = this.Engine.create();
                this.world = this.engine.world;
                
                // Set gravity (Matter.js uses different scale than Planck.js)
                this.engine.world.gravity.x = 0;
                this.engine.world.gravity.y = 1; // 1 pixel/frame² gravity
                
                // Track all dynamic bodies for rendering and cleanup
                this.dynamicBodies = [];
                
                // Camera shake system
                this.cameraShake = {
                    active: false,
                    intensity: 0,
                    duration: 0,
                    elapsed: 0,
                    frequencyX: 0.1,
                    frequencyY: 0.1,
                    offsetX: 0,
                    offsetY: 0
                };
                
                // Setup physics event listeners
                this.setupPhysicsEvents();
                
                // Create game platform and boundaries
                this.createPlatform();
                this.createBoundaries();
                
                // Start render loop
                this.startRenderLoop();
                
                console.log('🌍 Enhanced Physics Manager with Events initialized');
            }

            // Canvas Enhancement v9: Initialize default theme
            async initializeDefaultTheme() {
                try {
                    await this.assetManager.loadTheme(CANVAS_CONFIG.defaultTheme);
                    const bgStyle = this.assetManager.getBackgroundStyle();
                    if (bgStyle && bgStyle.type === 'gradient') {
                        this.backgroundGradient = bgStyle.colors;
                    }
                    const platformStyle = this.assetManager.getPlatformStyle();
                    if (platformStyle) {
                        this.platformColor = platformStyle.color;
                    }
                    console.log(`🎨 Default theme initialized: ${CANVAS_CONFIG.defaultTheme}`);
                } catch (error) {
                    console.error('❌ Failed to initialize default theme:', error);
                }
            }

            // Phase 1: Initialize dual renderer system
            async initializeRenderers() {
                try {
                    console.log('🎨 Initializing dual renderer system...');
                    
                    // Initialize the renderer manager
                    await this.rendererManager.initialize();
                    
                    // Auto-select optimal renderer based on configuration
                    const success = this.rendererManager.autoSelectRenderer();
                    
                    if (success) {
                        const currentRenderer = this.rendererManager.getCurrentRenderer();
                        console.log(`✅ Renderer system initialized with ${currentRenderer.toUpperCase()}`);
                        
                        // Phase 2: Initialize PixiJS shape rendering if enabled
                        if (PIXI_CONFIG.features.shapeRendering && currentRenderer === 'pixi') {
                            const shapeRenderingEnabled = this.pixiShapeRenderer.enable();
                            if (shapeRenderingEnabled) {
                                console.log('✅ PixiJS shape rendering enabled');
                            }
                        }
                        
                        // Add feature flag controls for testing
                        this.addRendererControls();
                    } else {
                        console.warn('⚠️ Renderer initialization had issues, Canvas fallback active');
                    }
                    
                } catch (error) {
                    console.error('❌ Renderer initialization failed:', error);
                    console.log('🔄 Falling back to Canvas-only mode');
                }
            }

            // Add renderer controls for development/testing
            addRendererControls() {
                // Add global functions for testing renderer switching
                window.switchToCanvas = () => {
                    this.rendererManager.switchRenderer('canvas');
                    console.log('🎨 Switched to Canvas renderer');
                };
                
                window.switchToPixi = () => {
                    if (this.rendererManager.canSwitchTo('pixi')) {
                        this.rendererManager.switchRenderer('pixi');
                        console.log('🎨 Switched to PixiJS renderer');
                    } else {
                        console.warn('⚠️ PixiJS renderer not available');
                    }
                };
                
                window.getCurrentRenderer = () => {
                    const current = this.rendererManager.getCurrentRenderer();
                    console.log('🎨 Current renderer:', current.toUpperCase());
                    return current;
                };
                
                window.showRendererInfo = () => {
                    const current = this.rendererManager.getCurrentRenderer();
                    const pixiAvailable = this.rendererManager.canSwitchTo('pixi');
                    const shapeRenderingEnabled = PIXI_CONFIG.features.shapeRendering && this.pixiShapeRenderer.isEnabled;
                    const shapeCount = this.pixiShapeRenderer.getShapeCount();
                    
                    console.log(`
🎨 RENDERER SYSTEM INFO (Phase 2):
Current: ${current.toUpperCase()}
PixiJS Available: ${pixiAvailable}
PixiJS Enabled: ${PIXI_CONFIG.enabled}
Canvas Fallback: ${PIXI_CONFIG.fallbackToCanvas}
Shape Rendering: ${shapeRenderingEnabled}
PixiJS Shape Count: ${shapeCount}

Phase 1 Commands:
- switchToCanvas()    // Switch to Canvas renderer
- switchToPixi()      // Switch to PixiJS renderer  
- getCurrentRenderer() // Show current renderer

Phase 2 Commands:
- enablePixiShapes()   // Enable PixiJS shape rendering
- disablePixiShapes()  // Disable PixiJS shape rendering
- getPixiShapeCount()  // Show PixiJS shape count
- showRendererInfo()   // Show this info
                    `);
                };
                
                // Phase 2: Add PixiJS shape rendering test functions
                window.enablePixiShapes = () => {
                    if (!this.rendererManager.isPixiActive()) {
                        console.warn('⚠️ PixiJS renderer must be active to enable shape rendering');
                        return false;
                    }
                    
                    PIXI_CONFIG.features.shapeRendering = true;
                    const success = this.pixiShapeRenderer.enable();
                    
                    if (success) {
                        // Recreate existing shapes
                        this.dynamicBodies.forEach(body => {
                            if (body.userData && body.userData.shapeType) {
                                this.pixiShapeRenderer.createShape(body, body.userData.shapeType);
                            }
                        });
                        
                        // Update UI
                        document.getElementById('enablePixiShapes').checked = true;
                        console.log(`✅ PixiJS shape rendering enabled with ${this.dynamicBodies.length} shapes`);
                        return true;
                    }
                    return false;
                };
                
                window.disablePixiShapes = () => {
                    PIXI_CONFIG.features.shapeRendering = false;
                    this.pixiShapeRenderer.disable();
                    document.getElementById('enablePixiShapes').checked = false;
                    console.log('🔄 PixiJS shape rendering disabled');
                };
                
                window.getPixiShapeCount = () => {
                    const count = this.pixiShapeRenderer.getShapeCount();
                    console.log(`🎨 PixiJS shapes: ${count}`);
                    return count;
                };
                
                console.log('🎮 Renderer control functions added to window object');
            }

            setupPhysicsEvents() {
                // Matter.js collision detection - when shapes start touching
                this.Events.on(this.engine, 'collisionStart', (event) => {
                    event.pairs.forEach(pair => {
                        this.handleBeginContact(pair);
                    });
                });
                
                // Matter.js collision end - when shapes stop touching  
                this.Events.on(this.engine, 'collisionEnd', (event) => {
                    event.pairs.forEach(pair => {
                        this.handleEndContact(pair);
                    });
                });
                
                console.log('🎯 Matter.js event listeners configured');
            }

            handleBeginContact(pair) {
                const bodyA = pair.bodyA;
                const bodyB = pair.bodyB;
                const userDataA = bodyA.userData || {};
                const userDataB = bodyB.userData || {};
                
                console.log(`🔍 RAW COLLISION: bodyA.userData =`, userDataA, `bodyB.userData =`, userDataB);
                
                this.collisionCount++;
                this.eventCount++;
                
                // Check for shape-platform collision
                if (this.isShapePlatformCollision(userDataA, userDataB)) {
                    console.log('🎯 PLATFORM COLLISION DETECTED!');
                    this.onShapeLandedOnPlatform(bodyA, bodyB);
                }
                
                // Check for shape-shape collision
                if (this.isShapeShapeCollision(userDataA, userDataB)) {
                    console.log('🔄 SHAPE-SHAPE COLLISION DETECTED!');
                    this.onShapeShapeCollision(bodyA, bodyB);
                }
                
                // Check for ground collision (fall detection)
                console.log('🧪 Testing ground collision...');
                if (this.isGroundCollision(userDataA, userDataB)) {
                    console.log('🔥 GROUND COLLISION DETECTED! Triggering shape fall...');
                    this.onShapeFellOffPlatform(bodyA, bodyB);
                } else {
                    console.log('❌ Ground collision test failed');
                }
                
                console.log(`📍 Collision detected: ${userDataA.type || 'unknown'} vs ${userDataB.type || 'unknown'}`);
            }

            handleEndContact(pair) {
                // Handle when objects stop touching
                const bodyA = pair.bodyA;
                const bodyB = pair.bodyB;
                
                // Could implement "unstable" detection here
                // console.log('📤 Contact ended');
            }

            isShapePlatformCollision(dataA, dataB) {
                const shapeTypes = ['shape', 'compound', 'rectangle', 'polygon', 'circle'];
                const isAShape = shapeTypes.includes(dataA.type);
                const isBShape = shapeTypes.includes(dataB.type);
                
                return (isAShape && dataB.type === 'platform') ||
                       (dataA.type === 'platform' && isBShape);
            }

            isShapeShapeCollision(dataA, dataB) {
                const shapeTypes = ['shape', 'compound', 'rectangle', 'polygon', 'circle'];
                const isAShape = shapeTypes.includes(dataA.type);
                const isBShape = shapeTypes.includes(dataB.type);
                
                return isAShape && isBShape;
            }

            isGroundCollision(dataA, dataB) {
                const shapeTypes = ['shape', 'compound', 'rectangle', 'polygon', 'circle'];
                const isAShape = shapeTypes.includes(dataA.type);
                const isBShape = shapeTypes.includes(dataB.type);
                
                const result = (isAShape && dataB.type === 'ground') ||
                              (dataA.type === 'ground' && isBShape);
                              
                if (result) {
                    console.log(`🎯 Ground collision detected: ${dataA.type} vs ${dataB.type} - isAShape: ${isAShape}, isBShape: ${isBShape}`);
                }
                
                return result;
            }

            onShapeLandedOnPlatform(bodyA, bodyB) {
                console.log('🎯 Shape landed on platform!');
                this.showEventNotification('Shape Landed!', 'collision');
                
                // Phase 3: Trigger platform landing animation
                this.triggerCollisionAnimation(bodyA, bodyB, 'platform');
                
                // Trigger game event
                if (window.gameManager) {
                    window.gameManager.onShapeLandedOnPlatform();
                }
            }

            onShapeShapeCollision(bodyA, bodyB) {
                console.log('🔄 Shape collision detected!');
                this.showEventNotification('Shape Contact!', 'balance');
                
                // Phase 3: Trigger collision flash animation
                this.triggerCollisionAnimation(bodyA, bodyB, 'collision');
                
                // Trigger game event
                if (window.gameManager) {
                    window.gameManager.onShapeCollision();
                }
            }

            // Phase 3: Animation trigger helper
            triggerCollisionAnimation(bodyA, bodyB, animationType) {
                const pixiShapeRenderer = this.pixiShapeRenderer;
                const animationManager = this.rendererManager?.pixiManager?.animationManager;
                
                if (!pixiShapeRenderer || !animationManager || !animationManager.isEnabled) {
                    return;
                }

                // Find which body is the shape and animate it
                const shapeBody = this.findShapeBody(bodyA, bodyB);
                if (shapeBody) {
                    const shapeData = pixiShapeRenderer.shapes.get(shapeBody.id);
                    if (shapeData && shapeData.graphics) {
                        if (animationType === 'platform') {
                            animationManager.animatePlatformLanding(shapeData.graphics);
                        } else if (animationType === 'collision') {
                            animationManager.animateCollisionFlash(shapeData.graphics);
                        }
                    }
                }
            }

            findShapeBody(bodyA, bodyB) {
                // Return the body that represents a shape (not platform/ground/boundary)
                const userDataA = bodyA.userData || {};
                const userDataB = bodyB.userData || {};
                
                if (userDataA.shapeType && userDataA.type !== 'platform' && userDataA.type !== 'ground' && userDataA.type !== 'boundary') {
                    return bodyA;
                }
                
                if (userDataB.shapeType && userDataB.type !== 'platform' && userDataB.type !== 'ground' && userDataB.type !== 'boundary') {
                    return bodyB;
                }
                
                return null;
            }

            onShapeFellOffPlatform(bodyA, bodyB) {
                console.log('💥 Shape fell off platform!');
                this.fallCount++;
                
                this.showEventNotification('Shape Fell!', 'fall');
                
                // Trigger game event
                if (window.gameManager) {
                    window.gameManager.onShapeFell();
                }
            }

            showEventNotification(message, type) {
                const notification = document.getElementById('eventNotification');
                notification.textContent = message;
                notification.className = `event-notification ${type} show`;
                
                setTimeout(() => {
                    notification.classList.remove('show');
                }, 2000);
            }

            resizeCanvas() {
                const container = this.canvas.parentElement;
                this.canvas.width = container.clientWidth;
                this.canvas.height = container.clientHeight;
                console.log(`📐 Canvas resized to: ${this.canvas.width}x${this.canvas.height}`);
            }

            createBoundaries() {
                // Create invisible ground boundary for fall detection
                const groundY = this.canvas.height + 150; // Extended to +150 (was +50) for longer fall distance
                const groundWidth = this.canvas.width;
                
                const ground = this.Bodies.rectangle(
                    this.canvas.width / 2, 
                    groundY, 
                    groundWidth, 
                    100, 
                    {
                        isStatic: true,
                        render: { visible: false }
                    }
                );
                
                // Set user data for collision detection
                ground.userData = {
                    type: 'ground',
                    name: 'fallDetectionBoundary'
                };
                
                this.World.add(this.world, ground);
                console.log('🚧 Matter.js boundaries created');
            }

            createPlatform() {
                // Restore original angled platform from v1 (-50 degrees)
                const platformX = this.canvas.width / 2 - 30;  // Pixel coordinates
                const platformY = this.canvas.height - 20;     // Moved down 100px (was -120, now -20)
                const platformWidth = 200;
                const platformHeight = 20;
                const platformAngle = -0.873; // -50 degrees
                
                // Create angled platform with Matter.js
                const platform = this.Bodies.rectangle(
                    platformX, 
                    platformY, 
                    platformWidth, 
                    platformHeight,
                    {
                        isStatic: true,
                        angle: platformAngle,
                        render: {
                            fillStyle: '#95A5A6',
                            strokeStyle: '#7F8C8D',
                            lineWidth: 2
                        },
                        friction: 0.9,
                        restitution: 0
                    }
                );
                
                // Set user data for collision detection
                platform.userData = {
                    type: 'platform',
                    visible: true,
                    color: '#95A5A6',
                    stroke: '#7F8C8D',
                    strokeWidth: 2,
                    width: platformWidth,
                    height: platformHeight
                };
                
                this.World.add(this.world, platform);
                console.log(`🏗️ Matter.js angled platform created: -50° at (${platformX}, ${platformY})`);
            }

            createCompoundShape(x, y, type, rotation = 0) {
                // Forward to unified createShape method for consistency
                return this.createShape(x, y, type, rotation);
            }

            createShape(x, y, type, rotation = 0) {
                const config = getShapeConfig(type);
                if (!config) {
                    console.error(`Unknown shape type: ${type}`);
                    return null;
                }

                // V9: Matter.js compound shape creation with perfect collision detection
                console.log(`🎯 Creating Matter.js shape: ${type} at (${x}, ${y})`);

                let body;

                // Handle compound shapes (shapes with parts) using SHAPE_CONFIG
                if (config.type === 'compound' && config.parts) {
                    body = this.createMatterCompoundShape(x, y, type, rotation, config);
                } else {
                    // Handle simple shapes with standard Matter.js bodies
                    body = this.createMatterSimpleShape(x, y, type, rotation, config);
                }

                if (body) {
                    // Set Matter.js physics properties from config
                    body.restitution = config.restitution || 0.1;      // Reduced bounce to prevent rotation changes
                    body.friction = config.friction || 0.9;       
                    body.frictionAir = 0.02;   // Reduced air resistance to maintain manual rotation
                    
                    // Stabilize rotation for a brief moment after drop
                    const originalAngularVelocity = body.angularVelocity;
                    body.angularVelocity = 0; // Stop any spinning from collision
                    
                    // After a short delay, allow normal physics
                    setTimeout(() => {
                        if (body && body.angularVelocity === 0) {
                            body.frictionAir = 0.05; // Restore normal air resistance
                        }
                    }, 100); // Brief stabilization period

                    // Set user data for collision detection and rendering
                    body.userData = {
                        type: 'shape',
                        shapeType: type,
                        ...config
                    };
                    
                    console.log(`🏷️ Shape userData set:`, body.userData);

                    this.World.add(this.world, body);
                    this.dynamicBodies.push(body);

                    // Phase 2: Create PixiJS shape if shape rendering is enabled
                    if (PIXI_CONFIG.features.shapeRendering && this.pixiShapeRenderer.isEnabled) {
                        this.pixiShapeRenderer.createShape(body, type);
                    }

                    console.log(`✅ Matter.js ${type} created successfully`);
                    return body;
                }

                console.error(`❌ Failed to create Matter.js shape: ${type}`);
                return null;
            }

            createMatterCompoundShape(x, y, type, rotation, config) {
                console.log(`🎯 Creating Matter.js compound shape: ${type} using SHAPE_CONFIG`);
                
                if (!config.parts || config.parts.length === 0) {
                    console.error(`❌ No parts defined for compound shape: ${type}`);
                    return null;
                }
                
                const bodyParts = [];
                
                // Create each part based on SHAPE_CONFIG specification
                config.parts.forEach((partConfig, index) => {
                    // Use relative positioning for compound body parts
                    const partX = x + (partConfig.offsetX || 0);
                    const partY = y + (partConfig.offsetY || 0);
                    let bodyPart = null;
                    
                    if (partConfig.type === 'rectangle') {
                        bodyPart = this.Bodies.rectangle(partX, partY, partConfig.width, partConfig.height, {
                            render: {
                                fillStyle: partConfig.color || config.color,
                                strokeStyle: partConfig.stroke || config.stroke,
                                lineWidth: config.strokeWidth || 2
                            }
                        });
                    } else if (partConfig.type === 'circle') {
                        bodyPart = this.Bodies.circle(partX, partY, partConfig.radius, {
                            render: {
                                fillStyle: partConfig.color || config.color,
                                strokeStyle: partConfig.stroke || config.stroke,
                                lineWidth: config.strokeWidth || 2
                            }
                        });
                    } else if (partConfig.type === 'diamond') {
                        // Create diamond as a rotated square
                        const size = partConfig.width || partConfig.height || 12;
                        bodyPart = this.Bodies.polygon(partX, partY, 4, size / Math.sqrt(2), {
                            angle: Math.PI / 4, // 45 degree rotation for diamond
                            render: {
                                fillStyle: partConfig.color || config.color,
                                strokeStyle: partConfig.stroke || config.stroke,
                                lineWidth: config.strokeWidth || 2
                            }
                        });
                    }
                    
                    if (bodyPart) {
                        bodyParts.push(bodyPart);
                        console.log(`✅ Created ${partConfig.type} part at offset (${partConfig.offsetX}, ${partConfig.offsetY})`);
                    }
                });
                
                if (bodyParts.length === 0) {
                    console.error(`❌ No body parts created for compound shape: ${type}`);
                    return null;
                }
                
                // Create compound body and then rotate it smoothly
                const compoundBody = this.Body.create({
                    parts: bodyParts
                });
                
                // Apply rotation after creation to prevent snapping
                if (rotation !== 0) {
                    this.Body.setAngle(compoundBody, rotation);
                }
                
                // CRITICAL: Set userData on compound body AND all parts
                const userData = {
                    type: 'compound',
                    shapeType: type,
                    ...config
                };
                
                compoundBody.userData = userData;
                
                // Also set userData on all parts so collision detection works
                bodyParts.forEach(part => {
                    part.userData = userData;
                });
                
                console.log(`🏷️ Compound shape userData set on main body and ${bodyParts.length} parts:`, userData);
                console.log(`✅ Matter.js compound shape ${type} created with ${bodyParts.length} parts, rotated ${(rotation * 180 / Math.PI).toFixed(1)}°`);
                return compoundBody;
            }

            createMatterSimpleShape(x, y, type, rotation, config) {
                console.log(`🎯 Creating Matter.js simple shape: ${type}`);
                
                let body = null;

                // Create shape based on type
                if (type === 'square') {
                    body = this.Bodies.rectangle(x, y, config.width || 50, config.height || 50, {
                        angle: rotation,
                        render: {
                            fillStyle: config.color || '#FFD700',
                            strokeStyle: config.stroke || '#FFA500',
                            lineWidth: config.strokeWidth || 2
                        }
                    });
                } else if (type === 'triangle') {
                    // Create triangle using polygon but fix the default orientation
                    // Matter.js Bodies.polygon(x, y, 3, radius) creates triangle with different default rotation
                    const sides = 3;
                    const radius = 20; // Match approximate size of our config vertices
                    
                    // Add Math.PI/2 (90 degrees) to align with our triangle config (point up)
                    const adjustedRotation = rotation + Math.PI/2;
                    
                    body = this.Bodies.polygon(x, y, sides, radius, {
                        angle: adjustedRotation,
                        render: {
                            fillStyle: config.color || '#9B59B6',
                            strokeStyle: config.stroke || '#8E44AD',
                            lineWidth: config.strokeWidth || 2
                        }
                    });
                    
                    console.log(`🔺 Triangle created with 90° adjustment, final rotation ${(adjustedRotation * 180 / Math.PI).toFixed(1)}°`);
                } else if (type === 'circle') {
                    body = this.Bodies.circle(x, y, config.radius || 25, {
                        render: {
                            fillStyle: config.color || '#1ABC9C',
                            strokeStyle: config.stroke || '#16A085',
                            lineWidth: config.strokeWidth || 2
                        }
                    });
                }

                if (body) {
                    // Set userData on simple shape body  
                    body.userData = {
                        type: config.type || 'rectangle', // Use config type (rectangle, polygon, circle)
                        shapeType: type,
                        ...config
                    };
                    console.log(`🏷️ Simple shape userData set:`, body.userData);
                }

                console.log(`✅ Matter.js simple shape ${type} created`);
                return body;
            }

            startRenderLoop() {
                let lastTime = 0;
                const render = (currentTime) => {
                    const deltaTime = currentTime - lastTime;
                    lastTime = currentTime;
                    
                    // Update camera shake
                    this.updateCameraShake(deltaTime);
                    
                    // Step Matter.js physics simulation
                    this.Engine.update(this.engine, 1000 / 60); // 60 FPS
                    
                    // Clear canvas
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    
                    // v9: Enhanced rendering with themes (no camera shake transforms needed)
                    this.renderBackground();
                    this.renderWorld();
                    this.particleSystem.update(16); // ~16ms per frame at 60fps
                    this.particleSystem.render();
                    
                    // Phase 2: Update PixiJS shapes to match physics bodies
                    if (PIXI_CONFIG.features.shapeRendering && this.pixiShapeRenderer.isEnabled) {
                        this.pixiShapeRenderer.updateShapes();
                    }
                    
                    requestAnimationFrame(render);
                };
                render(performance.now());
                console.log('🎬 Matter.js render loop with Canvas Enhancement and Camera Shake started');
            }

            // v9: Enhanced background rendering with theme support
            renderBackground() {
                if (!CANVAS_CONFIG.enabled || !CANVAS_CONFIG.useBackgroundTextures) {
                    return; // Use default CSS background
                }

                const backgroundStyle = this.assetManager.getBackgroundStyle();
                if (!backgroundStyle) return;

                // Check if we have a background image
                if (backgroundStyle.image && backgroundStyle.imageConfig) {
                    this.renderBackgroundImage(backgroundStyle);
                } else if (backgroundStyle.colors && backgroundStyle.colors.length >= 2) {
                    this.renderBackgroundGradient(backgroundStyle);
                }
                
                // Add texture overlay if configured
                this.renderBackgroundTexture();
            }

            // Render background image
            renderBackgroundImage(backgroundStyle) {
                const image = backgroundStyle.image;
                const config = backgroundStyle.imageConfig;
                
                this.ctx.save();
                
                // Apply image based on configuration
                switch(config.size) {
                    case 'cover':
                        this.drawImageCover(image);
                        break;
                    case 'contain':
                        this.drawImageContain(image);
                        break;
                    case 'auto':
                        this.ctx.drawImage(image, 0, 0);
                        break;
                    default: // "100% 100%" or similar
                        this.ctx.drawImage(image, 0, 0, this.canvas.width, this.canvas.height);
                }
                
                // If there are gradient colors too, overlay them with reduced opacity
                if (backgroundStyle.colors && backgroundStyle.colors.length >= 2) {
                    this.ctx.globalAlpha = 0.3; // Reduce opacity for overlay
                    this.renderBackgroundGradient(backgroundStyle);
                }
                
                this.ctx.restore();
            }

            // Helper to draw image with 'cover' behavior
            drawImageCover(image) {
                const canvasRatio = this.canvas.width / this.canvas.height;
                const imageRatio = image.width / image.height;
                
                let drawWidth, drawHeight, drawX, drawY;
                
                if (imageRatio > canvasRatio) {
                    // Image is wider than canvas ratio
                    drawHeight = this.canvas.height;
                    drawWidth = drawHeight * imageRatio;
                    drawX = (this.canvas.width - drawWidth) / 2;
                    drawY = 0;
                } else {
                    // Image is taller than canvas ratio
                    drawWidth = this.canvas.width;
                    drawHeight = drawWidth / imageRatio;
                    drawX = 0;
                    drawY = (this.canvas.height - drawHeight) / 2;
                }
                
                this.ctx.drawImage(image, drawX, drawY, drawWidth, drawHeight);
            }

            // Helper to draw image with 'contain' behavior
            drawImageContain(image) {
                const canvasRatio = this.canvas.width / this.canvas.height;
                const imageRatio = image.width / image.height;
                
                let drawWidth, drawHeight, drawX, drawY;
                
                if (imageRatio > canvasRatio) {
                    // Fit to canvas width
                    drawWidth = this.canvas.width;
                    drawHeight = drawWidth / imageRatio;
                    drawX = 0;
                    drawY = (this.canvas.height - drawHeight) / 2;
                } else {
                    // Fit to canvas height
                    drawHeight = this.canvas.height;
                    drawWidth = drawHeight * imageRatio;
                    drawX = (this.canvas.width - drawWidth) / 2;
                    drawY = 0;
                }
                
                this.ctx.drawImage(image, drawX, drawY, drawWidth, drawHeight);
            }

            // Render gradient background (extracted from previous method)
            renderBackgroundGradient(backgroundStyle) {
                const colors = backgroundStyle.colors;
                if (!colors || colors.length < 2) return;

                // Create linear gradient background
                const gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
                
                // Distribute colors evenly across gradient
                const colorStep = 1 / (colors.length - 1);
                colors.forEach((color, index) => {
                    gradient.addColorStop(index * colorStep, color);
                });
                
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            }

            // v9: Add subtle texture to background
            renderBackgroundTexture() {
                const currentTheme = this.assetManager.getCurrentTheme();
                if (!currentTheme) return;
                
                this.ctx.save();
                this.ctx.globalAlpha = 0.1;
                
                // Add theme-specific background patterns
                switch(currentTheme.config.platform.material) {
                    case 'wood':
                        this.renderWoodTexture();
                        break;
                    case 'metal':
                        this.renderMetalTexture();
                        break;
                    case 'coral':
                        this.renderCoralTexture();
                        break;
                    default:
                        this.renderGeometricTexture();
                }
                
                this.ctx.restore();
            }

            renderWoodTexture() {
                // Simple wood grain effect
                this.ctx.strokeStyle = '#8B4513';
                this.ctx.lineWidth = 0.5;
                for (let i = 0; i < 20; i++) {
                    const y = (this.canvas.height / 20) * i;
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.canvas.width, y + Math.sin(i) * 5);
                    this.ctx.stroke();
                }
            }

            renderMetalTexture() {
                // Diagonal line pattern
                this.ctx.strokeStyle = '#708090';
                this.ctx.lineWidth = 0.3;
                for (let i = -this.canvas.width; i < this.canvas.width + this.canvas.height; i += 10) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(i, 0);
                    this.ctx.lineTo(i + this.canvas.height, this.canvas.height);
                    this.ctx.stroke();
                }
            }

            renderCoralTexture() {
                // Organic bubble pattern
                this.ctx.fillStyle = '#2E8B57';
                for (let i = 0; i < 50; i++) {
                    const x = Math.random() * this.canvas.width;
                    const y = Math.random() * this.canvas.height;
                    const radius = Math.random() * 3 + 1;
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, radius, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }

            renderGeometricTexture() {
                // Simple dot pattern
                this.ctx.fillStyle = '#cccccc';
                for (let x = 10; x < this.canvas.width; x += 20) {
                    for (let y = 10; y < this.canvas.height; y += 20) {
                        this.ctx.beginPath();
                        this.ctx.arc(x, y, 1, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                }
            }

            // =============================================================================
            // CAMERA SHAKE SYSTEM
            // =============================================================================

            /**
             * Trigger camera shake effect
             * @param {number} intensity - Shake intensity (1-10)
             * @param {number} duration - Duration in milliseconds
             */
            startCameraShake(intensity = 5, duration = 500) {
                console.log(`🚨 startCameraShake called with intensity=${intensity}, duration=${duration}ms`);
                
                this.cameraShake.active = true;
                this.cameraShake.intensity = intensity;
                this.cameraShake.duration = duration;
                this.cameraShake.elapsed = 0;
                this.cameraShake.frequencyX = 0.1 + Math.random() * 0.1; // Randomize frequency
                this.cameraShake.frequencyY = 0.1 + Math.random() * 0.1;
                
                console.log(`✅ Camera shake activated - state:`, this.cameraShake);
                console.log(`🎯 Canvas element:`, this.canvas);
                
                // Immediate test shake to verify it works
                this.canvas.style.transform = `translate(${intensity}px, ${intensity}px)`;
                setTimeout(() => {
                    this.canvas.style.transform = 'translate(0px, 0px)';
                }, 100);
                
                console.log(`📹 Camera shake started: intensity=${intensity}, duration=${duration}ms`);
            }

            /**
             * Update camera shake effect - applies shake directly to canvas element
             * @param {number} deltaTime - Time since last update
             */
            updateCameraShake(deltaTime) {
                if (!this.cameraShake.active) {
                    // Reset canvas position when not shaking
                    this.canvas.style.transform = 'translate(0px, 0px)';
                    return;
                }

                console.log(`🔄 updateCameraShake: elapsed=${this.cameraShake.elapsed}, duration=${this.cameraShake.duration}, intensity=${this.cameraShake.intensity}`);

                this.cameraShake.elapsed += deltaTime;

                if (this.cameraShake.elapsed >= this.cameraShake.duration) {
                    // Shake finished
                    this.cameraShake.active = false;
                    this.canvas.style.transform = 'translate(0px, 0px)';
                    console.log('✅ Camera shake completed');
                    return;
                }

                // Calculate shake progress (1.0 at start, 0.0 at end)
                const progress = 1.0 - (this.cameraShake.elapsed / this.cameraShake.duration);
                const currentIntensity = this.cameraShake.intensity * progress * progress; // Quadratic falloff

                // Generate shake offset using sine waves with different frequencies
                const time = this.cameraShake.elapsed * 0.01; // Convert to suitable time scale
                let offsetX = Math.sin(time * this.cameraShake.frequencyX * 50) * currentIntensity;
                let offsetY = Math.sin(time * this.cameraShake.frequencyY * 47) * currentIntensity; // Different frequency for variety

                // Add random jitter for more chaotic feel
                offsetX += (Math.random() - 0.5) * currentIntensity * 0.5;
                offsetY += (Math.random() - 0.5) * currentIntensity * 0.5;

                console.log(`📳 Applying shake: offsetX=${offsetX.toFixed(1)}, offsetY=${offsetY.toFixed(1)}, currentIntensity=${currentIntensity.toFixed(1)}`);

                // Apply transform to canvas element
                this.canvas.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
            }

            /**
             * Apply camera shake to canvas transform (legacy method - now unused)
             */
            applyCameraShake() {
                // This method is no longer used - shake is applied directly to canvas element
            }

            /**
             * Reset camera shake transform (legacy method - now unused)
             */
            resetCameraShake() {
                // This method is no longer used - shake is applied directly to canvas element
            }

            renderWorld() {
                // Render all Matter.js bodies in the world
                const bodies = this.world.bodies;
                for (let i = 0; i < bodies.length; i++) {
                    this.renderBody(bodies[i]);
                }
            }

            renderBody(body) {
                // Skip rendering invisible bodies
                if (body.render && body.render.visible === false) return;
                
                // V9: Render Matter.js body parts directly (no coordinate transformation)
                if (body.parts && body.parts.length > 1) {
                    // Compound body - render each part separately
                    for (let i = 1; i < body.parts.length; i++) { // Skip first part (it's the parent)
                        this.renderMatterPart(body.parts[i], body);
                    }
                } else {
                    // Simple body - render directly
                    this.renderMatterPart(body, body);
                }
            }

            renderMatterPart(part, parentBody) {
                // Get render properties from Matter.js body
                const render = part.render || {};
                const userData = parentBody.userData || {};
                
                // Skip invisible parts
                if (render.visible === false) return;
                
                // v9: Theme-based color selection
                let fillColor = render.fillStyle || userData.color || '#95A5A6';
                let strokeColor = render.strokeStyle || userData.stroke || '#7F8C8D';
                
                // Apply theme colors for platform
                if (userData.type === 'platform' && this.platformColor) {
                    fillColor = this.platformColor;
                    strokeColor = this.darkenColor(this.platformColor, 20);
                }
                
                // v9: Check for image textures
                const shouldUseTexture = CANVAS_CONFIG.enabled && CANVAS_CONFIG.useBackgroundTextures;
                let textureImage = null;
                let textureConfig = null;
                
                if (shouldUseTexture) {
                    if (userData.type === 'platform') {
                        const platformStyle = this.assetManager.getPlatformStyle();
                        textureImage = platformStyle?.image;
                        textureConfig = platformStyle?.imageConfig;
                    } else if (userData.shapeType) {
                        const shapeStyle = this.assetManager.getShapeStyle(userData.shapeType);
                        textureImage = shapeStyle?.texture;
                        textureConfig = shapeStyle?.textureConfig;
                    }
                }
                
                // Set drawing style
                this.ctx.fillStyle = fillColor;
                this.ctx.strokeStyle = strokeColor;
                this.ctx.lineWidth = render.lineWidth || userData.strokeWidth || 2;
                
                // Render based on shape type
                if (part.circleRadius !== undefined && part.circleRadius > 0) {
                    // Circle - use part's own position (already in world coordinates)
                    this.renderCircleWithTexture(part, textureImage, textureConfig);
                } else if (part.vertices && part.vertices.length > 0) {
                    // Polygon (including rectangles) - vertices are in world coordinates
                    this.renderPolygonWithTexture(part, textureImage, textureConfig);
                } else {
                    console.log(`⚠️ Unknown body type - circleRadius: ${part.circleRadius}, vertices: ${part.vertices ? part.vertices.length : 'none'} for ${userData.type || 'unknown'}`);
                }
            }

            renderCircleWithTexture(part, textureImage, textureConfig) {
                this.ctx.save();
                
                // Create circular clipping path
                this.ctx.beginPath();
                this.ctx.arc(part.position.x, part.position.y, part.circleRadius, 0, Math.PI * 2);
                
                if (textureImage && textureConfig) {
                    // Fill with texture
                    this.ctx.clip();
                    this.applyTextureToShape(part.position.x - part.circleRadius, 
                                           part.position.y - part.circleRadius,
                                           part.circleRadius * 2, 
                                           part.circleRadius * 2,
                                           textureImage, textureConfig);
                } else {
                    // Fill with solid color
                    this.ctx.fill();
                }
                
                // Restore for stroke
                this.ctx.restore();
                
                // Draw stroke
                this.ctx.beginPath();
                this.ctx.arc(part.position.x, part.position.y, part.circleRadius, 0, Math.PI * 2);
                this.ctx.stroke();
            }

            renderPolygonWithTexture(part, textureImage, textureConfig) {
                const vertices = part.vertices;
                
                this.ctx.save();
                
                // Create polygon clipping path
                this.ctx.beginPath();
                this.ctx.moveTo(vertices[0].x, vertices[0].y);
                for (let i = 1; i < vertices.length; i++) {
                    this.ctx.lineTo(vertices[i].x, vertices[i].y);
                }
                this.ctx.closePath();
                
                if (textureImage && textureConfig) {
                    // Get bounding box for texture positioning
                    const bounds = this.getPolygonBounds(vertices);
                    
                    // Fill with texture
                    this.ctx.clip();
                    this.applyTextureToShape(bounds.x, bounds.y, bounds.width, bounds.height,
                                           textureImage, textureConfig);
                } else {
                    // Fill with solid color
                    this.ctx.fill();
                }
                
                // Restore for stroke
                this.ctx.restore();
                
                // Draw stroke
                this.ctx.beginPath();
                this.ctx.moveTo(vertices[0].x, vertices[0].y);
                for (let i = 1; i < vertices.length; i++) {
                    this.ctx.lineTo(vertices[i].x, vertices[i].y);
                }
                this.ctx.closePath();
                this.ctx.stroke();
            }

            applyTextureToShape(x, y, width, height, image, textureConfig) {
                if (!image) return;
                
                this.ctx.save();
                
                // Apply blend mode
                if (textureConfig.blend && textureConfig.blend !== 'normal') {
                    this.ctx.globalCompositeOperation = textureConfig.blend;
                }
                
                // Apply opacity
                if (textureConfig.opacity !== undefined) {
                    this.ctx.globalAlpha = textureConfig.opacity;
                }
                
                // Handle texture repeat patterns
                switch(textureConfig.repeat) {
                    case 'repeat':
                        this.drawRepeatedTexture(x, y, width, height, image);
                        break;
                    case 'repeat-x':
                        this.drawRepeatedTextureX(x, y, width, height, image);
                        break;
                    case 'repeat-y':
                        this.drawRepeatedTextureY(x, y, width, height, image);
                        break;
                    case 'no-repeat':
                    default:
                        this.ctx.drawImage(image, x, y, width, height);
                        break;
                }
                
                this.ctx.restore();
            }

            drawRepeatedTexture(x, y, width, height, image) {
                const pattern = this.ctx.createPattern(image, 'repeat');
                if (pattern) {
                    this.ctx.fillStyle = pattern;
                    this.ctx.fillRect(x, y, width, height);
                } else {
                    // Fallback: manual tiling
                    this.manualTileTexture(x, y, width, height, image);
                }
            }

            drawRepeatedTextureX(x, y, width, height, image) {
                const aspectRatio = image.width / image.height;
                const tileHeight = height;
                const tileWidth = tileHeight * aspectRatio;
                
                for (let tx = x; tx < x + width; tx += tileWidth) {
                    const drawWidth = Math.min(tileWidth, x + width - tx);
                    this.ctx.drawImage(image, 0, 0, image.width * (drawWidth / tileWidth), image.height,
                                     tx, y, drawWidth, tileHeight);
                }
            }

            drawRepeatedTextureY(x, y, width, height, image) {
                const aspectRatio = image.width / image.height;
                const tileWidth = width;
                const tileHeight = tileWidth / aspectRatio;
                
                for (let ty = y; ty < y + height; ty += tileHeight) {
                    const drawHeight = Math.min(tileHeight, y + height - ty);
                    this.ctx.drawImage(image, 0, 0, image.width, image.height * (drawHeight / tileHeight),
                                     x, ty, tileWidth, drawHeight);
                }
            }

            manualTileTexture(x, y, width, height, image) {
                const tileWidth = image.width;
                const tileHeight = image.height;
                
                for (let ty = y; ty < y + height; ty += tileHeight) {
                    for (let tx = x; tx < x + width; tx += tileWidth) {
                        const drawWidth = Math.min(tileWidth, x + width - tx);
                        const drawHeight = Math.min(tileHeight, y + height - ty);
                        
                        this.ctx.drawImage(image, 0, 0, 
                                         image.width * (drawWidth / tileWidth), 
                                         image.height * (drawHeight / tileHeight),
                                         tx, ty, drawWidth, drawHeight);
                    }
                }
            }

            getPolygonBounds(vertices) {
                let minX = Infinity, minY = Infinity;
                let maxX = -Infinity, maxY = -Infinity;
                
                vertices.forEach(vertex => {
                    minX = Math.min(minX, vertex.x);
                    minY = Math.min(minY, vertex.y);
                    maxX = Math.max(maxX, vertex.x);
                    maxY = Math.max(maxY, vertex.y);
                });
                
                return {
                    x: minX,
                    y: minY,
                    width: maxX - minX,
                    height: maxY - minY
                };
            }

            getEventStats() {
                return {
                    events: this.eventCount,
                    collisions: this.collisionCount,
                    falls: this.fallCount
                };
            }

            darkenColor(color, amount = 30) {
                // v9: Enhanced color darkening with configurable amount
                if (!color) return '#7F8C8D';
                
                // Convert hex to RGB and darken by specified amount
                const hex = color.replace('#', '');
                const r = Math.max(0, parseInt(hex.substr(0, 2), 16) - amount);
                const g = Math.max(0, parseInt(hex.substr(2, 2), 16) - amount);
                const b = Math.max(0, parseInt(hex.substr(4, 2), 16) - amount);
                
                return `rgb(${r}, ${g}, ${b})`;
            }

            /*╔═══════════════════════════════════════════════════════════════════════════
              ║ CLEAR ALL SHAPES
              ║ Removes all dynamic bodies (shapes) from the physics world while preserving
              ║ static bodies (platform, walls). Used for level resets and shape management.
              ║ Essential for providing a fresh start without recreating the entire world.
              ╚═══════════════════════════════════════════════════════════════════════════*/
            clearAllShapes() {
                // Remove all dynamic bodies from Matter.js world
                this.dynamicBodies.forEach(body => {
                    this.World.remove(this.world, body);
                });
                this.dynamicBodies = [];
                
                // Phase 2: Clear PixiJS shapes as well
                if (PIXI_CONFIG.features.shapeRendering && this.pixiShapeRenderer.isEnabled) {
                    this.pixiShapeRenderer.clearAllShapes();
                }
                
                console.log('🧹 Cleared all shapes from playfield');
            }

            cleanup() {
                // Remove all dynamic bodies from Matter.js world
                this.dynamicBodies.forEach(body => {
                    this.World.remove(this.world, body);
                });
                this.dynamicBodies = [];
                
                // Phase 2: Clear PixiJS shapes as well
                if (PIXI_CONFIG.features.shapeRendering && this.pixiShapeRenderer.isEnabled) {
                    this.pixiShapeRenderer.clearAllShapes();
                }
                
                // Reset event counters
                this.eventCount = 0;
                this.collisionCount = 0;
                this.fallCount = 0;
                
                console.log('🧹 Matter.js physics cleanup complete');
            }
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ ENHANCED DRAG AND DROP MANAGER WITH ROTATION
          ║ Task 4.2b: Adds rotation functionality during drag and drop operations
          ║ Maintains existing drag & drop functionality while adding rotation controls
          ╚═══════════════════════════════════════════════════════════════════════════*/
        class DragDropManager {
            constructor(physicsManager, gameManager) {
                this.physicsManager = physicsManager;
                this.gameManager = gameManager;
                this.isDragging = false;
                this.draggedElement = null;
                this.draggedShapeType = null;
                this.ghostElement = null;
                
                // Touch offset configuration for mobile devices
                this.touchOffset = {
                    x: 0,      // Horizontal offset (positive = right, negative = left)
                    y: -80,    // Vertical offset (positive = down, negative = up)
                    enabled: true // Enable/disable offset system
                };
                
                // Rotation system
                this.currentRotation = 0; // Current rotation in radians
                this.rotationStep = Math.PI / 6; // 30 degrees per step
                
                // Throttling for smooth dragging - reduce jerkiness
                this.lastMoveTime = 0;
                this.moveThrottleMs = 16; // ~60fps throttling
                this.pendingMove = null;
                
                // Track if drag started from dock
                this.dragStartedFromDock = false;
                
                this.setupEventListeners();
                console.log('🖱️ Streamlined Drag & Drop Manager with touch offset support initialized');
            }

            setupEventListeners() {
                // Mouse events - use throttled movement for smoother dragging
                document.addEventListener('mousedown', (e) => this.handlePointerDown(e));
                document.addEventListener('mousemove', (e) => this.throttledHandlePointerMove(e));
                document.addEventListener('mouseup', (e) => this.handlePointerUp(e));
                
                // Touch events for mobile support
                document.addEventListener('touchstart', (e) => this.handleTouchStart(e), { passive: false });
                document.addEventListener('touchmove', (e) => this.handleTouchMove(e), { passive: false });
                document.addEventListener('touchend', (e) => this.handleTouchEnd(e), { passive: false });
                
                // Keyboard controls
                document.addEventListener('keydown', (e) => this.handleRotationKey(e));
                
                console.log('🖱️ Drag & Drop Manager initialized with touch support');
            }
            
            // Throttled mouse movement to reduce jerkiness
            throttledHandlePointerMove(e) {
                if (!this.isDragging) return;
                
                const now = performance.now();
                if (now - this.lastMoveTime < this.moveThrottleMs) {
                    // Store the most recent event for later processing
                    this.pendingMove = e;
                    return;
                }
                
                this.lastMoveTime = now;
                this.handlePointerMove(e);
                
                // Process any pending move after throttle delay
                if (this.pendingMove && this.pendingMove !== e) {
                    setTimeout(() => {
                        if (this.pendingMove && this.isDragging) {
                            this.handlePointerMove(this.pendingMove);
                            this.pendingMove = null;
                        }
                    }, this.moveThrottleMs);
                }
            }

            handleRotationKey(e) {
                if (!this.isDragging) return;
                
                switch(e.key) {
                    case 'r':
                    case 'R':
                    case 'ArrowRight':
                        this.rotateShape(this.rotationStep); // Rotate clockwise
                        e.preventDefault();
                        break;
                    case 'e':
                    case 'E':
                    case 'ArrowLeft':
                        this.rotateShape(-this.rotationStep); // Rotate counter-clockwise
                        e.preventDefault();
                        break;
                }
            }

            rotateShape(deltaRotation) {
                this.currentRotation += deltaRotation;
                
                // Sound effect integration point
                this.gameManager.playSound('shapeRotation');
                
                if (this.ghostElement) {
                    // Apply both scale, centering translation, and rotation to the ghost element
                    this.ghostElement.style.transform = `translate(-50%, -50%) scale(1.1) rotate(${this.currentRotation}rad)`;
                }
                
                // Update rotation indicator with current angle
                const degrees = Math.round(this.currentRotation * 180 / Math.PI);
                this.updateRotationIndicator(degrees);
                
                console.log(`🔄 Shape rotated: ${degrees}°`);
            }

            handlePointerDown(pointer) {
                const element = document.elementFromPoint(pointer.clientX, pointer.clientY);
                
                if (element && element.classList.contains('game-shape')) {
                    // Check if drag started from docking area
                    this.dragStartedFromDock = element.closest('.docking-area') !== null;
                    console.log(`🖱️ Starting drag, from dock: ${this.dragStartedFromDock}`);
                    this.startDrag(element, pointer);
                }
            }

            startDrag(element, pointer) {
                this.isDragging = true;
                this.draggedElement = element;
                this.draggedShapeType = element.dataset.shape;
                
                // Initialize rotation based on shape type and dock settings
                if (this.draggedShapeType && this.draggedShapeType.includes('barbell')) {
                    // For barbells, preserve dock orientation setting
                    const barbellOrientationSelect = document.getElementById('barbellOrientation');
                    if (barbellOrientationSelect && barbellOrientationSelect.value === 'vertical') {
                        this.currentRotation = Math.PI / 2; // 90 degrees for vertical barbells
                        console.log(`🔄 Starting barbell drag with vertical dock orientation (90°)`);
                    } else {
                        this.currentRotation = 0; // Horizontal for barbells
                        console.log(`🔄 Starting barbell drag with horizontal dock orientation (0°)`);
                    }
                } else {
                    // For non-barbell shapes, always start at 0
                    this.currentRotation = 0;
                }
                
                // Add visual feedback with ghost effect
                element.classList.add('ghost-active');
                
                // Show rotation indicator
                this.showRotationIndicator();
                
                // Update rotation indicator with initial rotation
                this.updateRotationIndicator(Math.round(this.currentRotation * 180 / Math.PI));
                
                // Create ghost element for dragging
                this.createGhostElement(element, pointer);
                
                console.log(`🟢 Started dragging: ${this.draggedShapeType} with initial rotation ${(this.currentRotation * 180 / Math.PI).toFixed(1)}° (R/E or ←/→ to rotate)`);
            }

            createGhostElement(element, pointer) {
                // Create ghost element like Planck version - using CSS transform rotation
                this.ghostElement = this.createGhostPreview(this.draggedShapeType, 90);
                
                // Add ghost-shape class for CSS styling
                this.ghostElement.classList.add('ghost-shape');
                
                // Apply comprehensive ghost styling to prevent clipping
                this.ghostElement.style.position = 'fixed';
                this.ghostElement.style.pointerEvents = 'none';
                this.ghostElement.style.zIndex = '10000'; // Higher z-index to ensure visibility
                this.ghostElement.style.filter = 'drop-shadow(0 5px 15px rgba(0,0,0,0.3))';
                this.ghostElement.style.visibility = 'visible';
                this.ghostElement.style.opacity = '0.9';
                this.ghostElement.style.display = 'block';
                
                // Use CSS transform with consistent centering, scale, and rotation
                const initialTransform = `translate(-50%, -50%) scale(1.1) rotate(${this.currentRotation}rad)`;
                this.ghostElement.style.transform = initialTransform;
                console.log(`👻 Ghost element created with CSS rotation: ${(this.currentRotation * 180 / Math.PI).toFixed(1)}°`);
                
                // Position at pointer
                this.updateGhostPosition(pointer);
                
                // Append to drag overlay instead of document.body to prevent clipping
                const dragOverlay = document.getElementById('dragOverlay');
                if (dragOverlay) {
                    dragOverlay.appendChild(this.ghostElement);
                    console.log(`👻 Ghost element created in drag overlay for ${this.draggedShapeType}`);
                } else {
                    document.body.appendChild(this.ghostElement);
                    console.log(`👻 Ghost element created in document body for ${this.draggedShapeType} (fallback)`);
                }
            }

            createGhostPreview(shapeType, size) {
                // Create canvas element for ghost preview (no rotation - handled by CSS transform)
                const canvas = document.createElement('canvas');
                canvas.width = size;
                canvas.height = size;
                canvas.className = 'shape-preview ghost-preview';
                canvas.dataset.shape = shapeType;

                const ctx = canvas.getContext('2d');
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';

                // Use same scale as dock preview for consistency  
                const scale = 1.9;
                
                // Render with no rotation - rotation handled by CSS transform like Planck version
                shapeRenderer.renderShapeOnCanvas(ctx, shapeType, size / 2, size / 2, 0, scale);
                
                console.log(`👻 Ghost preview created for: ${shapeType} with scale ${scale}, rotation handled by CSS`);
                return canvas;
            }

            // Streamlined rotation method (like Planck version)
            rotateShape(delta) {
                this.currentRotation += delta;
                if (this.ghostElement) {
                    // Update CSS transform with consistent centering, scale, and rotation
                    this.ghostElement.style.transform = `translate(-50%, -50%) scale(1.1) rotate(${this.currentRotation}rad)`;
                }
                this.updateRotationIndicator(Math.round(this.currentRotation * 180 / Math.PI));
                if (this.gameManager && this.gameManager.playSound) {
                    this.gameManager.playSound('shapeRotation');
                }
            }

            updateGhostPosition(pointer) {
                if (this.ghostElement) {
                    let x = pointer.clientX;
                    let y = pointer.clientY;
                    
                    // Apply touch offset if dragging from dock and offset is enabled
                    if (this.dragStartedFromDock && this.touchOffset.enabled) {
                        x += this.touchOffset.x;
                        y += this.touchOffset.y;
                    }
                    
                    // Set position using left/top
                    this.ghostElement.style.left = `${x}px`;
                    this.ghostElement.style.top = `${y}px`;
                    
                    // Preserve scale (1.1 during drag) and rotation with centering
                    this.ghostElement.style.transform = `translate(-50%, -50%) scale(1.1) rotate(${this.currentRotation}rad)`;
                }
            }

            handlePointerMove(pointer) {
                if (this.isDragging && this.ghostElement) {
                    // Streamlined: Only update ghost position for optimal performance
                    this.updateGhostPosition(pointer);
                }
            }

            handlePointerUp(pointer) {
                if (!this.isDragging) return;
                
                // Check if dropped in game area
                const gameCanvas = document.getElementById('gameCanvas');
                const canvasRect = gameCanvas.getBoundingClientRect();
                
                // Calculate the actual drop position from ghost element if it exists
                let dropX, dropY;
                if (this.ghostElement) {
                    // Get ghost element's center position
                    const ghostRect = this.ghostElement.getBoundingClientRect();
                    dropX = ghostRect.left + ghostRect.width / 2;
                    dropY = ghostRect.top + ghostRect.height / 2;
                } else {
                    // Fallback to pointer position
                    dropX = pointer.clientX;
                    dropY = pointer.clientY;
                }
                
                if (dropX >= canvasRect.left && 
                    dropX <= canvasRect.right &&
                    dropY >= canvasRect.top && 
                    dropY <= canvasRect.bottom) {
                    
                    // Calculate position relative to canvas using ghost position
                    const x = dropX - canvasRect.left;
                    const y = dropY - canvasRect.top;
                    
                    // Use current rotation as-is (it already includes barbell orientation from dock/ghost)
                    const totalRotation = this.currentRotation;
                    console.log(`🔄 Physics: Using current rotation ${(totalRotation * 180 / Math.PI).toFixed(1)}° for ${this.draggedShapeType}`);
                    
                    // Log rotation for debugging
                    console.log(`🔍 DEBUG: Dropping ${this.draggedShapeType} with total rotation: ${totalRotation} radians (${(totalRotation * 180 / Math.PI).toFixed(1)}°)`);
                    
                    // Create physics shape at drop position with total rotation
                    this.physicsManager.createCompoundShape(x, y, this.draggedShapeType, totalRotation);
                    
                    // Update game state
                    this.gameManager.onShapePlaced(this.draggedShapeType);
                    
                    // Mark this slot as empty since shape was successfully placed
                    this.markSlotAsEmpty(this.draggedElement);
                    
                    console.log(`🎯 Shape dropped: ${this.draggedShapeType} at (${x}, ${y}) with ${(totalRotation * 180 / Math.PI).toFixed(0)}° total rotation`);
                } else {
                    // Shape was not dropped in game area, restore it to dock
                    this.restoreShapeToDock();
                    console.log(`↩️ Shape returned to dock: ${this.draggedShapeType}`);
                }
                
                this.endDrag();
            }

            markSlotAsEmpty(shapeElement) {
                // Remove the shape from dock and mark slot as empty
                const slot = shapeElement.parentElement;
                shapeElement.remove();
                slot.classList.add('empty');
                
                console.log(`📦 Dock slot emptied: ${this.draggedShapeType}`);
            }

            restoreShapeToDock() {
                // Restore the shape visibility in the dock
                if (this.draggedElement) {
                    this.draggedElement.style.visibility = 'visible';
                }
            }

            showRotationIndicator() {
                const indicator = document.getElementById('rotationIndicator');
                if (indicator) {
                    indicator.classList.add('show');
                }
            }

            hideRotationIndicator() {
                const indicator = document.getElementById('rotationIndicator');
                if (indicator) {
                    indicator.classList.remove('show');
                }
            }

            updateRotationIndicator(angle) {
                const indicator = document.getElementById('rotationIndicator');
                if (indicator) {
                    indicator.textContent = `🔄 Rotation: ${angle}°`;
                }
            }

            /*╔═══════════════════════════════════════════════════════════════════════════
              ║ STREAMLINED DRAG MANAGEMENT (KEYBOARD ONLY)
              ║ Removed mobile gestures and auto-rotation for optimal performance
              ╚═══════════════════════════════════════════════════════════════════════════*/

            // Simplified cleanup method (no auto-rotation timers to clear)
            stopMobileRotation() {
                // Keep method for compatibility, but no timers to clear
            }

            endDrag() {
                if (this.draggedElement) {
                    this.draggedElement.classList.remove('ghost-active');
                    
                    // If shape is still in dock (not removed), restore visibility
                    if (this.draggedElement.parentElement) {
                        this.draggedElement.style.visibility = 'visible';
                    }
                }
                
                if (this.ghostElement) {
                    // Remove from drag overlay if it exists, otherwise from document.body
                    const dragOverlay = document.getElementById('dragOverlay');
                    if (dragOverlay && dragOverlay.contains(this.ghostElement)) {
                        dragOverlay.removeChild(this.ghostElement);
                    } else if (this.ghostElement.parentNode) {
                        this.ghostElement.parentNode.removeChild(this.ghostElement);
                    }
                    this.ghostElement = null;
                }
                
                // Hide rotation indicator
                this.hideRotationIndicator();
                
                this.isDragging = false;
                this.draggedElement = null;
                this.draggedShapeType = null;
                this.currentRotation = 0;
                this.dragStartedFromDock = false;
            }

            // Configuration method for touch offset
            setTouchOffset(x, y, enabled = true) {
                this.touchOffset.x = x;
                this.touchOffset.y = y;
                this.touchOffset.enabled = enabled;
                console.log(`📱 Touch offset updated: x=${x}, y=${y}, enabled=${enabled}`);
            }

            // Get current touch offset settings
            getTouchOffset() {
                return { ...this.touchOffset };
            }

            // Touch event handlers for mobile support
            handleTouchStart(event) {
                if (event.touches.length !== 1) return;
                
                const touch = event.touches[0];
                
                // Add haptic feedback if supported
                if (navigator.vibrate && touch.target.closest('.game-shape')) {
                    navigator.vibrate(50); // Light haptic feedback
                }
                
                // Convert touch to mouse-like event
                const mouseEvent = new MouseEvent('mousedown', {
                    clientX: touch.clientX,
                    clientY: touch.clientY,
                    button: 0
                });
                
                this.handlePointerDown(mouseEvent);
                event.preventDefault();
            }
            
            handleTouchMove(event) {
                if (event.touches.length !== 1 || !this.isDragging) return;
                
                const touch = event.touches[0];
                
                // Convert touch to mouse-like event
                const mouseEvent = new MouseEvent('mousemove', {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
                
                this.throttledHandlePointerMove(mouseEvent);
                event.preventDefault();
            }
            
            handleTouchEnd(event) {
                if (!this.isDragging) return;
                
                const touch = event.changedTouches[0];
                
                // Light haptic feedback on drop if supported
                if (navigator.vibrate) {
                    navigator.vibrate(25); // Subtle feedback on drop
                }
                
                // Convert touch to mouse-like event
                const mouseEvent = new MouseEvent('mouseup', {
                    clientX: touch.clientX,
                    clientY: touch.clientY,
                    button: 0
                });
                
                this.handlePointerUp(mouseEvent);
                event.preventDefault();
            }
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ MOBILE ENHANCEMENT MANAGER 
          ║ Adds mobile touch support and rotation zones while preserving mouse/keyboard
          ║ Detects mobile devices and provides touch-optimized interactions
          ╚═══════════════════════════════════════════════════════════════════════════*/
        class MobileEnhancementManager {
            constructor(dragDropManager) {
                this.dragDropManager = dragDropManager;
                this.isMobileDevice = this.detectMobileDevice();
                this.touchStartTime = 0;
                this.touchThreshold = 10; // Minimum movement for drag
                this.rotationTimer = null;
                this.rotationInterval = 1000; // 1 second intervals for mobile rotation
                this.rotationIncrement = Math.PI / 4; // 45 degrees for mobile
                
                // Rotation zones
                this.rotationZones = {
                    left: {
                        element: document.getElementById('leftRotationZone'),
                        direction: -1, // CCW
                        active: false,
                        bounds: null
                    },
                    right: {
                        element: document.getElementById('rightRotationZone'), 
                        direction: 1, // CW
                        active: false,
                        bounds: null
                    }
                };
                
                if (this.isMobileDevice) {
                    this.setupTouchEnhancements();
                    console.log('📱 Mobile enhancements activated');
                } else {
                    console.log('🖥️ Desktop mode - mobile enhancements disabled');
                }
            }
            
            detectMobileDevice() {
                return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                       (navigator.maxTouchPoints && navigator.maxTouchPoints > 2) ||
                       window.innerWidth <= 768;
            }
            
            setupTouchEnhancements() {
                // Add touch event listeners for mobile-specific rotation zone features
                document.addEventListener('touchstart', (e) => this.handleTouchStart(e), { passive: false });
                document.addEventListener('touchmove', (e) => this.handleTouchMove(e), { passive: false });
                document.addEventListener('touchend', (e) => this.handleTouchEnd(e), { passive: false });
                
                // Update rotation zone bounds
                this.updateRotationZoneBounds();
                window.addEventListener('resize', () => this.updateRotationZoneBounds());
                
                // Hook into DragDropManager to add mobile features
                this.originalStartDrag = this.dragDropManager.startDrag.bind(this.dragDropManager);
                this.dragDropManager.startDrag = (element, event) => {
                    this.originalStartDrag(element, event);
                    this.showRotationZones();
                };
                
                this.originalEndDrag = this.dragDropManager.endDrag.bind(this.dragDropManager);
                this.dragDropManager.endDrag = () => {
                    this.hideRotationZones();
                    this.stopRotationTimer();
                    this.originalEndDrag();
                };
            }
            
            // Enable mouse events for debugging on desktop
            enableMouseSupport() {
                if (this.mouseEventsAdded) return;
                
                // Hook into DragDropManager mouse events for rotation zones
                const originalHandlePointerMove = this.dragDropManager.handlePointerMove.bind(this.dragDropManager);
                this.dragDropManager.handlePointerMove = (event) => {
                    originalHandlePointerMove(event);
                    
                    // Check rotation zones if dragging
                    if (this.dragDropManager.isDragging && this.isMobileDevice) {
                        this.checkRotationZones(event.clientX, event.clientY);
                    }
                };
                
                this.mouseEventsAdded = true;
                console.log('🖱️ Mouse support enabled for rotation zones');
            }
            
            disableMouseSupport() {
                // Note: This would require storing original methods to restore them
                // For now, we'll just flag that mouse support was added
                this.mouseEventsAdded = false;
                console.log('🖱️ Mouse support disabled for rotation zones');
            }
            
            updateRotationZoneBounds() {
                const canvas = document.getElementById('gameCanvas');
                const canvasRect = canvas.getBoundingClientRect();
                
                this.rotationZones.left.bounds = {
                    left: canvasRect.left,
                    right: canvasRect.left + 80,
                    top: canvasRect.top,
                    bottom: canvasRect.bottom
                };
                
                this.rotationZones.right.bounds = {
                    left: canvasRect.right - 80,
                    right: canvasRect.right,
                    top: canvasRect.top,
                    bottom: canvasRect.bottom
                };
            }
            
            handleTouchStart(event) {
                if (event.touches.length !== 1) return;
                
                const touch = event.touches[0];
                const element = document.elementFromPoint(touch.clientX, touch.clientY);
                
                // Only handle rotation zones here - let DragDropManager handle shape dragging
                this.checkRotationZones(touch.clientX, touch.clientY);
                
                this.touchStartTime = Date.now();
            }
            
            handleTouchMove(event) {
                if (!this.dragDropManager.isDragging) return;
                if (event.touches.length !== 1) return;
                
                const touch = event.touches[0];
                
                // Check rotation zones with haptic feedback
                const wasInZone = this.currentRotationZone;
                this.checkRotationZones(touch.clientX, touch.clientY);
                
                // Haptic feedback when entering rotation zone
                if (this.currentRotationZone && !wasInZone && navigator.vibrate) {
                    navigator.vibrate(30); // Light feedback when entering rotation zone
                }
                
                event.preventDefault();
            }

            handleTouchEnd(event) {
                // Rotation handling on touch end
                if (this.currentRotationZone && this.dragDropManager.isDragging) {
                    const rotationDirection = this.currentRotationZone === 'left' ? -1 : 1;
                    this.dragDropManager.rotateShape(rotationDirection * this.dragDropManager.rotationStep);
                    
                    // Stronger haptic feedback for rotation
                    if (navigator.vibrate) {
                        navigator.vibrate([50, 50, 50]); // Pattern for rotation feedback
                    }
                }
                
                this.hideRotationZones();
                this.stopRotationTimer();
                this.currentRotationZone = null;
                
                event.preventDefault();
            }            checkRotationZones(x, y) {
                let inZone = null;
                
                // Debug logging
                console.log(`📍 Checking rotation zones at (${x}, ${y})`);
                
                // Check left zone
                if (this.isPointInZone(x, y, this.rotationZones.left.bounds)) {
                    inZone = 'left';
                    console.log('📍 In LEFT rotation zone');
                }
                // Check right zone
                else if (this.isPointInZone(x, y, this.rotationZones.right.bounds)) {
                    inZone = 'right';
                    console.log('📍 In RIGHT rotation zone');
                }
                
                // Handle zone entry/exit
                if (inZone && !this.rotationZones[inZone].active) {
                    this.enterRotationZone(inZone);
                } else if (!inZone) {
                    this.exitAllRotationZones();
                }
            }
            
            isPointInZone(x, y, bounds) {
                return bounds && x >= bounds.left && x <= bounds.right && 
                       y >= bounds.top && y <= bounds.bottom;
            }
            
            enterRotationZone(zoneName) {
                const zone = this.rotationZones[zoneName];
                if (!zone || !zone.element) return;
                
                // Exit other zones first
                this.exitAllRotationZones();
                
                // Activate this zone
                zone.active = true;
                zone.element.classList.add('active');
                
                // Start rotation timer
                this.rotationTimer = setInterval(() => {
                    if (this.dragDropManager.isDragging) {
                        this.dragDropManager.currentRotation += zone.direction * this.rotationIncrement;
                        
                        // Update ghost element rotation
                        if (this.dragDropManager.ghostElement) {
                            this.dragDropManager.ghostElement.style.transform = 
                                `translate(-50%, -50%) scale(1.1) rotate(${this.dragDropManager.currentRotation}rad)`;
                        }
                        
                        // Haptic feedback
                        this.playHapticFeedback();
                    }
                }, this.rotationInterval);
                
                console.log(`📱 Entered ${zoneName} rotation zone`);
            }
            
            exitAllRotationZones() {
                Object.keys(this.rotationZones).forEach(zoneName => {
                    const zone = this.rotationZones[zoneName];
                    if (zone.active && zone.element) {
                        zone.active = false;
                        zone.element.classList.remove('active');
                    }
                });
                
                this.stopRotationTimer();
            }
            
            stopRotationTimer() {
                if (this.rotationTimer) {
                    clearInterval(this.rotationTimer);
                    this.rotationTimer = null;
                }
            }
            
            showRotationZones() {
                if (!this.isMobileDevice) return;
                
                Object.values(this.rotationZones).forEach(zone => {
                    if (zone.element) {
                        zone.element.classList.add('visible');
                    }
                });
            }
            
            hideRotationZones() {
                Object.values(this.rotationZones).forEach(zone => {
                    if (zone.element) {
                        zone.element.classList.remove('visible', 'active');
                    }
                });
            }
            
            playHapticFeedback() {
                if (navigator.vibrate) {
                    navigator.vibrate(50); // Short vibration
                }
            }
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ ENHANCED GAME STATE WITH END-LEVEL COUNTDOWN
          ║ Task 4.2c: Implements end-level countdown timer and level failure conditions
          ║ Level fails if any piece falls off screen before countdown expires
          ╚═══════════════════════════════════════════════════════════════════════════*/
        class GameState {
            constructor() {
                this.shapes = [];
                this.placedShapes = [];
                this.isGameActive = true;
                this.isCountdownActive = false;
                this.countdownTime = 3;
                
                // HUD State
                this.level = 1;
                this.score = 0;
                this.coins = 0;
                this.progress = 0; // 0-100%
                
                // Timer System
                this.timerMode = 'elapsed'; // 'elapsed', 'countdown', 'endlevel'
                this.gameTime = 0; // Elapsed seconds
                this.endLevelTime = currentLevelConfig.endLevelDuration; // End level countdown duration from config
                this.endLevelDots = 0;
                
                // Physics Event Tracking
                this.shapeCollisions = 0;
                this.platformLandings = 0;
                this.shapeFalls = 0;
                this.stability = 100; // Stability percentage
                
                // End-Level State
                this.endLevelStarted = false;
                this.levelFailed = false;
                this.levelCompleted = false;
            }

            startEndLevelCountdown() {
                this.endLevelStarted = true;
                this.timerMode = 'endlevel';
                this.endLevelTime = currentLevelConfig.endLevelDuration; // Use configured duration
                this.isCountdownActive = true;
                
                console.log(`⏰ End-level countdown started: ${currentLevelConfig.endLevelDuration} seconds`);
            }

            checkLevelFailure() {
                // Level fails if any shape falls during end-level countdown
                if (this.endLevelStarted && !this.levelCompleted && this.shapeFalls > 0) {
                    this.levelFailed = true;
                    this.isGameActive = false;
                    return true;
                }
                return false;
            }

            resetLevel() {
                this.shapes = [];
                this.placedShapes = [];
                this.isGameActive = true;
                this.isCountdownActive = false;
                this.countdownTime = 3;
                this.gameTime = 0;
                this.timerMode = 'elapsed';
                this.endLevelTime = currentLevelConfig.endLevelDuration;
                this.endLevelDots = 0;
                
                // Reset score and coins to zero for fresh start
                this.score = 0;
                this.coins = 0;
                this.progress = 0;
                
                // Reset physics event tracking
                this.shapeCollisions = 0;
                this.platformLandings = 0;
                this.shapeFalls = 0;
                this.stability = 100;
                
                // Reset end-level state
                this.endLevelStarted = false;
                this.levelFailed = false;
                this.levelCompleted = false;
                
                console.log('🔄 Game state reset for new level');
            }

            addPlacedShape(shapeType) {
                this.placedShapes.push({
                    type: shapeType,
                    timestamp: Date.now()
                });
                
                const totalShapes = currentLevelConfig.dockShapes.length;
                console.log(`📊 Shape placed: ${shapeType} (${this.placedShapes.length}/${totalShapes})`);
            }

            recordPhysicsEvent(eventType) {
                switch(eventType) {
                    case 'collision':
                        this.shapeCollisions++;
                        break;
                    case 'landing':
                        this.platformLandings++;
                        break;
                    case 'fall':
                        this.shapeFalls++;
                        this.stability = Math.max(0, this.stability - 10); // Reduce stability on falls
                        
                        // Check if this fall causes level failure
                        if (this.checkLevelFailure()) {
                            console.log('💥 LEVEL FAILED: Shape fell during end-level countdown!');
                        }
                        break;
                }
            }
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ ENHANCED GAME MANAGER WITH PHYSICS EVENT INTEGRATION
          ║ Phase 4.1: Integrates physics events with game logic and UI updates
          ╚═══════════════════════════════════════════════════════════════════════════*/
        class GameManager {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.physicsManager = new PhysicsManager(this.canvas);
                this.gameState = new GameState();
                this.dragDropManager = new DragDropManager(this.physicsManager, this);
                this.mobileEnhancementManager = new MobileEnhancementManager(this.dragDropManager);
                
                // v9: Canvas Enhancement System
                this.themeManager = new ThemeManager(this.physicsManager.assetManager, this);
                
                // Level management (Super Mario Bros style)
                this.currentWorld = 1;
                this.currentLevel = 1;
                
                // Make this globally available for physics events
                window.gameManager = this;
                
                this.setupUI();
                this.setupEventListeners();
                
                console.log('🎮 Enhanced Game Manager with Physics Events initialized');
            }

            setupUI() {
                // Initialize HUD displays
                this.updateScoreDisplay();
                this.updateCoinDisplay();
                this.updateLevelDisplay();
                this.updateStars(0);
                this.updateDebugInfo();
                
                // Initialize HUD timer system
                this.timerInterval = setInterval(() => this.updateTimer(), 1000);
                
                // Event listeners are handled by onclick in HTML - no need for duplicate listener
                console.log('🎮 GameManager initialized with unified reset system');
            }

            setupEventListeners() {
                // Keyboard controls for testing (fallback)
                document.addEventListener('keydown', (e) => {
                    if (!this.gameState.isGameActive) return;
                    
                    const centerX = this.canvas.width / 2;
                    const dropY = 100;
                    
                    switch(e.key) {
                        case '1':
                            this.physicsManager.createShape(centerX, dropY, 'square');
                            this.onShapePlaced('square');
                            break;
                        case '2':
                            this.physicsManager.createShape(centerX, dropY, 'triangle');
                            this.onShapePlaced('triangle');
                            break;
                        case '3':
                            this.physicsManager.createShape(centerX, dropY, 'circle');
                            this.onShapePlaced('circle');
                            break;
                        case '4':
                            this.physicsManager.createShape(centerX, dropY, 'cross2');
                            this.onShapePlaced('cross2');
                            break;
                        case '5':
                            this.physicsManager.createShape(centerX, dropY, 'l');
                            this.onShapePlaced('l');
                            break;
                        case '6':
                            this.physicsManager.createShape(centerX, dropY, 'cross');
                            this.onShapePlaced('cross');
                            break;
                        case '7':
                            this.physicsManager.createShape(centerX, dropY, 'barbell-one');
                            this.onShapePlaced('barbell-one');
                            break;
                        case '8':
                            this.physicsManager.createShape(centerX, dropY, 'barbell-two');
                            this.onShapePlaced('barbell-two');
                            break;
                        case '9':
                            this.physicsManager.createShape(centerX, dropY, 'diamond-barbell');
                            this.onShapePlaced('diamond-barbell');
                            break;
                    }
                });
            }

            // UI Update Methods
            updateScoreDisplay() {
                const scoreElement = document.getElementById('scoreText');
                if (scoreElement) {
                    scoreElement.textContent = this.gameState.score.toLocaleString();
                    
                    // Add animation for score increase
                    scoreElement.classList.add('score-increase');
                    setTimeout(() => {
                        scoreElement.classList.remove('score-increase');
                    }, 600);
                }
            }

            updateCoinDisplay() {
                const coinElement = document.getElementById('coinAmount');
                if (coinElement) {
                    coinElement.textContent = this.gameState.coins.toString();
                    
                    // Add animation for coin increase
                    coinElement.classList.add('coin-increase');
                    setTimeout(() => {
                        coinElement.classList.remove('coin-increase');
                    }, 600);
                }
            }

            updateLevelDisplay() {
                const levelElement = document.getElementById('levelDisplay');
                if (levelElement) {
                    levelElement.textContent = `World ${this.currentWorld}-${this.currentLevel}`;
                }
            }

            // Level progression methods
            nextLevel() {
                this.currentLevel++;
                this.updateLevelDisplay();
                console.log(`🏁 Advanced to World ${this.currentWorld}-${this.currentLevel}`);
            }

            nextWorld() {
                this.currentWorld++;
                this.currentLevel = 1;
                this.updateLevelDisplay();
                console.log(`🌍 Advanced to World ${this.currentWorld}-${this.currentLevel}`);
            }

            setLevel(world, level) {
                this.currentWorld = world;
                this.currentLevel = level;
                this.updateLevelDisplay();
                console.log(`📍 Set level to World ${this.currentWorld}-${this.currentLevel}`);
            }

            // Physics Event Handlers
            onShapeLandedOnPlatform() {
                console.log('🎯 GameManager: Shape landed on platform - triggering camera shake!');
                this.gameState.recordPhysicsEvent('landing');
                
                // Track consecutive landings for streak bonuses
                this.gameState.consecutiveLandings = (this.gameState.consecutiveLandings || 0) + 1;
                this.gameState.lastAction = 'landing';
                
                // Base rewards
                let scoreBonus = 50;
                let coinBonus = 1;
                
                // Streak multipliers
                if (this.gameState.consecutiveLandings >= 5) {
                    coinBonus += 5; // +5 coins for 5+ streak
                    scoreBonus += 100;
                    this.createCoinShower('LANDING MASTER!', 5);
                } else if (this.gameState.consecutiveLandings >= 3) {
                    coinBonus += 2; // +2 coins for 3+ streak
                    scoreBonus += 50;
                    this.createFloatingText(`🔥 ${this.gameState.consecutiveLandings}x STREAK!`, 
                        document.getElementById('coinAmount'), '#FF6B35');
                }
                
                this.gameState.score += scoreBonus;
                this.gameState.coins += coinBonus;
                this.updateScoreDisplay();
                this.updateCoinDisplay();
                
                // Sound effect integration point
                this.playSound('shapeLanding');
                
                // Create enhanced particle effects
                if (this.physicsManager && this.physicsManager.particleSystem) {
                    const canvasRect = this.physicsManager.canvas.getBoundingClientRect();
                    const platformY = canvasRect.height * 0.85;
                    const x = Math.random() * canvasRect.width * 0.6 + canvasRect.width * 0.2;
                    const particleCount = Math.min(12 + this.gameState.consecutiveLandings * 2, 24);
                    this.physicsManager.particleSystem.createThemeParticles('landing', x, platformY, particleCount);
                }
                
                // Enhanced visual feedback
                const scoreElement = document.getElementById('scoreText');
                const coinElement = document.getElementById('coinAmount');
                
                this.createFloatingText(`+${scoreBonus}`, scoreElement, '#10B981');
                this.createFloatingText(`+${coinBonus}`, coinElement, '#FFD700');
                
                // Extra visual effects for big bonuses
                if (coinBonus > 3) {
                    this.createFloatingText('💰💰💰', coinElement, '#FFD700');
                    this.pulseElement(coinElement, 3);
                }
                
                console.log(`🎯 Landing streak: ${this.gameState.consecutiveLandings}, Coins: +${coinBonus}`);
            }

            onShapeCollision() {
                console.log('🔄 GameManager: Shape collision - triggering camera shake!');
                this.gameState.recordPhysicsEvent('collision');
                
                // Reset landing streak on collision
                this.gameState.consecutiveLandings = 0;
                
                // Track collision chains for bonus coins
                this.gameState.recentCollisions = (this.gameState.recentCollisions || 0) + 1;
                
                // Base rewards
                let scoreBonus = 25;
                let coinBonus = 0;
                
                // Collision-based coin rewards
                if (this.gameState.recentCollisions % 1 === 0) { // Every collision now gives coins!
                    coinBonus = 1;
                    
                    // Bonus for rapid collisions
                    if (this.gameState.recentCollisions >= 3) {
                        coinBonus += 2; // +2 extra for collision chains
                        scoreBonus += 25;
                        this.createFloatingText('💥 CHAIN REACTION!', document.getElementById('scoreText'), '#FF6B35');
                    }
                }
                
                // Random coin jackpots (5% chance)
                if (Math.random() < 0.05) {
                    const jackpot = Math.floor(Math.random() * 10) + 5; // 5-14 coins
                    coinBonus += jackpot;
                    this.createCoinShower('JACKPOT!', jackpot);
                    
                    // Small celebratory shake for big jackpots
                    if (jackpot >= 10 && this.physicsManager) {
                        this.physicsManager.startCameraShake(4, 300);
                    }
                }
                
                this.gameState.score += scoreBonus;
                this.gameState.coins += coinBonus;
                
                // Sound effect integration point
                this.playSound('shapeCollision');
                
                // Create enhanced particle effects
                if (this.physicsManager && this.physicsManager.particleSystem) {
                    const canvasRect = this.physicsManager.canvas.getBoundingClientRect();
                    const x = Math.random() * canvasRect.width * 0.8 + canvasRect.width * 0.1;
                    const y = Math.random() * canvasRect.height * 0.6 + canvasRect.height * 0.2;
                    const particleCount = Math.min(8 + this.gameState.recentCollisions, 20);
                    this.physicsManager.particleSystem.createThemeParticles('collision', x, y, particleCount);
                }
                
                this.updateScoreDisplay();
                if (coinBonus > 0) {
                    this.updateCoinDisplay();
                    const coinElement = document.getElementById('coinAmount');
                    this.createFloatingText(`+${coinBonus}`, coinElement, '#FFD700');
                }
                
                // Add visual feedback for collision bonuses
                const scoreElement = document.getElementById('scoreText');
                this.createFloatingText(`+${scoreBonus}`, scoreElement, '#4ECDC4');
                
                // Reset collision counter after a pause
                setTimeout(() => {
                    if (this.gameState.lastAction !== 'collision') {
                        this.gameState.recentCollisions = 0;
                    }
                }, 2000);
                
                this.gameState.lastAction = 'collision';
                
                console.log(`🔄 Collision chain: ${this.gameState.recentCollisions}, Coins: +${coinBonus}`);
            }

            onShapeFell() {
                console.log('💥 GameManager: Shape fell - triggering camera shake!');
                this.gameState.recordPhysicsEvent('fall');
                
                // Track fall time for stability bonuses
                this.gameState.lastFallTime = Date.now();
                
                // Reset all streaks on fall
                this.gameState.consecutiveLandings = 0;
                this.gameState.recentCollisions = 0;
                
                // Dramatic penalties based on current coin count
                let scorePenalty = 100;
                let coinPenalty = 3; // Increased base penalty
                
                // Scale penalties with current wealth (more coins = bigger penalty)
                if (this.gameState.coins >= 50) {
                    coinPenalty += 7; // -10 coins total for wealthy players
                    scorePenalty += 200;
                    this.createFloatingText('💸 MAJOR LOSS!', document.getElementById('coinAmount'), '#FF4444');
                } else if (this.gameState.coins >= 20) {
                    coinPenalty += 2; // -5 coins total
                    scorePenalty += 100;
                }
                
                // Apply penalties with minimums
                this.gameState.score = Math.max(0, this.gameState.score - scorePenalty);
                this.gameState.coins = Math.max(0, this.gameState.coins - coinPenalty);
                
                this.updateScoreDisplay();
                this.updateCoinDisplay();
                
                // Dramatic visual effects
                const coinElement = document.getElementById('coinAmount');
                const scoreElement = document.getElementById('scoreText');
                
                this.createFloatingText(`-${coinPenalty}`, coinElement, '#FF6B6B');
                this.createFloatingText(`-${scorePenalty}`, scoreElement, '#FF6B6B');
                
                // Shake effect for major losses
                if (coinPenalty >= 5) {
                    this.shakeElement(coinElement, 5);
                    this.createFloatingText('💀💀�', coinElement, '#FF4444');
                }
                
                // Camera shake effect for dramatic falls - RANDOM INTENSITY
                const randomIntensity = Math.floor(Math.random() * 10) + 10; // Random 10-19 intensity
                const duration = 800;
                console.log(`🔥 ATTEMPTING CAMERA SHAKE: intensity=${randomIntensity}, duration=${duration}ms`);
                
                if (this.physicsManager) {
                    console.log('✅ PhysicsManager found, calling startCameraShake...');
                    this.physicsManager.startCameraShake(randomIntensity, duration);
                } else {
                    console.log('❌ PhysicsManager not found!');
                }
                
                // Sound effect integration point
                this.playSound('shapeFall');
                
                console.log(`💥 FALL PENALTY: -${coinPenalty} coins, -${scorePenalty} points`);
                
                // Check if level failed due to fall during countdown
                if (this.gameState.levelFailed) {
                    this.onLevelFailed();
                    return;
                }
                
                // Check if this should trigger game over (outside of end-level countdown)
                if (!this.gameState.endLevelStarted && this.gameState.shapeFalls >= 3) {
                    this.onGameOver();
                }
            }

            onShapePlaced(shapeType) {
                this.gameState.addPlacedShape(shapeType);
                this.updateDebugInfo();
                
                // Update score
                this.gameState.score += 100;
                document.getElementById('scoreText').textContent = this.gameState.score.toLocaleString();
                
                // Update progress bar using current dock configuration
                const totalShapes = currentLevelConfig.dockShapes.length;
                const progress = (this.gameState.placedShapes.length / totalShapes) * 100;
                document.getElementById('starProgressBar').style.width = progress + '%';
                
                // Update stars based on progress
                this.updateStars(this.gameState.placedShapes.length);
                
                // Check for level completion (start end-level countdown)
                if (this.gameState.placedShapes.length >= totalShapes) {
                    console.log(`🎯 All ${totalShapes} shapes placed! Starting end-level countdown...`);
                    
                    // Coin reward for successfully placing all shapes
                    this.gameState.coins += 5;
                    this.updateCoinDisplay();
                    
                    // Show coin reward particle
                    const coinElement = document.getElementById('coinAmount');
                    this.createFloatingText('+5 All Shapes!', coinElement, '#FFD700');
                    
                    this.gameState.startEndLevelCountdown();
                    this.physicsManager.showEventNotification('End-Level Countdown!', 'balance');
                }
            }

            updateStars(shapesPlaced) {
                const stars = document.querySelectorAll('.star');
                const totalShapes = currentLevelConfig.dockShapes.length;
                const progressPercent = (shapesPlaced / totalShapes) * 100;
                
                // Star thresholds: 33.33%, 66.66%, 100%
                const starThresholds = [33.33, 66.66, 100];
                
                stars.forEach((star, index) => {
                    const threshold = starThresholds[index];
                    const shouldBeFilled = progressPercent >= threshold;
                    
                    if (shouldBeFilled && !star.classList.contains('filled')) {
                        // Star should be filled and isn't yet
                        const wasEmpty = !star.classList.contains('filled');
                        star.classList.add('filled');
                        
                        // Add particle effect for newly filled star
                        if (wasEmpty) {
                            setTimeout(() => {
                                this.createFloatingText('⭐', star, '#FFD700');
                            }, 100);
                        }
                    } else if (!shouldBeFilled && star.classList.contains('filled')) {
                        // Star should not be filled but is
                        star.classList.remove('filled');
                    }
                });
                
                // Update progress bar with animation using current dock configuration
                const progressBar = document.getElementById('starProgressBar');
                
                // Smooth progress bar animation
                progressBar.style.transition = 'width 0.5s ease-out';
                progressBar.style.width = progressPercent + '%';
                
                if (shapesPlaced > 0) {
                    this.animateProgressBar(progressBar);
                }
            }

            updateTimer() {
                if (!this.gameState.isGameActive) return;
                
                const timerElement = document.getElementById('gameTimer');
                
                switch(this.gameState.timerMode) {
                    case 'elapsed':
                        this.updateElapsedTimer(timerElement);
                        break;
                    case 'countdown':
                        this.updateCountdownTimer(timerElement);
                        break;
                    case 'endlevel':
                        this.updateEndLevelTimer(timerElement);
                        break;
                }
            }

            updateElapsedTimer(element) {
                const minutes = Math.floor(this.gameState.gameTime / 60);
                const seconds = this.gameState.gameTime % 60;
                element.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                this.gameState.gameTime++;
                
                // Remove any warning classes
                element.classList.remove('timer-warning', 'timer-critical');
            }

            updateCountdownTimer(element) {
                // Use gameTime for countdown timer (starts from configured time and counts down)
                const minutes = Math.floor(this.gameState.gameTime / 60);
                const seconds = this.gameState.gameTime % 60;
                element.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                
                // Remove previous warning classes
                element.classList.remove('timer-warning', 'timer-critical');
                
                // Add warning effects based on time remaining
                if (this.gameState.gameTime <= 5 && this.gameState.gameTime > 0) {
                    element.classList.add('timer-critical');
                } else if (this.gameState.gameTime <= 10) {
                    element.classList.add('timer-warning');
                }
                
                // Countdown: decrease time
                this.gameState.gameTime--;
                
                // Check if countdown reached zero
                if (this.gameState.gameTime < 0) {
                    this.gameState.gameTime = 0; // Prevent negative display
                    element.textContent = '0:00';
                    
                    // Trigger game over due to time up
                    console.log('⏰ Countdown timer reached zero - Game Over!');
                    this.onGameTimeUp();
                }
            }

            updateEndLevelTimer(element) {
                // Create 3-dot display if it doesn't exist
                if (!element.querySelector('.countdown-dots')) {
                    console.log('🔴 Creating dramatic 3-dot countdown display...');
                    element.innerHTML = '';
                    const dotsContainer = document.createElement('div');
                    dotsContainer.className = 'countdown-dots';
                    
                    for (let i = 0; i < 3; i++) {
                        const dot = document.createElement('div');
                        dot.className = 'countdown-dot';
                        dot.id = `countdown-dot-${i}`;
                        dotsContainer.appendChild(dot);
                    }
                    
                    element.appendChild(dotsContainer);
                    this.gameState.endLevelDots = 0;
                    console.log('✅ 3-dot countdown display created!');
                }
                
                // Update dots based on time remaining using configured duration
                const totalDuration = currentLevelConfig.endLevelDuration;
                const timeElapsed = totalDuration - this.gameState.endLevelTime;
                const dotsToShow = Math.min(3, Math.ceil((timeElapsed / totalDuration) * 3));
                console.log(`🔵 Updating dots: ${dotsToShow} active dots, ${this.gameState.endLevelTime}s remaining (total: ${totalDuration}s)`);
                
                for (let i = 0; i < 3; i++) {
                    const dot = document.getElementById(`countdown-dot-${i}`);
                    if (dot) {
                        if (i < dotsToShow) {
                            if (i === dotsToShow - 1 && this.gameState.endLevelTime > 0) {
                                dot.className = 'countdown-dot active';
                            } else {
                                dot.className = 'countdown-dot completed';
                            }
                        } else {
                            dot.className = 'countdown-dot';
                        }
                    }
                }
                
                this.gameState.endLevelTime--;
                
                if (this.gameState.endLevelTime < 0) {
                    console.log('🏆 End level countdown complete! Level finished!');
                    this.triggerLevelCompleteEffects();
                    this.onLevelComplete();
                }
            }

            updateDebugInfo() {
                const debugInfo = document.getElementById('debugInfo');
                const physicsStats = this.physicsManager.getEventStats();
                const totalShapes = currentLevelConfig.dockShapes.length;
                
                // Fix #4: Count available shapes properly - shapes that are visible and not being dragged
                const availableShapes = document.querySelectorAll('.game-shape:not(.dragging)').length;
                
                debugInfo.textContent = `Placed: ${this.gameState.placedShapes.length}/${totalShapes} | Dock: ${availableShapes}/${totalShapes} | Events: ${physicsStats.events} | FPS: 60`;
            }

            onGameTimeUp() {
                this.gameState.isGameActive = false;
                console.log('⏰ Time Up! Level Failed!');
            }

            onGameOver() {
                this.gameState.isGameActive = false;
                console.log('💀 Game Over! Too many shapes fell.');
            }

            /*╔═══════════════════════════════════════════════════════════════════════════
              ║ SHOW LEVEL CLEARED POPUP
              ║ Displays a celebratory popup modal when the level is successfully cleared.
              ║ Includes animated title, stars, and button to continue or replay level.
              ╚═══════════════════════════════════════════════════════════════════════════*/
            showLevelClearedPopup() {
                // Create modal overlay
                const modal = document.createElement('div');
                modal.className = 'level-cleared-modal';
                modal.id = 'levelClearedModal';
                
                // Create modal content
                const content = document.createElement('div');
                content.className = 'level-cleared-content';
                
                // Title
                const title = document.createElement('div');
                title.className = 'level-cleared-title';
                title.textContent = 'Level Cleared!';
                
                // Subtitle with score info
                const subtitle = document.createElement('div');
                subtitle.className = 'level-cleared-subtitle';
                subtitle.textContent = `Score: ${this.gameState.score} | Coins: ${this.gameState.coins}`;
                
                // Animated stars
                const stars = document.createElement('div');
                stars.className = 'level-cleared-stars';
                stars.textContent = '⭐ ⭐ ⭐';
                
                // Continue button
                const continueBtn = document.createElement('button');
                continueBtn.className = 'level-cleared-button';
                continueBtn.textContent = 'Continue';
                continueBtn.onclick = () => this.closeLevelClearedPopup();
                
                // Replay button
                const replayBtn = document.createElement('button');
                replayBtn.className = 'level-cleared-button';
                replayBtn.textContent = 'Replay Level';
                replayBtn.style.background = 'linear-gradient(135deg, #2196F3 0%, #1976D2 100%)';
                replayBtn.onclick = () => {
                    this.closeLevelClearedPopup();
                    resetLevel();
                };
                
                // Assemble modal
                content.appendChild(title);
                content.appendChild(subtitle);
                content.appendChild(stars);
                content.appendChild(continueBtn);
                content.appendChild(replayBtn);
                modal.appendChild(content);
                
                // Add to page
                document.body.appendChild(modal);
                
                console.log('🎉 Level Cleared popup displayed!');
            }

            closeLevelClearedPopup() {
                const modal = document.getElementById('levelClearedModal');
                if (modal) {
                    modal.style.animation = 'modalFadeIn 0.3s ease-out reverse';
                    setTimeout(() => {
                        modal.remove();
                    }, 300);
                }
            }

            /*╔═══════════════════════════════════════════════════════════════════════════
              ║ TRIGGER LEVEL COMPLETE EFFECTS
              ║ Creates spectacular visual effects when level is completed successfully.
              ║ Includes cascading star effects, screen flash, and celebration particles.
              ╚═══════════════════════════════════════════════════════════════════════════*/
            triggerLevelCompleteEffects() {
                // Flash effect for completion
                const screen = document.querySelector('.screen');
                screen.style.animation = 'levelCompleteFlash 1s ease-out';
                setTimeout(() => {
                    screen.style.animation = '';
                }, 1000);
                
                // Cascade star effects
                const stars = document.querySelectorAll('.star');
                stars.forEach((star, index) => {
                    setTimeout(() => {
                        star.style.animation = 'starBurst 0.8s ease-out';
                        this.createFloatingText('★', star, '#FFD700');
                    }, index * 150);
                });
                
                // Multiple celebration particles
                setTimeout(() => {
                    const scoreElement = document.getElementById('scoreText');
                    const coinElement = document.getElementById('coinAmount');
                    
                    this.createFloatingText('🎉', scoreElement, '#FF6B6B');
                    this.createFloatingText('🎊', coinElement, '#4ECDC4');
                    
                    setTimeout(() => {
                        this.createFloatingText('🏆', scoreElement, '#FFD700');
                    }, 300);
                }, 500);
            }

            onLevelComplete() {
                this.gameState.isGameActive = false;
                this.gameState.levelCompleted = true;
                console.log('🎯 Level Complete! Score: ' + this.gameState.score);
                
                // Sound effect integration point
                this.playSound('levelComplete');
                
                // Bonus points for completion with particle effects
                this.gameState.score += 500;
                this.gameState.coins += 25; // Increased completion bonus
                
                // Show Level Cleared popup immediately
                this.showLevelClearedPopup();
                
                // Advance to next level after a delay
                setTimeout(() => {
                    this.nextLevel();
                }, 3000); // Increased delay to account for popup
                
                // Create floating text for completion bonus
                const scoreElement = document.getElementById('scoreText');
                this.createFloatingText('+500', scoreElement, '#FFD700');
                
                const coinElement = document.getElementById('coinAmount');
                this.createFloatingText('+25 Complete!', coinElement, '#4ECDC4');
                
                // Stability bonus
                const stabilityBonus = Math.floor(this.gameState.stability * 2);
                this.gameState.score += stabilityBonus;
                
                // Stability coin bonus for high stability (80%+)
                if (this.gameState.stability >= 80) {
                    const coinBonus = Math.floor(this.gameState.stability / 10);
                    this.gameState.coins += coinBonus;
                    
                    setTimeout(() => {
                        this.createFloatingText(`+${coinBonus} Stability`, coinElement, '#10B981');
                    }, 750);
                }
                
                if (stabilityBonus > 0) {
                    setTimeout(() => {
                        this.createFloatingText(`+${stabilityBonus} Stability`, scoreElement, '#10B981');
                    }, 500);
                }
                
                // Update display
                this.updateScoreDisplay();
                this.updateCoinDisplay();
                
                // All stars should be filled with animation
                this.updateStars(3);
                const progressBar = document.getElementById('starProgressBar');
                this.animateProgressBar(progressBar);
                
                this.physicsManager.showEventNotification('Level Complete!', 'collision');
            }

            onLevelFailed() {
                this.gameState.isGameActive = false;
                console.log('💀 Level Failed! Shape fell during countdown.');
                this.physicsManager.showEventNotification('Level Failed!', 'fall');
            }

            resetLevel() {
                console.log('🔄 Resetting level...');
                
                // Clear all dynamic physics bodies
                this.physicsManager.cleanup();
                
                // Recreate the platform and boundaries
                this.physicsManager.createPlatform();
                this.physicsManager.createBoundaries();
                
                // Reset game state
                this.gameState.resetLevel();
                
                // Restore all shapes to docking area
                this.restoreAllShapesToDock();
                
                // Reset HUD to initial values
                this.updateScoreDisplay();
                this.updateCoinDisplay();
                document.getElementById('starProgressBar').style.width = '0%';
                document.getElementById('gameTimer').textContent = '0:00';
                
                // Reset timer mode to elapsed
                const modeIndicator = document.getElementById('timerModeIndicator');
                modeIndicator.className = 'timer-mode-indicator timer-mode-elapsed';
                modeIndicator.textContent = '⏱';
                
                // Reset all stars
                document.querySelectorAll('.star').forEach(star => {
                    star.classList.remove('filled');
                });
                
                // Update debug info
                this.updateDebugInfo();
                
                console.log('✅ Level reset complete');
            }

            /*╔═══════════════════════════════════════════════════════════════════════════
              ║ CREATE FLOATING TEXT PARTICLE
              ║ Generates animated floating text particles for visual feedback. Creates
              ║ temporary DOM elements positioned relative to target elements that float
              ║ upward and fade out. Used for score/coin increase notifications.
              ║ Parameters: text - Text to display, element - Reference element, color - Text color
              ╚═══════════════════════════════════════════════════════════════════════════*/
            createFloatingText(text, element, color = '#FFD700') {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.textContent = text;
                particle.style.color = color;
                
                const rect = element.getBoundingClientRect();
                particle.style.left = (rect.left + rect.width / 2) + 'px';
                particle.style.top = rect.top + 'px';
                
                document.body.appendChild(particle);
                
                setTimeout(() => {
                    if (particle.parentNode) {
                        document.body.removeChild(particle);
                    }
                }, 2000);
            }

            /*╔═══════════════════════════════════════════════════════════════════════════
              ║ CREATE COIN SHOWER EFFECT
              ║ Creates a spectacular shower of coin particles for major achievements.
              ║ Multiple floating coins rain down from the coin counter element.
              ║ Used for jackpots, streaks, and other exciting coin-earning events.
              ╚═══════════════════════════════════════════════════════════════════════════*/
            createCoinShower(message, coinCount) {
                const coinElement = document.getElementById('coinAmount');
                const rect = coinElement.getBoundingClientRect();
                
                // Create the main message
                this.createFloatingText(message, coinElement, '#FFD700');
                
                // Create shower of individual coins
                for (let i = 0; i < Math.min(coinCount, 15); i++) {
                    setTimeout(() => {
                        const coin = document.createElement('div');
                        coin.className = 'particle';
                        coin.textContent = '💰';
                        coin.style.fontSize = '20px';
                        coin.style.left = (rect.left + Math.random() * rect.width) + 'px';
                        coin.style.top = rect.top + 'px';
                        coin.style.transform = `translate(${(Math.random() - 0.5) * 200}px, ${Math.random() * -100}px)`;
                        coin.style.opacity = '0';
                        coin.style.transition = 'all 2s ease-out';
                        
                        document.body.appendChild(coin);
                        
                        // Animate the coin
                        setTimeout(() => {
                            coin.style.transform += ` translateY(${Math.random() * 200 + 100}px)`;
                            coin.style.opacity = '1';
                        }, 50);
                        
                        // Remove after animation
                        setTimeout(() => {
                            if (coin.parentNode) {
                                document.body.removeChild(coin);
                            }
                        }, 2500);
                    }, i * 100); // Stagger the coins
                }
            }

            /*╔═══════════════════════════════════════════════════════════════════════════
              ║ PULSE ELEMENT EFFECT
              ║ Makes an element pulse with a glowing effect to draw attention.
              ║ Used for significant coin increases and achievements.
              ╚═══════════════════════════════════════════════════════════════════════════*/
            pulseElement(element, pulses = 3) {
                let count = 0;
                const originalTransform = element.style.transform;
                const originalBoxShadow = element.style.boxShadow;
                
                const pulse = () => {
                    if (count >= pulses) {
                        element.style.transform = originalTransform;
                        element.style.boxShadow = originalBoxShadow;
                        return;
                    }
                    
                    element.style.transform = 'scale(1.2)';
                    element.style.boxShadow = '0 0 20px #FFD700';
                    element.style.transition = 'all 0.2s ease-in-out';
                    
                    setTimeout(() => {
                        element.style.transform = 'scale(1)';
                        element.style.boxShadow = originalBoxShadow;
                        count++;
                        setTimeout(pulse, 300);
                    }, 200);
                };
                
                pulse();
            }

            /*╔═══════════════════════════════════════════════════════════════════════════
              ║ SHAKE ELEMENT EFFECT
              ║ Makes an element shake violently to show dramatic losses or penalties.
              ║ Used when players lose significant amounts of coins.
              ╚═══════════════════════════════════════════════════════════════════════════*/
            shakeElement(element, intensity = 3) {
                const originalTransform = element.style.transform;
                let shakeCount = 0;
                const maxShakes = intensity * 4; // More shakes for higher intensity
                
                const shake = () => {
                    if (shakeCount >= maxShakes) {
                        element.style.transform = originalTransform;
                        element.style.transition = '';
                        return;
                    }
                    
                    const x = (Math.random() - 0.5) * intensity * 4;
                    const y = (Math.random() - 0.5) * intensity * 4;
                    element.style.transform = `translate(${x}px, ${y}px)`;
                    element.style.transition = 'none';
                    
                    shakeCount++;
                    setTimeout(shake, 50);
                };
                
                shake();
            }

            /*╔═══════════════════════════════════════════════════════════════════════════
              ║ ANIMATE PROGRESS BAR
              ║ Provides visual feedback when the progress bar fills. Adds temporary 
              ║ animation class that causes the bar to pulse/glow, then removes it.
              ║ Enhances the user experience when star progress increases.
              ║ Parameters: progressBar - The progress bar DOM element to animate
              ╚═══════════════════════════════════════════════════════════════════════════*/
            animateProgressBar(progressBar) {
                progressBar.classList.add('progress-animate');
                setTimeout(() => progressBar.classList.remove('progress-animate'), 800);
            }

            /*╔═══════════════════════════════════════════════════════════════════════════
              ║ SOUND SYSTEM INTEGRATION POINTS
              ║ Placeholder functions for easy sound effect integration. These functions
              ║ can be enhanced later with actual audio implementation using Web Audio API
              ║ or HTML5 audio elements. Currently logs sound events for development.
              ╚═══════════════════════════════════════════════════════════════════════════*/
            playSound(soundType) {
                // Integration point for sound effects
                // Future enhancement: Load and play actual audio files
                console.log(`🔊 Sound: ${soundType}`);
                
                switch (soundType) {
                    case 'shapeLanding':
                        // Soft landing sound - positive feedback
                        break;
                    case 'shapeCollision':
                        // Click/tap sound - interaction feedback  
                        break;
                    case 'shapeRotation':
                        // Quick whoosh sound - rotation feedback
                        break;
                    case 'coinEarned':
                        // Coin pickup sound - reward feedback
                        break;
                    case 'starFilled':
                        // Bright ding sound - progress feedback
                        break;
                    case 'levelComplete':
                        // Victory fanfare - completion feedback
                        break;
                    case 'levelFailed':
                        // Disappointment sound - failure feedback
                        break;
                    case 'endLevelCountdown':
                        // Ticking sound - tension building
                        break;
                    default:
                        console.log(`Unknown sound type: ${soundType}`);
                }
            }

            restoreAllShapesToDock() {
                // Restore all nine shapes to their dock positions
                const shapes = [
                    { id: 'shape-square', type: 'square', slot: 'slot-square' },
                    { id: 'shape-triangle', type: 'triangle', slot: 'slot-triangle' },
                    { id: 'shape-circle', type: 'circle', slot: 'slot-circle' },
                    { id: 'shape-cross2', type: 'cross2', slot: 'slot-cross2' },
                    { id: 'shape-l', type: 'l', slot: 'slot-l' },
                    { id: 'shape-cross', type: 'cross', slot: 'slot-cross' },
                    { id: 'shape-barbell-one', type: 'barbell-one', slot: 'slot-barbell-one' },
                    { id: 'shape-barbell-two', type: 'barbell-two', slot: 'slot-barbell-two' },
                    { id: 'shape-diamond-barbell', type: 'diamond-barbell', slot: 'slot-diamond-barbell' }
                ];
                
                shapes.forEach(shapeInfo => {
                    const slot = document.getElementById(shapeInfo.slot);
                    if (slot) {
                        slot.classList.remove('empty');
                        
                        // Remove any existing shape in the slot
                        const existingShape = slot.querySelector('.game-shape');
                        if (existingShape) {
                            existingShape.remove();
                        }
                        
                        // Create new shape element
                        const shapeElement = document.createElement('div');
                        shapeElement.className = `game-shape shape-${shapeInfo.type}`;
                        shapeElement.dataset.shape = shapeInfo.type;
                        shapeElement.id = shapeInfo.id;
                        
                        slot.appendChild(shapeElement);
                    }
                });
                
                console.log('🔄 All 9 shapes restored to docking area');
            }
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ PHASE 2: MODE TOGGLE SYSTEM - LEVEL EDITOR FUNCTIONALITY
          ║ Implements the level editor mode toggle system allowing users to switch
          ║ between Play Mode (normal gameplay) and Design Mode (level configuration).
          ║ Includes dock configuration, timer settings, and level parameters.
          ╚═══════════════════════════════════════════════════════════════════════════*/

        // Level configuration state
        let currentMode = 'play';
        let currentLevelConfig = {
            world: 1,
            level: 1,
            timerMode: 'elapsed',
            timerStart: 60,
            endLevelDuration: 5,
            dockSlots: 9,
            barbellOrientation: 'vertical',
            dockShapes: ['square', 'triangle', 'circle', 'cross2', 'l', 'cross', 'barbell-one', 'barbell-two', 'diamond-barbell']
        };

        // Make level config globally available for dock system
        window.currentLevelConfig = currentLevelConfig;

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ TOGGLE MODE SWITCH FUNCTION
          ║ New toggle switch function that switches between Play Mode and Design Mode
          ║ using a compact toggle switch in the HUD instead of separate buttons.
          ╚═══════════════════════════════════════════════════════════════════════════*/
        function toggleModeSwitch() {
            const toggleSwitch = document.getElementById('modeToggleSwitch');
            const slider = toggleSwitch.querySelector('.mode-toggle-slider');
            
            if (currentMode === 'play') {
                toggleMode('design');
                toggleSwitch.classList.add('design-active');
                slider.textContent = '🔧';
            } else {
                toggleMode('play');
                toggleSwitch.classList.remove('design-active');
                slider.textContent = '🎮';
            }
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ TOGGLE MODE FUNCTION (UPDATED)
          ║ Updated to work with new toggle switch instead of separate buttons.
          ╚═══════════════════════════════════════════════════════════════════════════*/
        function toggleMode(mode) {
            const gameContainer = document.getElementById('gameContainer');
            const designSidebar = document.getElementById('designSidebar');
            
            if (mode === 'design') {
                gameContainer.classList.add('design-mode');
                designSidebar.classList.add('active');
                currentMode = 'design';
                
                console.log('🔧 Entered Design Mode - Level Editor Active');
                
                // Sync current dock configuration to design sidebar
                syncDockToDesign();
                generateDockSlots();
            } else {
                gameContainer.classList.remove('design-mode');
                designSidebar.classList.remove('active');
                currentMode = 'play';
                
                console.log('🎮 Entered Play Mode - Game Active');
                
                // Apply any design changes to the play dock
                rebuildGameDock();
            }
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ SYNC DOCK TO DESIGN
          ║ Reads the current dock configuration from the game and updates the design
          ║ sidebar to match. Ensures design mode reflects the actual game state.
          ║ Used when entering design mode to show current level configuration.
          ╚═══════════════════════════════════════════════════════════════════════════*/
        function syncDockToDesign() {
            const currentShapes = [];
            const dockingArea = document.getElementById('dockingArea');
            
            if (dockingArea) {
                const shapes = dockingArea.querySelectorAll('.game-shape');
                shapes.forEach(shape => {
                    const shapeType = shape.getAttribute('data-shape');
                    if (shapeType) {
                        currentShapes.push(shapeType);
                    }
                });
                
                if (currentShapes.length > 0) {
                    currentLevelConfig.dockShapes = currentShapes;
                    currentLevelConfig.dockSlots = currentShapes.length;
                    
                    // Update UI controls
                    const slotCountInput = document.getElementById('dockSlotCount');
                    if (slotCountInput) {
                        slotCountInput.value = currentShapes.length;
                    }
                }
            }
            
            console.log('🔄 Synced current dock to design:', currentLevelConfig.dockShapes);
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ GENERATE DOCK SLOTS
          ║ Creates the dynamic dock slot configuration UI in the design sidebar.
          ║ Generates dropdown selectors for each dock slot allowing shape assignment.
          ║ Preserves existing shape assignments when slot count changes.
          ╚═══════════════════════════════════════════════════════════════════════════*/
        function generateDockSlots() {
            const dockContainer = document.getElementById('dockSlotsContainer');
            const slotCount = parseInt(document.getElementById('dockSlotCount').value);
            
            if (!dockContainer) return;
            
            dockContainer.innerHTML = '';
            
            // Ensure we have enough shapes in the configuration
            const allShapes = ['square', 'triangle', 'circle', 'l', 'cross', 'cross2', 
                              'barbell-one', 'barbell-two', 'diamond-barbell'];
            
            // Preserve existing shapes or use defaults
            if (currentLevelConfig.dockShapes.length !== slotCount) {
                const newShapes = [];
                for (let i = 0; i < slotCount; i++) {
                    if (i < currentLevelConfig.dockShapes.length) {
                        newShapes.push(currentLevelConfig.dockShapes[i]);
                    } else {
                        newShapes.push(allShapes[i % allShapes.length]);
                    }
                }
                currentLevelConfig.dockShapes = newShapes;
            }
            
            // Generate configuration UI for each slot
            for (let i = 0; i < slotCount; i++) {
                const slotDiv = document.createElement('div');
                slotDiv.className = 'dock-slot-config';
                const selectedShape = currentLevelConfig.dockShapes[i];
                
                slotDiv.innerHTML = `
                    <div style="font-weight: bold; margin-bottom: 3px;">Slot ${i + 1}</div>
                    <select onchange="updateDockShape(${i}, this.value)" style="width: 100%; background: rgba(0,0,0,0.3); color: white; border: 1px solid rgba(255,255,255,0.3); padding: 2px;">
                        <option value="square" ${selectedShape === 'square' ? 'selected' : ''}>Square</option>
                        <option value="triangle" ${selectedShape === 'triangle' ? 'selected' : ''}>Triangle</option>
                        <option value="circle" ${selectedShape === 'circle' ? 'selected' : ''}>Circle</option>
                        <option value="l" ${selectedShape === 'l' ? 'selected' : ''}>L-Shape</option>
                        <option value="cross" ${selectedShape === 'cross' ? 'selected' : ''}>Green Cross</option>
                        <option value="cross2" ${selectedShape === 'cross2' ? 'selected' : ''}>Pink Cross</option>
                        <option value="barbell-one" ${selectedShape === 'barbell-one' ? 'selected' : ''}>One-Ended Barbell</option>
                        <option value="barbell-two" ${selectedShape === 'barbell-two' ? 'selected' : ''}>Two-Ended Barbell</option>
                        <option value="diamond-barbell" ${selectedShape === 'diamond-barbell' ? 'selected' : ''}>Diamond Barbell</option>
                    </select>
                `;
                dockContainer.appendChild(slotDiv);
            }
            
            currentLevelConfig.dockSlots = slotCount;
            console.log('🎛️ Generated dock slots configuration:', slotCount);
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ UPDATE DOCK SHAPE
          ║ Updates a specific dock slot's shape assignment in the level configuration.
          ║ Called when user changes shape selection in design sidebar dropdown.
          ║ Parameters: slotIndex - Index of slot to update, shape - New shape type
          ╚═══════════════════════════════════════════════════════════════════════════*/
        function updateDockShape(slotIndex, shape) {
            if (slotIndex < currentLevelConfig.dockShapes.length) {
                currentLevelConfig.dockShapes[slotIndex] = shape;
                console.log(`🔄 Updated slot ${slotIndex + 1} to ${shape}`);
            }
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ UPDATE BARBELL ORIENTATION
          ║ Changes the barbell orientation in the dock (vertical vs horizontal).
          ║ Applies CSS classes to the docking area to control barbell display.
          ║ Called when user changes barbell orientation setting in design sidebar.
          ╚═══════════════════════════════════════════════════════════════════════════*/
        function updateBarbellOrientation() {
            const orientation = document.getElementById('barbellOrientation').value;
            currentLevelConfig.barbellOrientation = orientation;
            
            // Rebuild the dock to apply rotation changes to barbell previews
            rebuildGameDock();
            
            console.log(`🔄 Updated barbell orientation to ${orientation} - dock rebuilt with rotated previews`);
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ APPLY LEVEL CHANGES
          ║ Applies all design sidebar configuration changes to the active game.
          ║ Updates level info, timer settings, and rebuilds the dock layout.
          ║ Provides visual feedback to confirm changes were applied.
          ╚═══════════════════════════════════════════════════════════════════════════*/
        function applyLevelChanges() {
            // Save current configuration from sidebar
            const worldLevelValue = document.getElementById('levelNumber').value;
            const parts = worldLevelValue.split('-');
            currentLevelConfig.world = parseInt(parts[0]) || 1;
            currentLevelConfig.level = parseInt(parts[1]) || 1;
            currentLevelConfig.timerMode = document.getElementById('timerMode').value;
            currentLevelConfig.timerStart = parseInt(document.getElementById('timerStart').value);
            currentLevelConfig.endLevelDuration = parseInt(document.getElementById('endLevelDuration').value);
            
            // Update game UI
            updateGameUI();
            
            // Apply timer changes if countdown mode is selected
            if (currentLevelConfig.timerMode === 'countdown' && window.gameManager && window.gameManager.gameState) {
                const startTime = currentLevelConfig.timerStart || 60;
                window.gameManager.gameState.gameTime = startTime;
                
                // Update timer display
                const timerElement = document.getElementById('gameTimer');
                if (timerElement) {
                    const minutes = Math.floor(startTime / 60);
                    const seconds = startTime % 60;
                    timerElement.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                }
                
                console.log('⏳ Applied countdown timer start value:', startTime);
            }
            
            // Rebuild dock with new configuration
            rebuildGameDock();
            
            // Show feedback
            const btn = document.getElementById('applyChangesBtn');
            const originalText = btn.textContent;
            btn.textContent = 'Applied!';
            btn.style.background = 'linear-gradient(135deg, #27ae60 0%, #229954 100%)';
            setTimeout(() => {
                btn.textContent = originalText;
                btn.style.background = 'linear-gradient(135deg, #27ae60 0%, #229954 100%)';
            }, 1500);
            
            console.log('✅ Applied level changes:', currentLevelConfig);
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ UPDATE TIMER MODE CONFIG
          ║ Updates timer mode configuration when user changes dropdown in design sidebar.
          ║ Immediately applies the new timer mode to current level configuration and UI.
          ╚═══════════════════════════════════════════════════════════════════════════*/
        function updateTimerModeConfig() {
            // Update current level config with new timer mode
            const timerModeSelect = document.getElementById('timerMode');
            currentLevelConfig.timerMode = timerModeSelect.value;
            
            // Update game state if game manager exists
            if (window.gameManager && window.gameManager.gameState) {
                window.gameManager.gameState.timerMode = timerModeSelect.value;
                
                // Initialize timer based on mode
                if (timerModeSelect.value === 'countdown') {
                    // Set countdown timer to start value
                    const startTime = currentLevelConfig.timerStart || 60;
                    window.gameManager.gameState.gameTime = startTime;
                    
                    // Update timer display immediately
                    const timerElement = document.getElementById('gameTimer');
                    if (timerElement) {
                        const minutes = Math.floor(startTime / 60);
                        const seconds = startTime % 60;
                        timerElement.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                    }
                } else if (timerModeSelect.value === 'elapsed') {
                    // Reset to 0 for elapsed timer
                    window.gameManager.gameState.gameTime = 0;
                    
                    // Update timer display immediately
                    const timerElement = document.getElementById('gameTimer');
                    if (timerElement) {
                        timerElement.textContent = '0:00';
                    }
                }
            }
            
            // Update timer UI to reflect new mode
            const modeIndicator = document.getElementById('timerModeIndicator');
            if (modeIndicator && timerModeSelect.value === 'countdown') {
                modeIndicator.className = 'timer-mode-indicator timer-mode-countdown';
                modeIndicator.textContent = '⏳';
            } else if (modeIndicator && timerModeSelect.value === 'elapsed') {
                modeIndicator.className = 'timer-mode-indicator timer-mode-elapsed';
                modeIndicator.textContent = '⏱';
            } else if (modeIndicator && timerModeSelect.value === 'none') {
                modeIndicator.className = 'timer-mode-indicator timer-mode-elapsed';
                modeIndicator.textContent = '⚪';
            }
            
            console.log('🕒 Updated timer mode to:', timerModeSelect.value);
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ UPDATE GAME UI
          ║ Updates the game's UI elements to reflect current level configuration.
          ║ Updates level display and other HUD elements based on design settings.
          ╚═══════════════════════════════════════════════════════════════════════════*/
        function updateGameUI() {
            const levelDisplay = document.getElementById('levelDisplay');
            if (levelDisplay) {
                levelDisplay.textContent = `World ${currentLevelConfig.world}-${currentLevelConfig.level}`;
            }
            
            console.log(`🎮 Updated game UI for World ${currentLevelConfig.world}-${currentLevelConfig.level}`);
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ THEME CYCLING (GLOBAL WRAPPER) - SIMPLIFIED
          ║ Simple theme cycling that uses the existing dropdown functionality.
          ║ Just cycles through the dropdown options and triggers changeTheme().
          ╚═══════════════════════════════════════════════════════════════════════════*/
        function cycleThemes() {
            console.log('🎨 Theme cycling requested from HUD button');
            
            try {
                const themeSelector = document.getElementById('themeSelector');
                if (!themeSelector) {
                    console.error('❌ Theme selector not found');
                    return;
                }
                
                // Get all available options
                const options = Array.from(themeSelector.options);
                const currentIndex = themeSelector.selectedIndex;
                
                // Calculate next index (cycle back to 0 if at end)
                const nextIndex = (currentIndex + 1) % options.length;
                
                // Set the new value and trigger the change event
                themeSelector.selectedIndex = nextIndex;
                const newTheme = themeSelector.value;
                
                console.log(`🎨 Cycling to theme: ${newTheme}`);
                
                // Trigger the existing changeTheme function
                changeTheme();
                
            } catch (error) {
                console.error('❌ Failed to cycle themes:', error);
            }
        }
        
        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ RESET LEVEL (GLOBAL WRAPPER) - ENHANCED
          ║ Enhanced reset function that properly resets timer, restores shapes to dock,
          ║ and clears physics simulation. Handles both design mode and play mode resets.
          ╚═══════════════════════════════════════════════════════════════════════════*/
        function resetLevel() {
            console.log('🔄 Starting level reset...');
            
            // Clear all shapes from playfield
            if (window.gameManager && window.gameManager.physicsManager) {
                window.gameManager.physicsManager.clearAllShapes();
                console.log('🧹 Cleared physics shapes');
            }
            
            // Reset timer and game state
            if (window.gameManager && window.gameManager.gameState) {
                // Reset timer to 0:00
                window.gameManager.gameState.gameTime = 0;
                window.gameManager.gameState.endLevelTime = currentLevelConfig.endLevelDuration;
                
                // Apply current timer mode from config
                window.gameManager.gameState.timerMode = currentLevelConfig.timerMode || 'elapsed';
                
                // Update timer display
                const timerElement = document.getElementById('gameTimer');
                if (timerElement) {
                    if (currentLevelConfig.timerMode === 'countdown') {
                        // For countdown, start from configured start time
                        const startTime = currentLevelConfig.timerStart || 60;
                        window.gameManager.gameState.gameTime = startTime;
                        const minutes = Math.floor(startTime / 60);
                        const seconds = startTime % 60;
                        timerElement.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                    } else {
                        // For elapsed timer, start at 0:00
                        timerElement.textContent = '0:00';
                    }
                }
                
                // Update timer mode indicator based on current config
                const modeIndicator = document.getElementById('timerModeIndicator');
                if (modeIndicator) {
                    if (currentLevelConfig.timerMode === 'countdown') {
                        modeIndicator.className = 'timer-mode-indicator timer-mode-countdown';
                        modeIndicator.textContent = '⏳';
                    } else if (currentLevelConfig.timerMode === 'elapsed') {
                        modeIndicator.className = 'timer-mode-indicator timer-mode-elapsed';
                        modeIndicator.textContent = '⏱';
                    } else if (currentLevelConfig.timerMode === 'none') {
                        modeIndicator.className = 'timer-mode-indicator timer-mode-elapsed';
                        modeIndicator.textContent = '⚪';
                    }
                }
                
                console.log('⏰ Reset timer and game state with mode:', currentLevelConfig.timerMode);
            }
            
            // Rebuild dock with current configuration (preserves design mode settings)
            rebuildGameDock();
            
            // Force reinitialize drag and drop system after dock rebuild
            if (window.gameManager && window.gameManager.dragDropManager) {
                console.log('🔄 Drag and drop system already initialized');
                
                // Verify all shapes are interactive
                const dockShapes = document.querySelectorAll('.game-shape');
                console.log(`🎯 Found ${dockShapes.length} shapes after reset:`, 
                    Array.from(dockShapes).map(s => s.dataset.shape));
                    
                // Ensure all shapes are visible and interactive
                dockShapes.forEach(shape => {
                    shape.style.visibility = 'visible';
                    shape.classList.remove('dragging', 'ghost-active');
                });
            }
            
            // Reset additional game state elements
            if (window.gameManager) {
                // Reset shape counters
                if (window.gameManager.gameState) {
                    window.gameManager.gameState.shapesPlaced = 0;
                    window.gameManager.gameState.isGameActive = true;
                    window.gameManager.gameState.isLevelComplete = false;
                    window.gameManager.gameState.isGameOver = false;
                    
                    // Reset placed shapes array - this fixes the "placed" count not resetting
                    window.gameManager.gameState.placedShapes = [];
                    
                    // Fix #2: Reset score and coins to zero
                    window.gameManager.gameState.score = 0;
                    window.gameManager.gameState.coins = 0;
                    
                    // Update displays
                    document.getElementById('scoreText').textContent = '0';
                    document.getElementById('coinAmount').textContent = '0';
                }
                
                // Reset progress bar
                const progressBar = document.getElementById('starProgressBar');
                if (progressBar) {
                    progressBar.style.width = '0%';
                }
                
                // Reset stars
                document.querySelectorAll('.star').forEach(star => {
                    star.classList.remove('filled');
                });
                
                console.log('🎮 Reset game state elements including score and coins');
            }
            
            // Update debug info to reflect reset state
            if (window.gameManager && window.gameManager.updateDebugInfo) {
                window.gameManager.updateDebugInfo();
            }
            
            console.log('✅ Level reset completed');
        }

        // Global functions for HUD interactions
        function switchTimerMode() {
            console.log('🔄 Timer mode switch requested');
        }

        function initializeProgressBarInteraction() {
            console.log('⭐ Progress bar interaction');
        }

        function animateCoin() {
            console.log('💰 Coin animation triggered');
        }

        // Mobile Debug Toggle for Testing
        let mobileDebugMode = false;
        let originalMobileDetection = null;
        function toggleMobileDebug() {
            mobileDebugMode = !mobileDebugMode;
            const button = document.getElementById('mobileDebugButton');
            
            if (!window.gameManager?.mobileEnhancementManager) {
                console.log('❌ Mobile enhancement manager not found');
                console.log('Available gameManager properties:', Object.keys(window.gameManager || {}));
                return;
            }
            
            const mobileManager = window.gameManager.mobileEnhancementManager;
            
            if (mobileDebugMode) {
                // Store original detection result
                if (originalMobileDetection === null) {
                    originalMobileDetection = mobileManager.detectMobileDevice();
                }
                
                // Force mobile mode
                window.gameManager.dragDropManager.isMobileDevice = true;
                mobileManager.isMobileDevice = true;
                
                // Enable mouse support for testing on desktop
                mobileManager.enableMouseSupport();
                
                // Update rotation zone bounds and show zones
                mobileManager.updateRotationZoneBounds();
                mobileManager.showRotationZones();
                
                button.style.background = 'linear-gradient(135deg, #27ae60 0%, #2ecc71 100%)';
                button.title = 'Mobile Debug: ON (Click to disable)';
                console.log('📱 Mobile Debug Mode: ON - Rotation zones should be visible');
                console.log('📱 Rotation zones bounds:', {
                    left: mobileManager.rotationZones.left.bounds,
                    right: mobileManager.rotationZones.right.bounds
                });
            } else {
                // Restore original detection
                const originalDetection = originalMobileDetection || mobileManager.detectMobileDevice();
                window.gameManager.dragDropManager.isMobileDevice = originalDetection;
                mobileManager.isMobileDevice = originalDetection;
                
                // Disable mouse support
                mobileManager.disableMouseSupport();
                
                if (!originalDetection) {
                    mobileManager.hideRotationZones();
                }
                
                button.style.background = 'linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%)';
                button.title = 'Mobile Debug: OFF (Click to enable)';
                console.log('📱 Mobile Debug Mode: OFF');
            }
        }

        // Global level management functions (for console testing)
        function nextLevel() {
            if (window.gameManager) {
                window.gameManager.nextLevel();
            }
        }

        function nextWorld() {
            if (window.gameManager) {
                window.gameManager.nextWorld();
            }
        }

        function setLevel(world, level) {
            if (window.gameManager) {
                window.gameManager.setLevel(world, level);
            }
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ v9: CANVAS ENHANCEMENT THEME MANAGEMENT FUNCTIONS
          ║ User interface functions for theme switching and canvas configuration
          ╚═══════════════════════════════════════════════════════════════════════════*/

        // Theme switching function called from UI
        function changeTheme() {
            const themeSelector = document.getElementById('themeSelector');
            const selectedTheme = themeSelector.value;
            
            // Synchronize both dropdowns to use the same values
            const enhancedThemeSelect = document.getElementById('enhancedThemeSelect');
            if (enhancedThemeSelect) {
                enhancedThemeSelect.value = selectedTheme;
                // Apply the enhanced theme with texture loading
                applyEnhancedTheme();
            }
            
            if (window.gameManager && window.gameManager.themeManager) {
                // Material themes are free - no premium themes
                const isCurrentTheme = window.currentTheme && window.currentTheme.name === selectedTheme;
                
                if (!isCurrentTheme) {
                    // All material themes are free
                    const coinElement = document.getElementById('coinAmount');
                    window.gameManager.createFloatingText(`-${themeCost} Theme`, coinElement, '#FF6B6B');
                    window.gameManager.createFloatingText('🎨 PREMIUM!', coinElement, '#FFD700');
                    
                    console.log(`💰 Purchased premium theme "${selectedTheme}" for ${themeCost} coins`);
                } else if (!isCurrentTheme && themeCost > 0) {
                    // Not enough coins for premium theme
                    console.log(`❌ Need ${themeCost} coins for premium theme "${selectedTheme}"`);
                    const coinElement = document.getElementById('coinAmount');
                    window.gameManager.createFloatingText(`Need ${themeCost} coins!`, coinElement, '#FF6B6B');
                    window.gameManager.shakeElement(coinElement, 2);
                    return;
                }
                
                window.gameManager.themeManager.switchTheme(selectedTheme, true);
                console.log(`🎨 Theme changed to: ${selectedTheme}${themeCost > 0 ? ' (Premium)' : ''}`);
            }
        }

        // Toggle canvas enhancements on/off
        function toggleCanvasEnhancements() {
            const enableCanvas = document.getElementById('enableCanvas');
            CANVAS_CONFIG.enabled = enableCanvas.checked;
            
            console.log(`🎨 Canvas enhancements: ${CANVAS_CONFIG.enabled ? 'ON' : 'OFF'}`);
            
            // Apply change immediately
            if (window.gameManager) {
                if (CANVAS_CONFIG.enabled) {
                    // Re-initialize current theme
                    const currentTheme = window.gameManager.themeManager.getCurrentTheme();
                    window.gameManager.themeManager.switchTheme(currentTheme, false);
                } else {
                    // Reset to basic appearance
                    window.gameManager.physicsManager.backgroundGradient = null;
                }
            }
        }

        // Toggle particle effects
        function toggleParticleEffects() {
            const enableParticles = document.getElementById('enableParticles');
            CANVAS_CONFIG.useParticles = enableParticles.checked;
            
            console.log(`🎨 Particle effects: ${CANVAS_CONFIG.useParticles ? 'ON' : 'OFF'}`);
            
            if (!CANVAS_CONFIG.useParticles && window.gameManager) {
                // Clear existing particles
                window.gameManager.physicsManager.particleSystem.particles = [];
            }
        }

        // Touch offset configuration functions
        function toggleTouchOffset() {
            const enableTouchOffset = document.getElementById('enableTouchOffset');
            if (window.gameManager && window.gameManager.dragDropManager) {
                const currentOffset = window.gameManager.dragDropManager.getTouchOffset();
                window.gameManager.dragDropManager.setTouchOffset(
                    currentOffset.x, 
                    currentOffset.y, 
                    enableTouchOffset.checked
                );
                console.log(`📱 Touch offset: ${enableTouchOffset.checked ? 'ON' : 'OFF'}`);
            }
        }

        function updateTouchOffset() {
            const offsetX = parseInt(document.getElementById('touchOffsetX').value);
            const offsetY = parseInt(document.getElementById('touchOffsetY').value);
            const enabled = document.getElementById('enableTouchOffset').checked;
            
            if (window.gameManager && window.gameManager.dragDropManager) {
                window.gameManager.dragDropManager.setTouchOffset(offsetX, offsetY, enabled);
                updateTouchOffsetDisplay();
                console.log(`📱 Touch offset updated: X=${offsetX}px, Y=${offsetY}px`);
            }
        }

        function updateTouchOffsetDisplay() {
            const offsetX = document.getElementById('touchOffsetX').value;
            const offsetY = document.getElementById('touchOffsetY').value;
            
            document.getElementById('touchOffsetXValue').textContent = `${offsetX}px`;
            document.getElementById('touchOffsetYValue').textContent = `${offsetY}px`;
        }

        // Toggle shape animations  
        function toggleAnimations() {
            const enableAnimations = document.getElementById('enableAnimations');
            CANVAS_CONFIG.useAnimations = enableAnimations.checked;
            
            console.log(`🎨 Shape animations: ${CANVAS_CONFIG.useAnimations ? 'ON' : 'OFF'}`);
        }

        // Initialize theme selector UI state
        function initializeThemeUI() {
            // Set initial checkbox states
            document.getElementById('enableCanvas').checked = CANVAS_CONFIG.enabled;
            document.getElementById('enableParticles').checked = CANVAS_CONFIG.useParticles;
            document.getElementById('enableAnimations').checked = CANVAS_CONFIG.useAnimations;
            
            // Set initial theme
            document.getElementById('themeSelector').value = CANVAS_CONFIG.defaultTheme;
            
            console.log('🎨 Theme UI initialized');
        }

        // Test function to cycle through all themes (for development)
        function testAllThemes() {
            if (!window.gameManager) return;
            
            const themes = Object.keys(THEME_DEFINITIONS);
            let currentIndex = 0;
            
            const cycleTheme = () => {
                const theme = themes[currentIndex];
                window.gameManager.themeManager.switchTheme(theme, true);
                document.getElementById('themeSelector').value = theme;
                
                console.log(`🎨 Testing theme: ${theme}`);
                
                currentIndex = (currentIndex + 1) % themes.length;
                
                if (currentIndex !== 0) {
                    setTimeout(cycleTheme, 3000); // Change every 3 seconds
                }
            };
            
            cycleTheme();
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ PIXIJS CONTROL FUNCTIONS - PHASE 1
          ║ UI controls for PixiJS system configuration and testing
          ╚═══════════════════════════════════════════════════════════════════════════*/
        
        // Toggle PixiJS system on/off
        function togglePixiSystem() {
            const enablePixi = document.getElementById('enablePixi');
            PIXI_CONFIG.enabled = enablePixi.checked;
            
            console.log(`🎨 PixiJS system: ${PIXI_CONFIG.enabled ? 'ON' : 'OFF'}`);
            
            // Apply change immediately if game is running
            if (window.gameManager && window.gameManager.physicsManager.rendererManager) {
                if (PIXI_CONFIG.enabled) {
                    // Try to switch to PixiJS if available
                    window.gameManager.physicsManager.rendererManager.autoSelectRenderer();
                } else {
                    // Force Canvas mode
                    window.gameManager.physicsManager.rendererManager.switchRenderer('canvas');
                }
                
                // Update renderer selector
                const rendererSelect = document.getElementById('rendererSelect');
                const currentRenderer = window.gameManager.physicsManager.rendererManager.getCurrentRenderer();
                rendererSelect.value = PIXI_CONFIG.enabled ? PIXI_CONFIG.renderer : 'canvas';
            }
        }

        // Switch renderer based on selection
        function switchRenderer() {
            const rendererSelect = document.getElementById('rendererSelect');
            const selectedRenderer = rendererSelect.value;
            
            if (!window.gameManager || !window.gameManager.physicsManager.rendererManager) {
                console.warn('⚠️ Game not initialized yet');
                return;
            }
            
            const rendererManager = window.gameManager.physicsManager.rendererManager;
            
            // Update PixiJS configuration
            PIXI_CONFIG.renderer = selectedRenderer;
            
            // Switch renderer
            let success = false;
            if (selectedRenderer === 'auto') {
                success = rendererManager.autoSelectRenderer();
            } else {
                success = rendererManager.switchRenderer(selectedRenderer);
            }
            
            if (success) {
                const currentRenderer = rendererManager.getCurrentRenderer();
                console.log(`✅ Switched to: ${currentRenderer.toUpperCase()}`);
                
                // Update PixiJS enable checkbox based on result
                const enablePixi = document.getElementById('enablePixi');
                enablePixi.checked = currentRenderer === 'pixi' || PIXI_CONFIG.enabled;
            } else {
                console.warn('⚠️ Renderer switch failed');
            }
        }

        // Toggle PixiJS debug mode
        function togglePixiDebug() {
            const pixiDebug = document.getElementById('pixiDebug');
            PIXI_CONFIG.debug.enabled = pixiDebug.checked;
            
            console.log(`🔍 PixiJS debug mode: ${PIXI_CONFIG.debug.enabled ? 'ON' : 'OFF'}`);
            
            // Show additional debug info when enabled
            if (PIXI_CONFIG.debug.enabled && window.gameManager) {
                showRendererInfo();
            }
        }

        // Toggle PixiJS FPS counter
        function togglePixiFPS() {
            const pixiShowFPS = document.getElementById('pixiShowFPS');
            PIXI_CONFIG.debug.showFPS = pixiShowFPS.checked;
            
            console.log(`📊 PixiJS FPS counter: ${PIXI_CONFIG.debug.showFPS ? 'ON' : 'OFF'}`);
            
            // TODO: Phase 3 - Implement FPS counter display
        }

        // Toggle PixiJS shape rendering (Phase 2)
        function togglePixiShapeRendering() {
            const enablePixiShapes = document.getElementById('enablePixiShapes');
            PIXI_CONFIG.features.shapeRendering = enablePixiShapes.checked;
            
            console.log(`🎨 PixiJS shape rendering: ${PIXI_CONFIG.features.shapeRendering ? 'ON' : 'OFF'}`);
            
            if (!window.gameManager || !window.gameManager.physicsManager.pixiShapeRenderer) {
                console.warn('⚠️ Game not initialized yet');
                return;
            }
            
            const pixiShapeRenderer = window.gameManager.physicsManager.pixiShapeRenderer;
            const rendererManager = window.gameManager.physicsManager.rendererManager;
            
            if (PIXI_CONFIG.features.shapeRendering) {
                // Enable PixiJS shape rendering - auto-enable PixiJS if needed
                if (!rendererManager.isPixiActive()) {
                    console.log('🔄 Enabling PixiJS system for shape rendering...');
                    
                    // Auto-enable PixiJS system
                    PIXI_CONFIG.enabled = true;
                    const enablePixi = document.getElementById('enablePixi');
                    if (enablePixi) enablePixi.checked = true;
                    
                    // Switch to PixiJS renderer
                    const switchSuccess = rendererManager.switchRenderer('pixi');
                    if (!switchSuccess) {
                        console.error('❌ Failed to activate PixiJS - shape rendering unavailable');
                        enablePixiShapes.checked = false;
                        PIXI_CONFIG.features.shapeRendering = false;
                        return;
                    }
                }
                
                // Now enable PixiJS shape rendering
                const success = pixiShapeRenderer.enable();
                if (success) {
                    console.log('✅ PixiJS shape rendering enabled');
                    
                    // Recreate existing shapes in PixiJS
                    const dynamicBodies = window.gameManager.physicsManager.dynamicBodies;
                    dynamicBodies.forEach(body => {
                        if (body.userData && body.userData.shapeType) {
                            pixiShapeRenderer.createShape(body, body.userData.shapeType);
                        }
                    });
                    
                    console.log(`🎨 Recreated ${dynamicBodies.length} shapes in PixiJS`);
                } else {
                    console.error('❌ Failed to enable PixiJS shape rendering');
                    enablePixiShapes.checked = false;
                    PIXI_CONFIG.features.shapeRendering = false;
                }
            } else {
                // Disable PixiJS shape rendering
                pixiShapeRenderer.disable();
                console.log('🔄 PixiJS shape rendering disabled');
            }
        }

        // Phase 3: Toggle PixiJS Animations
        function togglePixiAnimations() {
            const enablePixiAnimations = document.getElementById('enablePixiAnimations');
            PIXI_CONFIG.animations.enabled = enablePixiAnimations.checked;
            
            console.log(`🎬 PixiJS animations: ${PIXI_CONFIG.animations.enabled ? 'ON' : 'OFF'}`);
            
            // Apply to animation manager if available
            if (window.gameManager && window.gameManager.physicsManager.rendererManager.pixiManager.animationManager) {
                const animationManager = window.gameManager.physicsManager.rendererManager.pixiManager.animationManager;
                
                if (PIXI_CONFIG.animations.enabled) {
                    animationManager.enable();
                } else {
                    animationManager.disable();
                }
            }
        }

        // Initialize and synchronize both theme dropdowns
        function initializeThemeSync() {
            const visualThemeSelect = document.getElementById('themeSelector');
            const enhancedThemeSelect = document.getElementById('enhancedThemeSelect');
            
            if (visualThemeSelect && enhancedThemeSelect) {
                // Ensure both dropdowns have the same default value
                const defaultTheme = 'classic';
                visualThemeSelect.value = defaultTheme;
                enhancedThemeSelect.value = defaultTheme;
                
                console.log(`🔄 Initialized both theme dropdowns to: ${defaultTheme}`);
            }
            
            // Initialize theme button icon
            console.log('🎨 Theme button initialized');
        }

        // Unified theme change handler
        function handleThemeChange(selectedTheme, source = 'visual') {
            console.log(`🎨 Theme change requested: ${selectedTheme} from ${source} dropdown`);
            
            // Clear previous theme textures globally before applying new theme
            clearPreviousThemeTextures();
            
            // Apply theme colors to SHAPE_CONFIG for proper fallback colors
            applyThemeColorsToShapeConfig(selectedTheme);
            
            const visualThemeSelect = document.getElementById('themeSelector');
            const enhancedThemeSelect = document.getElementById('enhancedThemeSelect');
            
            // Synchronize both dropdowns
            if (visualThemeSelect && visualThemeSelect.value !== selectedTheme) {
                visualThemeSelect.value = selectedTheme;
            }
            if (enhancedThemeSelect && enhancedThemeSelect.value !== selectedTheme) {
                enhancedThemeSelect.value = selectedTheme;
            }
            
            // Apply the theme changes first (background, platform colors)
            if (window.gameManager && window.gameManager.themeManager) {
                window.gameManager.themeManager.switchTheme(selectedTheme, true);
                console.log(`🎨 Applied visual theme: ${selectedTheme}`);
            }
            
            // Apply enhanced theme with textures
            applyMaterialTheme(selectedTheme);
        }
        
        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ CLEAR PREVIOUS THEME TEXTURES - GLOBAL TEXTURE UNLOADING
          ║ Clears all texture data from previous themes to prevent texture persistence.
          ║ This ensures clean transitions between all themes (Wood→Stone, Metal→Classic, etc.)
          ╚═══════════════════════════════════════════════════════════════════════════*/
        function clearPreviousThemeTextures() {
            console.log('🧹 Clearing previous theme textures globally');
            
            try {
                // Clear window.currentTheme texture data
                if (window.currentTheme) {
                    if (window.currentTheme.shapes && window.currentTheme.shapes.textures) {
                        delete window.currentTheme.shapes.textures;
                        console.log('🧹 Cleared window.currentTheme.shapes.textures');
                    }
                    if (window.currentTheme.background && window.currentTheme.background.image) {
                        delete window.currentTheme.background.image;
                        console.log('🧹 Cleared window.currentTheme.background.image');
                    }
                    if (window.currentTheme.platform && window.currentTheme.platform.image) {
                        delete window.currentTheme.platform.image;
                        console.log('🧹 Cleared window.currentTheme.platform.image');
                    }
                }
                
                // Clear textureManager loaded textures
                if (window.textureManager && window.textureManager.loadedTextures.size > 0) {
                    console.log(`🧹 Clearing ${window.textureManager.loadedTextures.size} loaded textures from textureManager`);
                    window.textureManager.loadedTextures.clear();
                    
                    // Clear texture references from SHAPE_CONFIG
                    Object.keys(SHAPE_CONFIG).forEach(shapeType => {
                        if (SHAPE_CONFIG[shapeType].texture) {
                            delete SHAPE_CONFIG[shapeType].texture;
                        }
                    });
                    console.log('🧹 Cleared texture references from SHAPE_CONFIG');
                }
                
                console.log('✅ Previous theme textures cleared successfully');
                
            } catch (error) {
                console.error('❌ Error clearing previous theme textures:', error);
            }
        }
        
        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ APPLY THEME COLORS TO SHAPE CONFIG
          ║ Applies the appropriate theme colors to SHAPE_CONFIG after texture clearing.
          ║ Ensures shapes show correct fallback colors for each theme.
          ╚═══════════════════════════════════════════════════════════════════════════*/
        function applyThemeColorsToShapeConfig(themeName) {
            console.log(`🎨 Applying ${themeName} theme colors to SHAPE_CONFIG`);
            
            try {
                // Define theme-specific color palettes
                const themeColors = {
                    classic: {
                        square: { color: '#F39C12', stroke: '#E67E22' },
                        triangle: { color: '#9B59B6', stroke: '#8E44AD' },
                        circle: { color: '#1ABC9C', stroke: '#16A085' },
                        cross2: { color: '#3498DB', stroke: '#2980B9' },
                        l: { color: '#8E44AD', stroke: '#732D91' },
                        cross: { color: '#E74C3C', stroke: '#C0392B' },
                        'barbell-one': { color: '#16A085', stroke: '#138D75' },
                        'barbell-two': { color: '#D35400', stroke: '#BA4A00' },
                        'diamond-barbell': { color: '#C0392B', stroke: '#A93226' }
                    },
                    stone: {
                        square: { color: '#708090', stroke: '#2F4F4F' },
                        triangle: { color: '#696969', stroke: '#708090' },
                        circle: { color: '#778899', stroke: '#2F4F4F' },
                        cross2: { color: '#D3D3D3', stroke: '#708090' },
                        l: { color: '#696969', stroke: '#2F4F4F' },
                        cross: { color: '#708090', stroke: '#2F4F4F' },
                        'barbell-one': { color: '#778899', stroke: '#696969' },
                        'barbell-two': { color: '#D3D3D3', stroke: '#708090' },
                        'diamond-barbell': { color: '#2F4F4F', stroke: '#708090' }
                    },
                    metal: {
                        square: { color: '#696969', stroke: '#C0C0C0' },
                        triangle: { color: '#808080', stroke: '#696969' },
                        circle: { color: '#A9A9A9', stroke: '#C0C0C0' },
                        cross2: { color: '#778899', stroke: '#696969' },
                        l: { color: '#C0C0C0', stroke: '#808080' },
                        cross: { color: '#696969', stroke: '#C0C0C0' },
                        'barbell-one': { color: '#A9A9A9', stroke: '#778899' },
                        'barbell-two': { color: '#808080', stroke: '#696969' },
                        'diamond-barbell': { color: '#C0C0C0', stroke: '#A9A9A9' }
                    },
                    wood: {
                        square: { color: '#D2691E', stroke: '#8B4513' },
                        triangle: { color: '#CD853F', stroke: '#A0522D' },
                        circle: { color: '#DEB887', stroke: '#D2691E' },
                        cross2: { color: '#F4A460', stroke: '#CD853F' },
                        l: { color: '#8B4513', stroke: '#A0522D' },
                        cross: { color: '#CD7F32', stroke: '#DAA520' },
                        'barbell-one': { color: '#D2691E', stroke: '#8B4513' },
                        'barbell-two': { color: '#CD853F', stroke: '#A0522D' },
                        'diamond-barbell': { color: '#DAA520', stroke: '#B8860B' }
                    }
                };
                
                const colors = themeColors[themeName] || themeColors.classic;
                
                // Apply colors to SHAPE_CONFIG
                Object.keys(colors).forEach(shapeType => {
                    if (SHAPE_CONFIG[shapeType]) {
                        SHAPE_CONFIG[shapeType].color = colors[shapeType].color;
                        SHAPE_CONFIG[shapeType].stroke = colors[shapeType].stroke;
                    }
                });
                
                console.log(`✅ Applied ${themeName} theme colors to ${Object.keys(colors).length} shapes`);
                
            } catch (error) {
                console.error(`❌ Error applying ${themeName} theme colors:`, error);
            }
        }

        // Updated changeTheme function
        function changeTheme() {
            const themeSelector = document.getElementById('themeSelector');
            const selectedTheme = themeSelector.value;
            handleThemeChange(selectedTheme, 'visual');
        }

        // Updated applyEnhancedTheme function  
        function applyEnhancedTheme() {
            const enhancedThemeSelect = document.getElementById('enhancedThemeSelect');
            const selectedTheme = enhancedThemeSelect.value;
            handleThemeChange(selectedTheme, 'enhanced');
        }

        // Material theme application with texture loading
        function applyMaterialTheme(selectedTheme) {
            console.log(`🎨 Applying material theme: ${selectedTheme}`);
            
            // Initialize window.currentTheme if not exists
            if (!window.currentTheme) {
                window.currentTheme = {
                    name: selectedTheme,
                    shapes: {},
                    platform: {},
                    background: {}
                };
            }
            window.currentTheme.name = selectedTheme;
            
            // Handle classic theme separately
            if (selectedTheme === 'classic') {
                // Apply classic visual theme
                if (window.gameManager && window.gameManager.themeManager) {
                    window.gameManager.themeManager.switchTheme('classic', true);
                    console.log(`🎨 Applied classic visual theme`);
                }
                
                // Apply classic enhanced theme if available
                if (window.gameManager && window.gameManager.physicsManager.rendererManager.pixiManager.themeManager) {
                    const themeManager = window.gameManager.physicsManager.rendererManager.pixiManager.themeManager;
                    if (themeManager.switchTheme) {
                        themeManager.switchTheme('classic');
                        console.log(`🎨 Applied classic enhanced theme`);
                    }
                }
                return;
            }
            
            // For material themes (wood, stone, metal), add delay to ensure visual theme loads first
            setTimeout(() => {
                if (window.textureManager) {
                    console.log(`🖼️ Loading textures for ${selectedTheme} theme (after visual theme)`);
                    window.textureManager.applyTextureTheme(selectedTheme).then(() => {
                        console.log(`✅ Textures loaded for ${selectedTheme} theme`);
                        
                        // Apply enhanced theme with textures AFTER visual theme is done
                        if (window.gameManager && window.gameManager.physicsManager.rendererManager.pixiManager.themeManager) {
                            const themeManager = window.gameManager.physicsManager.rendererManager.pixiManager.themeManager;
                            if (themeManager.switchTheme) {
                                themeManager.switchTheme(selectedTheme);
                                console.log(`🎨 Applied ${selectedTheme} enhanced theme with textures (final step)`);
                            }
                        }
                        
                        // Refresh dock to show textures immediately
                        if (window.gameManager && window.gameManager.dockManager) {
                            window.gameManager.dockManager.refreshDock();
                            console.log(`🔄 Refreshed dock with ${selectedTheme} textures (final step)`);
                        }
                    }).catch(error => {
                        console.error(`❌ Error loading ${selectedTheme} textures:`, error);
                    });
                } else {
                    console.warn(`⚠️ TextureManager not available for ${selectedTheme} theme`);
                }
            }, 200); // Delay to ensure visual theme completes first
        }

        // Initialize theme synchronization on page load
        document.addEventListener('DOMContentLoaded', function() {
            initializeThemeSync();
        });
        // Initialize PixiJS control states
        function initializePixiControls() {
            try {
                // Set initial control states based on configuration
                document.getElementById('enablePixi').checked = PIXI_CONFIG.enabled;
                document.getElementById('enablePixiShapes').checked = PIXI_CONFIG.features.shapeRendering;
                document.getElementById('rendererSelect').value = PIXI_CONFIG.renderer;
                document.getElementById('pixiDebug').checked = PIXI_CONFIG.debug.enabled;
                document.getElementById('pixiShowFPS').checked = PIXI_CONFIG.debug.showFPS;
                
                // Phase 3: Initialize animation controls
                document.getElementById('enablePixiAnimations').checked = PIXI_CONFIG.animations.enabled;
                document.getElementById('enhancedThemeSelect').value = 'classic';
                
                console.log('✅ PixiJS control states initialized (Phase 3)');
            } catch (error) {
                console.error('❌ Failed to initialize PixiJS controls:', error);
            }
        }

        // Test particle effects manually
        function testParticles() {
            if (!window.gameManager || !window.gameManager.physicsManager) {
                console.log('❌ Game not initialized yet');
                return;
            }
            
            const particleSystem = window.gameManager.physicsManager.particleSystem;
            const canvas = window.gameManager.physicsManager.canvas;
            
            console.log('🎆 Creating test particle burst!');
            
            // Create a big burst in the center of the canvas
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            particleSystem.createThemeParticles('test', centerX, centerY, 20);
            
            // Create smaller bursts around the edges
            setTimeout(() => {
                particleSystem.createThemeParticles('test', 100, 100, 10);
                particleSystem.createThemeParticles('test', canvas.width - 100, 100, 10);
                particleSystem.createThemeParticles('test', centerX, canvas.height - 100, 10);
            }, 500);
            
            console.log(`🎆 Created particle test burst! Current particle count: ${particleSystem.particles.length}`);
        }

        // =============================================================================
        // DYNAMIC COIN BONUS SYSTEM
        // =============================================================================

        function startCoinBonusSystem() {
            // Random coin bonuses every 15-30 seconds
            setInterval(() => {
                if (!gameManager || !gameManager.gameState.isGameActive) return;
                
                const randomEvent = Math.random();
                const coinElement = document.getElementById('coinAmount');
                
                if (randomEvent < 0.3) { // 30% chance
                    // Small bonus coins
                    const bonus = Math.floor(Math.random() * 3) + 1; // 1-3 coins
                    gameManager.gameState.coins += bonus;
                    gameManager.updateCoinDisplay();
                    gameManager.createFloatingText(`🎁 +${bonus}`, coinElement, '#32CD32');
                    console.log(`🎁 Random coin bonus: +${bonus}`);
                    
                } else if (randomEvent < 0.35) { // 5% chance
                    // Medium jackpot
                    const jackpot = Math.floor(Math.random() * 8) + 5; // 5-12 coins
                    gameManager.gameState.coins += jackpot;
                    gameManager.updateCoinDisplay();
                    gameManager.createCoinShower('LUCKY BONUS!', jackpot);
                    console.log(`🍀 Lucky bonus: +${jackpot} coins`);
                    
                } else if (randomEvent < 0.37) { // 2% chance  
                    // Big jackpot
                    const megaJackpot = Math.floor(Math.random() * 15) + 10; // 10-24 coins
                    gameManager.gameState.coins += megaJackpot;
                    gameManager.updateCoinDisplay();
                    gameManager.createCoinShower('MEGA JACKPOT!', megaJackpot);
                    gameManager.pulseElement(coinElement, 5);
                    console.log(`💎 MEGA JACKPOT: +${megaJackpot} coins`);
                }
            }, Math.random() * 15000 + 15000); // Every 15-30 seconds
            
            // Stability bonus system - rewards for keeping shapes stable
            setInterval(() => {
                if (!gameManager || !gameManager.gameState.isGameActive) return;
                if (gameManager.gameState.placedShapes.length === 0) return;
                
                // Check if shapes haven't fallen recently
                const timeSinceLastFall = Date.now() - (gameManager.gameState.lastFallTime || 0);
                if (timeSinceLastFall > 30000) { // 30 seconds of stability
                    const stabilityBonus = Math.floor(Math.random() * 4) + 2; // 2-5 coins
                    gameManager.gameState.coins += stabilityBonus;
                    gameManager.updateCoinDisplay();
                    
                    const coinElement = document.getElementById('coinAmount');
                    gameManager.createFloatingText(`⚖️ STABLE +${stabilityBonus}`, coinElement, '#4ECDC4');
                    console.log(`⚖️ Stability bonus: +${stabilityBonus} coins`);
                }
            }, 30000); // Check every 30 seconds
            
            console.log('🎰 Dynamic coin bonus system activated!');
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ V14 UNIFIED CLASSES - Phase 1 Implementation
          ║ These classes implement the unified PixiJS system while preserving
          ║ all existing functionality and UI components
          ╚═══════════════════════════════════════════════════════════════════════════*/

        /**
         * V14 Unified Shape Renderer - Centralized rendering system
         * Handles both Canvas2D fallback and PixiJS rendering seamlessly
         */
        class UnifiedShapeRenderer {
            constructor() {
                this.config = UNIFIED_GAME_CONFIG;
                this.themeManager = null;
                this.textureManager = null;
                this.pixiManager = null;
                
                console.log('🎨 UnifiedShapeRenderer: Initializing with config:', this.config);
            }
            
            async initialize() {
                try {
                    console.log('🚀 UnifiedShapeRenderer: Starting initialization');
                    
                    // Initialize texture manager first
                    this.textureManager = new UnifiedTextureManager();
                    await this.textureManager.initialize();
                    
                    // Initialize PixiJS manager
                    this.pixiManager = new UnifiedPixiManager();
                    await this.pixiManager.initialize();
                    
                    // V14: Connect with existing ThemeManager if available
                    if (typeof window.themeManager !== 'undefined') {
                        this.themeManager = window.themeManager;
                        console.log('🎨 UnifiedShapeRenderer: Connected to existing ThemeManager');
                    } else {
                        console.log('🎨 UnifiedShapeRenderer: No existing ThemeManager found');
                    }
                    
                    console.log('✅ UnifiedShapeRenderer: Initialization complete');
                    return true;
                } catch (error) {
                    console.error('❌ UnifiedShapeRenderer: Initialization failed:', error);
                    return false;
                }
            }
            
            renderShape(shapeType, x, y, rotation = 0, scale = 1, context = null) {
                // Use existing Canvas2D rendering for compatibility
                if (context && typeof window.renderShapeOnCanvas === 'function') {
                    return window.renderShapeOnCanvas(context, shapeType, x, y, rotation, scale);
                }
                
                console.log(`🎨 UnifiedShapeRenderer: Rendering ${shapeType} at (${x}, ${y})`);
                return true;
            }
        }

        /**
         * V14 Unified Texture Manager - Centralized texture handling
         */
        class UnifiedTextureManager {
            constructor() {
                this.textureCache = new Map();
                this.loadingQueue = new Map();
                this.isInitialized = false;
                
                console.log('🖼️ UnifiedTextureManager: Created');
            }
            
            async initialize() {
                console.log('🖼️ UnifiedTextureManager: Initializing');
                this.isInitialized = true;
                return true;
            }
            
            async loadTexture(url) {
                if (this.textureCache.has(url)) {
                    return this.textureCache.get(url);
                }
                
                try {
                    const texture = await this.loadTextureFromURL(url);
                    this.textureCache.set(url, texture);
                    return texture;
                } catch (error) {
                    console.error(`❌ Failed to load texture: ${url}`, error);
                    return null;
                }
            }
            
            async loadTextureFromURL(url) {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    img.onload = () => resolve(img);
                    img.onerror = () => reject(new Error(`Failed to load ${url}`));
                    img.src = url;
                });
            }
            
            clearTextureCache() {
                console.log('🧹 UnifiedTextureManager: Clearing all texture cache');
                this.textureCache.clear();
                this.loadingQueue.clear();
            }
            
            clearThemeTextures(themeName) {
                console.log(`🧹 UnifiedTextureManager: Clearing textures for theme: ${themeName}`);
                
                // Create a list of texture URLs that belong to this theme
                const themeConfig = THEME_DEFINITIONS[themeName];
                if (!themeConfig) return;
                
                const themeUrls = new Set();
                
                // Add background image URL
                if (themeConfig.background?.image?.url) {
                    themeUrls.add(themeConfig.background.image.url);
                }
                
                // Add platform image URL
                if (themeConfig.platform?.image?.url) {
                    themeUrls.add(themeConfig.platform.image.url);
                }
                
                // Add shape texture URLs
                if (themeConfig.shapes?.textures) {
                    Object.values(themeConfig.shapes.textures).forEach(textureData => {
                        if (textureData?.url) {
                            themeUrls.add(textureData.url);
                        }
                    });
                }
                
                // Remove theme textures from cache
                let removedCount = 0;
                for (const url of themeUrls) {
                    if (this.textureCache.has(url)) {
                        this.textureCache.delete(url);
                        removedCount++;
                    }
                    if (this.loadingQueue.has(url)) {
                        this.loadingQueue.delete(url);
                    }
                }
                
                console.log(`🧹 UnifiedTextureManager: Removed ${removedCount} textures for theme: ${themeName}`);
            }
        }

        /**
         * V14 Unified PixiJS Manager - Handles PixiJS application lifecycle
         */
        class UnifiedPixiManager {
            constructor() {
                this.app = null;
                this.isInitialized = false;
                this.config = UNIFIED_GAME_CONFIG.renderer;
                this.features = UNIFIED_GAME_CONFIG.features;
                
                console.log('⚡ UnifiedPixiManager: Created with config:', this.config);
                console.log('🎯 UnifiedPixiManager: Always-on features:', this.features);
            }
            
            async initialize() {
                try {
                    console.log('⚡ UnifiedPixiManager: Initializing PixiJS application');
                    console.log('🚀 Phase 1: PixiJS Consolidation - Creating unified application');
                    
                    // Create PixiJS application with unified config
                    this.app = new PIXI.Application({
                        width: this.config.width,
                        height: this.config.height,
                        antialias: this.config.antialias,
                        transparent: this.config.transparent,
                        resolution: this.config.resolution,
                        autoDensity: this.config.autoDensity,
                        powerPreference: this.config.powerPreference,
                        backgroundColor: this.config.backgroundColor
                    });
                    
                    // Initialize always-on features
                    this.initializeAlwaysOnFeatures();
                    
                    this.isInitialized = true;
                    console.log('✅ UnifiedPixiManager: PixiJS application created successfully');
                    console.log('🎯 Phase 1 Complete: Always-on features initialized');
                    return true;
                    
                } catch (error) {
                    console.error('❌ UnifiedPixiManager: Failed to initialize PixiJS:', error);
                    console.log('🔄 Falling back to Canvas2D rendering');
                    return false;
                }
            }
            
            // V14 Phase 1: Initialize always-on features (no toggles)
            initializeAlwaysOnFeatures() {
                console.log('🎯 Initializing always-on features (V14 Phase 1):');
                console.log('   ✅ Shape Animations:', this.features.shapeAnimations);
                console.log('   ✅ Particle Effects:', this.features.particleEffects);
                console.log('   ✅ Advanced Graphics:', this.features.advancedGraphics);
                console.log('   ✅ Theme Textures:', this.features.themeTextures);
                console.log('   ✅ Smooth Transitions:', this.features.smoothTransitions);
                console.log('   ✅ Camera Shake:', this.features.cameraShake);
                console.log('   ✅ Enhanced Text:', this.features.enhancedText);
                console.log('   ✅ Tweening:', this.features.tweening);
                
                // Features are always enabled in V14 - no configuration complexity
                this.featuresReady = true;
            }
            
            getApplication() {
                return this.app;
            }
            
            isReady() {
                return this.isInitialized && this.app !== null;
            }
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ V14 TESTING AND DEBUG FUNCTIONS
          ║ Console functions for testing the unified system
          ╚═══════════════════════════════════════════════════════════════════════════*/
        
        // V14 testing functions available in browser console
        window.testUnifiedRenderer = function() {
            console.log('🧪 Testing V14 Unified Renderer System');
            console.log('📊 UNIFIED_GAME_CONFIG:', UNIFIED_GAME_CONFIG);
            
            if (window.unifiedRenderer) {
                console.log('✅ UnifiedShapeRenderer:', window.unifiedRenderer);
                console.log('🎨 Texture Manager:', window.unifiedRenderer.textureManager);
                console.log('⚡ PixiJS Manager:', window.unifiedRenderer.pixiManager);
            } else {
                console.log('❌ UnifiedShapeRenderer not initialized');
            }
        };
        
        window.showUnifiedConfig = function() {
            console.log('📋 V14 Unified Configuration:');
            console.table(UNIFIED_GAME_CONFIG);
        };
        
        window.v14Status = function() {
            console.log('🎮 V14 Status Report:');
            console.log('🔧 Unified Config Available:', typeof UNIFIED_GAME_CONFIG !== 'undefined');
            console.log('🎨 Unified Renderer Available:', typeof window.unifiedRenderer !== 'undefined');
            console.log('🖼️ Legacy Canvas Config Preserved:', typeof CANVAS_CONFIG !== 'undefined');
            console.log('⚡ Legacy PixiJS Config Preserved:', typeof PIXI_CONFIG !== 'undefined');
            console.log('🎯 Phase 1 Goal: PixiJS Consolidation - IMPLEMENTED');
        };
        
        // V14 Checkpoint 3: Enhanced Theme Integration Testing
        window.testThemeIntegration = function() {
            console.log('🎨 Testing V14 Theme Integration (Checkpoint 3)');
            
            // Test ThemeManager compatibility
            if (window.themeManager) {
                console.log('✅ Legacy ThemeManager available:', window.themeManager);
                console.log('🔧 Uses unified config:', window.themeManager.useUnifiedConfig);
                console.log('🎨 Current theme:', window.themeManager.currentTheme);
                console.log('⚙️ Theme system enabled:', window.themeManager.isThemeSystemEnabled());
            } else {
                console.log('❌ ThemeManager not available');
            }
            
            // Test unified renderer theme connection
            if (window.unifiedRenderer && window.unifiedRenderer.themeManager) {
                console.log('✅ Unified renderer connected to ThemeManager');
            } else {
                console.log('⚠️ Unified renderer not connected to ThemeManager');
            }
        };
        
        window.testCompatibilityMode = function() {
            console.log('🔄 Testing V14 Compatibility Mode');
            console.log('📊 Configuration Comparison:');
            
            if (typeof UNIFIED_GAME_CONFIG !== 'undefined') {
                console.log('🆕 V14 Default Theme:', UNIFIED_GAME_CONFIG.theme?.defaultTheme);
                console.log('🆕 V14 Theme Enabled:', UNIFIED_GAME_CONFIG.theme?.enabled);
            }
            
            console.log('🔧 Legacy Default Theme:', CANVAS_CONFIG.defaultTheme);
            console.log('🔧 Legacy Theme Enabled:', CANVAS_CONFIG.enabled && CANVAS_CONFIG.useThemes);
            
            // Test theme manager resolution
            if (window.themeManager) {
                console.log('🎯 ThemeManager Resolution:');
                console.log('   Default Theme:', window.themeManager.getDefaultTheme());
                console.log('   System Enabled:', window.themeManager.isThemeSystemEnabled());
            }
        };
        
        window.v14Phase1Status = function() {
            console.log('🚀 V14 Phase 1 Implementation Status:');
            console.log('');
            console.log('✅ CHECKPOINT 1: Basic Structure - COMPLETE');
            console.log('✅ CHECKPOINT 2: Unified Classes - COMPLETE');
            console.log('✅ CHECKPOINT 3: Enhanced ThemeManager Integration - COMPLETE');
            console.log('✅ CHECKPOINT 4: Phase 1 Completion - COMPLETE');
            console.log('');
            console.log('🎯 Phase 1 Goals Achieved:');
            console.log('   ✅ Remove Configuration Complexity - Unified config implemented');
            console.log('   ✅ Always-On Feature System - Features enabled by default');
            console.log('   ✅ Single Unified Renderer - PixiJS consolidation complete');
            console.log('');
            console.log('🧪 Available Tests:');
            console.log('   testUnifiedRenderer() - Test core unified system');
            console.log('   testThemeIntegration() - Test theme system integration');
            console.log('   testCompatibilityMode() - Test legacy compatibility');
            console.log('   testPhase1Features() - Test always-on features');
            console.log('   showUnifiedConfig() - Show V14 configuration');
        };
        
        window.testPhase1Features = function() {
            console.log('🎯 Testing V14 Phase 1 Always-On Features:');
            
            if (window.unifiedRenderer && window.unifiedRenderer.pixiManager) {
                const pixi = window.unifiedRenderer.pixiManager;
                console.log('⚡ PixiJS Manager Status:', pixi.isInitialized ? 'Ready' : 'Not Ready');
                console.log('🎮 Features Ready:', pixi.featuresReady ? 'Yes' : 'No');
                
                if (pixi.features) {
                    console.log('');
                    console.log('🎯 Always-On Features (No Toggles):');
                    Object.entries(pixi.features).forEach(([key, value]) => {
                        console.log(`   ${value ? '✅' : '❌'} ${key}: ${value}`);
                    });
                }
            } else {
                console.log('❌ UnifiedPixiManager not available');
            }
            
            console.log('');
            console.log('🎨 Legacy System Compatibility:');
            console.log('   Canvas Config:', typeof CANVAS_CONFIG !== 'undefined' ? 'Preserved' : 'Missing');
            console.log('   PixiJS Config:', typeof PIXI_CONFIG !== 'undefined' ? 'Preserved' : 'Missing');
            console.log('   Theme Definitions:', typeof THEME_DEFINITIONS !== 'undefined' ? 'Available' : 'Missing');
        };

        // Initialize game when page loads
        let gameManager;
        
        window.addEventListener('load', async () => {
            console.log('🌍 Page loaded, starting initialization...');
            console.log('🔧 Current level config:', window.currentLevelConfig);
            console.log('🎨 Shape renderer available:', !!shapeRenderer);
            
            // v9: Initialize Canvas Enhancement UI
            initializeThemeUI();
            
            // V14: Initialize Unified PixiJS System (Phase 1)
            console.log('🌍 V14 Phase 1: Initializing unified PixiJS system...');
            try {
                window.unifiedRenderer = new UnifiedShapeRenderer();
                const success = await window.unifiedRenderer.initialize();
                
                if (success) {
                    console.log('✅ V14: Unified system initialized successfully');
                    console.log('� V14 Phase 1: PixiJS Consolidation - COMPLETE!');
                    console.log('   ✅ Configuration complexity removed');
                    console.log('   ✅ Always-on feature system implemented');  
                    console.log('   ✅ Single unified renderer operational');
                    console.log('🧪 V14 Testing functions available:');
                    console.log('   testUnifiedRenderer(), testThemeIntegration(), testCompatibilityMode()');
                    console.log('   testPhase1Features(), v14Phase1Status(), showUnifiedConfig()');
                } else {
                    console.log('⚠️ V14: Unified system initialization failed, using legacy system');
                }
            } catch (error) {
                console.error('❌ V14: Failed to initialize unified system:', error);
                console.log('🔄 V14: Falling back to legacy Canvas/PixiJS system');
            }
            
            // V14: Commented out test shape configuration logging
            /*
            // Test shape configuration
            console.log('🧪 Testing shape configs:');
            const testShapes = ['square', 'triangle', 'circle'];
            testShapes.forEach(shape => {
                const config = getShapeConfig(shape);
                console.log(`${shape} config:`, config);
            });
            */
            
            // Initialize game manager first to load default theme
            gameManager = new GameManager();
            
            // Wait for default theme to load before building dock
            await gameManager.physicsManager.initializeDefaultTheme();
            
            // THEN initialize unified dock system with theme loaded
            rebuildGameDock();
            
            // Phase 1: Initialize PixiJS control panel
            initializePixiControls();
            
            // Initialize touch offset display values
            updateTouchOffsetDisplay();
            
            // Start dynamic coin bonus system
            startCoinBonusSystem();
            
            // Phase 2: Initialize mode toggle system
            generateDockSlots();
            updateGameUI();
            
            // V14: Clean console output - legacy status messages commented out
            /*
            console.log('🎮 Canvas Enhancement Edition v9 - INITIALIZATION COMPLETE!');
            console.log('✅ UNIFIED SHAPE CONFIGURATION implemented');
            console.log('✅ CANVAS-BASED DOCK PREVIEWS implemented');  
            console.log('🎯 All shapes now use single physics-based appearance system');
            console.log('�️ Features: Angled platform, rotation, end-level countdown, level failure');
            console.log('🎯 Game Rules: Place 3 shapes → 5s countdown starts → don\'t let any fall!');
            console.log('🖱️ Controls: Drag shapes, R/E or ←/→ to rotate during drag');
            console.log('⌨️ Keyboard Shortcuts: 1=Square, 2=Triangle, 3=Circle, 4=Pink Cross, 5=Orange L, 6=Green Cross, 7=Barbell-1, 8=Barbell-2, 9=Diamond Barbell');
            console.log('🎨 Theme Testing: Call testAllThemes() in console to cycle through all themes');
            console.log('🎆 Particle Testing: Call testParticles() in console to see particle effects');
            console.log('🖼️ Image Texture Functions: loadShapeTexture(), loadPlatformTexture(), loadBackgroundImage(), testSampleTextures()');
            console.log('📹 Camera Shake Testing: testCameraShake(), simulateShapeFall(), cameraShake(intensity, duration)');
            console.log('');
            console.log('🚀 PIXIJS INTEGRATION PHASE 2 COMPLETE!');
            console.log('✅ Dual renderer system (Canvas + PixiJS) initialized');
            console.log('✅ PixiJS shape rendering system implemented');
            console.log('✅ Visual parity with existing Canvas shapes maintained');
            console.log('✅ Physics synchronization with Matter.js bodies');
            console.log('✅ Theme system integration for PixiJS shapes');
            console.log('🎨 Phase 1 Testing: switchToCanvas(), switchToPixi(), getCurrentRenderer()');
            console.log('🎨 Phase 2 Testing: enablePixiShapes(), disablePixiShapes(), getPixiShapeCount()');
            console.log('🎬 Phase 3 Testing: togglePixiAnimations(), applyEnhancedTheme()');
            console.log('⚙️ Use Settings Panel: Enable PixiJS System → Enable Animations → Apply Enhanced Themes');
            console.log('✅ Phase 3 Complete: Advanced animations, enhanced themes, collision effects');
            console.log('🚧 Phase 4 Ready: Advanced tweening and particle systems');
            */
            
            // V14: Simplified completion message
            console.log('');
            console.log('🎮 V14 Clean Implementation - GAME READY!');
            console.log('✅ All V13 functionality preserved');
            console.log('✅ V14 unified system operational');
            console.log('🧪 V14 Testing: v14Phase1Status(), testPhase1Features()');
            console.log('');
        });

        // =============================================================================
        // IMAGE TEXTURE HELPER FUNCTIONS
        // =============================================================================

        /**
         * Load a texture image for shapes
         * @param {string} imageUrl - URL or path to the image
         * @param {string} shapeName - Name of shape ('square', 'triangle', 'circle', etc.)
         * @param {Object} options - Texture options
         * @returns {Promise<boolean>} Success/failure
         */
        async function loadShapeTexture(imageUrl, shapeName = 'square', options = {}) {
            try {
                console.log(`🖼️ Loading texture for ${shapeName}: ${imageUrl}`);
                
                // Default texture options
                const textureConfig = {
                    url: imageUrl,
                    repeat: options.repeat || 'repeat',
                    blendMode: options.blendMode || 'source-over',
                    opacity: options.opacity || 1.0,
                    scale: options.scale || 1.0
                };

                // Add texture to current theme
                if (!window.currentTheme) {
                    window.currentTheme = { shapes: {}, platform: {}, background: {} };
                }
                if (!window.currentTheme.shapes) {
                    window.currentTheme.shapes = {};
                }
                if (!window.currentTheme.shapes.textures) {
                    window.currentTheme.shapes.textures = {};
                }
                window.currentTheme.shapes.textures[shapeName] = textureConfig;
                console.log(`✅ Set texture config for ${shapeName}:`, textureConfig);
                console.log(`🔍 Current theme textures:`, window.currentTheme.shapes.textures);

                // Also update THEME_DEFINITIONS so the regular theme loading system knows about this texture
                if (window.currentTheme.name && THEME_DEFINITIONS[window.currentTheme.name]) {
                    const themeDef = THEME_DEFINITIONS[window.currentTheme.name];
                    if (themeDef.shapes && themeDef.shapes.textures && themeDef.shapes.textures[shapeName]) {
                        themeDef.shapes.textures[shapeName].url = imageUrl;
                        console.log(`🔄 Updated THEME_DEFINITIONS for ${window.currentTheme.name}.${shapeName}`);
                    }
                }

                // Load the image
                const success = await window.assetManager.loadImage(imageUrl);
                if (success) {
                    console.log(`✅ Texture loaded successfully for ${shapeName}`);
                    return true;
                } else {
                    console.warn(`❌ Failed to load texture for ${shapeName}`);
                    return false;
                }
            } catch (error) {
                console.error(`❌ Error loading texture for ${shapeName}:`, error);
                return false;
            }
        }

        /**
         * Load a texture image for platforms
         * @param {string} imageUrl - URL or path to the image
         * @param {Object} options - Texture options
         * @returns {Promise<boolean>} Success/failure
         */
        async function loadPlatformTexture(imageUrl, options = {}) {
            try {
                console.log(`🖼️ Loading platform texture: ${imageUrl}`);
                
                // Default texture options
                const textureConfig = {
                    url: imageUrl,
                    repeat: options.repeat || 'repeat',
                    blendMode: options.blendMode || 'source-over',
                    opacity: options.opacity || 1.0,
                    scale: options.scale || 1.0
                };

                // Add texture to current theme
                window.currentTheme.platform.image = textureConfig;

                // Load the image
                const success = await window.assetManager.loadImage(imageUrl);
                if (success) {
                    console.log(`✅ Platform texture loaded successfully`);
                    return true;
                } else {
                    console.warn(`❌ Failed to load platform texture`);
                    return false;
                }
            } catch (error) {
                console.error(`❌ Error loading platform texture:`, error);
                return false;
            }
        }

        /**
         * Load a background image
         * @param {string} imageUrl - URL or path to the image
         * @param {Object} options - Background options
         * @returns {Promise<boolean>} Success/failure
         */
        async function loadBackgroundImage(imageUrl, options = {}) {
            try {
                console.log(`🖼️ Loading background image: ${imageUrl}`);
                
                // Default background options
                const backgroundConfig = {
                    url: imageUrl,
                    mode: options.mode || 'cover', // 'cover', 'contain', 'stretch', 'tile'
                    opacity: options.opacity || 1.0,
                    blur: options.blur || 0,
                    brightness: options.brightness || 1.0
                };

                // Add background to current theme
                window.currentTheme.background.image = backgroundConfig;

                // Load the image
                const success = await window.assetManager.loadImage(imageUrl);
                if (success) {
                    console.log(`✅ Background image loaded successfully`);
                    return true;
                } else {
                    console.warn(`❌ Failed to load background image`);
                    return false;
                }
            } catch (error) {
                console.error(`❌ Error loading background image:`, error);
                return false;
            }
        }

        /**
         * Test sample textures with placeholder images
         */
        async function testSampleTextures() {
            console.log('🧪 Testing sample textures...');
            
            try {
                // Test background image
                await loadBackgroundImage('https://picsum.photos/1200/800?random=1', { mode: 'cover' });
                
                // Test platform texture
                await loadPlatformTexture('https://picsum.photos/200/50?random=2', { repeat: 'repeat-x' });
                
                // Test shape textures
                await loadShapeTexture('https://picsum.photos/100/100?random=3', 'square', { blendMode: 'multiply' });
                await loadShapeTexture('https://picsum.photos/100/100?random=4', 'circle', { blendMode: 'overlay' });
                await loadShapeTexture('https://picsum.photos/100/100?random=5', 'triangle', { blendMode: 'soft-light' });
                
                console.log('✅ Sample textures loaded! Drop some shapes to see the effect.');
                
            } catch (error) {
                console.error('❌ Error testing sample textures:', error);
            }
        }

        /**
         * Clear all textures and return to gradient/solid colors
         */
        function clearAllTextures() {
            console.log('🧹 Clearing all textures...');
            
            // Clear background image
            if (window.currentTheme.background.image) {
                delete window.currentTheme.background.image;
            }
            
            // Clear platform texture
            if (window.currentTheme.platform.image) {
                delete window.currentTheme.platform.image;
            }
            
            // Clear shape textures
            if (window.currentTheme.shapes.textures) {
                delete window.currentTheme.shapes.textures;
            }
            
            console.log('✅ All textures cleared - back to gradients and solid colors');
        }

        /**
         * Show texture configuration examples
         */
        function showTextureExamples() {
            console.log(`
🖼️ TEXTURE CONFIGURATION EXAMPLES:

1. Load Background Image:
   await loadBackgroundImage('path/to/background.jpg', {
       mode: 'cover',      // 'cover', 'contain', 'stretch', 'tile'
       opacity: 0.8,       // 0.0 to 1.0
       blur: 2,            // blur amount in pixels
       brightness: 1.2     // brightness multiplier
   });

2. Load Platform Texture:
   await loadPlatformTexture('path/to/wood.jpg', {
       repeat: 'repeat-x', // 'repeat', 'repeat-x', 'repeat-y', 'no-repeat'
       blendMode: 'multiply',
       opacity: 0.9,
       scale: 1.5
   });

3. Load Shape Textures:
   await loadShapeTexture('path/to/metal.jpg', 'square', {
       repeat: 'repeat',
       blendMode: 'overlay',  // Try: 'multiply', 'overlay', 'soft-light', 'hard-light'
       opacity: 0.7,
       scale: 2.0
   });

4. Test Sample Textures:
   testSampleTextures();

5. Clear All Textures:
   clearAllTextures();

6. Multiple Shape Textures:
   await loadShapeTexture('stone.jpg', 'square');
   await loadShapeTexture('fabric.jpg', 'circle');
   await loadShapeTexture('paper.jpg', 'triangle');

BLEND MODES: source-over, multiply, screen, overlay, darken, lighten, 
             color-dodge, color-burn, hard-light, soft-light, difference, exclusion

IMAGE SOURCES: Local files, URLs, data URLs, or any valid image source
            `);
        }

        // Make functions globally available
        window.loadShapeTexture = loadShapeTexture;
        window.loadPlatformTexture = loadPlatformTexture;
        window.loadBackgroundImage = loadBackgroundImage;
        window.testSampleTextures = testSampleTextures;
        window.clearAllTextures = clearAllTextures;
        window.showTextureExamples = showTextureExamples;

        // =============================================================================
        // CAMERA SHAKE TESTING FUNCTIONS
        // =============================================================================

        /**
         * Test camera shake with different intensities
         */
        function testCameraShake() {
            if (!window.gameManager || !window.gameManager.physicsManager) {
                console.log('❌ Game not initialized yet');
                return;
            }

            console.log('📹 Testing camera shake effects...');
            
            // Immediate intense shake to show it works
            console.log('🔴 INTENSE SHAKE NOW!');
            window.gameManager.physicsManager.startCameraShake(15, 1000);
            
            // Then test sequence
            setTimeout(() => {
                console.log('🔸 Light shake (intensity 5)');
                window.gameManager.physicsManager.startCameraShake(5, 600);
            }, 2000);
            
            setTimeout(() => {
                console.log('🔹 Medium shake (intensity 8)');
                window.gameManager.physicsManager.startCameraShake(8, 800);
            }, 4000);
            
            setTimeout(() => {
                console.log('🔴 Maximum shake (intensity 20)');
                window.gameManager.physicsManager.startCameraShake(20, 1000);
            }, 6500);
            
            console.log('📹 Camera shake test sequence started with immediate intense shake!');
        }

        /**
         * Simulate shape falling for camera shake
         */
        function simulateShapeFall() {
            if (!window.gameManager || !window.gameManager.physicsManager) {
                console.log('❌ Game not initialized yet');
                return;
            }

            console.log('💥 Simulating shape fall...');
            window.gameManager.physicsManager.onShapeFellOffPlatform();
            console.log('📹 Shape fall camera shake triggered!');
        }

        /**
         * Custom camera shake with user parameters
         */
        function cameraShake(intensity = 5, duration = 500) {
            if (!window.gameManager || !window.gameManager.physicsManager) {
                console.log('❌ Game not initialized yet');
                return;
            }

            window.gameManager.physicsManager.startCameraShake(intensity, duration);
            console.log(`📹 Camera shake: intensity=${intensity}, duration=${duration}ms`);
        }

        /**
         * Quick test - immediate strong shake
         */
        function shakeNow() {
            console.log('🧪 shakeNow() called - testing camera shake system...');
            
            if (!window.gameManager || !window.gameManager.physicsManager) {
                console.log('❌ Game not initialized yet');
                return;
            }
            
            console.log('✅ Game manager and physics manager found');
            window.gameManager.physicsManager.startCameraShake(20, 1000);
            console.log('💥 MAXIMUM SHAKE ACTIVATED!');
        }

        /**
         * Test camera shake by directly calling the function
         */
        function testDirectShake() {
            console.log('🧪 testDirectShake() - bypassing all collision detection...');
            
            if (!window.gameManager) {
                console.log('❌ Game not initialized yet');
                return;
            }
            
            // Directly call onShapeFell to test the entire chain
            console.log('✅ Directly calling onShapeFell...');
            window.gameManager.onShapeFell();
        }

        /**
         * Test camera shake by simulating a shape falling off screen
         */
        function testShapeFall() {
            console.log('🧪 testShapeFall() called - simulating shape fall...');
            
            if (!window.gameManager) {
                console.log('❌ Game not initialized yet');
                return;
            }
            
            console.log('✅ Game manager found, calling onShapeFell...');
            window.gameManager.onShapeFell();
            console.log('🍃 Simulated shape fall with camera shake!');
        }

        /**
         * Show camera shake examples
         */
        function showCameraShakeExamples() {
            console.log(`
📹 CAMERA SHAKE EXAMPLES:

1. Test Different Intensities:
   testCameraShake();

2. Simulate Shape Fall:
   simulateShapeFall();

3. Custom Camera Shake:
   cameraShake(7, 800);    // Intensity 7, 800ms duration
   cameraShake(3, 300);    // Light shake, 300ms
   cameraShake(10, 1000);  // Maximum intensity, 1 second

4. Intensity Guide:
   1-3:  Light shake (subtle feedback)
   4-6:  Medium shake (noticeable effect) 
   7-9:  Heavy shake (dramatic effect)
   10+:  Maximum shake (screen earthquake!)

5. Duration Guide:
   200-400ms: Quick feedback
   500-800ms: Standard effect
   1000ms+:   Extended shake

The camera shake automatically triggers when shapes fall off screen!
Try dropping a shape off the edge to see it in action.
            `);
        }

        // Make camera shake functions globally available
        window.testCameraShake = testCameraShake;
        window.simulateShapeFall = simulateShapeFall;
        window.cameraShake = cameraShake;
        window.showCameraShakeExamples = showCameraShakeExamples;

        // =============================================================================
        // ENHANCED TEXTURE MANAGEMENT SYSTEM
        // =============================================================================

        /**
         * Enhanced texture management class
         */
class TextureManager {
    constructor() {
        this.loadedTextures = new Map();
        this.textureCache = new Map();
        this.currentTheme = null;
        console.log('������ Enhanced Texture Manager initialized');
    }

    /**
     * Apply texture theme - simplified and fixed
     */
    async applyTextureTheme(themeName) {
        console.log(`������ Applying texture theme: ${themeName}`);
        
        // For wood theme, use the known oak.png texture
        if (themeName === 'wood') {
            const textureUrl = 'assets/textures/wood/oak.png';
            console.log(`������️ Loading wood texture: ${textureUrl}`);
            
            // Preload the texture image
            try {
                const img = await this.loadImage(textureUrl);
                if (img) {
                    console.log(`✅ Wood texture loaded successfully`);
                    
                    // Store the loaded texture
                    this.loadedTextures.set('wood', textureUrl);
                    
                    // Apply texture to all shapes
                    const allShapeTypes = ['square', 'triangle', 'circle', 'cross', 'cross2', 'l', 'barbell-one', 'barbell-two', 'diamond-barbell'];
                    
                    for (const shapeType of allShapeTypes) {
                        // Update shape configuration with texture
                        if (!SHAPE_CONFIG[shapeType]) continue;
                        
                        SHAPE_CONFIG[shapeType].texture = textureUrl;
                        console.log(`✅ Added texture to ${shapeType} config`);
                        
                        // Also update window.currentTheme for consistency
                        if (!window.currentTheme) {
                            window.currentTheme = { shapes: { textures: {} } };
                        }
                        if (!window.currentTheme.shapes) {
                            window.currentTheme.shapes = { textures: {} };
                        }
                        if (!window.currentTheme.shapes.textures) {
                            window.currentTheme.shapes.textures = {};
                        }
                        
                        window.currentTheme.shapes.textures[shapeType] = {
                            url: textureUrl,
                            repeat: 'repeat',
                            blend: 'multiply',
                            opacity: 0.7
                        };
                        
                        // Mark texture as loaded for this shape
                        this.loadedTextures.set(shapeType, textureUrl);
                    }
                    
                    console.log(`✅ Applied wood texture to all shapes`);
                    
                    // Immediately rebuild the dock to show textures
                    if (typeof rebuildGameDock === 'function') {
                        console.log('������ Rebuilding dock with textures...');
                        rebuildGameDock();
                    }
                    
                    return true;
                }
            } catch (error) {
                console.error(`❌ Failed to load texture: ${error}`);
            }
        }
        
        return false;
    }
    
    /**
     * Load an image and return it
     */
    async loadImage(url) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.crossOrigin = 'anonymous';
            
            img.onload = () => {
                console.log(`✅ Image loaded: ${url}`);
                this.textureCache.set(url, img);
                resolve(img);
            };
            
            img.onerror = () => {
                console.error(`❌ Failed to load image: ${url}`);
                reject(new Error(`Failed to load ${url}`));
            };
            
            img.src = url;
        });
    }
    
    /**
     * Check if a texture is loaded
     */
    isTextureLoaded(shapeType) {
        return this.loadedTextures.has(shapeType);
    }
    
    /**
     * Get loaded texture URL for a shape
     */
    getTextureUrl(shapeType) {
        return this.loadedTextures.get(shapeType);
    }
}

// Fix the PhysicsShapeRenderer.createDockPreview method
PhysicsShapeRenderer.prototype.createDockPreview = function(shapeType, size = 90) {
    // V14: Commented out verbose dock preview logging
    // console.log(`🔍 createDockPreview called for: ${shapeType}, size: ${size}`);
    const config = getShapeConfig(shapeType);
    if (!config) {
        console.error(`❌ No config found for shape: ${shapeType}`);
        return null;
    }
    
    console.log(`������ Shape config for ${shapeType}:`, config);
    
    // Check if we have a texture loaded via TextureManager
    let hasTexture = false;
    if (window.textureManager && window.textureManager.isTextureLoaded(shapeType)) {
        hasTexture = true;
        console.log(`������️ Texture is loaded for ${shapeType}`);
    }
    
    // Always use canvas preview for now (can add PixiJS texture support later)
    return this.createCanvasDockPreview(shapeType, config, size, hasTexture);
};

// Enhanced canvas dock preview with texture rendering
PhysicsShapeRenderer.prototype.createCanvasDockPreview = function(shapeType, config, size = 90, hasTexture = false) {
    const canvas = document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    canvas.className = `shape-preview`;
    canvas.dataset.shape = shapeType;

    const ctx = canvas.getContext('2d');
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';
    
    // Visual indicator for textured shapes
    if (hasTexture) {
        canvas.style.border = '2px solid #DAA520';
        canvas.style.boxShadow = '0 0 8px rgba(218, 165, 32, 0.5)';
        canvas.title = `${shapeType} - Textured`;
    } else {
        canvas.style.border = '1px solid #ccc';
        canvas.title = `${shapeType}`;
    }

    const scale = 1.9;
    
    // Check for barbell rotation
    let rotation = 0;
    if (shapeType && shapeType.includes('barbell')) {
        const barbellOrientationSelect = document.getElementById('barbellOrientation');
        if (barbellOrientationSelect && barbellOrientationSelect.value === 'vertical') {
            rotation = Math.PI / 2;
        }
    }
    
    // If we have a texture, render with texture pattern
    if (hasTexture && window.textureManager) {
        const textureUrl = window.textureManager.getTextureUrl(shapeType);
        const cachedImage = window.textureManager.textureCache.get(textureUrl);
        
        if (cachedImage) {
            // Create pattern and apply to shape
            ctx.save();
            ctx.translate(size / 2, size / 2);
            ctx.rotate(rotation);
            ctx.scale(scale, scale);
            
            // Create clipping path for the shape
            this.createShapeClipPath(ctx, shapeType, config);
            ctx.clip();
            
            // Draw the texture pattern
            const pattern = ctx.createPattern(cachedImage, 'repeat');
            ctx.fillStyle = pattern;
            ctx.fillRect(-size, -size, size * 2, size * 2);
            
            // Add stroke
            ctx.restore();
            ctx.save();
            ctx.translate(size / 2, size / 2);
            ctx.rotate(rotation);
            ctx.scale(scale, scale);
            this.createShapeClipPath(ctx, shapeType, config);
            ctx.strokeStyle = config.stroke;
            ctx.lineWidth = config.strokeWidth;
            ctx.stroke();
            
            ctx.restore();
        } else {
            // Fallback to regular rendering
            this.renderShapeOnCanvas(ctx, shapeType, size / 2, size / 2, rotation, scale);
        }
    } else {
        // Regular rendering without texture
        this.renderShapeOnCanvas(ctx, shapeType, size / 2, size / 2, rotation, scale);
    }
    
    console.log(`✅ Canvas preview created for: ${shapeType} (textured: ${hasTexture})`);
    return canvas;
};

// Add helper method to create clipping path for shapes
PhysicsShapeRenderer.prototype.createShapeClipPath = function(ctx, shapeType, config) {
    ctx.beginPath();
    
    switch (config.type) {
        case 'rectangle':
            ctx.rect(-config.width / 2, -config.height / 2, config.width, config.height);
            break;
        case 'circle':
            ctx.arc(0, 0, config.radius, 0, Math.PI * 2);
            break;
        case 'polygon':
            if (config.vertices) {
                ctx.moveTo(config.vertices[0].x, config.vertices[0].y);
                for (let i = 1; i < config.vertices.length; i++) {
                    ctx.lineTo(config.vertices[i].x, config.vertices[i].y);
                }
                ctx.closePath();
            }
            break;
        case 'compound':
            // For compound shapes, create path for all parts
            if (config.parts) {
                for (const part of config.parts) {
                    ctx.save();
                    ctx.translate(part.offsetX || 0, part.offsetY || 0);
                    
                    if (part.type === 'rectangle') {
                        ctx.rect(-part.width / 2, -part.height / 2, part.width, part.height);
                    } else if (part.type === 'circle') {
                        ctx.moveTo(part.radius, 0);
                        ctx.arc(0, 0, part.radius, 0, Math.PI * 2);
                    } else if (part.type === 'diamond') {
                        // Create a diamond clipping path: top, right, bottom, left points
                        const size = part.width || part.height || 12;
                        const halfSize = size / 2;
                        ctx.moveTo(0, -halfSize);  // Top
                        ctx.lineTo(halfSize, 0);   // Right
                        ctx.lineTo(0, halfSize);   // Bottom
                        ctx.lineTo(-halfSize, 0);  // Left
                        ctx.closePath();
                                        }
                    
                    ctx.restore();
                }
            }
            break;
    }
};

// Override the drawDiamond method to render a proper diamond shape path
PhysicsShapeRenderer.prototype.drawDiamond = function(ctx, config) {
    const { width, height, color, stroke, strokeWidth } = config;
    ctx.fillStyle = color;
    ctx.strokeStyle = stroke;
    ctx.lineWidth = strokeWidth;
    const size = width || height || 12;
    const halfSize = size / 2;
    ctx.beginPath();
    ctx.moveTo(0, -halfSize);
    ctx.lineTo(halfSize, 0);
    ctx.lineTo(0, halfSize);
    ctx.lineTo(-halfSize, 0);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
};

// Fix the applyEnhancedTheme function
window.applyEnhancedTheme = function() {
    const enhancedThemeSelect = document.getElementById('enhancedThemeSelect');
    const selectedTheme = enhancedThemeSelect.value;
    
    console.log(`������ Applying enhanced theme: ${selectedTheme}`);
    
    // Initialize texture manager if needed
    if (!window.textureManager) {
        window.textureManager = new TextureManager();
    }
    
    // Apply the texture theme
    if (selectedTheme === 'wood') {
        window.textureManager.applyTextureTheme('wood').then(success => {
            if (success) {
                console.log('✅ Wood textures applied successfully!');
            } else {
                console.log('⚠️ Failed to apply wood textures');
            }
        });
    } else {
        // Clear textures for non-wood themes
        if (window.textureManager.loadedTextures.size > 0) {
            window.textureManager.loadedTextures.clear();
            
            // Clear texture references from SHAPE_CONFIG
            Object.keys(SHAPE_CONFIG).forEach(shapeType => {
                delete SHAPE_CONFIG[shapeType].texture;
            });
            
            // Rebuild dock without textures
            rebuildGameDock();
        }
    }
};

// Initialize texture manager on page load
if (!window.textureManager) {
    window.textureManager = new TextureManager();
}

console.log('✅ Texture loading system fixed and initialized');

    </script>
</body>
</html>
