<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Art of Balance - v10</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }

        html {
            overflow: hidden; /* Prevent scrolling on the game */
            height: 100%;
        }

        @import url('https://fonts.googleapis.com/css2?family=Fredoka:wght@400;500;600;700&display=swap');
        
        body {
            font-family: 'Fredoka', sans-serif;
            background: linear-gradient(135deg, #87CEEB 0%, #98FB98 100%);
            height: 100vh;
            height: 100dvh; /* Dynamic viewport height for mobile */
            overflow: hidden; /* Prevent scrolling */
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* New Responsive Game Viewport */
        .game-viewport {
            width: 100vw;
            height: 100vh;
            height: 100dvh;
            display: flex;
            flex-direction: column;
            max-width: min(100vw, 500px); /* Cap width at 500px on desktop */
            max-height: min(100vh, 889px); /* 500 * 16/9 for aspect ratio */
            margin: 0 auto;
            background: linear-gradient(135deg, #FF6B6B 0%, #4ECDC4 100%);
            position: relative;
            aspect-ratio: 9/16;
            overflow: visible; /* Allow dragged elements to extend beyond viewport */
            box-shadow: 0 0 50px rgba(0,0,0,0.3);
        }

        /* Border system for larger screens */
        @media (min-width: 501px) {
            body {
                background: linear-gradient(135deg, #87CEEB 0%, #98FB98 100%);
                padding: 20px;
            }
            
            .game-viewport {
                border-radius: 20px;
                box-shadow: 0 10px 50px rgba(0,0,0,0.4);
            }
        }

        /* Game HUD - Top Section */
        .game-hud {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: clamp(70px, 12vh, 90px); /* Responsive height */
            background: linear-gradient(135deg, #FF6B6B 0%, #4ECDC4 100%);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: clamp(6px, 2vw, 15px); /* Responsive padding */
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 100;
        }

        /* Left Section - Score and Star Meter */
        .left-section {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            color: white;
            font-weight: bold;
            justify-content: space-between;
            height: 100%;
            min-width: 0; /* Prevent flex overflow */
        }

        .score-display {
            display: flex;
            align-items: center;
            gap: clamp(4px, 1.5vw, 8px); /* Responsive gap */
            margin-bottom: 3px;
        }

        .trophy-icon {
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
            width: clamp(18px, 4vw, 24px); /* Responsive icon size */
            height: clamp(18px, 4vw, 24px);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(8px, 2vw, 12px); /* Responsive font */
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            border: 2px solid #B8860B;
            flex-shrink: 0; /* Prevent shrinking */
        }

        .score-text {
            font-size: clamp(14px, 4vw, 18px); /* Responsive font size */
            font-weight: 700;
            color: #FFE4B5;
            text-shadow: 0 2px 4px rgba(0,0,0,0.4);
            white-space: nowrap; /* Prevent text wrapping */
        }

        .star-progress-container {
            position: relative;
            width: clamp(100px, 25vw, 140px); /* Responsive width */
            height: clamp(14px, 3vw, 18px); /* Responsive height */
            background: rgba(255,255,255,0.25);
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.3);
            overflow: hidden;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.3);
            cursor: pointer; /* Indicate interactivity */
        }

        .progress-area {
            position: relative;
            width: clamp(100px, 25vw, 140px); /* Match container width */
            height: clamp(28px, 6vw, 36px); /* Responsive height for better touch */
        }

        .star-progress-container {
            margin-top: clamp(12px, 3vw, 18px); /* Responsive margin */
        }

        .star-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #8B5CF6 0%, #A855F7 50%, #C084FC 100%);
            border-radius: 7px;
            transition: width 0.8s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            box-shadow: 0 0 6px rgba(139, 92, 246, 0.6);
        }

        /* White progress markers inside the bar */
        .progress-markers {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 100%;
            pointer-events: none;
            z-index: 2;
        }

        .progress-marker {
            position: absolute;
            top: 0;
            width: 2px;
            height: 100%;
            background: rgba(255,255,255,0.8);
            border-radius: 1px;
        }

        .progress-marker:nth-child(1) {
            left: 33.33%;
            transform: translateX(-50%);
        }

        .progress-marker:nth-child(2) {
            left: 66.66%;
            transform: translateX(-50%);
        }

        .progress-marker:nth-child(3) {
            left: 90%;
            transform: translateX(-50%);
        }

        .star-markers {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 16px;
            width: 120px;
            pointer-events: none;
            z-index: 10;
        }

        .star {
            width: 14px;
            height: 14px;
            background: rgba(255,255,255,0.3);
            clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%);
            box-shadow: 0 2px 6px rgba(0,0,0,0.5);
            border: 1px solid rgba(255,255,255,0.6);
            transition: all 0.5s ease;
            position: absolute;
        }

        /* Position stars directly above the white markers */
        .star:nth-child(1) {
            left: 33.33%;
            transform: translateX(-50%);
        }

        .star:nth-child(2) {
            left: 66.66%;
            transform: translateX(-50%);
        }

        .star:nth-child(3) {
            left: 90%;
            transform: translateX(-50%);
        }

        .star.filled {
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
            border: 2px solid #B8860B;
            transform: translateX(-50%) scale(1.3);
            box-shadow: 0 0 20px rgba(255, 215, 0, 1), 0 2px 6px rgba(0,0,0,0.6);
            animation: starPulse 0.5s ease-out;
            z-index: 15;
        }

        /* Middle Section - Timer */
        .middle-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            gap: clamp(3px, 1vw, 6px); /* Responsive gap */
            min-width: 0; /* Prevent overflow */
        }

        /* Level Display */
        .level-display {
            font-size: clamp(11px, 3vw, 14px); /* Responsive font size */
            font-weight: 600;
            color: #FFE4B5;
            text-shadow: 0 1px 2px rgba(0,0,0,0.4);
            background: rgba(0,0,0,0.15);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            padding: clamp(3px, 1vw, 6px) clamp(6px, 2vw, 10px); /* Responsive padding */
            min-width: clamp(50px, 12vw, 70px); /* Responsive min-width */
            text-align: center;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
            white-space: nowrap;
        }

        .timer-container {
            background: rgba(0,0,0,0.2);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 12px;
            padding: clamp(6px, 2vw, 10px) clamp(8px, 3vw, 14px); /* Responsive padding */
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: clamp(60px, 15vw, 80px); /* Responsive min-width */
            min-height: 44px; /* Minimum touch target */
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }

        .timer-container:hover {
            background: rgba(0,0,0,0.3);
            transform: translateY(-1px);
        }

        .timer-text {
            font-size: clamp(12px, 3.5vw, 16px); /* Responsive font size */
            font-weight: 600;
            color: #FFE4B5;
            text-shadow: 0 1px 2px rgba(0,0,0,0.4);
            font-variant-numeric: tabular-nums;
            transition: all 0.3s ease;
            white-space: nowrap;
        }

        .timer-text.timer-warning {
            color: #FFA500;
            text-shadow: 0 0 10px rgba(255, 165, 0, 0.6);
        }

        .timer-text.timer-critical {
            color: #FF4444;
            text-shadow: 0 0 15px rgba(255, 68, 68, 0.8);
            animation: timerPulse 1s infinite;
        }

        @keyframes timerPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        /* Right Section - Settings, Reset, and Coins */
        .right-section {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            justify-content: space-between;
            height: 100%;
            min-width: 0; /* Prevent overflow */
        }

        .top-buttons {
            display: flex;
            gap: clamp(6px, 2vw, 10px); /* Responsive gap */
            align-items: center;
            flex-wrap: wrap; /* Allow wrapping on very small screens */
        }

        .settings-button, .reset-button {
            width: clamp(32px, 8vw, 44px); /* Responsive size with 44px max for touch */
            height: clamp(32px, 8vw, 44px);
            min-width: 44px; /* Minimum touch target */
            min-height: 44px;
            background: rgba(0,0,0,0.2);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            color: #FFE4B5;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            position: relative;
        }

        .settings-button:hover, .reset-button:hover {
            background: rgba(0,0,0,0.3);
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(0,0,0,0.4);
        }

        .settings-button:active, .reset-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }

        .reset-icon {
            width: clamp(12px, 3vw, 16px); /* Responsive icon size */
            height: clamp(12px, 3vw, 16px);
            color: #FFE4B5;
            font-size: clamp(10px, 3vw, 14px); /* Responsive font */
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .pause-icon {
            width: clamp(12px, 3vw, 16px);
            height: clamp(12px, 3vw, 16px);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 2px;
        }

        .pause-bar {
            width: 3px;
            height: clamp(10px, 3vw, 14px); /* Responsive height */
            background: #FFE4B5;
            border-radius: 1px;
        }

        .coin-counter {
            display: flex;
            align-items: center;
            gap: clamp(4px, 1.5vw, 7px); /* Responsive gap */
            background: rgba(0,0,0,0.2);
            padding: clamp(4px, 1.5vw, 7px) clamp(8px, 2.5vw, 12px); /* Responsive padding */
            border-radius: 10px;
            border: 1px solid rgba(255,255,255,0.2);
            cursor: pointer;
            transition: all 0.3s ease;
            min-height: 44px; /* Minimum touch target */
            min-width: 60px; /* Minimum width for readability */
        }

        .coin-counter:hover {
            background: rgba(0,0,0,0.3);
            transform: translateY(-1px);
        }

        .coin-icon {
            width: clamp(14px, 4vw, 18px); /* Responsive icon size */
            height: clamp(14px, 4vw, 18px);
            font-size: clamp(10px, 3vw, 14px); /* Responsive font */
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .coin-amount {
            font-size: clamp(12px, 3.5vw, 16px); /* Responsive font size */
            font-weight: 600;
            color: #FFE4B5;
            text-shadow: 0 1px 2px rgba(0,0,0,0.4);
            white-space: nowrap; /* Prevent text wrapping */
        }

        /* Timer Mode Indicator */
        .timer-mode-indicator {
            position: absolute;
            top: -5px;
            right: -5px;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            font-size: 8px;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            border: 1px solid rgba(255,255,255,0.3);
        }

        .timer-mode-elapsed {
            background: linear-gradient(135deg, #8B5CF6 0%, #7C3AED 100%);
        }

        .timer-mode-countdown {
            background: linear-gradient(135deg, #EF4444 0%, #DC2626 100%);
        }

        .timer-mode-endlevel {
            background: linear-gradient(135deg, #10B981 0%, #059669 100%);
        }

        /* Docking Area - Shape Selection */
        .docking-area {
            position: absolute;
            top: clamp(70px, 12vh, 90px); /* Match HUD height */
            left: 0;
            right: 0;
            height: clamp(120px, 20vh, 160px); /* Responsive height */
            background: #34495e;
            display: grid;
            grid-template-columns: repeat(5, 1fr); /* Equal column distribution */
            grid-template-rows: repeat(2, 1fr); /* Equal row distribution */
            gap: clamp(4px, 1.5vw, 10px); /* Responsive gap */
            padding: clamp(4px, 2vw, 8px); /* Responsive padding */
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            z-index: 50;
            align-items: center;
            justify-items: center;
            overflow: visible; /* Allow shapes to extend beyond docking area */
        }

        .shape-slot {
            width: 100%;
            height: 100%;
            min-width: clamp(50px, 12vw, 70px); /* Responsive minimum size */
            min-height: clamp(50px, 12vw, 70px);
            max-width: 80px; /* Prevent too large on desktop */
            max-height: 80px;
            background: rgba(255,255,255,0.1);
            border: 2px dashed rgba(255,255,255,0.3);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            transition: all 0.3s ease;
            padding: 0;
            margin: 0;
            overflow: visible;
            box-sizing: border-box;
            cursor: pointer; /* Indicate interactivity */
        }

        .shape-slot:hover {
            background: rgba(255,255,255,0.15);
            border-color: rgba(255,255,255,0.5);
            transform: scale(1.05);
        }

        .shape-slot.empty {
            border-color: rgba(255,255,255,0.1);
            background: rgba(255,255,255,0.05);
        }

        .shape-slot.empty:hover {
            border-color: rgba(255,255,255,0.2);
            background: rgba(255,255,255,0.1);
        }

        .game-shape {
            cursor: grab;
            transition: all 0.3s ease;
            position: relative;
            z-index: 60;
            width: 100%; /* Fill slot */
            height: 100%;
            min-width: 44px; /* Minimum touch target */
            min-height: 44px;
        }

        .game-shape:active {
            cursor: grabbing;
            transform: scale(1.15); /* Slightly larger feedback on touch */
            filter: drop-shadow(0 5px 15px rgba(0,0,0,0.4));
            transition: all 0.1s ease; /* Quick response for touch */
        }

        .game-shape:hover {
            transform: scale(1.1);
            filter: drop-shadow(0 3px 10px rgba(0,0,0,0.3));
        }

        .game-shape.dragging {
            z-index: 1000;
            transform: scale(1.2); /* Slightly larger when dragging */
            filter: drop-shadow(0 8px 20px rgba(0,0,0,0.4));
        }

        /* Enhanced touch feedback for mobile */
        @media (pointer: coarse) {
            .game-shape {
                transition: all 0.2s ease; /* Longer transitions on touch devices */
            }
            
            .game-shape:active {
                transform: scale(1.2); /* Larger feedback on touch devices */
                transition: all 0.05s ease; /* Very quick response */
            }
            
            .shape-slot:active {
                background: rgba(255,255,255,0.2);
                border-color: rgba(255,255,255,0.7);
                transform: scale(1.02);
                transition: all 0.05s ease;
            }
        }
        
        /* End Level Countdown - 3 Dot Display */
        .countdown-dots {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            padding: 8px 12px;
        }

        .countdown-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: rgba(255,255,255,0.3);
            transition: all 0.3s ease;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }

        .countdown-dot.active {
            background: linear-gradient(135deg, #10B981 0%, #059669 100%);
            transform: scale(1.7);
            box-shadow: 0 0 12px rgba(16, 185, 129, 0.8);
            animation: dotPulse 0.6s ease-in-out;
        }

        .countdown-dot.completed {
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
            transform: scale(1.8);
            box-shadow: 0 0 8px rgba(255, 215, 0, 0.6);
        }

        @keyframes dotPulse {
            0%, 100% { transform: scale(1.3); }
            50% { transform: scale(1.6); }
        }

        /* Particle Effects */
        .particle {
            position: fixed;
            pointer-events: none;
            z-index: 9999;
            font-size: 14px;
            font-weight: bold;
            opacity: 1;
            animation: particleFloat 2s ease-out forwards;
        }

        @keyframes particleFloat {
            0% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
            100% {
                opacity: 0;
                transform: translateY(-40px) scale(0);
            }
        }

        @keyframes starBurst {
            0% {
                opacity: 1;
                transform: scale(0) rotate(0deg);
            }
            50% {
                opacity: 0.8;
                transform: scale(1.5) rotate(180deg);
            }
            100% {
                opacity: 0;
                transform: scale(2) rotate(360deg);
            }
        }

        .progress-animate {
            animation: progressPulse 0.8s ease-out;
        }

        @keyframes progressPulse {
            0% { transform: scaleY(1); }
            50% { transform: scaleY(1.1); box-shadow: 0 0 15px rgba(255, 215, 0, 0.6); }
            100% { transform: scaleY(1); }
        }

        /* Enhanced Star Animations */
        .star.filled {
            animation: starFill 0.5s ease-out;
        }

        @keyframes starFill {
            0% { transform: scale(0) rotate(0deg); opacity: 0; }
            50% { transform: scale(1.3) rotate(180deg); opacity: 1; }
            100% { transform: scale(1) rotate(360deg); opacity: 1; }
        }

        /* Score Text Animation */
        .score-text {
            transition: all 0.3s ease;
        }

        .score-text.score-increase {
            animation: scoreBoost 0.6s ease-out;
        }

        @keyframes scoreBoost {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); color: #FFD700; }
            100% { transform: scale(1); }
        }

        /* Coin Animation */
        .coin-amount {
            transition: all 0.3s ease;
        }

        .coin-amount.coin-increase {
            animation: coinBoost 0.6s ease-out;
        }

        @keyframes coinBoost {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); color: #FFD700; text-shadow: 0 0 10px #FFD700; }
            100% { transform: scale(1); }
        }

        /* Enhanced Coin Animations */
        @keyframes coinShower {
            0% { 
                transform: translateY(0) rotate(0deg); 
                opacity: 1; 
            }
            50% { 
                transform: translateY(-50px) rotate(180deg); 
                opacity: 0.8; 
            }
            100% { 
                transform: translateY(100px) rotate(360deg); 
                opacity: 0; 
            }
        }

        @keyframes coinPulse {
            0%, 100% { 
                transform: scale(1); 
                box-shadow: 0 0 5px rgba(255, 215, 0, 0.3); 
            }
            50% { 
                transform: scale(1.3); 
                box-shadow: 0 0 25px rgba(255, 215, 0, 0.8); 
            }
        }

        @keyframes coinShake {
            0%, 100% { transform: translateX(0); }
            10% { transform: translateX(-2px) rotate(-1deg); }
            20% { transform: translateX(2px) rotate(1deg); }
            30% { transform: translateX(-3px) rotate(-1deg); }
            40% { transform: translateX(3px) rotate(1deg); }
            50% { transform: translateX(-2px) rotate(-1deg); }
            60% { transform: translateX(2px) rotate(1deg); }
            70% { transform: translateX(-1px) rotate(-1deg); }
            80% { transform: translateX(1px) rotate(1deg); }
            90% { transform: translateX(-1px) rotate(-1deg); }
        }

        /* Particle Effects */
        .particle {
            position: fixed;
            pointer-events: none;
            font-size: 18px;
            font-weight: bold;
            z-index: 9999;
            animation: floatUp 2s ease-out forwards;
        }

        /* Level Complete Effects */
        @keyframes levelCompleteFlash {
            0%, 100% { filter: brightness(1); }
            25% { filter: brightness(1.3) saturate(1.2); }
            50% { filter: brightness(1.1) saturate(1.1); }
            75% { filter: brightness(1.2) saturate(1.15); }
        }

        /* Level Cleared Popup Modal */
        .level-cleared-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            opacity: 0;
            animation: modalFadeIn 0.5s ease-out forwards;
        }

        .level-cleared-content {
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
            transform: scale(0.5);
            animation: modalPopIn 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55) forwards;
        }

        .level-cleared-title {
            font-size: 48px;
            font-weight: bold;
            color: #8B4513;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            animation: titlePulse 1s ease-in-out infinite alternate;
        }

        .level-cleared-subtitle {
            font-size: 24px;
            color: #654321;
            margin-bottom: 30px;
            font-weight: 600;
        }

        .level-cleared-stars {
            font-size: 60px;
            margin: 20px 0;
            animation: starsSparkle 2s ease-in-out infinite;
        }

        .level-cleared-button {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            margin: 10px;
        }

        .level-cleared-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
        }

        @keyframes modalFadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes modalPopIn {
            from { 
                transform: scale(0.5) rotate(-10deg);
                opacity: 0;
            }
            to { 
                transform: scale(1) rotate(0deg);
                opacity: 1;
            }
        }

        @keyframes titlePulse {
            from { transform: scale(1); }
            to { transform: scale(1.05); }
        }

        @keyframes starsSparkle {
            0%, 100% { 
                transform: scale(1) rotate(0deg);
                filter: brightness(1);
            }
            50% { 
                transform: scale(1.1) rotate(5deg);
                filter: brightness(1.3);
            }
        }

        /* Global Drag Overlay - Ensure dragging works across entire viewport */
        #dragOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 9998;
            overflow: visible;
        }

        .ghost-shape {
            position: fixed !important;
            pointer-events: none !important;
            z-index: 10000 !important; /* Increased z-index */
            visibility: visible !important;
            opacity: 0.9 !important;
            display: block !important;
            transition: transform 0.2s ease-out !important;
        }

        /* Rotation Visual Feedback */
        /* Enhanced Mobile Touch Interactions */
        .game-shape {
            touch-action: none;
            cursor: grab;
            transition: transform 0.2s ease;
        }

        .game-shape:hover {
            transform: scale(1.05);
        }

        .game-shape:active {
            cursor: grabbing;
            transform: scale(1.1);
        }

        .game-shape.ghost-active {
            opacity: 0.3;
            transform: scale(0.9);
            transition: all 0.3s ease;
        }

        /* Touch Feedback */
        .touch-ripple {
            position: fixed;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.6);
            pointer-events: none;
            z-index: 9998;
            animation: rippleEffect 0.6s ease-out forwards;
        }

        @keyframes rippleEffect {
            0% { transform: scale(0); opacity: 1; }
            100% { transform: scale(4); opacity: 0; }
        }

        .rotation-indicator {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: bold;
            z-index: 10000;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .rotation-indicator.show {
            opacity: 1;
        }

        /* Enhanced Drag Feedback */
        .game-shape.ghost-active {
            opacity: 0.3;
            transform: scale(0.9);
            transition: all 0.3s ease;
        }

        /* Shape Visual Designs - REMOVED: Now using unified canvas-based system */
        /* All shape appearances now handled by PhysicsShapeRenderer and SHAPE_CONFIG */

        /* Canvas preview styling for dock */
        .shape-preview {
            width: 46px;
            height: 46px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .shape-preview:hover {
            filter: brightness(1.1);
            transform: scale(1.05);
        }

        /* Ghost effect for dragged shapes */
        .shape-preview.ghost-active {
            opacity: 0.3;
            transform: scale(0.9);
            transition: all 0.3s ease;
        }

        /* Game shape base styles for drag/drop functionality */
        .game-shape {
            display: block;
            position: relative;
        }

        .game-shape.ghost-active {
            opacity: 0.3;
        }

        /* Mode Toggle Inside HUD */
        .mode-toggle-switch {
            position: relative;
            width: 60px;
            height: 28px;
            background: rgba(52, 73, 94, 0.8);
            border-radius: 14px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .mode-toggle-switch.design-active {
            background: rgba(52, 152, 219, 0.8);
            border-color: #3498db;
        }

        .mode-toggle-slider {
            position: absolute;
            top: 2px;
            left: 2px;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
        }

        .mode-toggle-switch.design-active .mode-toggle-slider {
            transform: translateX(28px);
        }

        .mode-toggle-labels {
            position: absolute;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            white-space: nowrap;
            color: rgba(255, 255, 255, 0.8);
        }

        /* Design Mode Sidebar */
        .design-sidebar {
            position: fixed;
            top: 0;
            left: -350px;
            width: 350px;
            height: 100vh;
            background: linear-gradient(180deg, #2c3e50 0%, #34495e 100%);
            box-shadow: 5px 0 20px rgba(0,0,0,0.3);
            transition: left 0.4s ease;
            z-index: 999;
            overflow-y: auto;
            color: white;
        }

        .design-sidebar.active {
            left: 0;
        }

        .design-mode .game-viewport {
            margin-left: 350px;
            transition: margin-left 0.4s ease;
        }

        .sidebar-header {
            padding: 20px;
            background: rgba(0,0,0,0.2);
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .sidebar-title {
            font-size: 16px;
            font-weight: bold;
            color: #3498db;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .sidebar-section {
            padding: 15px 20px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .config-group {
            margin-bottom: 12px;
        }

        .config-label {
            display: block;
            font-size: 13px;
            font-weight: 500;
            margin-bottom: 5px;
            color: #bdc3c7;
        }

        .config-input, .config-select {
            width: 100%;
            padding: 8px 12px;
            background: rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 6px;
            color: white;
            font-size: 14px;
        }

        .config-input:focus, .config-select:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 5px rgba(52, 152, 219, 0.3);
        }

        .config-sub-group {
            margin-left: 20px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .config-sub-group .config-label {
            min-width: 100px;
            margin-bottom: 0;
            font-size: 12px;
        }

        .config-sub-group input[type="range"] {
            flex: 1;
            margin: 0;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
        }

        .range-value {
            min-width: 50px;
            text-align: right;
            font-size: 12px;
            color: #FFE4B5;
            font-weight: 600;
            background: rgba(0,0,0,0.2);
            padding: 2px 6px;
            border-radius: 4px;
        }

        .config-btn {
            width: 100%;
            padding: 10px;
            background: linear-gradient(135deg, #27ae60 0%, #229954 100%);
            color: white;
            border: none;
            border-radius: 6px;
            font-weight: bold;
            cursor: pointer;
            margin-top: 8px;
            transition: all 0.3s ease;
        }

        .config-btn:hover {
            background: linear-gradient(135deg, #229954 0%, #1e8449 100%);
            transform: translateY(-1px);
        }

        /* v9: Theme Selector Styles */
        .checkbox-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 8px;
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            color: #ecf0f1;
            cursor: pointer;
        }

        .checkbox-label input[type="checkbox"] {
            width: 16px;
            height: 16px;
            accent-color: #27ae60;
        }

        .theme-preview {
            width: 100%;
            height: 40px;
            border-radius: 4px;
            margin: 4px 0 8px 0;
            background: linear-gradient(135deg, #87CEEB 0%, #4ECDC4 50%, #90EE90 100%);
            border: 2px solid transparent;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .theme-preview:hover {
            border-color: #27ae60;
            transform: scale(1.02);
        }

        .theme-preview.active {
            border-color: #27ae60;
            box-shadow: 0 0 10px rgba(39, 174, 96, 0.5);
        }

        .dock-slot-config {
            background: rgba(0,0,0,0.2);
            padding: 8px;
            border-radius: 6px;
            margin-bottom: 8px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .game-canvas-container {
            position: absolute;
            top: calc(clamp(70px, 12vh, 90px) + clamp(120px, 20vh, 160px)); /* HUD + Docking height */
            left: 0;
            right: 0;
            bottom: 0; /* Use full available space */
            background: linear-gradient(135deg, #87CEEB 0%, #98FB98 100%);
            border-radius: 0;
            overflow: visible; /* Allow dragged shapes to extend beyond canvas boundaries */
        }

        #gameCanvas {
            width: 100%;
            height: 100%;
            display: block;
            background: transparent;
            cursor: crosshair;
        }

        /* Debug Info */
        .debug-info {
            position: absolute;
            bottom: clamp(5px, 2vh, 15px); /* Responsive bottom position */
            left: clamp(5px, 2vw, 15px); /* Responsive left position */
            color: white;
            font-size: clamp(10px, 2.5vw, 12px); /* Responsive font size */
            opacity: 0.7;
            font-family: monospace;
            background: rgba(0,0,0,0.7);
            padding: clamp(4px, 1.5vw, 8px); /* Responsive padding */
            border-radius: 6px;
            z-index: 100;
            max-width: 70vw; /* Prevent overflow */
            word-break: break-word;
        }

        /* Event Notifications */
        .event-notification {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: clamp(12px, 3vw, 20px) clamp(16px, 4vw, 24px); /* Responsive padding */
            border-radius: 12px;
            font-size: clamp(14px, 4vw, 18px); /* Responsive font size */
            font-weight: bold;
            z-index: 1000;
            opacity: 0;
            transition: all 0.3s ease;
            pointer-events: none;
            max-width: 80vw; /* Prevent overflow on small screens */
            min-width: 200px; /* Minimum readable width */
            text-align: center;
        }

        .event-notification.show {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1.1);
        }

        .event-notification.fall {
            background: rgba(231, 76, 60, 0.9);
            border: 2px solid #e74c3c;
        }

        .event-notification.collision {
            background: rgba(46, 204, 113, 0.9);
            border: 2px solid #2ecc71;
        }

        .event-notification.balance {
            background: rgba(52, 152, 219, 0.9);
            border: 2px solid #3498db;
        }

        /* Animations */
        @keyframes starPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.3); }
            100% { transform: scale(1.2); }
        }

        /* Test Controls (REMOVED - Debug squares eliminated) */

        /* Responsive Design - Mobile First */
        @media (max-width: 500px) {
            body {
                padding: 0;
            }
            
            .game-viewport {
                width: 100vw;
                height: 100vh;
                height: 100dvh;
                border-radius: 0;
                box-shadow: none;
                max-width: none;
                max-height: none;
                aspect-ratio: unset; /* Allow full screen on mobile */
                padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
            }
            
            .game-hud {
                height: clamp(60px, 10vh, 70px); /* Slightly smaller on mobile */
                padding: clamp(4px, 1.5vw, 8px);
            }
            
            .docking-area {
                height: clamp(100px, 18vh, 140px); /* Adjust for mobile */
                gap: clamp(3px, 1vw, 6px);
                padding: clamp(3px, 1vw, 6px);
            }
            
            .shape-slot {
                min-width: clamp(45px, 15vw, 60px); /* Optimize for mobile touch */
                min-height: clamp(45px, 15vw, 60px);
            }
            
            .game-canvas-container {
                border-radius: 0;
                top: calc(clamp(60px, 10vh, 70px) + clamp(100px, 18vh, 140px)); /* Updated for mobile HUD + docking */
            }
            
            /* Enhanced touch targets on mobile */
            .settings-button, .reset-button {
                min-width: 48px; /* Larger touch targets */
                min-height: 48px;
            }
            
            .timer-container {
                min-height: 48px; /* Better touch target */
            }
            
            .coin-counter {
                min-height: 48px; /* Better touch target */
                padding: 6px 10px;
            }
            
            /* Hide design mode on mobile */
            .design-sidebar {
                display: none;
            }
        }

        /* Tablet Portrait */
        @media (min-width: 501px) and (max-width: 1024px) and (orientation: portrait) {
            .game-viewport {
                max-width: 600px;
                max-height: 1067px; /* 600 * 16/9 */
            }
        }

        /* Desktop and Large Screens */
        @media (min-width: 1025px) {
            body {
                padding: 40px 20px;
            }
            
            .game-viewport {
                max-width: 500px;
                max-height: 889px; /* 500 * 16/9 */
                border-radius: 25px;
            }
        }

        /* Rotation Zones - Mobile Enhancement */
        .rotation-zone {
            position: absolute;
            width: 80px;
            height: 100%;
            top: 0;
            border: 2px dashed rgba(74, 144, 226, 0.4);
            border-radius: 10px;
            transition: all 0.3s ease;
            pointer-events: none;
            opacity: 0.3; /* Make visible for testing */
            z-index: 1000;
            display: block; /* Always visible for testing */
        }

        .rotation-zone.left {
            left: 0;
            background: linear-gradient(to right, rgba(229, 115, 115, 0.2), transparent);
            border-color: rgba(229, 115, 115, 0.4);
        }

        .rotation-zone.right {
            right: 0;
            background: linear-gradient(to left, rgba(129, 199, 132, 0.2), transparent);
            border-color: rgba(129, 199, 132, 0.4);
        }

        .rotation-zone.visible {
            display: block;
            opacity: 1;
        }

        .rotation-zone.active {
            border-color: rgba(74, 144, 226, 1);
            box-shadow: 0 0 20px rgba(74, 144, 226, 0.4);
        }

        .rotation-zone.left.active {
            background: linear-gradient(to right, rgba(229, 115, 115, 0.4), transparent);
            border-color: rgba(229, 115, 115, 1);
            box-shadow: 0 0 20px rgba(229, 115, 115, 0.4);
        }

        .rotation-zone.right.active {
            background: linear-gradient(to left, rgba(129, 199, 132, 0.4), transparent);
            border-color: rgba(129, 199, 132, 1);
            box-shadow: 0 0 20px rgba(129, 199, 132, 0.4);
        }

        .rotation-zone::before {
            content: "‚Ü∫";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2rem;
            color: rgba(255, 255, 255, 0.8);
            animation: zonePulse 2s infinite;
        }

        .rotation-zone.right::before {
            content: "‚Üª";
        }

        .rotation-zone.active::before {
            animation: zoneRotate 1s linear infinite;
            color: rgba(255, 255, 255, 1);
        }

        @keyframes zonePulse {
            0%, 100% { opacity: 0.6; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
        }

        @keyframes zoneRotate {
            from { transform: translate(-50%, -50%) rotate(0deg); }
            to { transform: translate(-50%, -50%) rotate(360deg); }
        }
        
    </style>
</head>
<body>
    <!-- Global drag overlay to prevent clipping -->
    <div id="dragOverlay"></div>
    
    <div class="game-viewport" id="gameContainer">
        <!-- Mobile Rotation Zones -->
        <div id="leftRotationZone" class="rotation-zone left"></div>
        <div id="rightRotationZone" class="rotation-zone right"></div>
            
            <!-- Game HUD -->
            <div class="game-hud">
                <div class="left-section">
                    <div class="score-display">
                        <div class="trophy-icon">üèÜ</div>
                        <span class="score-text" id="scoreText">0</span>
                    </div>
                    <div class="progress-area">
                        <div class="star-progress-container" onclick="initializeProgressBarInteraction()">
                            <div class="star-progress-bar" id="starProgressBar" style="width: 0%;"></div>
                            <div class="progress-markers">
                                <div class="progress-marker"></div>
                                <div class="progress-marker"></div>
                                <div class="progress-marker"></div>
                            </div>
                        </div>
                        <div class="star-markers">
                            <div class="star"></div>
                            <div class="star"></div>
                            <div class="star"></div>
                        </div>
                    </div>
                </div>

                <div class="middle-section">
                    <div class="level-display" id="levelDisplay">World 1-1</div>
                    <div class="timer-container" id="timerContainer" onclick="switchTimerMode()">
                        <span class="timer-text" id="gameTimer">0:00</span>
                        <div class="timer-mode-indicator timer-mode-elapsed" id="timerModeIndicator">‚è±</div>
                    </div>
                </div>

                <div class="right-section">
                    <div class="top-buttons">
                        <!-- Commented out pause button for mode toggle -->
                        <!-- <div class="settings-button" id="pauseButton">
                            <div class="pause-icon">
                                <div class="pause-bar"></div>
                                <div class="pause-bar"></div>
                            </div>
                        </div> -->
                        
                        <!-- Phase 2: Mode Toggle Switch -->
                        <div class="mode-toggle-switch" id="modeToggleSwitch" onclick="toggleModeSwitch()">
                            <div class="mode-toggle-slider">üéÆ</div>
                            <div class="mode-toggle-labels">Play/Design</div>
                        </div>
                        
                        <div class="reset-button" id="resetButton" onclick="resetLevel()">
                            <div class="reset-icon">‚ü≤</div>
                        </div>
                        
                        <div class="reset-button" id="mobileDebugButton" onclick="toggleMobileDebug()" style="background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%);">
                            <div class="reset-icon">üì±</div>
                        </div>
                    </div>
                    <div class="coin-counter" id="coinCounter" onclick="animateCoin()">
                        <div class="coin-icon">üí∞</div>
                        <span class="coin-amount" id="coinAmount">0</span>
                    </div>
                </div>
            </div>

            <!-- Docking Area -->
            <div class="docking-area" id="dockingArea">
                <div class="shape-slot" id="slot-square">
                    <div class="game-shape shape-square" data-shape="square" id="shape-square"></div>
                </div>
                <div class="shape-slot" id="slot-triangle">
                    <div class="game-shape shape-triangle" data-shape="triangle" id="shape-triangle"></div>
                </div>
                <div class="shape-slot" id="slot-circle">
                    <div class="game-shape shape-circle" data-shape="circle" id="shape-circle"></div>
                </div>
                <div class="shape-slot" id="slot-cross2">
                    <div class="game-shape shape-cross2" data-shape="cross2" id="shape-cross2"></div>
                </div>
                <div class="shape-slot" id="slot-l">
                    <div class="game-shape shape-l" data-shape="l" id="shape-l"></div>
                </div>
                <div class="shape-slot" id="slot-cross">
                    <div class="game-shape shape-cross" data-shape="cross" id="shape-cross"></div>
                </div>
                <div class="shape-slot" id="slot-barbell-one">
                    <div class="game-shape shape-barbell-one" data-shape="barbell-one" id="shape-barbell-one"></div>
                </div>
                <div class="shape-slot" id="slot-barbell-two">
                    <div class="game-shape shape-barbell-two" data-shape="barbell-two" id="shape-barbell-two"></div>
                </div>
                <div class="shape-slot" id="slot-diamond-barbell">
                    <div class="game-shape shape-diamond-barbell" data-shape="diamond-barbell" id="shape-diamond-barbell"></div>
                </div>
            </div>

            <!-- Game Canvas Area -->
            <div class="game-canvas-container">
                <canvas id="gameCanvas"></canvas>
            </div>

            <!-- Event Notification System -->
            <div class="event-notification" id="eventNotification"></div>

            <!-- Debug Info -->
            <div class="debug-info" id="debugInfo">
                Shapes: 0/9 | Events: 0 | Collisions: 0 | FPS: 60
            </div>

            <!-- Rotation Indicator -->
            <div class="rotation-indicator" id="rotationIndicator">
                üîÑ R/E or ‚Üê/‚Üí to rotate
            </div>
    </div>

    <!-- Phase 2: Design Mode Sidebar -->
    <div class="design-sidebar" id="designSidebar">
        <div class="sidebar-header">
            <h2>üîß Level Editor</h2>
            <p>Configure level settings and dock layout</p>
        </div>

        <!-- Level Configuration -->
        <div class="sidebar-section">
            <div class="sidebar-title">üìã Level Configuration</div>
            
            <div class="config-group">
                <label class="config-label">World-Level</label>
                <input type="text" class="config-input" id="levelNumber" value="1-1" placeholder="1-1">
            </div>

            <div class="config-group">
                <label class="config-label">Timer Mode</label>
                <select class="config-select" id="timerMode" onchange="updateTimerModeConfig()">
                    <option value="none">No Timer</option>
                    <option value="elapsed" selected>Count-Up Timer</option>
                    <option value="countdown">Count-Down Timer</option>
                </select>
            </div>
            
            <div class="config-group">
                <label class="config-label">Starting Timer Value</label>
                <input type="number" class="config-input" id="timerStart" value="60" min="0" max="3600" placeholder="Seconds">
            </div>
            
            <div class="config-group">
                <label class="config-label">End-Level Countdown</label>
                <input type="number" class="config-input" id="endLevelDuration" value="5" min="3" max="15" placeholder="Seconds">
            </div>
        </div>

        <!-- v9: Theme Selection -->
        <div class="sidebar-section">
            <div class="sidebar-title">üé® Theme Selection</div>
            
            <div class="config-group">
                <label class="config-label">Visual Theme</label>
                <select class="config-select" id="themeSelector" onchange="changeTheme()">
                    <option value="classic" selected>Classic Puzzle</option>
                    <option value="underwater">Ocean Adventure</option>
                    <option value="space">Cosmic Voyage</option>
                    <option value="forest">Enchanted Forest</option>
                </select>
            </div>

            <div class="config-group">
                <label class="config-label">Canvas Enhancements</label>
                <div class="checkbox-group">
                    <label class="checkbox-label">
                        <input type="checkbox" id="enableCanvas" checked onchange="toggleCanvasEnhancements()">
                        Enable Advanced Graphics
                    </label>
                    <label class="checkbox-label">
                        <input type="checkbox" id="enableParticles" checked onchange="toggleParticleEffects()">
                        Particle Effects
                    </label>
                    <label class="checkbox-label">
                        <input type="checkbox" id="enableAnimations" checked onchange="toggleAnimations()">
                        Shape Animations
                    </label>
                </div>
            </div>

            <div class="config-group">
                <label class="config-label">Mobile Touch Offset</label>
                <div class="checkbox-group">
                    <label class="checkbox-label">
                        <input type="checkbox" id="enableTouchOffset" checked onchange="toggleTouchOffset()">
                        Enable Touch Offset
                    </label>
                </div>
                <div class="config-sub-group">
                    <label class="config-label">X Offset (Horizontal)</label>
                    <input type="range" id="touchOffsetX" min="-100" max="100" value="0" 
                           onchange="updateTouchOffset()" oninput="updateTouchOffsetDisplay()">
                    <span class="range-value" id="touchOffsetXValue">0px</span>
                </div>
                <div class="config-sub-group">
                    <label class="config-label">Y Offset (Vertical)</label>
                    <input type="range" id="touchOffsetY" min="-150" max="50" value="-80" 
                           onchange="updateTouchOffset()" oninput="updateTouchOffsetDisplay()">
                    <span class="range-value" id="touchOffsetYValue">-80px</span>
                </div>
            </div>
        </div>

        <!-- Dock Configuration -->
        <div class="sidebar-section">
            <div class="sidebar-title">üîß Dock Configuration</div>
            
            <div class="config-group">
                <label class="config-label">Number of Dock Slots</label>
                <input type="number" class="config-input" id="dockSlotCount" value="9" min="3" max="12" onchange="generateDockSlots()">
            </div>
            
            <div class="config-group">
                <label class="config-label">Barbell Orientation in Dock</label>
                <select class="config-select" id="barbellOrientation" onchange="updateBarbellOrientation()">
                    <option value="vertical" selected>Vertical (90¬∞)</option>
                    <option value="horizontal">Horizontal (0¬∞)</option>
                </select>
            </div>
            
            <div class="config-group">
                <label class="config-label">Shape Assignment</label>
                <div id="dockSlotsContainer">
                    <!-- Dynamic dock slots will be generated here -->
                </div>
            </div>
        </div>

        <!-- Actions -->
        <div class="sidebar-section">
            <div class="sidebar-title">‚ö° Actions</div>
            
            <button class="config-btn" id="applyChangesBtn" onclick="applyLevelChanges()">
                Apply Level Changes
            </button>
            
            <button class="config-btn" onclick="resetLevel()" style="background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);">
                Reset Level
            </button>
            
            <button class="config-btn" onclick="syncDockToDesign()" style="background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);">
                Sync Current Dock
            </button>
        </div>
    </div>



    <!-- Matter.js Physics Engine -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    
    <script>
        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë CANVAS ENHANCEMENT CONFIGURATION v9
          ‚ïë Feature flags and settings for texture, theme, and visual enhancement system
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        const CANVAS_CONFIG = {
            // Feature flags
            enabled: true,                    // Master switch for canvas enhancements
            useTextures: true,               // Enable texture system for shapes
            useThemes: true,                 // Enable theme switching
            useParticles: true,              // Enable particle effects
            useAnimations: true,             // Enable shape animations
            useBackgroundTextures: true,     // Enable background textures
            usePlatformTextures: true,       // Enable platform textures
            
            // Performance settings
            maxParticles: 50,                // Maximum particles on screen
            textureQuality: 'high',          // 'low', 'medium', 'high'
            enableLOD: true,                 // Level of detail for small shapes
            cacheTextures: true,             // Cache rendered textures
            
            // Default theme and fallback behavior
            defaultTheme: 'classic',
            fallbackToSolid: true,           // Use solid colors if textures fail
            showLoadingProgress: true,       // Show loading indicators
            
            // Debug options
            debugMode: false,                // Show texture loading info
            showBounds: false,               // Show texture boundaries
            logAssetLoading: true            // Console logging for asset loading
        };

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë THEME DEFINITIONS - VISUAL THEMES FOR THE GAME
          ‚ïë Each theme defines complete visual styling for all game elements
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        const THEME_DEFINITIONS = {
            classic: {
                name: "Classic Puzzle",
                description: "Clean, geometric shapes with simple colors",
                background: {
                    type: "gradient",
                    colors: ["#87CEEB", "#4ECDC4", "#90EE90"],
                    texture: null,
                    // Image background support
                    image: {
                        url: null,          // "path/to/background.jpg"
                        repeat: "no-repeat", // "repeat", "repeat-x", "repeat-y", "no-repeat"
                        position: "center",  // "center", "top", "bottom", "left", "right"
                        size: "cover"        // "cover", "contain", "auto", "100% 100%"
                    }
                },
                platform: {
                    texture: null,  // Will use solid color initially
                    color: "#8B4513",
                    material: "wood",
                    pattern: "solid",
                    // Platform image texture support
                    image: {
                        url: null,          // "path/to/platform-texture.jpg"
                        repeat: "repeat",    // How to repeat the texture
                        blend: "multiply",   // How to blend with base color
                        opacity: 0.8        // Texture opacity (0-1)
                    }
                },
                shapes: {
                    useTextures: false,      // Start with solid colors
                    baseTexturePath: null,
                    specialEffects: ["shadow"],
                    animations: ["bounce"],
                    // Shape texture mapping
                    textures: {
                        square: { url: null, repeat: "repeat", blend: "multiply", opacity: 0.7 },
                        circle: { url: null, repeat: "repeat", blend: "multiply", opacity: 0.7 },
                        triangle: { url: null, repeat: "repeat", blend: "multiply", opacity: 0.7 },
                        cross: { url: null, repeat: "repeat", blend: "multiply", opacity: 0.7 },
                        cross2: { url: null, repeat: "repeat", blend: "multiply", opacity: 0.7 },
                        l: { url: null, repeat: "repeat", blend: "multiply", opacity: 0.7 },
                        "barbell-one": { url: null, repeat: "repeat", blend: "multiply", opacity: 0.7 },
                        "barbell-two": { url: null, repeat: "repeat", blend: "multiply", opacity: 0.7 },
                        "diamond-barbell": { url: null, repeat: "repeat", blend: "multiply", opacity: 0.7 }
                    }
                },
                particles: {
                    style: "geometric",
                    colors: ["#FFD700", "#FF6B6B", "#4ECDC4"]
                }
            },
            
            underwater: {
                name: "Ocean Adventure", 
                description: "Dive into an underwater world with sea creatures",
                background: {
                    type: "gradient",
                    colors: ["#006994", "#0077be", "#4da6ff"],
                    texture: "coral_bubbles",
                    // Ocean background image support
                    image: {
                        url: null,          // "textures/ocean-background.jpg"
                        repeat: "no-repeat",
                        position: "center", 
                        size: "cover"
                    }
                },
                platform: {
                    texture: "coral_bubbles",
                    color: "#2E8B57",
                    material: "coral",
                    pattern: "bubbles",
                    // Coral platform texture
                    image: {
                        url: null,          // "textures/coral-platform.jpg"
                        repeat: "repeat-x",
                        blend: "overlay",
                        opacity: 0.6
                    }
                },
                shapes: {
                    useTextures: true,
                    baseTexturePath: "textures/ocean/",
                    specialEffects: ["bubble", "flow"],
                    animations: ["float", "wave"],
                    textures: {
                        square: { url: null, repeat: "repeat", blend: "overlay", opacity: 0.8 },
                        circle: { url: null, repeat: "repeat", blend: "overlay", opacity: 0.8 },
                        triangle: { url: null, repeat: "repeat", blend: "overlay", opacity: 0.8 },
                        cross: { url: null, repeat: "repeat", blend: "overlay", opacity: 0.8 },
                        cross2: { url: null, repeat: "repeat", blend: "overlay", opacity: 0.8 },
                        l: { url: null, repeat: "repeat", blend: "overlay", opacity: 0.8 },
                        "barbell-one": { url: null, repeat: "repeat", blend: "overlay", opacity: 0.8 },
                        "barbell-two": { url: null, repeat: "repeat", blend: "overlay", opacity: 0.8 },
                        "diamond-barbell": { url: null, repeat: "repeat", blend: "overlay", opacity: 0.8 }
                    }
                },
                particles: {
                    style: "bubbles",
                    colors: ["#00CED1", "#40E0D0", "#48CAE4"]
                }
            },
            
            space: {
                name: "Cosmic Voyage",
                description: "Journey through space with planets and stars", 
                background: {
                    type: "gradient",
                    colors: ["#0B1426", "#1a237e", "#3949ab"],
                    texture: null,
                    // Space background image support
                    image: {
                        url: null,          // "textures/space-background.jpg"
                        repeat: "no-repeat",
                        position: "center",
                        size: "cover"
                    }
                },
                platform: {
                    texture: null,
                    color: "#708090",
                    material: "metal",
                    pattern: "tech",
                    // Metal platform texture
                    image: {
                        url: null,          // "textures/metal-platform.jpg"
                        repeat: "repeat",
                        blend: "hard-light",
                        opacity: 0.9
                    }
                },
                shapes: {
                    useTextures: true,
                    baseTexturePath: "textures/space/",
                    specialEffects: ["starlight", "cosmic"],
                    animations: ["rotate", "pulse"],
                    textures: {
                        square: { url: null, repeat: "repeat", blend: "screen", opacity: 0.6 },
                        circle: { url: null, repeat: "repeat", blend: "screen", opacity: 0.6 },
                        triangle: { url: null, repeat: "repeat", blend: "screen", opacity: 0.6 },
                        cross: { url: null, repeat: "repeat", blend: "screen", opacity: 0.6 },
                        cross2: { url: null, repeat: "repeat", blend: "screen", opacity: 0.6 },
                        l: { url: null, repeat: "repeat", blend: "screen", opacity: 0.6 },
                        "barbell-one": { url: null, repeat: "repeat", blend: "screen", opacity: 0.6 },
                        "barbell-two": { url: null, repeat: "repeat", blend: "screen", opacity: 0.6 },
                        "diamond-barbell": { url: null, repeat: "repeat", blend: "screen", opacity: 0.6 }
                    }
                },
                particles: {
                    style: "stardust", 
                    colors: ["#FFD700", "#FF1493", "#00BFFF"]
                }
            },
            
            forest: {
                name: "Enchanted Forest",
                description: "Magical woodland with natural elements",
                background: {
                    type: "gradient",
                    colors: ["#2E7D32", "#4CAF50", "#8BC34A"],
                    texture: null,
                    // Forest background image support
                    image: {
                        url: null,          // "textures/forest-background.jpg"
                        repeat: "no-repeat",
                        position: "center",
                        size: "cover"
                    }
                },
                platform: {
                    texture: null,
                    color: "#8B4513", 
                    material: "wood",
                    pattern: "natural",
                    // Wood platform texture
                    image: {
                        url: null,          // "textures/wood-platform.jpg"
                        repeat: "repeat",
                        blend: "multiply",
                        opacity: 0.7
                    }
                },
                shapes: {
                    useTextures: true,
                    baseTexturePath: "textures/forest/",
                    specialEffects: ["leaf", "sparkle", "magic"],
                    animations: ["sway", "glow"],
                    textures: {
                        square: { url: null, repeat: "repeat", blend: "multiply", opacity: 0.8 },
                        circle: { url: null, repeat: "repeat", blend: "multiply", opacity: 0.8 },
                        triangle: { url: null, repeat: "repeat", blend: "multiply", opacity: 0.8 },
                        cross: { url: null, repeat: "repeat", blend: "multiply", opacity: 0.8 },
                        cross2: { url: null, repeat: "repeat", blend: "multiply", opacity: 0.8 },
                        l: { url: null, repeat: "repeat", blend: "multiply", opacity: 0.8 },
                        "barbell-one": { url: null, repeat: "repeat", blend: "multiply", opacity: 0.8 },
                        "barbell-two": { url: null, repeat: "repeat", blend: "multiply", opacity: 0.8 },
                        "diamond-barbell": { url: null, repeat: "repeat", blend: "multiply", opacity: 0.8 }
                    }
                },
                particles: {
                    style: "nature",
                    colors: ["#228B22", "#DAA520", "#FF6347"]
                }
            }
        };

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë UNIFIED SHAPE CONFIGURATION - PHYSICS-FIRST APPROACH
          ‚ïë Single source of truth for ALL shape appearances and properties
          ‚ïë Eliminates dual CSS/Canvas systems in favor of physics-based rendering
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        const SHAPE_CONFIG = {
            square: {
                // Visual properties
                color: '#F39C12',
                stroke: '#E67E22',
                strokeWidth: 2,

                // Physical properties  
                width: 35,
                height: 35,
                density: 0.5,
                friction: 0.7,
                restitution: 0.2,

                // Rendering properties
                type: 'rectangle',
                borderRadius: 3
            },

            triangle: {
                color: '#9B59B6',
                stroke: '#8E44AD', 
                strokeWidth: 2,

                // Triangle vertices (relative to center)
                vertices: [
                    { x: 0, y: -15 },      // Top point
                    { x: -17.5, y: 15 },   // Bottom left
                    { x: 17.5, y: 15 }     // Bottom right
                ],
                density: 0.5,
                friction: 0.7,
                restitution: 0.2,

                type: 'polygon'
            },

            circle: {
                color: '#1ABC9C',
                stroke: '#16A085',
                strokeWidth: 2,

                radius: 17.5,
                density: 0.5,
                friction: 0.7,
                restitution: 0.2,

                type: 'circle'
            },

            cross: {
                color: '#E74C3C',         // Changed from green to red for better contrast
                stroke: '#C0392B',
                strokeWidth: 2,

                // Cross consists of two overlapping rectangles
                parts: [
                    {
                        type: 'rectangle',
                        width: 15,
                        height: 35,
                        offsetX: 0,
                        offsetY: 0
                    },
                    {
                        type: 'rectangle', 
                        width: 35,
                        height: 15,
                        offsetX: 0,
                        offsetY: 0
                    }
                ],
                density: 0.5,
                friction: 0.7,
                restitution: 0.2,

                type: 'compound'
            },

            cross2: {
                color: '#3498DB',         // Changed from pink to blue for better contrast
                stroke: '#2980B9',
                strokeWidth: 2,

                parts: [
                    {
                        type: 'rectangle',
                        width: 15,
                        height: 35,
                        offsetX: 0,
                        offsetY: 0
                    },
                    {
                        type: 'rectangle',
                        width: 35, 
                        height: 15,
                        offsetX: 0,
                        offsetY: 0
                    }
                ],
                density: 0.5,
                friction: 0.7,
                restitution: 0.2,

                type: 'compound'
            },

            l: {
                color: '#8E44AD',         // Changed from orange to purple for variety
                stroke: '#732D91',
                strokeWidth: 2,

                // L-shape consists of two rectangles
                parts: [
                    {
                        type: 'rectangle',
                        width: 15,
                        height: 35,
                        offsetX: -7.5,      // Left side
                        offsetY: 0
                    },
                    {
                        type: 'rectangle',
                        width: 15,
                        height: 15, 
                        offsetX: 7.5,       // Right extension
                        offsetY: 10         // Bottom alignment
                    }
                ],
                density: 0.5,
                friction: 0.7,
                restitution: 0.2,

                type: 'compound'
            },

            'barbell-one': {
                color: '#16A085',
                stroke: '#138D75',
                strokeWidth: 2,

                parts: [
                    {
                        type: 'rectangle',
                        width: 31,
                        height: 5,
                        offsetX: -12,
                        offsetY: 0,
                        color: '#E74C3C',   // Bar color
                        stroke: '#C0392B'
                    },
                    {
                        type: 'circle',
                        radius: 8,
                        offsetX: 12,
                        offsetY: 0,
                        color: '#3498DB',   // Weight color
                        stroke: '#2980B9'
                    }
                ],
                density: 0.5,
                friction: 0.7,
                restitution: 0.2,

                type: 'compound'
            },

            'barbell-two': {
                color: '#D35400',
                stroke: '#BA4A00',
                strokeWidth: 2,

                parts: [
                    {
                        type: 'rectangle',
                        width: 26,
                        height: 5,
                        offsetX: 0,
                        offsetY: 0,
                        color: '#E74C3C',
                        stroke: '#C0392B'
                    },
                    {
                        type: 'circle',
                        radius: 9,
                        offsetX: -17,
                        offsetY: 0,
                        color: '#3498DB',
                        stroke: '#2980B9'
                    },
                    {
                        type: 'circle',
                        radius: 9,
                        offsetX: 17,
                        offsetY: 0,
                        color: '#3498DB',
                        stroke: '#2980B9'
                    }
                ],
                density: 0.5,
                friction: 0.7,
                restitution: 0.2,

                type: 'compound'
            },

            'diamond-barbell': {
                color: '#C0392B',
                stroke: '#A93226',
                strokeWidth: 2,

                parts: [
                    {
                        type: 'rectangle',
                        width: 26,
                        height: 5,
                        offsetX: -13,
                        offsetY: 0,
                        color: '#E74C3C',
                        stroke: '#C0392B'
                    },
                    {
                        type: 'diamond',
                        width: 12,
                        height: 12,
                        offsetX: 13,
                        offsetY: 0,
                        color: '#F39C12',
                        stroke: '#E67E22'
                    }
                ],
                density: 0.5,
                friction: 0.7,
                restitution: 0.2,

                type: 'compound'
            }
        };

        // Utility functions for shape configuration
        function getShapeConfig(shapeType) {
            return SHAPE_CONFIG[shapeType] || null;
        }

        function getAllShapeTypes() {
            return Object.keys(SHAPE_CONFIG);
        }

        function validateShapeConfig() {
            // Validation logic can be added here
            return true;
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë ASSET MANAGER - HANDLES TEXTURE LOADING AND THEME ASSETS
          ‚ïë Provides centralized asset management with fallbacks and caching
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        class AssetManager {
            constructor() {
                this.themes = {};
                this.currentTheme = CANVAS_CONFIG.defaultTheme;
                this.loadingProgress = 0;
                this.isLoaded = false;
                this.textureCache = new Map();
                this.loadingCallbacks = [];
                this.imageCache = new Map(); // Cache for loaded images
                this.loadingPromises = new Map(); // Track loading promises
            }

            async loadTheme(themeName) {
                if (!CANVAS_CONFIG.enabled || !CANVAS_CONFIG.useThemes) {
                    console.log('üì¶ Asset Manager: Canvas enhancements disabled');
                    return;
                }

                console.log(`üì¶ Loading theme: ${themeName}`);
                
                try {
                    const themeConfig = THEME_DEFINITIONS[themeName];
                    if (!themeConfig) {
                        console.error(`‚ùå Theme not found: ${themeName}`);
                        return;
                    }

                    // Initialize theme structure
                    this.themes[themeName] = {
                        config: themeConfig,
                        assets: {
                            backgroundImage: null,
                            platformImage: null,
                            shapeTextures: {}
                        },
                        loaded: false
                    };

                    // Load all images for this theme
                    await this.loadThemeImages(themeName, themeConfig);
                    
                    this.themes[themeName].loaded = true;
                    this.loadingProgress = 100;
                    this.isLoaded = true;
                    
                    console.log(`‚úÖ Theme loaded: ${themeName}`);
                    this.notifyLoadingComplete(themeName);
                    
                } catch (error) {
                    console.error(`‚ùå Failed to load theme ${themeName}:`, error);
                    this.loadingProgress = 0;
                }
            }

            async loadThemeImages(themeName, themeConfig) {
                const loadPromises = [];
                const theme = this.themes[themeName];

                // Load background image
                if (themeConfig.background.image && themeConfig.background.image.url) {
                    const bgPromise = this.loadImage(themeConfig.background.image.url)
                        .then(img => {
                            theme.assets.backgroundImage = img;
                            console.log(`üñºÔ∏è Background image loaded for ${themeName}`);
                        })
                        .catch(err => {
                            console.warn(`‚ö†Ô∏è Background image failed for ${themeName}:`, err.message);
                        });
                    loadPromises.push(bgPromise);
                }

                // Load platform image
                if (themeConfig.platform.image && themeConfig.platform.image.url) {
                    const platformPromise = this.loadImage(themeConfig.platform.image.url)
                        .then(img => {
                            theme.assets.platformImage = img;
                            console.log(`üèóÔ∏è Platform image loaded for ${themeName}`);
                        })
                        .catch(err => {
                            console.warn(`‚ö†Ô∏è Platform image failed for ${themeName}:`, err.message);
                        });
                    loadPromises.push(platformPromise);
                }

                // Load shape textures
                if (themeConfig.shapes.textures) {
                    Object.keys(themeConfig.shapes.textures).forEach(shapeType => {
                        const textureConfig = themeConfig.shapes.textures[shapeType];
                        if (textureConfig.url) {
                            const shapePromise = this.loadImage(textureConfig.url)
                                .then(img => {
                                    theme.assets.shapeTextures[shapeType] = img;
                                    console.log(`üî∂ Shape texture loaded for ${shapeType} in ${themeName}`);
                                })
                                .catch(err => {
                                    console.warn(`‚ö†Ô∏è Shape texture failed for ${shapeType} in ${themeName}:`, err.message);
                                });
                            loadPromises.push(shapePromise);
                        }
                    });
                }

                // Wait for all images to load (or fail)
                await Promise.allSettled(loadPromises);
                
                const successCount = loadPromises.length;
                console.log(`üì¶ Theme ${themeName}: Attempted to load ${successCount} images`);
            }

            async loadImage(url) {
                // Check cache first
                if (this.imageCache.has(url)) {
                    return this.imageCache.get(url);
                }

                // Check if already loading
                if (this.loadingPromises.has(url)) {
                    return this.loadingPromises.get(url);
                }

                // Create loading promise
                const loadPromise = new Promise((resolve, reject) => {
                    const img = new Image();
                    img.crossOrigin = 'anonymous'; // Enable CORS for external images
                    
                    img.onload = () => {
                        this.imageCache.set(url, img);
                        this.loadingPromises.delete(url);
                        resolve(img);
                    };
                    
                    img.onerror = () => {
                        this.loadingPromises.delete(url);
                        reject(new Error(`Failed to load image: ${url}`));
                    };
                    
                    img.src = url;
                    
                    // Set timeout for image loading
                    setTimeout(() => {
                        if (!img.complete) {
                            this.loadingPromises.delete(url);
                            reject(new Error(`Image load timeout: ${url}`));
                        }
                    }, 10000); // 10 second timeout
                });

                this.loadingPromises.set(url, loadPromise);
                return loadPromise;
            }

            // Get loaded image assets
            getBackgroundImage(themeName = null) {
                const theme = themeName ? this.getTheme(themeName) : this.getCurrentTheme();
                return theme?.assets?.backgroundImage || null;
            }

            getPlatformImage(themeName = null) {
                const theme = themeName ? this.getTheme(themeName) : this.getCurrentTheme();
                return theme?.assets?.platformImage || null;
            }

            getShapeTexture(shapeType, themeName = null) {
                const theme = themeName ? this.getTheme(themeName) : this.getCurrentTheme();
                return theme?.assets?.shapeTextures?.[shapeType] || null;
            }

            // Clear cache (useful for development)
            clearImageCache() {
                this.imageCache.clear();
                this.loadingPromises.clear();
                console.log('üßπ Image cache cleared');
            }

            getTheme(themeName) {
                return this.themes[themeName] || null;
            }

            getCurrentTheme() {
                return this.getTheme(this.currentTheme);
            }

            getBackgroundStyle(themeName = null) {
                const theme = themeName ? this.getTheme(themeName) : this.getCurrentTheme();
                if (!theme) return null;
                
                const bgConfig = theme.config.background;
                const bgImage = this.getBackgroundImage(themeName);
                
                return {
                    type: bgConfig.type,
                    colors: bgConfig.colors,
                    image: bgImage,
                    imageConfig: bgConfig.image || null
                };
            }

            getPlatformStyle(themeName = null) {
                const theme = themeName ? this.getTheme(themeName) : this.getCurrentTheme();
                if (!theme) return null;
                
                const platformConfig = theme.config.platform;
                const platformImage = this.getPlatformImage(themeName);
                
                return {
                    ...platformConfig,
                    image: platformImage,
                    imageConfig: platformConfig.image || null
                };
            }

            getShapeStyle(shapeType, themeName = null) {
                const theme = themeName ? this.getTheme(themeName) : this.getCurrentTheme();
                if (!theme) return null;
                
                const shapeConfig = theme.config.shapes;
                const shapeTexture = this.getShapeTexture(shapeType, themeName);
                
                if (shapeConfig.textures && shapeConfig.textures[shapeType]) {
                    return {
                        useTextures: shapeConfig.useTextures,
                        texture: shapeTexture,
                        textureConfig: shapeConfig.textures[shapeType]
                    };
                }
                
                return {
                    useTextures: false,
                    texture: null,
                    textureConfig: null
                };
            }

            getParticleStyle(themeName = null) {
                const theme = themeName ? this.getTheme(themeName) : this.getCurrentTheme();
                if (!theme) return null;
                
                return theme.config.particles;
            }

            notifyLoadingComplete(themeName) {
                this.loadingCallbacks.forEach(callback => {
                    try {
                        callback(themeName);
                    } catch (error) {
                        console.error('‚ùå Error in loading callback:', error);
                    }
                });
            }

            onThemeLoaded(callback) {
                this.loadingCallbacks.push(callback);
            }
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë THEME MANAGER - HANDLES THEME SWITCHING AND VISUAL UPDATES
          ‚ïë Coordinates theme changes across all game systems
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        class ThemeManager {
            constructor(assetManager, gameManager) {
                this.assetManager = assetManager;
                this.gameManager = gameManager;
                this.currentTheme = CANVAS_CONFIG.defaultTheme;
                this.isTransitioning = false;
                this.transitionCallbacks = [];
            }

            async switchTheme(themeName, animated = true) {
                if (!CANVAS_CONFIG.enabled || !CANVAS_CONFIG.useThemes) {
                    console.log('üé® Theme Manager: Theme switching disabled');
                    return;
                }

                if (this.isTransitioning || !THEME_DEFINITIONS[themeName]) {
                    console.log(`üé® Cannot switch to theme: ${themeName}`);
                    return;
                }

                console.log(`üé® Switching theme from ${this.currentTheme} to ${themeName}`);
                this.isTransitioning = true;

                try {
                    // Load the new theme
                    await this.assetManager.loadTheme(themeName);
                    
                    // Update visual elements
                    this.updateBackgroundStyle(themeName);
                    this.updatePlatformStyle(themeName);
                    
                    // Update current theme
                    this.currentTheme = themeName;
                    this.assetManager.currentTheme = themeName;
                    
                    // Notify listeners
                    this.notifyThemeChanged(themeName);
                    
                    console.log(`‚úÖ Theme switched to: ${themeName}`);
                    
                } catch (error) {
                    console.error(`‚ùå Failed to switch theme to ${themeName}:`, error);
                } finally {
                    this.isTransitioning = false;
                }
            }

            updateBackgroundStyle(themeName) {
                const bgStyle = this.assetManager.getBackgroundStyle(themeName);
                if (!bgStyle || !this.gameManager?.physicsManager) return;

                // Update the physics manager's background rendering
                if (bgStyle.type === 'gradient') {
                    this.gameManager.physicsManager.backgroundGradient = bgStyle.colors;
                    console.log(`üé® Updated background gradient for ${themeName}:`, bgStyle.colors);
                }
            }

            updatePlatformStyle(themeName) {
                const platformStyle = this.assetManager.getPlatformStyle(themeName);
                if (!platformStyle || !this.gameManager?.physicsManager) return;

                // Update platform color
                this.gameManager.physicsManager.platformColor = platformStyle.color;
                console.log(`üé® Updated platform color for ${themeName}:`, platformStyle.color);
            }

            getAvailableThemes() {
                return Object.keys(THEME_DEFINITIONS);
            }

            getCurrentTheme() {
                return this.currentTheme;
            }

            onThemeChanged(callback) {
                this.transitionCallbacks.push(callback);
            }

            notifyThemeChanged(themeName) {
                this.transitionCallbacks.forEach(callback => {
                    try {
                        callback(themeName);
                    } catch (error) {
                        console.error('‚ùå Error in theme change callback:', error);
                    }
                });
            }
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë PARTICLE SYSTEM - THEME-BASED VISUAL EFFECTS
          ‚ïë Creates and manages particle effects based on current theme
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        class ParticleSystem {
            constructor(canvas, assetManager) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.assetManager = assetManager;
                this.particles = [];
                this.maxParticles = CANVAS_CONFIG.maxParticles;
                this.ambientParticleTimer = 0;
                this.ambientParticleInterval = 1000; // Spawn ambient particle every 1 second
            }

            createThemeParticles(type, x, y, count = 5) {
                if (!CANVAS_CONFIG.enabled || !CANVAS_CONFIG.useParticles) return;

                const particleStyle = this.assetManager.getParticleStyle();
                if (!particleStyle) return;

                for (let i = 0; i < Math.min(count, this.maxParticles - this.particles.length); i++) {
                    this.particles.push(this.createParticle(particleStyle, x, y, type));
                }
            }

            createParticle(style, x, y, type) {
                const colors = style.colors;
                const color = colors[Math.floor(Math.random() * colors.length)];
                
                return {
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4 - 2,
                    life: 1.0,
                    decay: 0.02 + Math.random() * 0.02,
                    size: 2 + Math.random() * 3,
                    color: color,
                    style: style.style
                };
            }

            createAmbientParticle() {
                if (!CANVAS_CONFIG.enabled || !CANVAS_CONFIG.useParticles) return;
                if (this.particles.length >= this.maxParticles) return;

                const particleStyle = this.assetManager.getParticleStyle();
                if (!particleStyle) return;

                // Create particles from random positions around the canvas edges
                const side = Math.floor(Math.random() * 4); // 0=top, 1=right, 2=bottom, 3=left
                let x, y, vx, vy;

                switch(side) {
                    case 0: // Top
                        x = Math.random() * this.canvas.width;
                        y = -10;
                        vx = (Math.random() - 0.5) * 2;
                        vy = Math.random() * 2 + 1;
                        break;
                    case 1: // Right  
                        x = this.canvas.width + 10;
                        y = Math.random() * this.canvas.height;
                        vx = -Math.random() * 2 - 1;
                        vy = (Math.random() - 0.5) * 2;
                        break;
                    case 2: // Bottom
                        x = Math.random() * this.canvas.width;
                        y = this.canvas.height + 10;
                        vx = (Math.random() - 0.5) * 2;
                        vy = -Math.random() * 2 - 1;
                        break;
                    case 3: // Left
                        x = -10;
                        y = Math.random() * this.canvas.height;
                        vx = Math.random() * 2 + 1;
                        vy = (Math.random() - 0.5) * 2;
                        break;
                }

                const colors = particleStyle.colors;
                const color = colors[Math.floor(Math.random() * colors.length)];
                
                this.particles.push({
                    x: x,
                    y: y,
                    vx: vx,
                    vy: vy,
                    life: 1.0,
                    decay: 0.01 + Math.random() * 0.01, // Slower decay for ambient particles
                    size: 1 + Math.random() * 2, // Smaller ambient particles
                    color: color,
                    style: particleStyle.style,
                    isAmbient: true
                });
            }

            update(deltaTime) {
                if (!CANVAS_CONFIG.useParticles) return;

                // Spawn ambient background particles periodically
                this.ambientParticleTimer += deltaTime;
                if (this.ambientParticleTimer >= this.ambientParticleInterval) {
                    this.createAmbientParticle();
                    this.ambientParticleTimer = 0;
                }

                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const particle = this.particles[i];
                    
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.vy += 0.1; // Gravity
                    particle.life -= particle.decay;
                    
                    if (particle.life <= 0) {
                        this.particles.splice(i, 1);
                    }
                }
            }

            render() {
                if (!CANVAS_CONFIG.useParticles) return;

                this.particles.forEach(particle => {
                    this.ctx.save();
                    this.ctx.globalAlpha = particle.life;
                    this.ctx.fillStyle = particle.color;
                    
                    if (particle.style === 'bubbles') {
                        this.ctx.strokeStyle = particle.color;
                        this.ctx.lineWidth = 1;
                        this.ctx.beginPath();
                        this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        this.ctx.stroke();
                    } else {
                        this.ctx.beginPath();
                        this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                    
                    this.ctx.restore();
                });
            }
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë PHYSICS-BASED SHAPE RENDERER
          ‚ïë Renders shapes consistently using physics configuration
          ‚ïë Used for both dock previews and physics simulation
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        class PhysicsShapeRenderer {
            renderShapeOnCanvas(ctx, shapeType, x, y, rotation = 0, scale = 1) {
                console.log(`üé® renderShapeOnCanvas: ${shapeType} at (${x},${y})`);
                const config = getShapeConfig(shapeType);
                if (!config) {
                    console.error(`‚ùå No config found for renderShapeOnCanvas: ${shapeType}`);
                    return;
                }

                console.log(`üìê Config for ${shapeType}:`, config);

                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.scale(scale, scale);

                switch (config.type) {
                    case 'rectangle':
                        console.log(`üì¶ Drawing rectangle for ${shapeType}`);
                        this.drawRectangle(ctx, config);
                        break;
                    case 'circle':
                        console.log(`‚≠ï Drawing circle for ${shapeType}`);
                        this.drawCircle(ctx, config);
                        break;
                    case 'polygon':
                        console.log(`üî∑ Drawing polygon for ${shapeType}`);
                        this.drawPolygon(ctx, config);
                        break;
                    case 'compound':
                        console.log(`üîó Drawing compound shape for ${shapeType}`);
                        this.drawCompoundShape(ctx, config);
                        break;
                    default:
                        console.error(`‚ùå Unknown shape type: ${config.type} for ${shapeType}`);
                }

                ctx.restore();
                console.log(`‚úÖ Rendered ${shapeType}`);
            }

            createDockPreview(shapeType, size = 90) {
                console.log(`üé® createDockPreview called for: ${shapeType}, size: ${size}`);
                const config = getShapeConfig(shapeType);
                if (!config) {
                    console.error(`‚ùå No config found for shape: ${shapeType}`);
                    return null;
                }
                
                // Use larger canvas to accommodate full-size shape rendering
                const canvas = document.createElement('canvas');
                canvas.width = size;
                canvas.height = size;
                canvas.className = `shape-preview`;
                canvas.dataset.shape = shapeType;

                const ctx = canvas.getContext('2d');
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';

                // Use 2x scale for full-size display, matching 2x physics scale (30‚Üí60)
                const scale = 1.9;
                console.log(`üìê Shape ${shapeType}: using enlarged scale=${scale} for full-size display`);
                
                // Check barbell orientation setting for dock preview rotation
                let rotation = 0;
                if (shapeType && shapeType.includes('barbell')) {
                    const barbellOrientationSelect = document.getElementById('barbellOrientation');
                    if (barbellOrientationSelect && barbellOrientationSelect.value === 'vertical') {
                        rotation = Math.PI / 2; // 90 degrees for vertical orientation
                        console.log(`üîÑ Applying vertical rotation (90¬∞) to ${shapeType}`);
                    }
                }
                
                // Render the shape in the center of the preview canvas
                this.renderShapeOnCanvas(ctx, shapeType, size / 2, size / 2, rotation, scale);
                
                console.log(`‚úÖ Canvas preview created for: ${shapeType} with scale ${scale}, rotation ${(rotation * 180 / Math.PI).toFixed(0)}¬∞`);
                return canvas;
            }

            drawRectangle(ctx, config) {
                const { width, height, color, stroke, strokeWidth } = config;
                ctx.fillStyle = color;
                ctx.strokeStyle = stroke;
                ctx.lineWidth = strokeWidth;

                ctx.fillRect(-width / 2, -height / 2, width, height);
                ctx.strokeRect(-width / 2, -height / 2, width, height);
            }

            drawCircle(ctx, config) {
                const { radius, color, stroke, strokeWidth } = config;
                ctx.fillStyle = color;
                ctx.strokeStyle = stroke;
                ctx.lineWidth = strokeWidth;

                ctx.beginPath();
                ctx.arc(0, 0, radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
            }

            drawPolygon(ctx, config) {
                const { vertices, color, stroke, strokeWidth } = config;
                ctx.fillStyle = color;
                ctx.strokeStyle = stroke;
                ctx.lineWidth = strokeWidth;

                ctx.beginPath();
                ctx.moveTo(vertices[0].x, vertices[0].y);
                for (let i = 1; i < vertices.length; i++) {
                    ctx.lineTo(vertices[i].x, vertices[i].y);
                }
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            }

            drawCompoundShape(ctx, config) {
                for (const part of config.parts) {
                    ctx.save();
                    ctx.translate(part.offsetX || 0, part.offsetY || 0);

                    const partConfig = {
                        ...config,
                        ...part,
                        color: part.color || config.color,
                        stroke: part.stroke || config.stroke
                    };

                    switch (part.type) {
                        case 'rectangle':
                            this.drawRectangle(ctx, partConfig);
                            break;
                        case 'circle':
                            this.drawCircle(ctx, partConfig);
                            break;
                        case 'diamond':
                            this.drawDiamond(ctx, partConfig);
                            break;
                    }
                    ctx.restore();
                }
            }

            drawDiamond(ctx, config) {
                // For dock preview consistency, render diamond exactly as physics will:
                // as a rotated rectangle to match the planck.Box(..., Math.PI/4) creation
                const { width, height, color, stroke, strokeWidth } = config;
                ctx.fillStyle = color;
                ctx.strokeStyle = stroke;
                ctx.lineWidth = strokeWidth;

                ctx.save();
                // Apply the same rotation that's used in physics fixture creation
                ctx.rotate(Math.PI / 4);
                ctx.fillRect(-width / 2, -height / 2, width, height);
                ctx.strokeRect(-width / 2, -height / 2, width, height);
                ctx.restore();
            }
        }

        // Global shape renderer instance
        const shapeRenderer = new PhysicsShapeRenderer();

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë UNIFIED DOCK SYSTEM
          ‚ïë Replaces CSS-based dock with canvas-rendered previews matching physics
          ‚ïë Maintains existing functionality while implementing unified appearance
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        function rebuildGameDock() {
            console.log('üîß rebuildGameDock() called');
            const dockingArea = document.getElementById('dockingArea');
            if (!dockingArea) {
                console.error('‚ùå dockingArea not found!');
                return;
            }

            // Get current dock shapes from level config or fallback to all shapes
            const dockShapes = window.currentLevelConfig ? window.currentLevelConfig.dockShapes : getAllShapeTypes();
            console.log('üì¶ Building dock with shapes:', dockShapes);
            console.log('üì¶ Current level config exists:', !!window.currentLevelConfig);
            console.log('üì¶ Shape renderer available:', !!shapeRenderer);
            
            // Clear and rebuild dock with canvas previews
            dockingArea.innerHTML = '';
            console.log('üßπ Cleared existing dock content');
            
            dockShapes.forEach((shapeType, index) => {
                console.log(`üèóÔ∏è Creating slot ${index + 1} for: ${shapeType}`);
                const slotDiv = document.createElement('div');
                slotDiv.className = 'shape-slot'; // Ensure no 'empty' class on fresh slots
                slotDiv.id = `slot-${shapeType}`;

                if (shapeType && shapeRenderer) {
                    // Create full-size canvas preview using unified renderer
                    const canvasPreview = shapeRenderer.createDockPreview(shapeType, 90);
                    if (canvasPreview) {
                        canvasPreview.id = `shape-${shapeType}`;
                        canvasPreview.dataset.shape = shapeType;
                        canvasPreview.className = 'game-shape shape-preview';
                        canvasPreview.style.visibility = 'visible'; // Ensure visibility is reset
                        slotDiv.appendChild(canvasPreview);
                        console.log(`‚úÖ Created canvas preview for: ${shapeType}`);
                    } else {
                        console.error(`‚ùå Failed to create canvas preview for: ${shapeType}`);
                        // Create a temporary colored div fallback
                        const fallback = document.createElement('div');
                        fallback.className = 'game-shape shape-preview';
                        fallback.dataset.shape = shapeType;
                        fallback.id = `shape-${shapeType}`;
                        fallback.style.width = '50px';
                        fallback.style.height = '50px';
                        fallback.style.backgroundColor = getShapeConfig(shapeType)?.color || '#95A5A6';
                        fallback.style.border = '2px solid #7F8C8D';
                        fallback.style.borderRadius = '4px';
                        fallback.style.visibility = 'visible';
                        fallback.textContent = shapeType.charAt(0).toUpperCase();
                        slotDiv.appendChild(fallback);
                        console.log(`‚ö†Ô∏è Created fallback preview for: ${shapeType}`);
                    }
                } else {
                    console.warn(`‚ö†Ô∏è Empty slot or no renderer for: ${shapeType}`);
                    slotDiv.classList.add('empty');
                }
                
                dockingArea.appendChild(slotDiv);
                console.log(`üìç Added slot for ${shapeType} to dock`);
            });

            console.log(`‚úÖ Game dock rebuilt with ${dockShapes.length} slots total`);
        }

        // Initialize unified dock system (called after level config is ready)
        function initializeUnifiedDockSystem() {
            console.log('ÔøΩ Initializing Unified Dock System...');
            rebuildGameDock();
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë ENHANCED PHYSICS MANAGER WITH EVENT SYSTEM
          ‚ïë Phase 4.1: Implements collision detection, fall detection, and physics events
          ‚ïë Integrates physics events with game state for advanced game mechanics.
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        class PhysicsManager {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                
                // Matter.js aliases for cleaner code
                this.Engine = Matter.Engine;
                this.World = Matter.World;
                this.Bodies = Matter.Bodies;
                this.Body = Matter.Body;
                this.Events = Matter.Events;
                
                // Event tracking
                this.eventCount = 0;
                this.collisionCount = 0;
                this.fallCount = 0;
                
                // Canvas Enhancement System v9
                this.assetManager = new AssetManager();
                this.particleSystem = new ParticleSystem(canvas, this.assetManager);
                
                // Theme-based rendering properties
                this.backgroundGradient = null;
                this.platformColor = '#8B4513';
                
                console.log('üé® Canvas Enhancement System initialized');
                
                // Initialize with default theme
                this.initializeDefaultTheme();
                
                // Resize canvas to container
                this.resizeCanvas();
                
                // Create Matter.js world with physics engine
                this.engine = this.Engine.create();
                this.world = this.engine.world;
                
                // Set gravity (Matter.js uses different scale than Planck.js)
                this.engine.world.gravity.x = 0;
                this.engine.world.gravity.y = 1; // 1 pixel/frame¬≤ gravity
                
                // Track all dynamic bodies for rendering and cleanup
                this.dynamicBodies = [];
                
                // Camera shake system
                this.cameraShake = {
                    active: false,
                    intensity: 0,
                    duration: 0,
                    elapsed: 0,
                    frequencyX: 0.1,
                    frequencyY: 0.1,
                    offsetX: 0,
                    offsetY: 0
                };
                
                // Setup physics event listeners
                this.setupPhysicsEvents();
                
                // Create game platform and boundaries
                this.createPlatform();
                this.createBoundaries();
                
                // Start render loop
                this.startRenderLoop();
                
                console.log('üåç Enhanced Physics Manager with Events initialized');
            }

            // Canvas Enhancement v9: Initialize default theme
            async initializeDefaultTheme() {
                try {
                    await this.assetManager.loadTheme(CANVAS_CONFIG.defaultTheme);
                    const bgStyle = this.assetManager.getBackgroundStyle();
                    if (bgStyle && bgStyle.type === 'gradient') {
                        this.backgroundGradient = bgStyle.colors;
                    }
                    const platformStyle = this.assetManager.getPlatformStyle();
                    if (platformStyle) {
                        this.platformColor = platformStyle.color;
                    }
                    console.log(`üé® Default theme initialized: ${CANVAS_CONFIG.defaultTheme}`);
                } catch (error) {
                    console.error('‚ùå Failed to initialize default theme:', error);
                }
            }

            setupPhysicsEvents() {
                // Matter.js collision detection - when shapes start touching
                this.Events.on(this.engine, 'collisionStart', (event) => {
                    event.pairs.forEach(pair => {
                        this.handleBeginContact(pair);
                    });
                });
                
                // Matter.js collision end - when shapes stop touching  
                this.Events.on(this.engine, 'collisionEnd', (event) => {
                    event.pairs.forEach(pair => {
                        this.handleEndContact(pair);
                    });
                });
                
                console.log('üéØ Matter.js event listeners configured');
            }

            handleBeginContact(pair) {
                const bodyA = pair.bodyA;
                const bodyB = pair.bodyB;
                const userDataA = bodyA.userData || {};
                const userDataB = bodyB.userData || {};
                
                console.log(`üîç RAW COLLISION: bodyA.userData =`, userDataA, `bodyB.userData =`, userDataB);
                
                this.collisionCount++;
                this.eventCount++;
                
                // Check for shape-platform collision
                if (this.isShapePlatformCollision(userDataA, userDataB)) {
                    console.log('üéØ PLATFORM COLLISION DETECTED!');
                    this.onShapeLandedOnPlatform(bodyA, bodyB);
                }
                
                // Check for shape-shape collision
                if (this.isShapeShapeCollision(userDataA, userDataB)) {
                    console.log('üîÑ SHAPE-SHAPE COLLISION DETECTED!');
                    this.onShapeShapeCollision(bodyA, bodyB);
                }
                
                // Check for ground collision (fall detection)
                console.log('üß™ Testing ground collision...');
                if (this.isGroundCollision(userDataA, userDataB)) {
                    console.log('üî• GROUND COLLISION DETECTED! Triggering shape fall...');
                    this.onShapeFellOffPlatform(bodyA, bodyB);
                } else {
                    console.log('‚ùå Ground collision test failed');
                }
                
                console.log(`üìç Collision detected: ${userDataA.type || 'unknown'} vs ${userDataB.type || 'unknown'}`);
            }

            handleEndContact(pair) {
                // Handle when objects stop touching
                const bodyA = pair.bodyA;
                const bodyB = pair.bodyB;
                
                // Could implement "unstable" detection here
                // console.log('üì§ Contact ended');
            }

            isShapePlatformCollision(dataA, dataB) {
                const shapeTypes = ['shape', 'compound', 'rectangle', 'polygon', 'circle'];
                const isAShape = shapeTypes.includes(dataA.type);
                const isBShape = shapeTypes.includes(dataB.type);
                
                return (isAShape && dataB.type === 'platform') ||
                       (dataA.type === 'platform' && isBShape);
            }

            isShapeShapeCollision(dataA, dataB) {
                const shapeTypes = ['shape', 'compound', 'rectangle', 'polygon', 'circle'];
                const isAShape = shapeTypes.includes(dataA.type);
                const isBShape = shapeTypes.includes(dataB.type);
                
                return isAShape && isBShape;
            }

            isGroundCollision(dataA, dataB) {
                const shapeTypes = ['shape', 'compound', 'rectangle', 'polygon', 'circle'];
                const isAShape = shapeTypes.includes(dataA.type);
                const isBShape = shapeTypes.includes(dataB.type);
                
                const result = (isAShape && dataB.type === 'ground') ||
                              (dataA.type === 'ground' && isBShape);
                              
                if (result) {
                    console.log(`üéØ Ground collision detected: ${dataA.type} vs ${dataB.type} - isAShape: ${isAShape}, isBShape: ${isBShape}`);
                }
                
                return result;
            }

            onShapeLandedOnPlatform(bodyA, bodyB) {
                console.log('üéØ Shape landed on platform!');
                this.showEventNotification('Shape Landed!', 'collision');
                
                // Trigger game event
                if (window.gameManager) {
                    window.gameManager.onShapeLandedOnPlatform();
                }
            }

            onShapeShapeCollision(bodyA, bodyB) {
                console.log('üîÑ Shape collision detected!');
                this.showEventNotification('Shape Contact!', 'balance');
                
                // Trigger game event
                if (window.gameManager) {
                    window.gameManager.onShapeCollision();
                }
            }

            onShapeFellOffPlatform(bodyA, bodyB) {
                console.log('üí• Shape fell off platform!');
                this.fallCount++;
                
                this.showEventNotification('Shape Fell!', 'fall');
                
                // Trigger game event
                if (window.gameManager) {
                    window.gameManager.onShapeFell();
                }
            }

            showEventNotification(message, type) {
                const notification = document.getElementById('eventNotification');
                notification.textContent = message;
                notification.className = `event-notification ${type} show`;
                
                setTimeout(() => {
                    notification.classList.remove('show');
                }, 2000);
            }

            resizeCanvas() {
                const container = this.canvas.parentElement;
                this.canvas.width = container.clientWidth;
                this.canvas.height = container.clientHeight;
                console.log(`üìê Canvas resized to: ${this.canvas.width}x${this.canvas.height}`);
            }

            createBoundaries() {
                // Create invisible ground boundary for fall detection
                const groundY = this.canvas.height + 150; // Extended to +150 (was +50) for longer fall distance
                const groundWidth = this.canvas.width;
                
                const ground = this.Bodies.rectangle(
                    this.canvas.width / 2, 
                    groundY, 
                    groundWidth, 
                    100, 
                    {
                        isStatic: true,
                        render: { visible: false }
                    }
                );
                
                // Set user data for collision detection
                ground.userData = {
                    type: 'ground',
                    name: 'fallDetectionBoundary'
                };
                
                this.World.add(this.world, ground);
                console.log('üöß Matter.js boundaries created');
            }

            createPlatform() {
                // Restore original angled platform from v1 (-50 degrees)
                const platformX = this.canvas.width / 2 - 30;  // Pixel coordinates
                const platformY = this.canvas.height - 20;     // Moved down 100px (was -120, now -20)
                const platformWidth = 200;
                const platformHeight = 20;
                const platformAngle = -0.873; // -50 degrees
                
                // Create angled platform with Matter.js
                const platform = this.Bodies.rectangle(
                    platformX, 
                    platformY, 
                    platformWidth, 
                    platformHeight,
                    {
                        isStatic: true,
                        angle: platformAngle,
                        render: {
                            fillStyle: '#95A5A6',
                            strokeStyle: '#7F8C8D',
                            lineWidth: 2
                        },
                        friction: 0.9,
                        restitution: 0
                    }
                );
                
                // Set user data for collision detection
                platform.userData = {
                    type: 'platform',
                    visible: true,
                    color: '#95A5A6',
                    stroke: '#7F8C8D',
                    strokeWidth: 2,
                    width: platformWidth,
                    height: platformHeight
                };
                
                this.World.add(this.world, platform);
                console.log(`üèóÔ∏è Matter.js angled platform created: -50¬∞ at (${platformX}, ${platformY})`);
            }

            createCompoundShape(x, y, type, rotation = 0) {
                // Forward to unified createShape method for consistency
                return this.createShape(x, y, type, rotation);
            }

            createShape(x, y, type, rotation = 0) {
                const config = getShapeConfig(type);
                if (!config) {
                    console.error(`Unknown shape type: ${type}`);
                    return null;
                }

                // V9: Matter.js compound shape creation with perfect collision detection
                console.log(`üéØ Creating Matter.js shape: ${type} at (${x}, ${y})`);

                let body;

                // Handle compound shapes (shapes with parts) using SHAPE_CONFIG
                if (config.type === 'compound' && config.parts) {
                    body = this.createMatterCompoundShape(x, y, type, rotation, config);
                } else {
                    // Handle simple shapes with standard Matter.js bodies
                    body = this.createMatterSimpleShape(x, y, type, rotation, config);
                }

                if (body) {
                    // Set Matter.js physics properties from config
                    body.restitution = config.restitution || 0.1;      // Reduced bounce to prevent rotation changes
                    body.friction = config.friction || 0.9;       
                    body.frictionAir = 0.02;   // Reduced air resistance to maintain manual rotation
                    
                    // Stabilize rotation for a brief moment after drop
                    const originalAngularVelocity = body.angularVelocity;
                    body.angularVelocity = 0; // Stop any spinning from collision
                    
                    // After a short delay, allow normal physics
                    setTimeout(() => {
                        if (body && body.angularVelocity === 0) {
                            body.frictionAir = 0.05; // Restore normal air resistance
                        }
                    }, 100); // Brief stabilization period

                    // Set user data for collision detection and rendering
                    body.userData = {
                        type: 'shape',
                        shapeType: type,
                        ...config
                    };
                    
                    console.log(`üè∑Ô∏è Shape userData set:`, body.userData);

                    this.World.add(this.world, body);
                    this.dynamicBodies.push(body);

                    console.log(`‚úÖ Matter.js ${type} created successfully`);
                    return body;
                }

                console.error(`‚ùå Failed to create Matter.js shape: ${type}`);
                return null;
            }

            createMatterCompoundShape(x, y, type, rotation, config) {
                console.log(`üéØ Creating Matter.js compound shape: ${type} using SHAPE_CONFIG`);
                
                if (!config.parts || config.parts.length === 0) {
                    console.error(`‚ùå No parts defined for compound shape: ${type}`);
                    return null;
                }
                
                const bodyParts = [];
                
                // Create each part based on SHAPE_CONFIG specification
                config.parts.forEach((partConfig, index) => {
                    // Use relative positioning for compound body parts
                    const partX = x + (partConfig.offsetX || 0);
                    const partY = y + (partConfig.offsetY || 0);
                    let bodyPart = null;
                    
                    if (partConfig.type === 'rectangle') {
                        bodyPart = this.Bodies.rectangle(partX, partY, partConfig.width, partConfig.height, {
                            render: {
                                fillStyle: partConfig.color || config.color,
                                strokeStyle: partConfig.stroke || config.stroke,
                                lineWidth: config.strokeWidth || 2
                            }
                        });
                    } else if (partConfig.type === 'circle') {
                        bodyPart = this.Bodies.circle(partX, partY, partConfig.radius, {
                            render: {
                                fillStyle: partConfig.color || config.color,
                                strokeStyle: partConfig.stroke || config.stroke,
                                lineWidth: config.strokeWidth || 2
                            }
                        });
                    } else if (partConfig.type === 'diamond') {
                        // Create diamond as a rotated square
                        const size = partConfig.width || partConfig.height || 12;
                        bodyPart = this.Bodies.polygon(partX, partY, 4, size / Math.sqrt(2), {
                            angle: Math.PI / 4, // 45 degree rotation for diamond
                            render: {
                                fillStyle: partConfig.color || config.color,
                                strokeStyle: partConfig.stroke || config.stroke,
                                lineWidth: config.strokeWidth || 2
                            }
                        });
                    }
                    
                    if (bodyPart) {
                        bodyParts.push(bodyPart);
                        console.log(`‚úÖ Created ${partConfig.type} part at offset (${partConfig.offsetX}, ${partConfig.offsetY})`);
                    }
                });
                
                if (bodyParts.length === 0) {
                    console.error(`‚ùå No body parts created for compound shape: ${type}`);
                    return null;
                }
                
                // Create compound body and then rotate it smoothly
                const compoundBody = this.Body.create({
                    parts: bodyParts
                });
                
                // Apply rotation after creation to prevent snapping
                if (rotation !== 0) {
                    this.Body.setAngle(compoundBody, rotation);
                }
                
                // CRITICAL: Set userData on compound body AND all parts
                const userData = {
                    type: 'compound',
                    shapeType: type,
                    ...config
                };
                
                compoundBody.userData = userData;
                
                // Also set userData on all parts so collision detection works
                bodyParts.forEach(part => {
                    part.userData = userData;
                });
                
                console.log(`üè∑Ô∏è Compound shape userData set on main body and ${bodyParts.length} parts:`, userData);
                console.log(`‚úÖ Matter.js compound shape ${type} created with ${bodyParts.length} parts, rotated ${(rotation * 180 / Math.PI).toFixed(1)}¬∞`);
                return compoundBody;
            }

            createMatterSimpleShape(x, y, type, rotation, config) {
                console.log(`üéØ Creating Matter.js simple shape: ${type}`);
                
                let body = null;

                // Create shape based on type
                if (type === 'square') {
                    body = this.Bodies.rectangle(x, y, config.width || 50, config.height || 50, {
                        angle: rotation,
                        render: {
                            fillStyle: config.color || '#FFD700',
                            strokeStyle: config.stroke || '#FFA500',
                            lineWidth: config.strokeWidth || 2
                        }
                    });
                } else if (type === 'triangle') {
                    // Create triangle using polygon but fix the default orientation
                    // Matter.js Bodies.polygon(x, y, 3, radius) creates triangle with different default rotation
                    const sides = 3;
                    const radius = 20; // Match approximate size of our config vertices
                    
                    // Add Math.PI/2 (90 degrees) to align with our triangle config (point up)
                    const adjustedRotation = rotation + Math.PI/2;
                    
                    body = this.Bodies.polygon(x, y, sides, radius, {
                        angle: adjustedRotation,
                        render: {
                            fillStyle: config.color || '#9B59B6',
                            strokeStyle: config.stroke || '#8E44AD',
                            lineWidth: config.strokeWidth || 2
                        }
                    });
                    
                    console.log(`üî∫ Triangle created with 90¬∞ adjustment, final rotation ${(adjustedRotation * 180 / Math.PI).toFixed(1)}¬∞`);
                } else if (type === 'circle') {
                    body = this.Bodies.circle(x, y, config.radius || 25, {
                        render: {
                            fillStyle: config.color || '#1ABC9C',
                            strokeStyle: config.stroke || '#16A085',
                            lineWidth: config.strokeWidth || 2
                        }
                    });
                }

                if (body) {
                    // Set userData on simple shape body  
                    body.userData = {
                        type: config.type || 'rectangle', // Use config type (rectangle, polygon, circle)
                        shapeType: type,
                        ...config
                    };
                    console.log(`üè∑Ô∏è Simple shape userData set:`, body.userData);
                }

                console.log(`‚úÖ Matter.js simple shape ${type} created`);
                return body;
            }

            startRenderLoop() {
                let lastTime = 0;
                const render = (currentTime) => {
                    const deltaTime = currentTime - lastTime;
                    lastTime = currentTime;
                    
                    // Update camera shake
                    this.updateCameraShake(deltaTime);
                    
                    // Step Matter.js physics simulation
                    this.Engine.update(this.engine, 1000 / 60); // 60 FPS
                    
                    // Clear canvas
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    
                    // v9: Enhanced rendering with themes (no camera shake transforms needed)
                    this.renderBackground();
                    this.renderWorld();
                    this.particleSystem.update(16); // ~16ms per frame at 60fps
                    this.particleSystem.render();
                    
                    requestAnimationFrame(render);
                };
                render(performance.now());
                console.log('üé¨ Matter.js render loop with Canvas Enhancement and Camera Shake started');
            }

            // v9: Enhanced background rendering with theme support
            renderBackground() {
                if (!CANVAS_CONFIG.enabled || !CANVAS_CONFIG.useBackgroundTextures) {
                    return; // Use default CSS background
                }

                const backgroundStyle = this.assetManager.getBackgroundStyle();
                if (!backgroundStyle) return;

                // Check if we have a background image
                if (backgroundStyle.image && backgroundStyle.imageConfig) {
                    this.renderBackgroundImage(backgroundStyle);
                } else if (backgroundStyle.colors && backgroundStyle.colors.length >= 2) {
                    this.renderBackgroundGradient(backgroundStyle);
                }
                
                // Add texture overlay if configured
                this.renderBackgroundTexture();
            }

            // Render background image
            renderBackgroundImage(backgroundStyle) {
                const image = backgroundStyle.image;
                const config = backgroundStyle.imageConfig;
                
                this.ctx.save();
                
                // Apply image based on configuration
                switch(config.size) {
                    case 'cover':
                        this.drawImageCover(image);
                        break;
                    case 'contain':
                        this.drawImageContain(image);
                        break;
                    case 'auto':
                        this.ctx.drawImage(image, 0, 0);
                        break;
                    default: // "100% 100%" or similar
                        this.ctx.drawImage(image, 0, 0, this.canvas.width, this.canvas.height);
                }
                
                // If there are gradient colors too, overlay them with reduced opacity
                if (backgroundStyle.colors && backgroundStyle.colors.length >= 2) {
                    this.ctx.globalAlpha = 0.3; // Reduce opacity for overlay
                    this.renderBackgroundGradient(backgroundStyle);
                }
                
                this.ctx.restore();
            }

            // Helper to draw image with 'cover' behavior
            drawImageCover(image) {
                const canvasRatio = this.canvas.width / this.canvas.height;
                const imageRatio = image.width / image.height;
                
                let drawWidth, drawHeight, drawX, drawY;
                
                if (imageRatio > canvasRatio) {
                    // Image is wider than canvas ratio
                    drawHeight = this.canvas.height;
                    drawWidth = drawHeight * imageRatio;
                    drawX = (this.canvas.width - drawWidth) / 2;
                    drawY = 0;
                } else {
                    // Image is taller than canvas ratio
                    drawWidth = this.canvas.width;
                    drawHeight = drawWidth / imageRatio;
                    drawX = 0;
                    drawY = (this.canvas.height - drawHeight) / 2;
                }
                
                this.ctx.drawImage(image, drawX, drawY, drawWidth, drawHeight);
            }

            // Helper to draw image with 'contain' behavior
            drawImageContain(image) {
                const canvasRatio = this.canvas.width / this.canvas.height;
                const imageRatio = image.width / image.height;
                
                let drawWidth, drawHeight, drawX, drawY;
                
                if (imageRatio > canvasRatio) {
                    // Fit to canvas width
                    drawWidth = this.canvas.width;
                    drawHeight = drawWidth / imageRatio;
                    drawX = 0;
                    drawY = (this.canvas.height - drawHeight) / 2;
                } else {
                    // Fit to canvas height
                    drawHeight = this.canvas.height;
                    drawWidth = drawHeight * imageRatio;
                    drawX = (this.canvas.width - drawWidth) / 2;
                    drawY = 0;
                }
                
                this.ctx.drawImage(image, drawX, drawY, drawWidth, drawHeight);
            }

            // Render gradient background (extracted from previous method)
            renderBackgroundGradient(backgroundStyle) {
                const colors = backgroundStyle.colors;
                if (!colors || colors.length < 2) return;

                // Create linear gradient background
                const gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
                
                // Distribute colors evenly across gradient
                const colorStep = 1 / (colors.length - 1);
                colors.forEach((color, index) => {
                    gradient.addColorStop(index * colorStep, color);
                });
                
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            }

            // v9: Add subtle texture to background
            renderBackgroundTexture() {
                const currentTheme = this.assetManager.getCurrentTheme();
                if (!currentTheme) return;
                
                this.ctx.save();
                this.ctx.globalAlpha = 0.1;
                
                // Add theme-specific background patterns
                switch(currentTheme.config.platform.material) {
                    case 'wood':
                        this.renderWoodTexture();
                        break;
                    case 'metal':
                        this.renderMetalTexture();
                        break;
                    case 'coral':
                        this.renderCoralTexture();
                        break;
                    default:
                        this.renderGeometricTexture();
                }
                
                this.ctx.restore();
            }

            renderWoodTexture() {
                // Simple wood grain effect
                this.ctx.strokeStyle = '#8B4513';
                this.ctx.lineWidth = 0.5;
                for (let i = 0; i < 20; i++) {
                    const y = (this.canvas.height / 20) * i;
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.canvas.width, y + Math.sin(i) * 5);
                    this.ctx.stroke();
                }
            }

            renderMetalTexture() {
                // Diagonal line pattern
                this.ctx.strokeStyle = '#708090';
                this.ctx.lineWidth = 0.3;
                for (let i = -this.canvas.width; i < this.canvas.width + this.canvas.height; i += 10) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(i, 0);
                    this.ctx.lineTo(i + this.canvas.height, this.canvas.height);
                    this.ctx.stroke();
                }
            }

            renderCoralTexture() {
                // Organic bubble pattern
                this.ctx.fillStyle = '#2E8B57';
                for (let i = 0; i < 50; i++) {
                    const x = Math.random() * this.canvas.width;
                    const y = Math.random() * this.canvas.height;
                    const radius = Math.random() * 3 + 1;
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, radius, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }

            renderGeometricTexture() {
                // Simple dot pattern
                this.ctx.fillStyle = '#cccccc';
                for (let x = 10; x < this.canvas.width; x += 20) {
                    for (let y = 10; y < this.canvas.height; y += 20) {
                        this.ctx.beginPath();
                        this.ctx.arc(x, y, 1, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                }
            }

            // =============================================================================
            // CAMERA SHAKE SYSTEM
            // =============================================================================

            /**
             * Trigger camera shake effect
             * @param {number} intensity - Shake intensity (1-10)
             * @param {number} duration - Duration in milliseconds
             */
            startCameraShake(intensity = 5, duration = 500) {
                console.log(`üö® startCameraShake called with intensity=${intensity}, duration=${duration}ms`);
                
                this.cameraShake.active = true;
                this.cameraShake.intensity = intensity;
                this.cameraShake.duration = duration;
                this.cameraShake.elapsed = 0;
                this.cameraShake.frequencyX = 0.1 + Math.random() * 0.1; // Randomize frequency
                this.cameraShake.frequencyY = 0.1 + Math.random() * 0.1;
                
                console.log(`‚úÖ Camera shake activated - state:`, this.cameraShake);
                console.log(`üéØ Canvas element:`, this.canvas);
                
                // Immediate test shake to verify it works
                this.canvas.style.transform = `translate(${intensity}px, ${intensity}px)`;
                setTimeout(() => {
                    this.canvas.style.transform = 'translate(0px, 0px)';
                }, 100);
                
                console.log(`üìπ Camera shake started: intensity=${intensity}, duration=${duration}ms`);
            }

            /**
             * Update camera shake effect - applies shake directly to canvas element
             * @param {number} deltaTime - Time since last update
             */
            updateCameraShake(deltaTime) {
                if (!this.cameraShake.active) {
                    // Reset canvas position when not shaking
                    this.canvas.style.transform = 'translate(0px, 0px)';
                    return;
                }

                console.log(`üîÑ updateCameraShake: elapsed=${this.cameraShake.elapsed}, duration=${this.cameraShake.duration}, intensity=${this.cameraShake.intensity}`);

                this.cameraShake.elapsed += deltaTime;

                if (this.cameraShake.elapsed >= this.cameraShake.duration) {
                    // Shake finished
                    this.cameraShake.active = false;
                    this.canvas.style.transform = 'translate(0px, 0px)';
                    console.log('‚úÖ Camera shake completed');
                    return;
                }

                // Calculate shake progress (1.0 at start, 0.0 at end)
                const progress = 1.0 - (this.cameraShake.elapsed / this.cameraShake.duration);
                const currentIntensity = this.cameraShake.intensity * progress * progress; // Quadratic falloff

                // Generate shake offset using sine waves with different frequencies
                const time = this.cameraShake.elapsed * 0.01; // Convert to suitable time scale
                let offsetX = Math.sin(time * this.cameraShake.frequencyX * 50) * currentIntensity;
                let offsetY = Math.sin(time * this.cameraShake.frequencyY * 47) * currentIntensity; // Different frequency for variety

                // Add random jitter for more chaotic feel
                offsetX += (Math.random() - 0.5) * currentIntensity * 0.5;
                offsetY += (Math.random() - 0.5) * currentIntensity * 0.5;

                console.log(`üì≥ Applying shake: offsetX=${offsetX.toFixed(1)}, offsetY=${offsetY.toFixed(1)}, currentIntensity=${currentIntensity.toFixed(1)}`);

                // Apply transform to canvas element
                this.canvas.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
            }

            /**
             * Apply camera shake to canvas transform (legacy method - now unused)
             */
            applyCameraShake() {
                // This method is no longer used - shake is applied directly to canvas element
            }

            /**
             * Reset camera shake transform (legacy method - now unused)
             */
            resetCameraShake() {
                // This method is no longer used - shake is applied directly to canvas element
            }

            renderWorld() {
                // Render all Matter.js bodies in the world
                const bodies = this.world.bodies;
                for (let i = 0; i < bodies.length; i++) {
                    this.renderBody(bodies[i]);
                }
            }

            renderBody(body) {
                // Skip rendering invisible bodies
                if (body.render && body.render.visible === false) return;
                
                // V9: Render Matter.js body parts directly (no coordinate transformation)
                if (body.parts && body.parts.length > 1) {
                    // Compound body - render each part separately
                    for (let i = 1; i < body.parts.length; i++) { // Skip first part (it's the parent)
                        this.renderMatterPart(body.parts[i], body);
                    }
                } else {
                    // Simple body - render directly
                    this.renderMatterPart(body, body);
                }
            }

            renderMatterPart(part, parentBody) {
                // Get render properties from Matter.js body
                const render = part.render || {};
                const userData = parentBody.userData || {};
                
                // Skip invisible parts
                if (render.visible === false) return;
                
                // v9: Theme-based color selection
                let fillColor = render.fillStyle || userData.color || '#95A5A6';
                let strokeColor = render.strokeStyle || userData.stroke || '#7F8C8D';
                
                // Apply theme colors for platform
                if (userData.type === 'platform' && this.platformColor) {
                    fillColor = this.platformColor;
                    strokeColor = this.darkenColor(this.platformColor, 20);
                }
                
                // v9: Check for image textures
                const shouldUseTexture = CANVAS_CONFIG.enabled && CANVAS_CONFIG.useBackgroundTextures;
                let textureImage = null;
                let textureConfig = null;
                
                if (shouldUseTexture) {
                    if (userData.type === 'platform') {
                        const platformStyle = this.assetManager.getPlatformStyle();
                        textureImage = platformStyle?.image;
                        textureConfig = platformStyle?.imageConfig;
                    } else if (userData.shapeType) {
                        const shapeStyle = this.assetManager.getShapeStyle(userData.shapeType);
                        textureImage = shapeStyle?.texture;
                        textureConfig = shapeStyle?.textureConfig;
                    }
                }
                
                // Set drawing style
                this.ctx.fillStyle = fillColor;
                this.ctx.strokeStyle = strokeColor;
                this.ctx.lineWidth = render.lineWidth || userData.strokeWidth || 2;
                
                // Render based on shape type
                if (part.circleRadius !== undefined && part.circleRadius > 0) {
                    // Circle - use part's own position (already in world coordinates)
                    this.renderCircleWithTexture(part, textureImage, textureConfig);
                } else if (part.vertices && part.vertices.length > 0) {
                    // Polygon (including rectangles) - vertices are in world coordinates
                    this.renderPolygonWithTexture(part, textureImage, textureConfig);
                } else {
                    console.log(`‚ö†Ô∏è Unknown body type - circleRadius: ${part.circleRadius}, vertices: ${part.vertices ? part.vertices.length : 'none'} for ${userData.type || 'unknown'}`);
                }
            }

            renderCircleWithTexture(part, textureImage, textureConfig) {
                this.ctx.save();
                
                // Create circular clipping path
                this.ctx.beginPath();
                this.ctx.arc(part.position.x, part.position.y, part.circleRadius, 0, Math.PI * 2);
                
                if (textureImage && textureConfig) {
                    // Fill with texture
                    this.ctx.clip();
                    this.applyTextureToShape(part.position.x - part.circleRadius, 
                                           part.position.y - part.circleRadius,
                                           part.circleRadius * 2, 
                                           part.circleRadius * 2,
                                           textureImage, textureConfig);
                } else {
                    // Fill with solid color
                    this.ctx.fill();
                }
                
                // Restore for stroke
                this.ctx.restore();
                
                // Draw stroke
                this.ctx.beginPath();
                this.ctx.arc(part.position.x, part.position.y, part.circleRadius, 0, Math.PI * 2);
                this.ctx.stroke();
            }

            renderPolygonWithTexture(part, textureImage, textureConfig) {
                const vertices = part.vertices;
                
                this.ctx.save();
                
                // Create polygon clipping path
                this.ctx.beginPath();
                this.ctx.moveTo(vertices[0].x, vertices[0].y);
                for (let i = 1; i < vertices.length; i++) {
                    this.ctx.lineTo(vertices[i].x, vertices[i].y);
                }
                this.ctx.closePath();
                
                if (textureImage && textureConfig) {
                    // Get bounding box for texture positioning
                    const bounds = this.getPolygonBounds(vertices);
                    
                    // Fill with texture
                    this.ctx.clip();
                    this.applyTextureToShape(bounds.x, bounds.y, bounds.width, bounds.height,
                                           textureImage, textureConfig);
                } else {
                    // Fill with solid color
                    this.ctx.fill();
                }
                
                // Restore for stroke
                this.ctx.restore();
                
                // Draw stroke
                this.ctx.beginPath();
                this.ctx.moveTo(vertices[0].x, vertices[0].y);
                for (let i = 1; i < vertices.length; i++) {
                    this.ctx.lineTo(vertices[i].x, vertices[i].y);
                }
                this.ctx.closePath();
                this.ctx.stroke();
            }

            applyTextureToShape(x, y, width, height, image, textureConfig) {
                if (!image) return;
                
                this.ctx.save();
                
                // Apply blend mode
                if (textureConfig.blend && textureConfig.blend !== 'normal') {
                    this.ctx.globalCompositeOperation = textureConfig.blend;
                }
                
                // Apply opacity
                if (textureConfig.opacity !== undefined) {
                    this.ctx.globalAlpha = textureConfig.opacity;
                }
                
                // Handle texture repeat patterns
                switch(textureConfig.repeat) {
                    case 'repeat':
                        this.drawRepeatedTexture(x, y, width, height, image);
                        break;
                    case 'repeat-x':
                        this.drawRepeatedTextureX(x, y, width, height, image);
                        break;
                    case 'repeat-y':
                        this.drawRepeatedTextureY(x, y, width, height, image);
                        break;
                    case 'no-repeat':
                    default:
                        this.ctx.drawImage(image, x, y, width, height);
                        break;
                }
                
                this.ctx.restore();
            }

            drawRepeatedTexture(x, y, width, height, image) {
                const pattern = this.ctx.createPattern(image, 'repeat');
                if (pattern) {
                    this.ctx.fillStyle = pattern;
                    this.ctx.fillRect(x, y, width, height);
                } else {
                    // Fallback: manual tiling
                    this.manualTileTexture(x, y, width, height, image);
                }
            }

            drawRepeatedTextureX(x, y, width, height, image) {
                const aspectRatio = image.width / image.height;
                const tileHeight = height;
                const tileWidth = tileHeight * aspectRatio;
                
                for (let tx = x; tx < x + width; tx += tileWidth) {
                    const drawWidth = Math.min(tileWidth, x + width - tx);
                    this.ctx.drawImage(image, 0, 0, image.width * (drawWidth / tileWidth), image.height,
                                     tx, y, drawWidth, tileHeight);
                }
            }

            drawRepeatedTextureY(x, y, width, height, image) {
                const aspectRatio = image.width / image.height;
                const tileWidth = width;
                const tileHeight = tileWidth / aspectRatio;
                
                for (let ty = y; ty < y + height; ty += tileHeight) {
                    const drawHeight = Math.min(tileHeight, y + height - ty);
                    this.ctx.drawImage(image, 0, 0, image.width, image.height * (drawHeight / tileHeight),
                                     x, ty, tileWidth, drawHeight);
                }
            }

            manualTileTexture(x, y, width, height, image) {
                const tileWidth = image.width;
                const tileHeight = image.height;
                
                for (let ty = y; ty < y + height; ty += tileHeight) {
                    for (let tx = x; tx < x + width; tx += tileWidth) {
                        const drawWidth = Math.min(tileWidth, x + width - tx);
                        const drawHeight = Math.min(tileHeight, y + height - ty);
                        
                        this.ctx.drawImage(image, 0, 0, 
                                         image.width * (drawWidth / tileWidth), 
                                         image.height * (drawHeight / tileHeight),
                                         tx, ty, drawWidth, drawHeight);
                    }
                }
            }

            getPolygonBounds(vertices) {
                let minX = Infinity, minY = Infinity;
                let maxX = -Infinity, maxY = -Infinity;
                
                vertices.forEach(vertex => {
                    minX = Math.min(minX, vertex.x);
                    minY = Math.min(minY, vertex.y);
                    maxX = Math.max(maxX, vertex.x);
                    maxY = Math.max(maxY, vertex.y);
                });
                
                return {
                    x: minX,
                    y: minY,
                    width: maxX - minX,
                    height: maxY - minY
                };
            }

            getEventStats() {
                return {
                    events: this.eventCount,
                    collisions: this.collisionCount,
                    falls: this.fallCount
                };
            }

            darkenColor(color, amount = 30) {
                // v9: Enhanced color darkening with configurable amount
                if (!color) return '#7F8C8D';
                
                // Convert hex to RGB and darken by specified amount
                const hex = color.replace('#', '');
                const r = Math.max(0, parseInt(hex.substr(0, 2), 16) - amount);
                const g = Math.max(0, parseInt(hex.substr(2, 2), 16) - amount);
                const b = Math.max(0, parseInt(hex.substr(4, 2), 16) - amount);
                
                return `rgb(${r}, ${g}, ${b})`;
            }

            /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
              ‚ïë CLEAR ALL SHAPES
              ‚ïë Removes all dynamic bodies (shapes) from the physics world while preserving
              ‚ïë static bodies (platform, walls). Used for level resets and shape management.
              ‚ïë Essential for providing a fresh start without recreating the entire world.
              ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
            clearAllShapes() {
                // Remove all dynamic bodies from Matter.js world
                this.dynamicBodies.forEach(body => {
                    this.World.remove(this.world, body);
                });
                this.dynamicBodies = [];
                
                console.log('üßπ Cleared all shapes from playfield');
            }

            cleanup() {
                // Remove all dynamic bodies from Matter.js world
                this.dynamicBodies.forEach(body => {
                    this.World.remove(this.world, body);
                });
                this.dynamicBodies = [];
                
                // Reset event counters
                this.eventCount = 0;
                this.collisionCount = 0;
                this.fallCount = 0;
                
                console.log('üßπ Matter.js physics cleanup complete');
            }
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë ENHANCED DRAG AND DROP MANAGER WITH ROTATION
          ‚ïë Task 4.2b: Adds rotation functionality during drag and drop operations
          ‚ïë Maintains existing drag & drop functionality while adding rotation controls
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        class DragDropManager {
            constructor(physicsManager, gameManager) {
                this.physicsManager = physicsManager;
                this.gameManager = gameManager;
                this.isDragging = false;
                this.draggedElement = null;
                this.draggedShapeType = null;
                this.ghostElement = null;
                
                // Touch offset configuration for mobile devices
                this.touchOffset = {
                    x: 0,      // Horizontal offset (positive = right, negative = left)
                    y: -80,    // Vertical offset (positive = down, negative = up)
                    enabled: true // Enable/disable offset system
                };
                
                // Rotation system
                this.currentRotation = 0; // Current rotation in radians
                this.rotationStep = Math.PI / 6; // 30 degrees per step
                
                // Throttling for smooth dragging - reduce jerkiness
                this.lastMoveTime = 0;
                this.moveThrottleMs = 16; // ~60fps throttling
                this.pendingMove = null;
                
                // Track if drag started from dock
                this.dragStartedFromDock = false;
                
                this.setupEventListeners();
                console.log('üñ±Ô∏è Streamlined Drag & Drop Manager with touch offset support initialized');
            }

            setupEventListeners() {
                // Mouse events - use throttled movement for smoother dragging
                document.addEventListener('mousedown', (e) => this.handlePointerDown(e));
                document.addEventListener('mousemove', (e) => this.throttledHandlePointerMove(e));
                document.addEventListener('mouseup', (e) => this.handlePointerUp(e));
                
                // Touch events for mobile support
                document.addEventListener('touchstart', (e) => this.handleTouchStart(e), { passive: false });
                document.addEventListener('touchmove', (e) => this.handleTouchMove(e), { passive: false });
                document.addEventListener('touchend', (e) => this.handleTouchEnd(e), { passive: false });
                
                // Keyboard controls
                document.addEventListener('keydown', (e) => this.handleRotationKey(e));
                
                console.log('üñ±Ô∏è Drag & Drop Manager initialized with touch support');
            }
            
            // Throttled mouse movement to reduce jerkiness
            throttledHandlePointerMove(e) {
                if (!this.isDragging) return;
                
                const now = performance.now();
                if (now - this.lastMoveTime < this.moveThrottleMs) {
                    // Store the most recent event for later processing
                    this.pendingMove = e;
                    return;
                }
                
                this.lastMoveTime = now;
                this.handlePointerMove(e);
                
                // Process any pending move after throttle delay
                if (this.pendingMove && this.pendingMove !== e) {
                    setTimeout(() => {
                        if (this.pendingMove && this.isDragging) {
                            this.handlePointerMove(this.pendingMove);
                            this.pendingMove = null;
                        }
                    }, this.moveThrottleMs);
                }
            }

            handleRotationKey(e) {
                if (!this.isDragging) return;
                
                switch(e.key) {
                    case 'r':
                    case 'R':
                    case 'ArrowRight':
                        this.rotateShape(this.rotationStep); // Rotate clockwise
                        e.preventDefault();
                        break;
                    case 'e':
                    case 'E':
                    case 'ArrowLeft':
                        this.rotateShape(-this.rotationStep); // Rotate counter-clockwise
                        e.preventDefault();
                        break;
                }
            }

            rotateShape(deltaRotation) {
                this.currentRotation += deltaRotation;
                
                // Sound effect integration point
                this.gameManager.playSound('shapeRotation');
                
                if (this.ghostElement) {
                    // Apply both scale, centering translation, and rotation to the ghost element
                    this.ghostElement.style.transform = `translate(-50%, -50%) scale(1.1) rotate(${this.currentRotation}rad)`;
                }
                
                // Update rotation indicator with current angle
                const degrees = Math.round(this.currentRotation * 180 / Math.PI);
                this.updateRotationIndicator(degrees);
                
                console.log(`üîÑ Shape rotated: ${degrees}¬∞`);
            }

            handlePointerDown(pointer) {
                const element = document.elementFromPoint(pointer.clientX, pointer.clientY);
                
                if (element && element.classList.contains('game-shape')) {
                    // Check if drag started from docking area
                    this.dragStartedFromDock = element.closest('.docking-area') !== null;
                    console.log(`üñ±Ô∏è Starting drag, from dock: ${this.dragStartedFromDock}`);
                    this.startDrag(element, pointer);
                }
            }

            startDrag(element, pointer) {
                this.isDragging = true;
                this.draggedElement = element;
                this.draggedShapeType = element.dataset.shape;
                
                // Initialize rotation based on shape type and dock settings
                if (this.draggedShapeType && this.draggedShapeType.includes('barbell')) {
                    // For barbells, preserve dock orientation setting
                    const barbellOrientationSelect = document.getElementById('barbellOrientation');
                    if (barbellOrientationSelect && barbellOrientationSelect.value === 'vertical') {
                        this.currentRotation = Math.PI / 2; // 90 degrees for vertical barbells
                        console.log(`üîÑ Starting barbell drag with vertical dock orientation (90¬∞)`);
                    } else {
                        this.currentRotation = 0; // Horizontal for barbells
                        console.log(`üîÑ Starting barbell drag with horizontal dock orientation (0¬∞)`);
                    }
                } else {
                    // For non-barbell shapes, always start at 0
                    this.currentRotation = 0;
                }
                
                // Add visual feedback with ghost effect
                element.classList.add('ghost-active');
                
                // Show rotation indicator
                this.showRotationIndicator();
                
                // Update rotation indicator with initial rotation
                this.updateRotationIndicator(Math.round(this.currentRotation * 180 / Math.PI));
                
                // Create ghost element for dragging
                this.createGhostElement(element, pointer);
                
                console.log(`üü¢ Started dragging: ${this.draggedShapeType} with initial rotation ${(this.currentRotation * 180 / Math.PI).toFixed(1)}¬∞ (R/E or ‚Üê/‚Üí to rotate)`);
            }

            createGhostElement(element, pointer) {
                // Create ghost element like Planck version - using CSS transform rotation
                this.ghostElement = this.createGhostPreview(this.draggedShapeType, 90);
                
                // Add ghost-shape class for CSS styling
                this.ghostElement.classList.add('ghost-shape');
                
                // Apply comprehensive ghost styling to prevent clipping
                this.ghostElement.style.position = 'fixed';
                this.ghostElement.style.pointerEvents = 'none';
                this.ghostElement.style.zIndex = '10000'; // Higher z-index to ensure visibility
                this.ghostElement.style.filter = 'drop-shadow(0 5px 15px rgba(0,0,0,0.3))';
                this.ghostElement.style.visibility = 'visible';
                this.ghostElement.style.opacity = '0.9';
                this.ghostElement.style.display = 'block';
                
                // Use CSS transform with consistent centering, scale, and rotation
                const initialTransform = `translate(-50%, -50%) scale(1.1) rotate(${this.currentRotation}rad)`;
                this.ghostElement.style.transform = initialTransform;
                console.log(`üëª Ghost element created with CSS rotation: ${(this.currentRotation * 180 / Math.PI).toFixed(1)}¬∞`);
                
                // Position at pointer
                this.updateGhostPosition(pointer);
                
                // Append to drag overlay instead of document.body to prevent clipping
                const dragOverlay = document.getElementById('dragOverlay');
                if (dragOverlay) {
                    dragOverlay.appendChild(this.ghostElement);
                    console.log(`üëª Ghost element created in drag overlay for ${this.draggedShapeType}`);
                } else {
                    document.body.appendChild(this.ghostElement);
                    console.log(`üëª Ghost element created in document body for ${this.draggedShapeType} (fallback)`);
                }
            }

            createGhostPreview(shapeType, size) {
                // Create canvas element for ghost preview (no rotation - handled by CSS transform)
                const canvas = document.createElement('canvas');
                canvas.width = size;
                canvas.height = size;
                canvas.className = 'shape-preview ghost-preview';
                canvas.dataset.shape = shapeType;

                const ctx = canvas.getContext('2d');
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';

                // Use same scale as dock preview for consistency  
                const scale = 1.9;
                
                // Render with no rotation - rotation handled by CSS transform like Planck version
                shapeRenderer.renderShapeOnCanvas(ctx, shapeType, size / 2, size / 2, 0, scale);
                
                console.log(`üëª Ghost preview created for: ${shapeType} with scale ${scale}, rotation handled by CSS`);
                return canvas;
            }

            // Streamlined rotation method (like Planck version)
            rotateShape(delta) {
                this.currentRotation += delta;
                if (this.ghostElement) {
                    // Update CSS transform with consistent centering, scale, and rotation
                    this.ghostElement.style.transform = `translate(-50%, -50%) scale(1.1) rotate(${this.currentRotation}rad)`;
                }
                this.updateRotationIndicator(Math.round(this.currentRotation * 180 / Math.PI));
                if (this.gameManager && this.gameManager.playSound) {
                    this.gameManager.playSound('shapeRotation');
                }
            }

            updateGhostPosition(pointer) {
                if (this.ghostElement) {
                    let x = pointer.clientX;
                    let y = pointer.clientY;
                    
                    // Apply touch offset if dragging from dock and offset is enabled
                    if (this.dragStartedFromDock && this.touchOffset.enabled) {
                        x += this.touchOffset.x;
                        y += this.touchOffset.y;
                    }
                    
                    // Set position using left/top
                    this.ghostElement.style.left = `${x}px`;
                    this.ghostElement.style.top = `${y}px`;
                    
                    // Preserve scale (1.1 during drag) and rotation with centering
                    this.ghostElement.style.transform = `translate(-50%, -50%) scale(1.1) rotate(${this.currentRotation}rad)`;
                }
            }

            handlePointerMove(pointer) {
                if (this.isDragging && this.ghostElement) {
                    // Streamlined: Only update ghost position for optimal performance
                    this.updateGhostPosition(pointer);
                }
            }

            handlePointerUp(pointer) {
                if (!this.isDragging) return;
                
                // Check if dropped in game area
                const gameCanvas = document.getElementById('gameCanvas');
                const canvasRect = gameCanvas.getBoundingClientRect();
                
                // Calculate the actual drop position from ghost element if it exists
                let dropX, dropY;
                if (this.ghostElement) {
                    // Get ghost element's center position
                    const ghostRect = this.ghostElement.getBoundingClientRect();
                    dropX = ghostRect.left + ghostRect.width / 2;
                    dropY = ghostRect.top + ghostRect.height / 2;
                } else {
                    // Fallback to pointer position
                    dropX = pointer.clientX;
                    dropY = pointer.clientY;
                }
                
                if (dropX >= canvasRect.left && 
                    dropX <= canvasRect.right &&
                    dropY >= canvasRect.top && 
                    dropY <= canvasRect.bottom) {
                    
                    // Calculate position relative to canvas using ghost position
                    const x = dropX - canvasRect.left;
                    const y = dropY - canvasRect.top;
                    
                    // Use current rotation as-is (it already includes barbell orientation from dock/ghost)
                    const totalRotation = this.currentRotation;
                    console.log(`üîÑ Physics: Using current rotation ${(totalRotation * 180 / Math.PI).toFixed(1)}¬∞ for ${this.draggedShapeType}`);
                    
                    // Log rotation for debugging
                    console.log(`üîç DEBUG: Dropping ${this.draggedShapeType} with total rotation: ${totalRotation} radians (${(totalRotation * 180 / Math.PI).toFixed(1)}¬∞)`);
                    
                    // Create physics shape at drop position with total rotation
                    this.physicsManager.createCompoundShape(x, y, this.draggedShapeType, totalRotation);
                    
                    // Update game state
                    this.gameManager.onShapePlaced(this.draggedShapeType);
                    
                    // Mark this slot as empty since shape was successfully placed
                    this.markSlotAsEmpty(this.draggedElement);
                    
                    console.log(`üéØ Shape dropped: ${this.draggedShapeType} at (${x}, ${y}) with ${(totalRotation * 180 / Math.PI).toFixed(0)}¬∞ total rotation`);
                } else {
                    // Shape was not dropped in game area, restore it to dock
                    this.restoreShapeToDock();
                    console.log(`‚Ü©Ô∏è Shape returned to dock: ${this.draggedShapeType}`);
                }
                
                this.endDrag();
            }

            markSlotAsEmpty(shapeElement) {
                // Remove the shape from dock and mark slot as empty
                const slot = shapeElement.parentElement;
                shapeElement.remove();
                slot.classList.add('empty');
                
                console.log(`üì¶ Dock slot emptied: ${this.draggedShapeType}`);
            }

            restoreShapeToDock() {
                // Restore the shape visibility in the dock
                if (this.draggedElement) {
                    this.draggedElement.style.visibility = 'visible';
                }
            }

            showRotationIndicator() {
                const indicator = document.getElementById('rotationIndicator');
                if (indicator) {
                    indicator.classList.add('show');
                }
            }

            hideRotationIndicator() {
                const indicator = document.getElementById('rotationIndicator');
                if (indicator) {
                    indicator.classList.remove('show');
                }
            }

            updateRotationIndicator(angle) {
                const indicator = document.getElementById('rotationIndicator');
                if (indicator) {
                    indicator.textContent = `üîÑ Rotation: ${angle}¬∞`;
                }
            }

            /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
              ‚ïë STREAMLINED DRAG MANAGEMENT (KEYBOARD ONLY)
              ‚ïë Removed mobile gestures and auto-rotation for optimal performance
              ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/

            // Simplified cleanup method (no auto-rotation timers to clear)
            stopMobileRotation() {
                // Keep method for compatibility, but no timers to clear
            }

            endDrag() {
                if (this.draggedElement) {
                    this.draggedElement.classList.remove('ghost-active');
                    
                    // If shape is still in dock (not removed), restore visibility
                    if (this.draggedElement.parentElement) {
                        this.draggedElement.style.visibility = 'visible';
                    }
                }
                
                if (this.ghostElement) {
                    // Remove from drag overlay if it exists, otherwise from document.body
                    const dragOverlay = document.getElementById('dragOverlay');
                    if (dragOverlay && dragOverlay.contains(this.ghostElement)) {
                        dragOverlay.removeChild(this.ghostElement);
                    } else if (this.ghostElement.parentNode) {
                        this.ghostElement.parentNode.removeChild(this.ghostElement);
                    }
                    this.ghostElement = null;
                }
                
                // Hide rotation indicator
                this.hideRotationIndicator();
                
                this.isDragging = false;
                this.draggedElement = null;
                this.draggedShapeType = null;
                this.currentRotation = 0;
                this.dragStartedFromDock = false;
            }

            // Configuration method for touch offset
            setTouchOffset(x, y, enabled = true) {
                this.touchOffset.x = x;
                this.touchOffset.y = y;
                this.touchOffset.enabled = enabled;
                console.log(`üì± Touch offset updated: x=${x}, y=${y}, enabled=${enabled}`);
            }

            // Get current touch offset settings
            getTouchOffset() {
                return { ...this.touchOffset };
            }

            // Touch event handlers for mobile support
            handleTouchStart(event) {
                if (event.touches.length !== 1) return;
                
                const touch = event.touches[0];
                
                // Add haptic feedback if supported
                if (navigator.vibrate && touch.target.closest('.game-shape')) {
                    navigator.vibrate(50); // Light haptic feedback
                }
                
                // Convert touch to mouse-like event
                const mouseEvent = new MouseEvent('mousedown', {
                    clientX: touch.clientX,
                    clientY: touch.clientY,
                    button: 0
                });
                
                this.handlePointerDown(mouseEvent);
                event.preventDefault();
            }
            
            handleTouchMove(event) {
                if (event.touches.length !== 1 || !this.isDragging) return;
                
                const touch = event.touches[0];
                
                // Convert touch to mouse-like event
                const mouseEvent = new MouseEvent('mousemove', {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
                
                this.throttledHandlePointerMove(mouseEvent);
                event.preventDefault();
            }
            
            handleTouchEnd(event) {
                if (!this.isDragging) return;
                
                const touch = event.changedTouches[0];
                
                // Light haptic feedback on drop if supported
                if (navigator.vibrate) {
                    navigator.vibrate(25); // Subtle feedback on drop
                }
                
                // Convert touch to mouse-like event
                const mouseEvent = new MouseEvent('mouseup', {
                    clientX: touch.clientX,
                    clientY: touch.clientY,
                    button: 0
                });
                
                this.handlePointerUp(mouseEvent);
                event.preventDefault();
            }
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë MOBILE ENHANCEMENT MANAGER 
          ‚ïë Adds mobile touch support and rotation zones while preserving mouse/keyboard
          ‚ïë Detects mobile devices and provides touch-optimized interactions
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        class MobileEnhancementManager {
            constructor(dragDropManager) {
                this.dragDropManager = dragDropManager;
                this.isMobileDevice = this.detectMobileDevice();
                this.touchStartTime = 0;
                this.touchThreshold = 10; // Minimum movement for drag
                this.rotationTimer = null;
                this.rotationInterval = 1000; // 1 second intervals for mobile rotation
                this.rotationIncrement = Math.PI / 4; // 45 degrees for mobile
                
                // Rotation zones
                this.rotationZones = {
                    left: {
                        element: document.getElementById('leftRotationZone'),
                        direction: -1, // CCW
                        active: false,
                        bounds: null
                    },
                    right: {
                        element: document.getElementById('rightRotationZone'), 
                        direction: 1, // CW
                        active: false,
                        bounds: null
                    }
                };
                
                if (this.isMobileDevice) {
                    this.setupTouchEnhancements();
                    console.log('üì± Mobile enhancements activated');
                } else {
                    console.log('üñ•Ô∏è Desktop mode - mobile enhancements disabled');
                }
            }
            
            detectMobileDevice() {
                return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                       (navigator.maxTouchPoints && navigator.maxTouchPoints > 2) ||
                       window.innerWidth <= 768;
            }
            
            setupTouchEnhancements() {
                // Add touch event listeners for mobile-specific rotation zone features
                document.addEventListener('touchstart', (e) => this.handleTouchStart(e), { passive: false });
                document.addEventListener('touchmove', (e) => this.handleTouchMove(e), { passive: false });
                document.addEventListener('touchend', (e) => this.handleTouchEnd(e), { passive: false });
                
                // Update rotation zone bounds
                this.updateRotationZoneBounds();
                window.addEventListener('resize', () => this.updateRotationZoneBounds());
                
                // Hook into DragDropManager to add mobile features
                this.originalStartDrag = this.dragDropManager.startDrag.bind(this.dragDropManager);
                this.dragDropManager.startDrag = (element, event) => {
                    this.originalStartDrag(element, event);
                    this.showRotationZones();
                };
                
                this.originalEndDrag = this.dragDropManager.endDrag.bind(this.dragDropManager);
                this.dragDropManager.endDrag = () => {
                    this.hideRotationZones();
                    this.stopRotationTimer();
                    this.originalEndDrag();
                };
            }
            
            // Enable mouse events for debugging on desktop
            enableMouseSupport() {
                if (this.mouseEventsAdded) return;
                
                // Hook into DragDropManager mouse events for rotation zones
                const originalHandlePointerMove = this.dragDropManager.handlePointerMove.bind(this.dragDropManager);
                this.dragDropManager.handlePointerMove = (event) => {
                    originalHandlePointerMove(event);
                    
                    // Check rotation zones if dragging
                    if (this.dragDropManager.isDragging && this.isMobileDevice) {
                        this.checkRotationZones(event.clientX, event.clientY);
                    }
                };
                
                this.mouseEventsAdded = true;
                console.log('üñ±Ô∏è Mouse support enabled for rotation zones');
            }
            
            disableMouseSupport() {
                // Note: This would require storing original methods to restore them
                // For now, we'll just flag that mouse support was added
                this.mouseEventsAdded = false;
                console.log('üñ±Ô∏è Mouse support disabled for rotation zones');
            }
            
            updateRotationZoneBounds() {
                const canvas = document.getElementById('gameCanvas');
                const canvasRect = canvas.getBoundingClientRect();
                
                this.rotationZones.left.bounds = {
                    left: canvasRect.left,
                    right: canvasRect.left + 80,
                    top: canvasRect.top,
                    bottom: canvasRect.bottom
                };
                
                this.rotationZones.right.bounds = {
                    left: canvasRect.right - 80,
                    right: canvasRect.right,
                    top: canvasRect.top,
                    bottom: canvasRect.bottom
                };
            }
            
            handleTouchStart(event) {
                if (event.touches.length !== 1) return;
                
                const touch = event.touches[0];
                const element = document.elementFromPoint(touch.clientX, touch.clientY);
                
                // Only handle rotation zones here - let DragDropManager handle shape dragging
                this.checkRotationZones(touch.clientX, touch.clientY);
                
                this.touchStartTime = Date.now();
            }
            
            handleTouchMove(event) {
                if (!this.dragDropManager.isDragging) return;
                if (event.touches.length !== 1) return;
                
                const touch = event.touches[0];
                
                // Check rotation zones with haptic feedback
                const wasInZone = this.currentRotationZone;
                this.checkRotationZones(touch.clientX, touch.clientY);
                
                // Haptic feedback when entering rotation zone
                if (this.currentRotationZone && !wasInZone && navigator.vibrate) {
                    navigator.vibrate(30); // Light feedback when entering rotation zone
                }
                
                event.preventDefault();
            }

            handleTouchEnd(event) {
                // Rotation handling on touch end
                if (this.currentRotationZone && this.dragDropManager.isDragging) {
                    const rotationDirection = this.currentRotationZone === 'left' ? -1 : 1;
                    this.dragDropManager.rotateShape(rotationDirection * this.dragDropManager.rotationStep);
                    
                    // Stronger haptic feedback for rotation
                    if (navigator.vibrate) {
                        navigator.vibrate([50, 50, 50]); // Pattern for rotation feedback
                    }
                }
                
                this.hideRotationZones();
                this.stopRotationTimer();
                this.currentRotationZone = null;
                
                event.preventDefault();
            }            checkRotationZones(x, y) {
                let inZone = null;
                
                // Debug logging
                console.log(`üìç Checking rotation zones at (${x}, ${y})`);
                
                // Check left zone
                if (this.isPointInZone(x, y, this.rotationZones.left.bounds)) {
                    inZone = 'left';
                    console.log('üìç In LEFT rotation zone');
                }
                // Check right zone
                else if (this.isPointInZone(x, y, this.rotationZones.right.bounds)) {
                    inZone = 'right';
                    console.log('üìç In RIGHT rotation zone');
                }
                
                // Handle zone entry/exit
                if (inZone && !this.rotationZones[inZone].active) {
                    this.enterRotationZone(inZone);
                } else if (!inZone) {
                    this.exitAllRotationZones();
                }
            }
            
            isPointInZone(x, y, bounds) {
                return bounds && x >= bounds.left && x <= bounds.right && 
                       y >= bounds.top && y <= bounds.bottom;
            }
            
            enterRotationZone(zoneName) {
                const zone = this.rotationZones[zoneName];
                if (!zone || !zone.element) return;
                
                // Exit other zones first
                this.exitAllRotationZones();
                
                // Activate this zone
                zone.active = true;
                zone.element.classList.add('active');
                
                // Start rotation timer
                this.rotationTimer = setInterval(() => {
                    if (this.dragDropManager.isDragging) {
                        this.dragDropManager.currentRotation += zone.direction * this.rotationIncrement;
                        
                        // Update ghost element rotation
                        if (this.dragDropManager.ghostElement) {
                            this.dragDropManager.ghostElement.style.transform = 
                                `translate(-50%, -50%) scale(1.1) rotate(${this.dragDropManager.currentRotation}rad)`;
                        }
                        
                        // Haptic feedback
                        this.playHapticFeedback();
                    }
                }, this.rotationInterval);
                
                console.log(`üì± Entered ${zoneName} rotation zone`);
            }
            
            exitAllRotationZones() {
                Object.keys(this.rotationZones).forEach(zoneName => {
                    const zone = this.rotationZones[zoneName];
                    if (zone.active && zone.element) {
                        zone.active = false;
                        zone.element.classList.remove('active');
                    }
                });
                
                this.stopRotationTimer();
            }
            
            stopRotationTimer() {
                if (this.rotationTimer) {
                    clearInterval(this.rotationTimer);
                    this.rotationTimer = null;
                }
            }
            
            showRotationZones() {
                if (!this.isMobileDevice) return;
                
                Object.values(this.rotationZones).forEach(zone => {
                    if (zone.element) {
                        zone.element.classList.add('visible');
                    }
                });
            }
            
            hideRotationZones() {
                Object.values(this.rotationZones).forEach(zone => {
                    if (zone.element) {
                        zone.element.classList.remove('visible', 'active');
                    }
                });
            }
            
            playHapticFeedback() {
                if (navigator.vibrate) {
                    navigator.vibrate(50); // Short vibration
                }
            }
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë ENHANCED GAME STATE WITH END-LEVEL COUNTDOWN
          ‚ïë Task 4.2c: Implements end-level countdown timer and level failure conditions
          ‚ïë Level fails if any piece falls off screen before countdown expires
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        class GameState {
            constructor() {
                this.shapes = [];
                this.placedShapes = [];
                this.isGameActive = true;
                this.isCountdownActive = false;
                this.countdownTime = 3;
                
                // HUD State
                this.level = 1;
                this.score = 0;
                this.coins = 0;
                this.progress = 0; // 0-100%
                
                // Timer System
                this.timerMode = 'elapsed'; // 'elapsed', 'countdown', 'endlevel'
                this.gameTime = 0; // Elapsed seconds
                this.endLevelTime = currentLevelConfig.endLevelDuration; // End level countdown duration from config
                this.endLevelDots = 0;
                
                // Physics Event Tracking
                this.shapeCollisions = 0;
                this.platformLandings = 0;
                this.shapeFalls = 0;
                this.stability = 100; // Stability percentage
                
                // End-Level State
                this.endLevelStarted = false;
                this.levelFailed = false;
                this.levelCompleted = false;
            }

            startEndLevelCountdown() {
                this.endLevelStarted = true;
                this.timerMode = 'endlevel';
                this.endLevelTime = currentLevelConfig.endLevelDuration; // Use configured duration
                this.isCountdownActive = true;
                
                console.log(`‚è∞ End-level countdown started: ${currentLevelConfig.endLevelDuration} seconds`);
            }

            checkLevelFailure() {
                // Level fails if any shape falls during end-level countdown
                if (this.endLevelStarted && !this.levelCompleted && this.shapeFalls > 0) {
                    this.levelFailed = true;
                    this.isGameActive = false;
                    return true;
                }
                return false;
            }

            resetLevel() {
                this.shapes = [];
                this.placedShapes = [];
                this.isGameActive = true;
                this.isCountdownActive = false;
                this.countdownTime = 3;
                this.gameTime = 0;
                this.timerMode = 'elapsed';
                this.endLevelTime = currentLevelConfig.endLevelDuration;
                this.endLevelDots = 0;
                
                // Reset score and coins to zero for fresh start
                this.score = 0;
                this.coins = 0;
                this.progress = 0;
                
                // Reset physics event tracking
                this.shapeCollisions = 0;
                this.platformLandings = 0;
                this.shapeFalls = 0;
                this.stability = 100;
                
                // Reset end-level state
                this.endLevelStarted = false;
                this.levelFailed = false;
                this.levelCompleted = false;
                
                console.log('üîÑ Game state reset for new level');
            }

            addPlacedShape(shapeType) {
                this.placedShapes.push({
                    type: shapeType,
                    timestamp: Date.now()
                });
                
                const totalShapes = currentLevelConfig.dockShapes.length;
                console.log(`üìä Shape placed: ${shapeType} (${this.placedShapes.length}/${totalShapes})`);
            }

            recordPhysicsEvent(eventType) {
                switch(eventType) {
                    case 'collision':
                        this.shapeCollisions++;
                        break;
                    case 'landing':
                        this.platformLandings++;
                        break;
                    case 'fall':
                        this.shapeFalls++;
                        this.stability = Math.max(0, this.stability - 10); // Reduce stability on falls
                        
                        // Check if this fall causes level failure
                        if (this.checkLevelFailure()) {
                            console.log('üí• LEVEL FAILED: Shape fell during end-level countdown!');
                        }
                        break;
                }
            }
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë ENHANCED GAME MANAGER WITH PHYSICS EVENT INTEGRATION
          ‚ïë Phase 4.1: Integrates physics events with game logic and UI updates
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        class GameManager {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.physicsManager = new PhysicsManager(this.canvas);
                this.gameState = new GameState();
                this.dragDropManager = new DragDropManager(this.physicsManager, this);
                this.mobileEnhancementManager = new MobileEnhancementManager(this.dragDropManager);
                
                // v9: Canvas Enhancement System
                this.themeManager = new ThemeManager(this.physicsManager.assetManager, this);
                
                // Level management (Super Mario Bros style)
                this.currentWorld = 1;
                this.currentLevel = 1;
                
                // Make this globally available for physics events
                window.gameManager = this;
                
                this.setupUI();
                this.setupEventListeners();
                
                console.log('üéÆ Enhanced Game Manager with Physics Events initialized');
            }

            setupUI() {
                // Initialize HUD displays
                this.updateScoreDisplay();
                this.updateCoinDisplay();
                this.updateLevelDisplay();
                this.updateStars(0);
                this.updateDebugInfo();
                
                // Initialize HUD timer system
                this.timerInterval = setInterval(() => this.updateTimer(), 1000);
                
                // Event listeners are handled by onclick in HTML - no need for duplicate listener
                console.log('üéÆ GameManager initialized with unified reset system');
            }

            setupEventListeners() {
                // Keyboard controls for testing (fallback)
                document.addEventListener('keydown', (e) => {
                    if (!this.gameState.isGameActive) return;
                    
                    const centerX = this.canvas.width / 2;
                    const dropY = 100;
                    
                    switch(e.key) {
                        case '1':
                            this.physicsManager.createShape(centerX, dropY, 'square');
                            this.onShapePlaced('square');
                            break;
                        case '2':
                            this.physicsManager.createShape(centerX, dropY, 'triangle');
                            this.onShapePlaced('triangle');
                            break;
                        case '3':
                            this.physicsManager.createShape(centerX, dropY, 'circle');
                            this.onShapePlaced('circle');
                            break;
                        case '4':
                            this.physicsManager.createShape(centerX, dropY, 'cross2');
                            this.onShapePlaced('cross2');
                            break;
                        case '5':
                            this.physicsManager.createShape(centerX, dropY, 'l');
                            this.onShapePlaced('l');
                            break;
                        case '6':
                            this.physicsManager.createShape(centerX, dropY, 'cross');
                            this.onShapePlaced('cross');
                            break;
                        case '7':
                            this.physicsManager.createShape(centerX, dropY, 'barbell-one');
                            this.onShapePlaced('barbell-one');
                            break;
                        case '8':
                            this.physicsManager.createShape(centerX, dropY, 'barbell-two');
                            this.onShapePlaced('barbell-two');
                            break;
                        case '9':
                            this.physicsManager.createShape(centerX, dropY, 'diamond-barbell');
                            this.onShapePlaced('diamond-barbell');
                            break;
                    }
                });
            }

            // UI Update Methods
            updateScoreDisplay() {
                const scoreElement = document.getElementById('scoreText');
                if (scoreElement) {
                    scoreElement.textContent = this.gameState.score.toLocaleString();
                    
                    // Add animation for score increase
                    scoreElement.classList.add('score-increase');
                    setTimeout(() => {
                        scoreElement.classList.remove('score-increase');
                    }, 600);
                }
            }

            updateCoinDisplay() {
                const coinElement = document.getElementById('coinAmount');
                if (coinElement) {
                    coinElement.textContent = this.gameState.coins.toString();
                    
                    // Add animation for coin increase
                    coinElement.classList.add('coin-increase');
                    setTimeout(() => {
                        coinElement.classList.remove('coin-increase');
                    }, 600);
                }
            }

            updateLevelDisplay() {
                const levelElement = document.getElementById('levelDisplay');
                if (levelElement) {
                    levelElement.textContent = `World ${this.currentWorld}-${this.currentLevel}`;
                }
            }

            // Level progression methods
            nextLevel() {
                this.currentLevel++;
                this.updateLevelDisplay();
                console.log(`üèÅ Advanced to World ${this.currentWorld}-${this.currentLevel}`);
            }

            nextWorld() {
                this.currentWorld++;
                this.currentLevel = 1;
                this.updateLevelDisplay();
                console.log(`üåç Advanced to World ${this.currentWorld}-${this.currentLevel}`);
            }

            setLevel(world, level) {
                this.currentWorld = world;
                this.currentLevel = level;
                this.updateLevelDisplay();
                console.log(`üìç Set level to World ${this.currentWorld}-${this.currentLevel}`);
            }

            // Physics Event Handlers
            onShapeLandedOnPlatform() {
                console.log('üéØ GameManager: Shape landed on platform - triggering camera shake!');
                this.gameState.recordPhysicsEvent('landing');
                
                // Track consecutive landings for streak bonuses
                this.gameState.consecutiveLandings = (this.gameState.consecutiveLandings || 0) + 1;
                this.gameState.lastAction = 'landing';
                
                // Base rewards
                let scoreBonus = 50;
                let coinBonus = 1;
                
                // Streak multipliers
                if (this.gameState.consecutiveLandings >= 5) {
                    coinBonus += 5; // +5 coins for 5+ streak
                    scoreBonus += 100;
                    this.createCoinShower('LANDING MASTER!', 5);
                } else if (this.gameState.consecutiveLandings >= 3) {
                    coinBonus += 2; // +2 coins for 3+ streak
                    scoreBonus += 50;
                    this.createFloatingText(`üî• ${this.gameState.consecutiveLandings}x STREAK!`, 
                        document.getElementById('coinAmount'), '#FF6B35');
                }
                
                this.gameState.score += scoreBonus;
                this.gameState.coins += coinBonus;
                this.updateScoreDisplay();
                this.updateCoinDisplay();
                
                // Sound effect integration point
                this.playSound('shapeLanding');
                
                // Create enhanced particle effects
                if (this.physicsManager && this.physicsManager.particleSystem) {
                    const canvasRect = this.physicsManager.canvas.getBoundingClientRect();
                    const platformY = canvasRect.height * 0.85;
                    const x = Math.random() * canvasRect.width * 0.6 + canvasRect.width * 0.2;
                    const particleCount = Math.min(12 + this.gameState.consecutiveLandings * 2, 24);
                    this.physicsManager.particleSystem.createThemeParticles('landing', x, platformY, particleCount);
                }
                
                // Enhanced visual feedback
                const scoreElement = document.getElementById('scoreText');
                const coinElement = document.getElementById('coinAmount');
                
                this.createFloatingText(`+${scoreBonus}`, scoreElement, '#10B981');
                this.createFloatingText(`+${coinBonus}`, coinElement, '#FFD700');
                
                // Extra visual effects for big bonuses
                if (coinBonus > 3) {
                    this.createFloatingText('üí∞üí∞üí∞', coinElement, '#FFD700');
                    this.pulseElement(coinElement, 3);
                }
                
                console.log(`üéØ Landing streak: ${this.gameState.consecutiveLandings}, Coins: +${coinBonus}`);
            }

            onShapeCollision() {
                console.log('üîÑ GameManager: Shape collision - triggering camera shake!');
                this.gameState.recordPhysicsEvent('collision');
                
                // Reset landing streak on collision
                this.gameState.consecutiveLandings = 0;
                
                // Track collision chains for bonus coins
                this.gameState.recentCollisions = (this.gameState.recentCollisions || 0) + 1;
                
                // Base rewards
                let scoreBonus = 25;
                let coinBonus = 0;
                
                // Collision-based coin rewards
                if (this.gameState.recentCollisions % 1 === 0) { // Every collision now gives coins!
                    coinBonus = 1;
                    
                    // Bonus for rapid collisions
                    if (this.gameState.recentCollisions >= 3) {
                        coinBonus += 2; // +2 extra for collision chains
                        scoreBonus += 25;
                        this.createFloatingText('üí• CHAIN REACTION!', document.getElementById('scoreText'), '#FF6B35');
                    }
                }
                
                // Random coin jackpots (5% chance)
                if (Math.random() < 0.05) {
                    const jackpot = Math.floor(Math.random() * 10) + 5; // 5-14 coins
                    coinBonus += jackpot;
                    this.createCoinShower('JACKPOT!', jackpot);
                    
                    // Small celebratory shake for big jackpots
                    if (jackpot >= 10 && this.physicsManager) {
                        this.physicsManager.startCameraShake(4, 300);
                    }
                }
                
                this.gameState.score += scoreBonus;
                this.gameState.coins += coinBonus;
                
                // Sound effect integration point
                this.playSound('shapeCollision');
                
                // Create enhanced particle effects
                if (this.physicsManager && this.physicsManager.particleSystem) {
                    const canvasRect = this.physicsManager.canvas.getBoundingClientRect();
                    const x = Math.random() * canvasRect.width * 0.8 + canvasRect.width * 0.1;
                    const y = Math.random() * canvasRect.height * 0.6 + canvasRect.height * 0.2;
                    const particleCount = Math.min(8 + this.gameState.recentCollisions, 20);
                    this.physicsManager.particleSystem.createThemeParticles('collision', x, y, particleCount);
                }
                
                this.updateScoreDisplay();
                if (coinBonus > 0) {
                    this.updateCoinDisplay();
                    const coinElement = document.getElementById('coinAmount');
                    this.createFloatingText(`+${coinBonus}`, coinElement, '#FFD700');
                }
                
                // Add visual feedback for collision bonuses
                const scoreElement = document.getElementById('scoreText');
                this.createFloatingText(`+${scoreBonus}`, scoreElement, '#4ECDC4');
                
                // Reset collision counter after a pause
                setTimeout(() => {
                    if (this.gameState.lastAction !== 'collision') {
                        this.gameState.recentCollisions = 0;
                    }
                }, 2000);
                
                this.gameState.lastAction = 'collision';
                
                console.log(`üîÑ Collision chain: ${this.gameState.recentCollisions}, Coins: +${coinBonus}`);
            }

            onShapeFell() {
                console.log('üí• GameManager: Shape fell - triggering camera shake!');
                this.gameState.recordPhysicsEvent('fall');
                
                // Track fall time for stability bonuses
                this.gameState.lastFallTime = Date.now();
                
                // Reset all streaks on fall
                this.gameState.consecutiveLandings = 0;
                this.gameState.recentCollisions = 0;
                
                // Dramatic penalties based on current coin count
                let scorePenalty = 100;
                let coinPenalty = 3; // Increased base penalty
                
                // Scale penalties with current wealth (more coins = bigger penalty)
                if (this.gameState.coins >= 50) {
                    coinPenalty += 7; // -10 coins total for wealthy players
                    scorePenalty += 200;
                    this.createFloatingText('üí∏ MAJOR LOSS!', document.getElementById('coinAmount'), '#FF4444');
                } else if (this.gameState.coins >= 20) {
                    coinPenalty += 2; // -5 coins total
                    scorePenalty += 100;
                }
                
                // Apply penalties with minimums
                this.gameState.score = Math.max(0, this.gameState.score - scorePenalty);
                this.gameState.coins = Math.max(0, this.gameState.coins - coinPenalty);
                
                this.updateScoreDisplay();
                this.updateCoinDisplay();
                
                // Dramatic visual effects
                const coinElement = document.getElementById('coinAmount');
                const scoreElement = document.getElementById('scoreText');
                
                this.createFloatingText(`-${coinPenalty}`, coinElement, '#FF6B6B');
                this.createFloatingText(`-${scorePenalty}`, scoreElement, '#FF6B6B');
                
                // Shake effect for major losses
                if (coinPenalty >= 5) {
                    this.shakeElement(coinElement, 5);
                    this.createFloatingText('üíÄüíÄÔøΩ', coinElement, '#FF4444');
                }
                
                // Camera shake effect for dramatic falls - RANDOM INTENSITY
                const randomIntensity = Math.floor(Math.random() * 10) + 10; // Random 10-19 intensity
                const duration = 800;
                console.log(`üî• ATTEMPTING CAMERA SHAKE: intensity=${randomIntensity}, duration=${duration}ms`);
                
                if (this.physicsManager) {
                    console.log('‚úÖ PhysicsManager found, calling startCameraShake...');
                    this.physicsManager.startCameraShake(randomIntensity, duration);
                } else {
                    console.log('‚ùå PhysicsManager not found!');
                }
                
                // Sound effect integration point
                this.playSound('shapeFall');
                
                console.log(`üí• FALL PENALTY: -${coinPenalty} coins, -${scorePenalty} points`);
                
                // Check if level failed due to fall during countdown
                if (this.gameState.levelFailed) {
                    this.onLevelFailed();
                    return;
                }
                
                // Check if this should trigger game over (outside of end-level countdown)
                if (!this.gameState.endLevelStarted && this.gameState.shapeFalls >= 3) {
                    this.onGameOver();
                }
            }

            onShapePlaced(shapeType) {
                this.gameState.addPlacedShape(shapeType);
                this.updateDebugInfo();
                
                // Update score
                this.gameState.score += 100;
                document.getElementById('scoreText').textContent = this.gameState.score.toLocaleString();
                
                // Update progress bar using current dock configuration
                const totalShapes = currentLevelConfig.dockShapes.length;
                const progress = (this.gameState.placedShapes.length / totalShapes) * 100;
                document.getElementById('starProgressBar').style.width = progress + '%';
                
                // Update stars based on progress
                this.updateStars(this.gameState.placedShapes.length);
                
                // Check for level completion (start end-level countdown)
                if (this.gameState.placedShapes.length >= totalShapes) {
                    console.log(`üéØ All ${totalShapes} shapes placed! Starting end-level countdown...`);
                    
                    // Coin reward for successfully placing all shapes
                    this.gameState.coins += 5;
                    this.updateCoinDisplay();
                    
                    // Show coin reward particle
                    const coinElement = document.getElementById('coinAmount');
                    this.createFloatingText('+5 All Shapes!', coinElement, '#FFD700');
                    
                    this.gameState.startEndLevelCountdown();
                    this.physicsManager.showEventNotification('End-Level Countdown!', 'balance');
                }
            }

            updateStars(shapesPlaced) {
                const stars = document.querySelectorAll('.star');
                const totalShapes = currentLevelConfig.dockShapes.length;
                const progressPercent = (shapesPlaced / totalShapes) * 100;
                
                // Star thresholds: 33.33%, 66.66%, 100%
                const starThresholds = [33.33, 66.66, 100];
                
                stars.forEach((star, index) => {
                    const threshold = starThresholds[index];
                    const shouldBeFilled = progressPercent >= threshold;
                    
                    if (shouldBeFilled && !star.classList.contains('filled')) {
                        // Star should be filled and isn't yet
                        const wasEmpty = !star.classList.contains('filled');
                        star.classList.add('filled');
                        
                        // Add particle effect for newly filled star
                        if (wasEmpty) {
                            setTimeout(() => {
                                this.createFloatingText('‚≠ê', star, '#FFD700');
                            }, 100);
                        }
                    } else if (!shouldBeFilled && star.classList.contains('filled')) {
                        // Star should not be filled but is
                        star.classList.remove('filled');
                    }
                });
                
                // Update progress bar with animation using current dock configuration
                const progressBar = document.getElementById('starProgressBar');
                
                // Smooth progress bar animation
                progressBar.style.transition = 'width 0.5s ease-out';
                progressBar.style.width = progressPercent + '%';
                
                if (shapesPlaced > 0) {
                    this.animateProgressBar(progressBar);
                }
            }

            updateTimer() {
                if (!this.gameState.isGameActive) return;
                
                const timerElement = document.getElementById('gameTimer');
                
                switch(this.gameState.timerMode) {
                    case 'elapsed':
                        this.updateElapsedTimer(timerElement);
                        break;
                    case 'countdown':
                        this.updateCountdownTimer(timerElement);
                        break;
                    case 'endlevel':
                        this.updateEndLevelTimer(timerElement);
                        break;
                }
            }

            updateElapsedTimer(element) {
                const minutes = Math.floor(this.gameState.gameTime / 60);
                const seconds = this.gameState.gameTime % 60;
                element.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                this.gameState.gameTime++;
                
                // Remove any warning classes
                element.classList.remove('timer-warning', 'timer-critical');
            }

            updateCountdownTimer(element) {
                // Use gameTime for countdown timer (starts from configured time and counts down)
                const minutes = Math.floor(this.gameState.gameTime / 60);
                const seconds = this.gameState.gameTime % 60;
                element.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                
                // Remove previous warning classes
                element.classList.remove('timer-warning', 'timer-critical');
                
                // Add warning effects based on time remaining
                if (this.gameState.gameTime <= 5 && this.gameState.gameTime > 0) {
                    element.classList.add('timer-critical');
                } else if (this.gameState.gameTime <= 10) {
                    element.classList.add('timer-warning');
                }
                
                // Countdown: decrease time
                this.gameState.gameTime--;
                
                // Check if countdown reached zero
                if (this.gameState.gameTime < 0) {
                    this.gameState.gameTime = 0; // Prevent negative display
                    element.textContent = '0:00';
                    
                    // Trigger game over due to time up
                    console.log('‚è∞ Countdown timer reached zero - Game Over!');
                    this.onGameTimeUp();
                }
            }

            updateEndLevelTimer(element) {
                // Create 3-dot display if it doesn't exist
                if (!element.querySelector('.countdown-dots')) {
                    console.log('üî¥ Creating dramatic 3-dot countdown display...');
                    element.innerHTML = '';
                    const dotsContainer = document.createElement('div');
                    dotsContainer.className = 'countdown-dots';
                    
                    for (let i = 0; i < 3; i++) {
                        const dot = document.createElement('div');
                        dot.className = 'countdown-dot';
                        dot.id = `countdown-dot-${i}`;
                        dotsContainer.appendChild(dot);
                    }
                    
                    element.appendChild(dotsContainer);
                    this.gameState.endLevelDots = 0;
                    console.log('‚úÖ 3-dot countdown display created!');
                }
                
                // Update dots based on time remaining using configured duration
                const totalDuration = currentLevelConfig.endLevelDuration;
                const timeElapsed = totalDuration - this.gameState.endLevelTime;
                const dotsToShow = Math.min(3, Math.ceil((timeElapsed / totalDuration) * 3));
                console.log(`üîµ Updating dots: ${dotsToShow} active dots, ${this.gameState.endLevelTime}s remaining (total: ${totalDuration}s)`);
                
                for (let i = 0; i < 3; i++) {
                    const dot = document.getElementById(`countdown-dot-${i}`);
                    if (dot) {
                        if (i < dotsToShow) {
                            if (i === dotsToShow - 1 && this.gameState.endLevelTime > 0) {
                                dot.className = 'countdown-dot active';
                            } else {
                                dot.className = 'countdown-dot completed';
                            }
                        } else {
                            dot.className = 'countdown-dot';
                        }
                    }
                }
                
                this.gameState.endLevelTime--;
                
                if (this.gameState.endLevelTime < 0) {
                    console.log('üèÜ End level countdown complete! Level finished!');
                    this.triggerLevelCompleteEffects();
                    this.onLevelComplete();
                }
            }

            updateDebugInfo() {
                const debugInfo = document.getElementById('debugInfo');
                const physicsStats = this.physicsManager.getEventStats();
                const totalShapes = currentLevelConfig.dockShapes.length;
                
                // Fix #4: Count available shapes properly - shapes that are visible and not being dragged
                const availableShapes = document.querySelectorAll('.game-shape:not(.dragging)').length;
                
                debugInfo.textContent = `Placed: ${this.gameState.placedShapes.length}/${totalShapes} | Dock: ${availableShapes}/${totalShapes} | Events: ${physicsStats.events} | FPS: 60`;
            }

            onGameTimeUp() {
                this.gameState.isGameActive = false;
                console.log('‚è∞ Time Up! Level Failed!');
            }

            onGameOver() {
                this.gameState.isGameActive = false;
                console.log('üíÄ Game Over! Too many shapes fell.');
            }

            /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
              ‚ïë SHOW LEVEL CLEARED POPUP
              ‚ïë Displays a celebratory popup modal when the level is successfully cleared.
              ‚ïë Includes animated title, stars, and button to continue or replay level.
              ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
            showLevelClearedPopup() {
                // Create modal overlay
                const modal = document.createElement('div');
                modal.className = 'level-cleared-modal';
                modal.id = 'levelClearedModal';
                
                // Create modal content
                const content = document.createElement('div');
                content.className = 'level-cleared-content';
                
                // Title
                const title = document.createElement('div');
                title.className = 'level-cleared-title';
                title.textContent = 'Level Cleared!';
                
                // Subtitle with score info
                const subtitle = document.createElement('div');
                subtitle.className = 'level-cleared-subtitle';
                subtitle.textContent = `Score: ${this.gameState.score} | Coins: ${this.gameState.coins}`;
                
                // Animated stars
                const stars = document.createElement('div');
                stars.className = 'level-cleared-stars';
                stars.textContent = '‚≠ê ‚≠ê ‚≠ê';
                
                // Continue button
                const continueBtn = document.createElement('button');
                continueBtn.className = 'level-cleared-button';
                continueBtn.textContent = 'Continue';
                continueBtn.onclick = () => this.closeLevelClearedPopup();
                
                // Replay button
                const replayBtn = document.createElement('button');
                replayBtn.className = 'level-cleared-button';
                replayBtn.textContent = 'Replay Level';
                replayBtn.style.background = 'linear-gradient(135deg, #2196F3 0%, #1976D2 100%)';
                replayBtn.onclick = () => {
                    this.closeLevelClearedPopup();
                    resetLevel();
                };
                
                // Assemble modal
                content.appendChild(title);
                content.appendChild(subtitle);
                content.appendChild(stars);
                content.appendChild(continueBtn);
                content.appendChild(replayBtn);
                modal.appendChild(content);
                
                // Add to page
                document.body.appendChild(modal);
                
                console.log('üéâ Level Cleared popup displayed!');
            }

            closeLevelClearedPopup() {
                const modal = document.getElementById('levelClearedModal');
                if (modal) {
                    modal.style.animation = 'modalFadeIn 0.3s ease-out reverse';
                    setTimeout(() => {
                        modal.remove();
                    }, 300);
                }
            }

            /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
              ‚ïë TRIGGER LEVEL COMPLETE EFFECTS
              ‚ïë Creates spectacular visual effects when level is completed successfully.
              ‚ïë Includes cascading star effects, screen flash, and celebration particles.
              ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
            triggerLevelCompleteEffects() {
                // Flash effect for completion
                const screen = document.querySelector('.screen');
                screen.style.animation = 'levelCompleteFlash 1s ease-out';
                setTimeout(() => {
                    screen.style.animation = '';
                }, 1000);
                
                // Cascade star effects
                const stars = document.querySelectorAll('.star');
                stars.forEach((star, index) => {
                    setTimeout(() => {
                        star.style.animation = 'starBurst 0.8s ease-out';
                        this.createFloatingText('‚òÖ', star, '#FFD700');
                    }, index * 150);
                });
                
                // Multiple celebration particles
                setTimeout(() => {
                    const scoreElement = document.getElementById('scoreText');
                    const coinElement = document.getElementById('coinAmount');
                    
                    this.createFloatingText('üéâ', scoreElement, '#FF6B6B');
                    this.createFloatingText('üéä', coinElement, '#4ECDC4');
                    
                    setTimeout(() => {
                        this.createFloatingText('üèÜ', scoreElement, '#FFD700');
                    }, 300);
                }, 500);
            }

            onLevelComplete() {
                this.gameState.isGameActive = false;
                this.gameState.levelCompleted = true;
                console.log('üéØ Level Complete! Score: ' + this.gameState.score);
                
                // Sound effect integration point
                this.playSound('levelComplete');
                
                // Bonus points for completion with particle effects
                this.gameState.score += 500;
                this.gameState.coins += 25; // Increased completion bonus
                
                // Show Level Cleared popup immediately
                this.showLevelClearedPopup();
                
                // Advance to next level after a delay
                setTimeout(() => {
                    this.nextLevel();
                }, 3000); // Increased delay to account for popup
                
                // Create floating text for completion bonus
                const scoreElement = document.getElementById('scoreText');
                this.createFloatingText('+500', scoreElement, '#FFD700');
                
                const coinElement = document.getElementById('coinAmount');
                this.createFloatingText('+25 Complete!', coinElement, '#4ECDC4');
                
                // Stability bonus
                const stabilityBonus = Math.floor(this.gameState.stability * 2);
                this.gameState.score += stabilityBonus;
                
                // Stability coin bonus for high stability (80%+)
                if (this.gameState.stability >= 80) {
                    const coinBonus = Math.floor(this.gameState.stability / 10);
                    this.gameState.coins += coinBonus;
                    
                    setTimeout(() => {
                        this.createFloatingText(`+${coinBonus} Stability`, coinElement, '#10B981');
                    }, 750);
                }
                
                if (stabilityBonus > 0) {
                    setTimeout(() => {
                        this.createFloatingText(`+${stabilityBonus} Stability`, scoreElement, '#10B981');
                    }, 500);
                }
                
                // Update display
                this.updateScoreDisplay();
                this.updateCoinDisplay();
                
                // All stars should be filled with animation
                this.updateStars(3);
                const progressBar = document.getElementById('starProgressBar');
                this.animateProgressBar(progressBar);
                
                this.physicsManager.showEventNotification('Level Complete!', 'collision');
            }

            onLevelFailed() {
                this.gameState.isGameActive = false;
                console.log('üíÄ Level Failed! Shape fell during countdown.');
                this.physicsManager.showEventNotification('Level Failed!', 'fall');
            }

            resetLevel() {
                console.log('üîÑ Resetting level...');
                
                // Clear all dynamic physics bodies
                this.physicsManager.cleanup();
                
                // Recreate the platform and boundaries
                this.physicsManager.createPlatform();
                this.physicsManager.createBoundaries();
                
                // Reset game state
                this.gameState.resetLevel();
                
                // Restore all shapes to docking area
                this.restoreAllShapesToDock();
                
                // Reset HUD to initial values
                this.updateScoreDisplay();
                this.updateCoinDisplay();
                document.getElementById('starProgressBar').style.width = '0%';
                document.getElementById('gameTimer').textContent = '0:00';
                
                // Reset timer mode to elapsed
                const modeIndicator = document.getElementById('timerModeIndicator');
                modeIndicator.className = 'timer-mode-indicator timer-mode-elapsed';
                modeIndicator.textContent = '‚è±';
                
                // Reset all stars
                document.querySelectorAll('.star').forEach(star => {
                    star.classList.remove('filled');
                });
                
                // Update debug info
                this.updateDebugInfo();
                
                console.log('‚úÖ Level reset complete');
            }

            /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
              ‚ïë CREATE FLOATING TEXT PARTICLE
              ‚ïë Generates animated floating text particles for visual feedback. Creates
              ‚ïë temporary DOM elements positioned relative to target elements that float
              ‚ïë upward and fade out. Used for score/coin increase notifications.
              ‚ïë Parameters: text - Text to display, element - Reference element, color - Text color
              ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
            createFloatingText(text, element, color = '#FFD700') {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.textContent = text;
                particle.style.color = color;
                
                const rect = element.getBoundingClientRect();
                particle.style.left = (rect.left + rect.width / 2) + 'px';
                particle.style.top = rect.top + 'px';
                
                document.body.appendChild(particle);
                
                setTimeout(() => {
                    if (particle.parentNode) {
                        document.body.removeChild(particle);
                    }
                }, 2000);
            }

            /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
              ‚ïë CREATE COIN SHOWER EFFECT
              ‚ïë Creates a spectacular shower of coin particles for major achievements.
              ‚ïë Multiple floating coins rain down from the coin counter element.
              ‚ïë Used for jackpots, streaks, and other exciting coin-earning events.
              ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
            createCoinShower(message, coinCount) {
                const coinElement = document.getElementById('coinAmount');
                const rect = coinElement.getBoundingClientRect();
                
                // Create the main message
                this.createFloatingText(message, coinElement, '#FFD700');
                
                // Create shower of individual coins
                for (let i = 0; i < Math.min(coinCount, 15); i++) {
                    setTimeout(() => {
                        const coin = document.createElement('div');
                        coin.className = 'particle';
                        coin.textContent = 'üí∞';
                        coin.style.fontSize = '20px';
                        coin.style.left = (rect.left + Math.random() * rect.width) + 'px';
                        coin.style.top = rect.top + 'px';
                        coin.style.transform = `translate(${(Math.random() - 0.5) * 200}px, ${Math.random() * -100}px)`;
                        coin.style.opacity = '0';
                        coin.style.transition = 'all 2s ease-out';
                        
                        document.body.appendChild(coin);
                        
                        // Animate the coin
                        setTimeout(() => {
                            coin.style.transform += ` translateY(${Math.random() * 200 + 100}px)`;
                            coin.style.opacity = '1';
                        }, 50);
                        
                        // Remove after animation
                        setTimeout(() => {
                            if (coin.parentNode) {
                                document.body.removeChild(coin);
                            }
                        }, 2500);
                    }, i * 100); // Stagger the coins
                }
            }

            /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
              ‚ïë PULSE ELEMENT EFFECT
              ‚ïë Makes an element pulse with a glowing effect to draw attention.
              ‚ïë Used for significant coin increases and achievements.
              ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
            pulseElement(element, pulses = 3) {
                let count = 0;
                const originalTransform = element.style.transform;
                const originalBoxShadow = element.style.boxShadow;
                
                const pulse = () => {
                    if (count >= pulses) {
                        element.style.transform = originalTransform;
                        element.style.boxShadow = originalBoxShadow;
                        return;
                    }
                    
                    element.style.transform = 'scale(1.2)';
                    element.style.boxShadow = '0 0 20px #FFD700';
                    element.style.transition = 'all 0.2s ease-in-out';
                    
                    setTimeout(() => {
                        element.style.transform = 'scale(1)';
                        element.style.boxShadow = originalBoxShadow;
                        count++;
                        setTimeout(pulse, 300);
                    }, 200);
                };
                
                pulse();
            }

            /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
              ‚ïë SHAKE ELEMENT EFFECT
              ‚ïë Makes an element shake violently to show dramatic losses or penalties.
              ‚ïë Used when players lose significant amounts of coins.
              ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
            shakeElement(element, intensity = 3) {
                const originalTransform = element.style.transform;
                let shakeCount = 0;
                const maxShakes = intensity * 4; // More shakes for higher intensity
                
                const shake = () => {
                    if (shakeCount >= maxShakes) {
                        element.style.transform = originalTransform;
                        element.style.transition = '';
                        return;
                    }
                    
                    const x = (Math.random() - 0.5) * intensity * 4;
                    const y = (Math.random() - 0.5) * intensity * 4;
                    element.style.transform = `translate(${x}px, ${y}px)`;
                    element.style.transition = 'none';
                    
                    shakeCount++;
                    setTimeout(shake, 50);
                };
                
                shake();
            }

            /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
              ‚ïë ANIMATE PROGRESS BAR
              ‚ïë Provides visual feedback when the progress bar fills. Adds temporary 
              ‚ïë animation class that causes the bar to pulse/glow, then removes it.
              ‚ïë Enhances the user experience when star progress increases.
              ‚ïë Parameters: progressBar - The progress bar DOM element to animate
              ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
            animateProgressBar(progressBar) {
                progressBar.classList.add('progress-animate');
                setTimeout(() => progressBar.classList.remove('progress-animate'), 800);
            }

            /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
              ‚ïë SOUND SYSTEM INTEGRATION POINTS
              ‚ïë Placeholder functions for easy sound effect integration. These functions
              ‚ïë can be enhanced later with actual audio implementation using Web Audio API
              ‚ïë or HTML5 audio elements. Currently logs sound events for development.
              ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
            playSound(soundType) {
                // Integration point for sound effects
                // Future enhancement: Load and play actual audio files
                console.log(`üîä Sound: ${soundType}`);
                
                switch (soundType) {
                    case 'shapeLanding':
                        // Soft landing sound - positive feedback
                        break;
                    case 'shapeCollision':
                        // Click/tap sound - interaction feedback  
                        break;
                    case 'shapeRotation':
                        // Quick whoosh sound - rotation feedback
                        break;
                    case 'coinEarned':
                        // Coin pickup sound - reward feedback
                        break;
                    case 'starFilled':
                        // Bright ding sound - progress feedback
                        break;
                    case 'levelComplete':
                        // Victory fanfare - completion feedback
                        break;
                    case 'levelFailed':
                        // Disappointment sound - failure feedback
                        break;
                    case 'endLevelCountdown':
                        // Ticking sound - tension building
                        break;
                    default:
                        console.log(`Unknown sound type: ${soundType}`);
                }
            }

            restoreAllShapesToDock() {
                // Restore all nine shapes to their dock positions
                const shapes = [
                    { id: 'shape-square', type: 'square', slot: 'slot-square' },
                    { id: 'shape-triangle', type: 'triangle', slot: 'slot-triangle' },
                    { id: 'shape-circle', type: 'circle', slot: 'slot-circle' },
                    { id: 'shape-cross2', type: 'cross2', slot: 'slot-cross2' },
                    { id: 'shape-l', type: 'l', slot: 'slot-l' },
                    { id: 'shape-cross', type: 'cross', slot: 'slot-cross' },
                    { id: 'shape-barbell-one', type: 'barbell-one', slot: 'slot-barbell-one' },
                    { id: 'shape-barbell-two', type: 'barbell-two', slot: 'slot-barbell-two' },
                    { id: 'shape-diamond-barbell', type: 'diamond-barbell', slot: 'slot-diamond-barbell' }
                ];
                
                shapes.forEach(shapeInfo => {
                    const slot = document.getElementById(shapeInfo.slot);
                    if (slot) {
                        slot.classList.remove('empty');
                        
                        // Remove any existing shape in the slot
                        const existingShape = slot.querySelector('.game-shape');
                        if (existingShape) {
                            existingShape.remove();
                        }
                        
                        // Create new shape element
                        const shapeElement = document.createElement('div');
                        shapeElement.className = `game-shape shape-${shapeInfo.type}`;
                        shapeElement.dataset.shape = shapeInfo.type;
                        shapeElement.id = shapeInfo.id;
                        
                        slot.appendChild(shapeElement);
                    }
                });
                
                console.log('üîÑ All 9 shapes restored to docking area');
            }
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë PHASE 2: MODE TOGGLE SYSTEM - LEVEL EDITOR FUNCTIONALITY
          ‚ïë Implements the level editor mode toggle system allowing users to switch
          ‚ïë between Play Mode (normal gameplay) and Design Mode (level configuration).
          ‚ïë Includes dock configuration, timer settings, and level parameters.
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/

        // Level configuration state
        let currentMode = 'play';
        let currentLevelConfig = {
            world: 1,
            level: 1,
            timerMode: 'elapsed',
            timerStart: 60,
            endLevelDuration: 5,
            dockSlots: 9,
            barbellOrientation: 'vertical',
            dockShapes: ['square', 'triangle', 'circle', 'cross2', 'l', 'cross', 'barbell-one', 'barbell-two', 'diamond-barbell']
        };

        // Make level config globally available for dock system
        window.currentLevelConfig = currentLevelConfig;

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë TOGGLE MODE SWITCH FUNCTION
          ‚ïë New toggle switch function that switches between Play Mode and Design Mode
          ‚ïë using a compact toggle switch in the HUD instead of separate buttons.
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        function toggleModeSwitch() {
            const toggleSwitch = document.getElementById('modeToggleSwitch');
            const slider = toggleSwitch.querySelector('.mode-toggle-slider');
            
            if (currentMode === 'play') {
                toggleMode('design');
                toggleSwitch.classList.add('design-active');
                slider.textContent = 'üîß';
            } else {
                toggleMode('play');
                toggleSwitch.classList.remove('design-active');
                slider.textContent = 'üéÆ';
            }
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë TOGGLE MODE FUNCTION (UPDATED)
          ‚ïë Updated to work with new toggle switch instead of separate buttons.
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        function toggleMode(mode) {
            const gameContainer = document.getElementById('gameContainer');
            const designSidebar = document.getElementById('designSidebar');
            
            if (mode === 'design') {
                gameContainer.classList.add('design-mode');
                designSidebar.classList.add('active');
                currentMode = 'design';
                
                console.log('üîß Entered Design Mode - Level Editor Active');
                
                // Sync current dock configuration to design sidebar
                syncDockToDesign();
                generateDockSlots();
            } else {
                gameContainer.classList.remove('design-mode');
                designSidebar.classList.remove('active');
                currentMode = 'play';
                
                console.log('üéÆ Entered Play Mode - Game Active');
                
                // Apply any design changes to the play dock
                rebuildGameDock();
            }
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë SYNC DOCK TO DESIGN
          ‚ïë Reads the current dock configuration from the game and updates the design
          ‚ïë sidebar to match. Ensures design mode reflects the actual game state.
          ‚ïë Used when entering design mode to show current level configuration.
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        function syncDockToDesign() {
            const currentShapes = [];
            const dockingArea = document.getElementById('dockingArea');
            
            if (dockingArea) {
                const shapes = dockingArea.querySelectorAll('.game-shape');
                shapes.forEach(shape => {
                    const shapeType = shape.getAttribute('data-shape');
                    if (shapeType) {
                        currentShapes.push(shapeType);
                    }
                });
                
                if (currentShapes.length > 0) {
                    currentLevelConfig.dockShapes = currentShapes;
                    currentLevelConfig.dockSlots = currentShapes.length;
                    
                    // Update UI controls
                    const slotCountInput = document.getElementById('dockSlotCount');
                    if (slotCountInput) {
                        slotCountInput.value = currentShapes.length;
                    }
                }
            }
            
            console.log('üîÑ Synced current dock to design:', currentLevelConfig.dockShapes);
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë GENERATE DOCK SLOTS
          ‚ïë Creates the dynamic dock slot configuration UI in the design sidebar.
          ‚ïë Generates dropdown selectors for each dock slot allowing shape assignment.
          ‚ïë Preserves existing shape assignments when slot count changes.
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        function generateDockSlots() {
            const dockContainer = document.getElementById('dockSlotsContainer');
            const slotCount = parseInt(document.getElementById('dockSlotCount').value);
            
            if (!dockContainer) return;
            
            dockContainer.innerHTML = '';
            
            // Ensure we have enough shapes in the configuration
            const allShapes = ['square', 'triangle', 'circle', 'l', 'cross', 'cross2', 
                              'barbell-one', 'barbell-two', 'diamond-barbell'];
            
            // Preserve existing shapes or use defaults
            if (currentLevelConfig.dockShapes.length !== slotCount) {
                const newShapes = [];
                for (let i = 0; i < slotCount; i++) {
                    if (i < currentLevelConfig.dockShapes.length) {
                        newShapes.push(currentLevelConfig.dockShapes[i]);
                    } else {
                        newShapes.push(allShapes[i % allShapes.length]);
                    }
                }
                currentLevelConfig.dockShapes = newShapes;
            }
            
            // Generate configuration UI for each slot
            for (let i = 0; i < slotCount; i++) {
                const slotDiv = document.createElement('div');
                slotDiv.className = 'dock-slot-config';
                const selectedShape = currentLevelConfig.dockShapes[i];
                
                slotDiv.innerHTML = `
                    <div style="font-weight: bold; margin-bottom: 3px;">Slot ${i + 1}</div>
                    <select onchange="updateDockShape(${i}, this.value)" style="width: 100%; background: rgba(0,0,0,0.3); color: white; border: 1px solid rgba(255,255,255,0.3); padding: 2px;">
                        <option value="square" ${selectedShape === 'square' ? 'selected' : ''}>Square</option>
                        <option value="triangle" ${selectedShape === 'triangle' ? 'selected' : ''}>Triangle</option>
                        <option value="circle" ${selectedShape === 'circle' ? 'selected' : ''}>Circle</option>
                        <option value="l" ${selectedShape === 'l' ? 'selected' : ''}>L-Shape</option>
                        <option value="cross" ${selectedShape === 'cross' ? 'selected' : ''}>Green Cross</option>
                        <option value="cross2" ${selectedShape === 'cross2' ? 'selected' : ''}>Pink Cross</option>
                        <option value="barbell-one" ${selectedShape === 'barbell-one' ? 'selected' : ''}>One-Ended Barbell</option>
                        <option value="barbell-two" ${selectedShape === 'barbell-two' ? 'selected' : ''}>Two-Ended Barbell</option>
                        <option value="diamond-barbell" ${selectedShape === 'diamond-barbell' ? 'selected' : ''}>Diamond Barbell</option>
                    </select>
                `;
                dockContainer.appendChild(slotDiv);
            }
            
            currentLevelConfig.dockSlots = slotCount;
            console.log('üéõÔ∏è Generated dock slots configuration:', slotCount);
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë UPDATE DOCK SHAPE
          ‚ïë Updates a specific dock slot's shape assignment in the level configuration.
          ‚ïë Called when user changes shape selection in design sidebar dropdown.
          ‚ïë Parameters: slotIndex - Index of slot to update, shape - New shape type
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        function updateDockShape(slotIndex, shape) {
            if (slotIndex < currentLevelConfig.dockShapes.length) {
                currentLevelConfig.dockShapes[slotIndex] = shape;
                console.log(`üîÑ Updated slot ${slotIndex + 1} to ${shape}`);
            }
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë UPDATE BARBELL ORIENTATION
          ‚ïë Changes the barbell orientation in the dock (vertical vs horizontal).
          ‚ïë Applies CSS classes to the docking area to control barbell display.
          ‚ïë Called when user changes barbell orientation setting in design sidebar.
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        function updateBarbellOrientation() {
            const orientation = document.getElementById('barbellOrientation').value;
            currentLevelConfig.barbellOrientation = orientation;
            
            // Rebuild the dock to apply rotation changes to barbell previews
            rebuildGameDock();
            
            console.log(`üîÑ Updated barbell orientation to ${orientation} - dock rebuilt with rotated previews`);
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë APPLY LEVEL CHANGES
          ‚ïë Applies all design sidebar configuration changes to the active game.
          ‚ïë Updates level info, timer settings, and rebuilds the dock layout.
          ‚ïë Provides visual feedback to confirm changes were applied.
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        function applyLevelChanges() {
            // Save current configuration from sidebar
            const worldLevelValue = document.getElementById('levelNumber').value;
            const parts = worldLevelValue.split('-');
            currentLevelConfig.world = parseInt(parts[0]) || 1;
            currentLevelConfig.level = parseInt(parts[1]) || 1;
            currentLevelConfig.timerMode = document.getElementById('timerMode').value;
            currentLevelConfig.timerStart = parseInt(document.getElementById('timerStart').value);
            currentLevelConfig.endLevelDuration = parseInt(document.getElementById('endLevelDuration').value);
            
            // Update game UI
            updateGameUI();
            
            // Apply timer changes if countdown mode is selected
            if (currentLevelConfig.timerMode === 'countdown' && window.gameManager && window.gameManager.gameState) {
                const startTime = currentLevelConfig.timerStart || 60;
                window.gameManager.gameState.gameTime = startTime;
                
                // Update timer display
                const timerElement = document.getElementById('gameTimer');
                if (timerElement) {
                    const minutes = Math.floor(startTime / 60);
                    const seconds = startTime % 60;
                    timerElement.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                }
                
                console.log('‚è≥ Applied countdown timer start value:', startTime);
            }
            
            // Rebuild dock with new configuration
            rebuildGameDock();
            
            // Show feedback
            const btn = document.getElementById('applyChangesBtn');
            const originalText = btn.textContent;
            btn.textContent = 'Applied!';
            btn.style.background = 'linear-gradient(135deg, #27ae60 0%, #229954 100%)';
            setTimeout(() => {
                btn.textContent = originalText;
                btn.style.background = 'linear-gradient(135deg, #27ae60 0%, #229954 100%)';
            }, 1500);
            
            console.log('‚úÖ Applied level changes:', currentLevelConfig);
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë UPDATE TIMER MODE CONFIG
          ‚ïë Updates timer mode configuration when user changes dropdown in design sidebar.
          ‚ïë Immediately applies the new timer mode to current level configuration and UI.
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        function updateTimerModeConfig() {
            // Update current level config with new timer mode
            const timerModeSelect = document.getElementById('timerMode');
            currentLevelConfig.timerMode = timerModeSelect.value;
            
            // Update game state if game manager exists
            if (window.gameManager && window.gameManager.gameState) {
                window.gameManager.gameState.timerMode = timerModeSelect.value;
                
                // Initialize timer based on mode
                if (timerModeSelect.value === 'countdown') {
                    // Set countdown timer to start value
                    const startTime = currentLevelConfig.timerStart || 60;
                    window.gameManager.gameState.gameTime = startTime;
                    
                    // Update timer display immediately
                    const timerElement = document.getElementById('gameTimer');
                    if (timerElement) {
                        const minutes = Math.floor(startTime / 60);
                        const seconds = startTime % 60;
                        timerElement.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                    }
                } else if (timerModeSelect.value === 'elapsed') {
                    // Reset to 0 for elapsed timer
                    window.gameManager.gameState.gameTime = 0;
                    
                    // Update timer display immediately
                    const timerElement = document.getElementById('gameTimer');
                    if (timerElement) {
                        timerElement.textContent = '0:00';
                    }
                }
            }
            
            // Update timer UI to reflect new mode
            const modeIndicator = document.getElementById('timerModeIndicator');
            if (modeIndicator && timerModeSelect.value === 'countdown') {
                modeIndicator.className = 'timer-mode-indicator timer-mode-countdown';
                modeIndicator.textContent = '‚è≥';
            } else if (modeIndicator && timerModeSelect.value === 'elapsed') {
                modeIndicator.className = 'timer-mode-indicator timer-mode-elapsed';
                modeIndicator.textContent = '‚è±';
            } else if (modeIndicator && timerModeSelect.value === 'none') {
                modeIndicator.className = 'timer-mode-indicator timer-mode-elapsed';
                modeIndicator.textContent = '‚ö™';
            }
            
            console.log('üïí Updated timer mode to:', timerModeSelect.value);
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë UPDATE GAME UI
          ‚ïë Updates the game's UI elements to reflect current level configuration.
          ‚ïë Updates level display and other HUD elements based on design settings.
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        function updateGameUI() {
            const levelDisplay = document.getElementById('levelDisplay');
            if (levelDisplay) {
                levelDisplay.textContent = `World ${currentLevelConfig.world}-${currentLevelConfig.level}`;
            }
            
            console.log(`üéÆ Updated game UI for World ${currentLevelConfig.world}-${currentLevelConfig.level}`);
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë RESET LEVEL (GLOBAL WRAPPER) - ENHANCED
          ‚ïë Enhanced reset function that properly resets timer, restores shapes to dock,
          ‚ïë and clears physics simulation. Handles both design mode and play mode resets.
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        function resetLevel() {
            console.log('üîÑ Starting level reset...');
            
            // Clear all shapes from playfield
            if (window.gameManager && window.gameManager.physicsManager) {
                window.gameManager.physicsManager.clearAllShapes();
                console.log('üßπ Cleared physics shapes');
            }
            
            // Reset timer and game state
            if (window.gameManager && window.gameManager.gameState) {
                // Reset timer to 0:00
                window.gameManager.gameState.gameTime = 0;
                window.gameManager.gameState.endLevelTime = currentLevelConfig.endLevelDuration;
                
                // Apply current timer mode from config
                window.gameManager.gameState.timerMode = currentLevelConfig.timerMode || 'elapsed';
                
                // Update timer display
                const timerElement = document.getElementById('gameTimer');
                if (timerElement) {
                    if (currentLevelConfig.timerMode === 'countdown') {
                        // For countdown, start from configured start time
                        const startTime = currentLevelConfig.timerStart || 60;
                        window.gameManager.gameState.gameTime = startTime;
                        const minutes = Math.floor(startTime / 60);
                        const seconds = startTime % 60;
                        timerElement.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                    } else {
                        // For elapsed timer, start at 0:00
                        timerElement.textContent = '0:00';
                    }
                }
                
                // Update timer mode indicator based on current config
                const modeIndicator = document.getElementById('timerModeIndicator');
                if (modeIndicator) {
                    if (currentLevelConfig.timerMode === 'countdown') {
                        modeIndicator.className = 'timer-mode-indicator timer-mode-countdown';
                        modeIndicator.textContent = '‚è≥';
                    } else if (currentLevelConfig.timerMode === 'elapsed') {
                        modeIndicator.className = 'timer-mode-indicator timer-mode-elapsed';
                        modeIndicator.textContent = '‚è±';
                    } else if (currentLevelConfig.timerMode === 'none') {
                        modeIndicator.className = 'timer-mode-indicator timer-mode-elapsed';
                        modeIndicator.textContent = '‚ö™';
                    }
                }
                
                console.log('‚è∞ Reset timer and game state with mode:', currentLevelConfig.timerMode);
            }
            
            // Rebuild dock with current configuration (preserves design mode settings)
            rebuildGameDock();
            
            // Force reinitialize drag and drop system after dock rebuild
            if (window.gameManager && window.gameManager.dragDropManager) {
                console.log('üîÑ Drag and drop system already initialized');
                
                // Verify all shapes are interactive
                const dockShapes = document.querySelectorAll('.game-shape');
                console.log(`üéØ Found ${dockShapes.length} shapes after reset:`, 
                    Array.from(dockShapes).map(s => s.dataset.shape));
                    
                // Ensure all shapes are visible and interactive
                dockShapes.forEach(shape => {
                    shape.style.visibility = 'visible';
                    shape.classList.remove('dragging', 'ghost-active');
                });
            }
            
            // Reset additional game state elements
            if (window.gameManager) {
                // Reset shape counters
                if (window.gameManager.gameState) {
                    window.gameManager.gameState.shapesPlaced = 0;
                    window.gameManager.gameState.isGameActive = true;
                    window.gameManager.gameState.isLevelComplete = false;
                    window.gameManager.gameState.isGameOver = false;
                    
                    // Reset placed shapes array - this fixes the "placed" count not resetting
                    window.gameManager.gameState.placedShapes = [];
                    
                    // Fix #2: Reset score and coins to zero
                    window.gameManager.gameState.score = 0;
                    window.gameManager.gameState.coins = 0;
                    
                    // Update displays
                    document.getElementById('scoreText').textContent = '0';
                    document.getElementById('coinAmount').textContent = '0';
                }
                
                // Reset progress bar
                const progressBar = document.getElementById('starProgressBar');
                if (progressBar) {
                    progressBar.style.width = '0%';
                }
                
                // Reset stars
                document.querySelectorAll('.star').forEach(star => {
                    star.classList.remove('filled');
                });
                
                console.log('üéÆ Reset game state elements including score and coins');
            }
            
            // Update debug info to reflect reset state
            if (window.gameManager && window.gameManager.updateDebugInfo) {
                window.gameManager.updateDebugInfo();
            }
            
            console.log('‚úÖ Level reset completed');
        }

        // Global functions for HUD interactions
        function switchTimerMode() {
            console.log('üîÑ Timer mode switch requested');
        }

        function initializeProgressBarInteraction() {
            console.log('‚≠ê Progress bar interaction');
        }

        function animateCoin() {
            console.log('üí∞ Coin animation triggered');
        }

        // Mobile Debug Toggle for Testing
        let mobileDebugMode = false;
        let originalMobileDetection = null;
        function toggleMobileDebug() {
            mobileDebugMode = !mobileDebugMode;
            const button = document.getElementById('mobileDebugButton');
            
            if (!window.gameManager?.mobileEnhancementManager) {
                console.log('‚ùå Mobile enhancement manager not found');
                console.log('Available gameManager properties:', Object.keys(window.gameManager || {}));
                return;
            }
            
            const mobileManager = window.gameManager.mobileEnhancementManager;
            
            if (mobileDebugMode) {
                // Store original detection result
                if (originalMobileDetection === null) {
                    originalMobileDetection = mobileManager.detectMobileDevice();
                }
                
                // Force mobile mode
                window.gameManager.dragDropManager.isMobileDevice = true;
                mobileManager.isMobileDevice = true;
                
                // Enable mouse support for testing on desktop
                mobileManager.enableMouseSupport();
                
                // Update rotation zone bounds and show zones
                mobileManager.updateRotationZoneBounds();
                mobileManager.showRotationZones();
                
                button.style.background = 'linear-gradient(135deg, #27ae60 0%, #2ecc71 100%)';
                button.title = 'Mobile Debug: ON (Click to disable)';
                console.log('üì± Mobile Debug Mode: ON - Rotation zones should be visible');
                console.log('üì± Rotation zones bounds:', {
                    left: mobileManager.rotationZones.left.bounds,
                    right: mobileManager.rotationZones.right.bounds
                });
            } else {
                // Restore original detection
                const originalDetection = originalMobileDetection || mobileManager.detectMobileDevice();
                window.gameManager.dragDropManager.isMobileDevice = originalDetection;
                mobileManager.isMobileDevice = originalDetection;
                
                // Disable mouse support
                mobileManager.disableMouseSupport();
                
                if (!originalDetection) {
                    mobileManager.hideRotationZones();
                }
                
                button.style.background = 'linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%)';
                button.title = 'Mobile Debug: OFF (Click to enable)';
                console.log('üì± Mobile Debug Mode: OFF');
            }
        }

        // Global level management functions (for console testing)
        function nextLevel() {
            if (window.gameManager) {
                window.gameManager.nextLevel();
            }
        }

        function nextWorld() {
            if (window.gameManager) {
                window.gameManager.nextWorld();
            }
        }

        function setLevel(world, level) {
            if (window.gameManager) {
                window.gameManager.setLevel(world, level);
            }
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë v9: CANVAS ENHANCEMENT THEME MANAGEMENT FUNCTIONS
          ‚ïë User interface functions for theme switching and canvas configuration
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/

        // Theme switching function called from UI
        function changeTheme() {
            const themeSelector = document.getElementById('themeSelector');
            const selectedTheme = themeSelector.value;
            
            if (window.gameManager && window.gameManager.themeManager) {
                // Premium themes cost coins (optional enhancement)
                const premiumThemes = ['neon', 'ocean', 'cosmic', 'forest'];
                const isCurrentTheme = window.currentTheme && window.currentTheme.name === selectedTheme;
                const themeCost = premiumThemes.includes(selectedTheme) ? 10 : 0;
                
                if (!isCurrentTheme && themeCost > 0 && window.gameManager.gameState.coins >= themeCost) {
                    // Spend coins for premium theme
                    window.gameManager.gameState.coins -= themeCost;
                    window.gameManager.updateCoinDisplay();
                    
                    const coinElement = document.getElementById('coinAmount');
                    window.gameManager.createFloatingText(`-${themeCost} Theme`, coinElement, '#FF6B6B');
                    window.gameManager.createFloatingText('üé® PREMIUM!', coinElement, '#FFD700');
                    
                    console.log(`üí∞ Purchased premium theme "${selectedTheme}" for ${themeCost} coins`);
                } else if (!isCurrentTheme && themeCost > 0) {
                    // Not enough coins for premium theme
                    console.log(`‚ùå Need ${themeCost} coins for premium theme "${selectedTheme}"`);
                    const coinElement = document.getElementById('coinAmount');
                    window.gameManager.createFloatingText(`Need ${themeCost} coins!`, coinElement, '#FF6B6B');
                    window.gameManager.shakeElement(coinElement, 2);
                    return;
                }
                
                window.gameManager.themeManager.switchTheme(selectedTheme, true);
                console.log(`üé® Theme changed to: ${selectedTheme}${themeCost > 0 ? ' (Premium)' : ''}`);
            }
        }

        // Toggle canvas enhancements on/off
        function toggleCanvasEnhancements() {
            const enableCanvas = document.getElementById('enableCanvas');
            CANVAS_CONFIG.enabled = enableCanvas.checked;
            
            console.log(`üé® Canvas enhancements: ${CANVAS_CONFIG.enabled ? 'ON' : 'OFF'}`);
            
            // Apply change immediately
            if (window.gameManager) {
                if (CANVAS_CONFIG.enabled) {
                    // Re-initialize current theme
                    const currentTheme = window.gameManager.themeManager.getCurrentTheme();
                    window.gameManager.themeManager.switchTheme(currentTheme, false);
                } else {
                    // Reset to basic appearance
                    window.gameManager.physicsManager.backgroundGradient = null;
                }
            }
        }

        // Toggle particle effects
        function toggleParticleEffects() {
            const enableParticles = document.getElementById('enableParticles');
            CANVAS_CONFIG.useParticles = enableParticles.checked;
            
            console.log(`üé® Particle effects: ${CANVAS_CONFIG.useParticles ? 'ON' : 'OFF'}`);
            
            if (!CANVAS_CONFIG.useParticles && window.gameManager) {
                // Clear existing particles
                window.gameManager.physicsManager.particleSystem.particles = [];
            }
        }

        // Touch offset configuration functions
        function toggleTouchOffset() {
            const enableTouchOffset = document.getElementById('enableTouchOffset');
            if (window.gameManager && window.gameManager.dragDropManager) {
                const currentOffset = window.gameManager.dragDropManager.getTouchOffset();
                window.gameManager.dragDropManager.setTouchOffset(
                    currentOffset.x, 
                    currentOffset.y, 
                    enableTouchOffset.checked
                );
                console.log(`üì± Touch offset: ${enableTouchOffset.checked ? 'ON' : 'OFF'}`);
            }
        }

        function updateTouchOffset() {
            const offsetX = parseInt(document.getElementById('touchOffsetX').value);
            const offsetY = parseInt(document.getElementById('touchOffsetY').value);
            const enabled = document.getElementById('enableTouchOffset').checked;
            
            if (window.gameManager && window.gameManager.dragDropManager) {
                window.gameManager.dragDropManager.setTouchOffset(offsetX, offsetY, enabled);
                updateTouchOffsetDisplay();
                console.log(`üì± Touch offset updated: X=${offsetX}px, Y=${offsetY}px`);
            }
        }

        function updateTouchOffsetDisplay() {
            const offsetX = document.getElementById('touchOffsetX').value;
            const offsetY = document.getElementById('touchOffsetY').value;
            
            document.getElementById('touchOffsetXValue').textContent = `${offsetX}px`;
            document.getElementById('touchOffsetYValue').textContent = `${offsetY}px`;
        }

        // Toggle shape animations  
        function toggleAnimations() {
            const enableAnimations = document.getElementById('enableAnimations');
            CANVAS_CONFIG.useAnimations = enableAnimations.checked;
            
            console.log(`üé® Shape animations: ${CANVAS_CONFIG.useAnimations ? 'ON' : 'OFF'}`);
        }

        // Initialize theme selector UI state
        function initializeThemeUI() {
            // Set initial checkbox states
            document.getElementById('enableCanvas').checked = CANVAS_CONFIG.enabled;
            document.getElementById('enableParticles').checked = CANVAS_CONFIG.useParticles;
            document.getElementById('enableAnimations').checked = CANVAS_CONFIG.useAnimations;
            
            // Set initial theme
            document.getElementById('themeSelector').value = CANVAS_CONFIG.defaultTheme;
            
            console.log('üé® Theme UI initialized');
        }

        // Test function to cycle through all themes (for development)
        function testAllThemes() {
            if (!window.gameManager) return;
            
            const themes = Object.keys(THEME_DEFINITIONS);
            let currentIndex = 0;
            
            const cycleTheme = () => {
                const theme = themes[currentIndex];
                window.gameManager.themeManager.switchTheme(theme, true);
                document.getElementById('themeSelector').value = theme;
                
                console.log(`üé® Testing theme: ${theme}`);
                
                currentIndex = (currentIndex + 1) % themes.length;
                
                if (currentIndex !== 0) {
                    setTimeout(cycleTheme, 3000); // Change every 3 seconds
                }
            };
            
            cycleTheme();
        }

        // Test particle effects manually
        function testParticles() {
            if (!window.gameManager || !window.gameManager.physicsManager) {
                console.log('‚ùå Game not initialized yet');
                return;
            }
            
            const particleSystem = window.gameManager.physicsManager.particleSystem;
            const canvas = window.gameManager.physicsManager.canvas;
            
            console.log('üéÜ Creating test particle burst!');
            
            // Create a big burst in the center of the canvas
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            particleSystem.createThemeParticles('test', centerX, centerY, 20);
            
            // Create smaller bursts around the edges
            setTimeout(() => {
                particleSystem.createThemeParticles('test', 100, 100, 10);
                particleSystem.createThemeParticles('test', canvas.width - 100, 100, 10);
                particleSystem.createThemeParticles('test', centerX, canvas.height - 100, 10);
            }, 500);
            
            console.log(`üéÜ Created particle test burst! Current particle count: ${particleSystem.particles.length}`);
        }

        // =============================================================================
        // DYNAMIC COIN BONUS SYSTEM
        // =============================================================================

        function startCoinBonusSystem() {
            // Random coin bonuses every 15-30 seconds
            setInterval(() => {
                if (!gameManager || !gameManager.gameState.isGameActive) return;
                
                const randomEvent = Math.random();
                const coinElement = document.getElementById('coinAmount');
                
                if (randomEvent < 0.3) { // 30% chance
                    // Small bonus coins
                    const bonus = Math.floor(Math.random() * 3) + 1; // 1-3 coins
                    gameManager.gameState.coins += bonus;
                    gameManager.updateCoinDisplay();
                    gameManager.createFloatingText(`üéÅ +${bonus}`, coinElement, '#32CD32');
                    console.log(`üéÅ Random coin bonus: +${bonus}`);
                    
                } else if (randomEvent < 0.35) { // 5% chance
                    // Medium jackpot
                    const jackpot = Math.floor(Math.random() * 8) + 5; // 5-12 coins
                    gameManager.gameState.coins += jackpot;
                    gameManager.updateCoinDisplay();
                    gameManager.createCoinShower('LUCKY BONUS!', jackpot);
                    console.log(`üçÄ Lucky bonus: +${jackpot} coins`);
                    
                } else if (randomEvent < 0.37) { // 2% chance  
                    // Big jackpot
                    const megaJackpot = Math.floor(Math.random() * 15) + 10; // 10-24 coins
                    gameManager.gameState.coins += megaJackpot;
                    gameManager.updateCoinDisplay();
                    gameManager.createCoinShower('MEGA JACKPOT!', megaJackpot);
                    gameManager.pulseElement(coinElement, 5);
                    console.log(`üíé MEGA JACKPOT: +${megaJackpot} coins`);
                }
            }, Math.random() * 15000 + 15000); // Every 15-30 seconds
            
            // Stability bonus system - rewards for keeping shapes stable
            setInterval(() => {
                if (!gameManager || !gameManager.gameState.isGameActive) return;
                if (gameManager.gameState.placedShapes.length === 0) return;
                
                // Check if shapes haven't fallen recently
                const timeSinceLastFall = Date.now() - (gameManager.gameState.lastFallTime || 0);
                if (timeSinceLastFall > 30000) { // 30 seconds of stability
                    const stabilityBonus = Math.floor(Math.random() * 4) + 2; // 2-5 coins
                    gameManager.gameState.coins += stabilityBonus;
                    gameManager.updateCoinDisplay();
                    
                    const coinElement = document.getElementById('coinAmount');
                    gameManager.createFloatingText(`‚öñÔ∏è STABLE +${stabilityBonus}`, coinElement, '#4ECDC4');
                    console.log(`‚öñÔ∏è Stability bonus: +${stabilityBonus} coins`);
                }
            }, 30000); // Check every 30 seconds
            
            console.log('üé∞ Dynamic coin bonus system activated!');
        }

        // Initialize game when page loads
        let gameManager;
        
        window.addEventListener('load', () => {
            console.log('üåç Page loaded, starting initialization...');
            console.log('üîß Current level config:', window.currentLevelConfig);
            console.log('üé® Shape renderer available:', !!shapeRenderer);
            
            // v9: Initialize Canvas Enhancement UI
            initializeThemeUI();
            
            // Test shape configuration
            console.log('üß™ Testing shape configs:');
            const testShapes = ['square', 'triangle', 'circle'];
            testShapes.forEach(shape => {
                const config = getShapeConfig(shape);
                console.log(`${shape} config:`, config);
            });
            
            // Initialize unified dock system using existing config
            rebuildGameDock();
            
            gameManager = new GameManager();
            
            // Initialize touch offset display values
            updateTouchOffsetDisplay();
            
            // Start dynamic coin bonus system
            startCoinBonusSystem();
            
            // Phase 2: Initialize mode toggle system
            generateDockSlots();
            updateGameUI();
            console.log('üéÆ Canvas Enhancement Edition v9 - INITIALIZATION COMPLETE!');
            console.log('‚úÖ UNIFIED SHAPE CONFIGURATION implemented');
            console.log('‚úÖ CANVAS-BASED DOCK PREVIEWS implemented');  
            console.log('üéØ All shapes now use single physics-based appearance system');
            console.log('ÔøΩÔ∏è Features: Angled platform, rotation, end-level countdown, level failure');
            console.log('üéØ Game Rules: Place 3 shapes ‚Üí 5s countdown starts ‚Üí don\'t let any fall!');
            console.log('üñ±Ô∏è Controls: Drag shapes, R/E or ‚Üê/‚Üí to rotate during drag');
            console.log('‚å®Ô∏è Keyboard Shortcuts: 1=Square, 2=Triangle, 3=Circle, 4=Pink Cross, 5=Orange L, 6=Green Cross, 7=Barbell-1, 8=Barbell-2, 9=Diamond Barbell');
            console.log('üé® Theme Testing: Call testAllThemes() in console to cycle through all themes');
            console.log('üéÜ Particle Testing: Call testParticles() in console to see particle effects');
            console.log('üñºÔ∏è Image Texture Functions: loadShapeTexture(), loadPlatformTexture(), loadBackgroundImage(), testSampleTextures()');
            console.log('üìπ Camera Shake Testing: testCameraShake(), simulateShapeFall(), cameraShake(intensity, duration)');
        });

        // =============================================================================
        // IMAGE TEXTURE HELPER FUNCTIONS
        // =============================================================================

        /**
         * Load a texture image for shapes
         * @param {string} imageUrl - URL or path to the image
         * @param {string} shapeName - Name of shape ('square', 'triangle', 'circle', etc.)
         * @param {Object} options - Texture options
         * @returns {Promise<boolean>} Success/failure
         */
        async function loadShapeTexture(imageUrl, shapeName = 'square', options = {}) {
            try {
                console.log(`üñºÔ∏è Loading texture for ${shapeName}: ${imageUrl}`);
                
                // Default texture options
                const textureConfig = {
                    url: imageUrl,
                    repeat: options.repeat || 'repeat',
                    blendMode: options.blendMode || 'source-over',
                    opacity: options.opacity || 1.0,
                    scale: options.scale || 1.0
                };

                // Add texture to current theme
                if (!window.currentTheme.shapes.textures) {
                    window.currentTheme.shapes.textures = {};
                }
                window.currentTheme.shapes.textures[shapeName] = textureConfig;

                // Load the image
                const success = await window.assetManager.loadImage(imageUrl);
                if (success) {
                    console.log(`‚úÖ Texture loaded successfully for ${shapeName}`);
                    return true;
                } else {
                    console.warn(`‚ùå Failed to load texture for ${shapeName}`);
                    return false;
                }
            } catch (error) {
                console.error(`‚ùå Error loading texture for ${shapeName}:`, error);
                return false;
            }
        }

        /**
         * Load a texture image for platforms
         * @param {string} imageUrl - URL or path to the image
         * @param {Object} options - Texture options
         * @returns {Promise<boolean>} Success/failure
         */
        async function loadPlatformTexture(imageUrl, options = {}) {
            try {
                console.log(`üñºÔ∏è Loading platform texture: ${imageUrl}`);
                
                // Default texture options
                const textureConfig = {
                    url: imageUrl,
                    repeat: options.repeat || 'repeat',
                    blendMode: options.blendMode || 'source-over',
                    opacity: options.opacity || 1.0,
                    scale: options.scale || 1.0
                };

                // Add texture to current theme
                window.currentTheme.platform.image = textureConfig;

                // Load the image
                const success = await window.assetManager.loadImage(imageUrl);
                if (success) {
                    console.log(`‚úÖ Platform texture loaded successfully`);
                    return true;
                } else {
                    console.warn(`‚ùå Failed to load platform texture`);
                    return false;
                }
            } catch (error) {
                console.error(`‚ùå Error loading platform texture:`, error);
                return false;
            }
        }

        /**
         * Load a background image
         * @param {string} imageUrl - URL or path to the image
         * @param {Object} options - Background options
         * @returns {Promise<boolean>} Success/failure
         */
        async function loadBackgroundImage(imageUrl, options = {}) {
            try {
                console.log(`üñºÔ∏è Loading background image: ${imageUrl}`);
                
                // Default background options
                const backgroundConfig = {
                    url: imageUrl,
                    mode: options.mode || 'cover', // 'cover', 'contain', 'stretch', 'tile'
                    opacity: options.opacity || 1.0,
                    blur: options.blur || 0,
                    brightness: options.brightness || 1.0
                };

                // Add background to current theme
                window.currentTheme.background.image = backgroundConfig;

                // Load the image
                const success = await window.assetManager.loadImage(imageUrl);
                if (success) {
                    console.log(`‚úÖ Background image loaded successfully`);
                    return true;
                } else {
                    console.warn(`‚ùå Failed to load background image`);
                    return false;
                }
            } catch (error) {
                console.error(`‚ùå Error loading background image:`, error);
                return false;
            }
        }

        /**
         * Test sample textures with placeholder images
         */
        async function testSampleTextures() {
            console.log('üß™ Testing sample textures...');
            
            try {
                // Test background image
                await loadBackgroundImage('https://picsum.photos/1200/800?random=1', { mode: 'cover' });
                
                // Test platform texture
                await loadPlatformTexture('https://picsum.photos/200/50?random=2', { repeat: 'repeat-x' });
                
                // Test shape textures
                await loadShapeTexture('https://picsum.photos/100/100?random=3', 'square', { blendMode: 'multiply' });
                await loadShapeTexture('https://picsum.photos/100/100?random=4', 'circle', { blendMode: 'overlay' });
                await loadShapeTexture('https://picsum.photos/100/100?random=5', 'triangle', { blendMode: 'soft-light' });
                
                console.log('‚úÖ Sample textures loaded! Drop some shapes to see the effect.');
                
            } catch (error) {
                console.error('‚ùå Error testing sample textures:', error);
            }
        }

        /**
         * Clear all textures and return to gradient/solid colors
         */
        function clearAllTextures() {
            console.log('üßπ Clearing all textures...');
            
            // Clear background image
            if (window.currentTheme.background.image) {
                delete window.currentTheme.background.image;
            }
            
            // Clear platform texture
            if (window.currentTheme.platform.image) {
                delete window.currentTheme.platform.image;
            }
            
            // Clear shape textures
            if (window.currentTheme.shapes.textures) {
                delete window.currentTheme.shapes.textures;
            }
            
            console.log('‚úÖ All textures cleared - back to gradients and solid colors');
        }

        /**
         * Show texture configuration examples
         */
        function showTextureExamples() {
            console.log(`
üñºÔ∏è TEXTURE CONFIGURATION EXAMPLES:

1. Load Background Image:
   await loadBackgroundImage('path/to/background.jpg', {
       mode: 'cover',      // 'cover', 'contain', 'stretch', 'tile'
       opacity: 0.8,       // 0.0 to 1.0
       blur: 2,            // blur amount in pixels
       brightness: 1.2     // brightness multiplier
   });

2. Load Platform Texture:
   await loadPlatformTexture('path/to/wood.jpg', {
       repeat: 'repeat-x', // 'repeat', 'repeat-x', 'repeat-y', 'no-repeat'
       blendMode: 'multiply',
       opacity: 0.9,
       scale: 1.5
   });

3. Load Shape Textures:
   await loadShapeTexture('path/to/metal.jpg', 'square', {
       repeat: 'repeat',
       blendMode: 'overlay',  // Try: 'multiply', 'overlay', 'soft-light', 'hard-light'
       opacity: 0.7,
       scale: 2.0
   });

4. Test Sample Textures:
   testSampleTextures();

5. Clear All Textures:
   clearAllTextures();

6. Multiple Shape Textures:
   await loadShapeTexture('stone.jpg', 'square');
   await loadShapeTexture('fabric.jpg', 'circle');
   await loadShapeTexture('paper.jpg', 'triangle');

BLEND MODES: source-over, multiply, screen, overlay, darken, lighten, 
             color-dodge, color-burn, hard-light, soft-light, difference, exclusion

IMAGE SOURCES: Local files, URLs, data URLs, or any valid image source
            `);
        }

        // Make functions globally available
        window.loadShapeTexture = loadShapeTexture;
        window.loadPlatformTexture = loadPlatformTexture;
        window.loadBackgroundImage = loadBackgroundImage;
        window.testSampleTextures = testSampleTextures;
        window.clearAllTextures = clearAllTextures;
        window.showTextureExamples = showTextureExamples;

        // =============================================================================
        // CAMERA SHAKE TESTING FUNCTIONS
        // =============================================================================

        /**
         * Test camera shake with different intensities
         */
        function testCameraShake() {
            if (!window.gameManager || !window.gameManager.physicsManager) {
                console.log('‚ùå Game not initialized yet');
                return;
            }

            console.log('üìπ Testing camera shake effects...');
            
            // Immediate intense shake to show it works
            console.log('üî¥ INTENSE SHAKE NOW!');
            window.gameManager.physicsManager.startCameraShake(15, 1000);
            
            // Then test sequence
            setTimeout(() => {
                console.log('üî∏ Light shake (intensity 5)');
                window.gameManager.physicsManager.startCameraShake(5, 600);
            }, 2000);
            
            setTimeout(() => {
                console.log('üîπ Medium shake (intensity 8)');
                window.gameManager.physicsManager.startCameraShake(8, 800);
            }, 4000);
            
            setTimeout(() => {
                console.log('üî¥ Maximum shake (intensity 20)');
                window.gameManager.physicsManager.startCameraShake(20, 1000);
            }, 6500);
            
            console.log('üìπ Camera shake test sequence started with immediate intense shake!');
        }

        /**
         * Simulate shape falling for camera shake
         */
        function simulateShapeFall() {
            if (!window.gameManager || !window.gameManager.physicsManager) {
                console.log('‚ùå Game not initialized yet');
                return;
            }

            console.log('üí• Simulating shape fall...');
            window.gameManager.physicsManager.onShapeFellOffPlatform();
            console.log('üìπ Shape fall camera shake triggered!');
        }

        /**
         * Custom camera shake with user parameters
         */
        function cameraShake(intensity = 5, duration = 500) {
            if (!window.gameManager || !window.gameManager.physicsManager) {
                console.log('‚ùå Game not initialized yet');
                return;
            }

            window.gameManager.physicsManager.startCameraShake(intensity, duration);
            console.log(`üìπ Camera shake: intensity=${intensity}, duration=${duration}ms`);
        }

        /**
         * Quick test - immediate strong shake
         */
        function shakeNow() {
            console.log('üß™ shakeNow() called - testing camera shake system...');
            
            if (!window.gameManager || !window.gameManager.physicsManager) {
                console.log('‚ùå Game not initialized yet');
                return;
            }
            
            console.log('‚úÖ Game manager and physics manager found');
            window.gameManager.physicsManager.startCameraShake(20, 1000);
            console.log('üí• MAXIMUM SHAKE ACTIVATED!');
        }

        /**
         * Test camera shake by directly calling the function
         */
        function testDirectShake() {
            console.log('üß™ testDirectShake() - bypassing all collision detection...');
            
            if (!window.gameManager) {
                console.log('‚ùå Game not initialized yet');
                return;
            }
            
            // Directly call onShapeFell to test the entire chain
            console.log('‚úÖ Directly calling onShapeFell...');
            window.gameManager.onShapeFell();
        }

        /**
         * Test camera shake by simulating a shape falling off screen
         */
        function testShapeFall() {
            console.log('üß™ testShapeFall() called - simulating shape fall...');
            
            if (!window.gameManager) {
                console.log('‚ùå Game not initialized yet');
                return;
            }
            
            console.log('‚úÖ Game manager found, calling onShapeFell...');
            window.gameManager.onShapeFell();
            console.log('üçÉ Simulated shape fall with camera shake!');
        }

        /**
         * Show camera shake examples
         */
        function showCameraShakeExamples() {
            console.log(`
üìπ CAMERA SHAKE EXAMPLES:

1. Test Different Intensities:
   testCameraShake();

2. Simulate Shape Fall:
   simulateShapeFall();

3. Custom Camera Shake:
   cameraShake(7, 800);    // Intensity 7, 800ms duration
   cameraShake(3, 300);    // Light shake, 300ms
   cameraShake(10, 1000);  // Maximum intensity, 1 second

4. Intensity Guide:
   1-3:  Light shake (subtle feedback)
   4-6:  Medium shake (noticeable effect) 
   7-9:  Heavy shake (dramatic effect)
   10+:  Maximum shake (screen earthquake!)

5. Duration Guide:
   200-400ms: Quick feedback
   500-800ms: Standard effect
   1000ms+:   Extended shake

The camera shake automatically triggers when shapes fall off screen!
Try dropping a shape off the edge to see it in action.
            `);
        }

        // Make camera shake functions globally available
        window.testCameraShake = testCameraShake;
        window.simulateShapeFall = simulateShapeFall;
        window.cameraShake = cameraShake;
        window.showCameraShakeExamples = showCameraShakeExamples;

    </script>
</body>
</html>
