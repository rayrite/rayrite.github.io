<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>BSH Game - Physics Puzzle Game v20 (Canvas2D)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }

        html {
            overflow: hidden; /* Prevent scrolling on the game */
            height: 100%;
        }

        @import url('https://fonts.googleapis.com/css2?family=Fredoka:wght@400;500;600;700&display=swap');
        
        body {
            font-family: 'Fredoka', sans-serif;
            /* background: linear-gradient(135deg, #87CEEB 0%, #98FB98 100%); */
            height: 100vh;
            height: 100dvh; /* Dynamic viewport height for mobile */
            overflow: hidden; /* Prevent scrolling */
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
        }

          /* Dynamic background system - controlled via JavaScript */
          .game-viewport::before {
              content: '';
              position: absolute;
              top: 0;
              left: 0;
              width: 100%;
              height: 100%;
              
              /* Dynamic background will be set via JavaScript */
              background-size: cover;
              background-position: center top;
              background-repeat: no-repeat;
              
              /* Default opacity - will be overridden by theme */
              opacity: 0.5;
              
              z-index: -1;
              transition: opacity 0.3s ease, background-image 0.3s ease;
          }

          /* Theme-based background control */
          .game-viewport.theme-background::before {
              opacity: var(--background-opacity, 0.5);
              background-image: var(--background-image, none);
          }

          /* Stone granite pattern - HIGHLY VISIBLE VERSION */
          .game-viewport.stone-pattern::before {
              content: '';
              position: absolute;
              top: 0;
              left: 0;
              width: 100%;
              height: 100%;
              z-index: -1;
              
              /* Very visible stone pattern with solid colors */
              background: 
                  /* Stone blocks - more opaque */
                  radial-gradient(ellipse at 15% 15%, #8B4513 0%, rgba(139, 69, 19, 0.6) 30%, transparent 50%),
                  radial-gradient(ellipse at 85% 20%, #A0522D 0%, rgba(160, 82, 45, 0.6) 25%, transparent 45%),
                  radial-gradient(ellipse at 25% 75%, #696969 0%, rgba(105, 105, 105, 0.7) 35%, transparent 55%),
                  radial-gradient(ellipse at 75% 80%, #778899 0%, rgba(119, 136, 153, 0.5) 30%, transparent 50%),
                  radial-gradient(ellipse at 50% 40%, #CD853F 0%, rgba(205, 133, 63, 0.6) 28%, transparent 48%),
                  
                  /* Strong base stone color */
                  linear-gradient(135deg, 
                      #8B4513 0%,    /* Saddle Brown */
                      #A0522D 20%,   /* Sienna */
                      #CD853F 40%,   /* Peru */
                      #696969 60%,   /* Dim Gray */
                      #778899 80%,   /* Light Slate Gray */
                      #708090 100%   /* Slate Gray */
                  );
              
              background-size: 
                  120px 90px,   /* Larger, more visible stone blocks */
                  100px 70px, 
                  140px 100px,
                  90px 60px,
                  110px 80px,
                  100% 100%;
                  
              opacity: 0.75;  /* More visible */
          }

          /* Metal brushed steel pattern */
          .game-viewport.metal-pattern::before {
              content: '';
              position: absolute;
              top: 0;
              left: 0;
              width: 100%;
              height: 100%;
              z-index: -1;
              background-image:
                  repeating-linear-gradient(90deg, 
                      transparent, 
                      transparent 1px, 
                      rgba(135, 206, 235, 0.1) 1px, 
                      rgba(135, 206, 235, 0.1) 2px),
                  repeating-linear-gradient(0deg, 
                      transparent, 
                      transparent 2px, 
                      rgba(70, 130, 180, 0.05) 2px, 
                      rgba(70, 130, 180, 0.05) 4px),
                  linear-gradient(45deg, #1e3a4f 0%, #4682B4 25%, #2d5a7b 50%, #5a7aa6 75%, #4682B4 100%);
              background-size: 4px 4px, 8px 8px, 100% 100%;
              opacity: 0.7;
          }

        /* New Responsive Game Viewport */
        .game-viewport {
            width: 100vw;
            height: 100vh;
            height: 100dvh;
            display: flex;
            flex-direction: column;
            /* Remove size constraints for mobile/tablet - let it use full screen */
            margin: 0 auto;
            /* background: linear-gradient(135deg, #FF6B6B 0%, #4ECDC4 100%); */
            /* REMOVE the background-image properties from here */
                
            /* ADD a solid background color to sit behind the faded image */
            background-color: #2c3e50; /* A dark blue-gray is a good starting point */
        
            position: relative; /* This is required for the pseudo-element to work */
            isolation: isolate; /* Ensures content stays on top of the new background layer */


            aspect-ratio: 9/16;
            overflow: visible; /* Allow dragged elements to extend beyond viewport */
            box-shadow: 0 0 50px rgba(0,0,0,0.3);
        }

        /* Desktop screens - size constraints and styling */
        @media (min-width: 1025px) {
            body {
                background: linear-gradient(135deg, #87CEEB 0%, #98FB98 100%);
                padding: 20px;
            }
            
            .game-viewport {
                max-width: 500px;
                max-height: 889px; /* 500 * 16/9 for aspect ratio */
                border-radius: 20px;
                box-shadow: 0 10px 50px rgba(0,0,0,0.4);
            }
        }

        /* Game HUD - Top Section */
        .game-hud {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: clamp(70px, 12vh, 90px); /* Responsive height */
            background: linear-gradient(135deg, #FF6B6B 0%, #4ECDC4 100%);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: clamp(6px, 2vw, 15px); /* Responsive padding */
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 100;
        }

        /* Left Section - Score and Star Meter */
        .left-section {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            color: white;
            font-weight: bold;
            justify-content: space-between;
            height: 100%;
            min-width: 0; /* Prevent flex overflow */
        }

        .score-display {
            display: flex;
            align-items: center;
            gap: clamp(4px, 1.5vw, 8px); /* Responsive gap */
            margin-bottom: 3px;
        }

        .trophy-icon {
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
            width: clamp(18px, 4vw, 24px); /* Responsive icon size */
            height: clamp(18px, 4vw, 24px);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(8px, 2vw, 12px); /* Responsive font */
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            border: 2px solid #B8860B;
            flex-shrink: 0; /* Prevent shrinking */
        }

        .score-text {
            font-size: clamp(14px, 4vw, 18px); /* Responsive font size */
            font-weight: 700;
            color: #FFE4B5;
            text-shadow: 0 2px 4px rgba(0,0,0,0.4);
            white-space: nowrap; /* Prevent text wrapping */
        }

        .star-progress-container {
            position: relative;
            width: clamp(100px, 25vw, 140px); /* Responsive width */
            height: clamp(14px, 3vw, 18px); /* Responsive height */
            background: rgba(255,255,255,0.25);
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.3);
            overflow: hidden;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.3);
            cursor: pointer; /* Indicate interactivity */
        }

        .progress-area {
            position: relative;
            width: clamp(100px, 25vw, 140px); /* Match container width */
            height: clamp(28px, 6vw, 36px); /* Responsive height for better touch */
        }

        .star-progress-container {
            margin-top: clamp(12px, 3vw, 18px); /* Responsive margin */
        }

        .star-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #8B5CF6 0%, #A855F7 50%, #C084FC 100%);
            border-radius: 7px;
            transition: width 0.8s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            box-shadow: 0 0 6px rgba(139, 92, 246, 0.6);
        }

        /* White progress markers inside the bar */
        .progress-markers {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 100%;
            pointer-events: none;
            z-index: 2;
        }

        .progress-marker {
            position: absolute;
            top: 0;
            width: 2px;
            height: 100%;
            background: rgba(255,255,255,0.8);
            border-radius: 1px;
        }

        .progress-marker:nth-child(1) {
            left: 33.33%;
            transform: translateX(-50%);
        }

        .progress-marker:nth-child(2) {
            left: 66.66%;
            transform: translateX(-50%);
        }

        .progress-marker:nth-child(3) {
            left: 90%;
            transform: translateX(-50%);
        }

        .star-markers {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 16px;
            width: 120px;
            pointer-events: none;
            z-index: 10;
        }

        .star {
            width: 14px;
            height: 14px;
            background: rgba(255,255,255,0.3);
            clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%);
            box-shadow: 0 2px 6px rgba(0,0,0,0.5);
            border: 1px solid rgba(255,255,255,0.6);
            transition: all 0.5s ease;
            position: absolute;
        }

        /* Position stars directly above the white markers */
        .star:nth-child(1) {
            left: 33.33%;
            transform: translateX(-50%);
        }

        .star:nth-child(2) {
            left: 66.66%;
            transform: translateX(-50%);
        }

        .star:nth-child(3) {
            left: 90%;
            transform: translateX(-50%);
        }

        .star.filled {
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
            border: 2px solid #B8860B;
            transform: translateX(-50%) scale(1.3);
            box-shadow: 0 0 20px rgba(255, 215, 0, 1), 0 2px 6px rgba(0,0,0,0.6);
            animation: starPulse 0.5s ease-out;
            z-index: 15;
        }

        /* Middle Section - Timer */
        .middle-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            gap: clamp(3px, 1vw, 6px); /* Responsive gap */
            min-width: 0; /* Prevent overflow */
        }

        /* Level Display */
        .level-display {
            font-size: clamp(11px, 3vw, 14px); /* Responsive font size */
            font-weight: 600;
            color: #FFE4B5;
            text-shadow: 0 1px 2px rgba(0,0,0,0.4);
            background: rgba(0,0,0,0.15);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            padding: clamp(3px, 1vw, 6px) clamp(6px, 2vw, 10px); /* Responsive padding */
            min-width: clamp(50px, 12vw, 70px); /* Responsive min-width */
            text-align: center;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
            white-space: nowrap;
        }

        .timer-container {
            background: rgba(0,0,0,0.2);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 12px;
            padding: clamp(6px, 2vw, 10px) clamp(8px, 3vw, 14px); /* Responsive padding */
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: clamp(60px, 15vw, 80px); /* Responsive min-width */
            min-height: 44px; /* Minimum touch target */
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }

        .timer-container:hover {
            background: rgba(0,0,0,0.3);
            transform: translateY(-1px);
        }

        .timer-text {
            font-size: clamp(12px, 3.5vw, 16px); /* Responsive font size */
            font-weight: 600;
            color: #FFE4B5;
            text-shadow: 0 1px 2px rgba(0,0,0,0.4);
            font-variant-numeric: tabular-nums;
            transition: all 0.3s ease;
            white-space: nowrap;
        }

        .timer-text.timer-warning {
            color: #FFA500;
            text-shadow: 0 0 10px rgba(255, 165, 0, 0.6);
        }

        .timer-text.timer-critical {
            color: #FF4444;
            text-shadow: 0 0 15px rgba(255, 68, 68, 0.8);
            animation: timerPulse 1s infinite;
        }

        @keyframes timerPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        /* Right Section - Settings, Reset, and Coins */
        .right-section {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            justify-content: space-between;
            height: 100%;
            min-width: 0; /* Prevent overflow */
        }

        .top-buttons {
            display: flex;
            gap: clamp(6px, 2vw, 10px); /* Responsive gap */
            align-items: center;
            flex-wrap: wrap; /* Allow wrapping on very small screens */
        }

        /* All Buttons - Consolidated Base Properties */
        .settings-button, .reset-button, .theme-button, .level-cleared-button, .game-over-button {
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            font-weight: 500;
        }

        .settings-button:hover, .reset-button:hover, .theme-button:hover, .level-cleared-button:hover, .game-over-button:hover {
            transform: translateY(-2px);
        }

        .settings-button:active, .reset-button:active, .theme-button:active, .level-cleared-button:active, .game-over-button:active {
            transform: translateY(0);
        }

        /* Top Navigation Buttons */
        .settings-button, .reset-button {
            width: clamp(32px, 8vw, 44px);
            height: clamp(32px, 8vw, 44px);
            min-width: 44px;
            min-height: 44px;
            background: rgba(0,0,0,0.2);
            border: 1px solid rgba(255,255,255,0.2);
            color: #FFE4B5;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }

        .settings-button:hover, .reset-button:hover {
            background: rgba(0,0,0,0.3);
            box-shadow: 0 6px 15px rgba(0,0,0,0.4);
        }

        .settings-button:active, .reset-button:active {
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }

        /* Theme Button */
        .theme-button {
            width: clamp(32px, 8vw, 44px);
            height: clamp(32px, 8vw, 44px);
            min-width: 44px;
            min-height: 44px;
            background: linear-gradient(135deg, #4ECDC4 0%, #44A08D 100%);
            border: 1px solid rgba(255,255,255,0.2);
            color: white;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            font-size: clamp(16px, 4vw, 20px);
        }

        .theme-button:hover {
            background: linear-gradient(135deg, #44A08D 0%, #4ECDC4 100%);
            box-shadow: 0 6px 15px rgba(0,0,0,0.4);
        }

        .theme-button:active {
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }

        .reset-icon {
            width: clamp(12px, 3vw, 16px); /* Responsive icon size */
            height: clamp(12px, 3vw, 16px);
            color: #FFE4B5;
            font-size: clamp(10px, 3vw, 14px); /* Responsive font */
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .pause-icon {
            width: clamp(12px, 3vw, 16px);
            height: clamp(12px, 3vw, 16px);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 2px;
        }

        .pause-bar {
            width: 3px;
            height: clamp(10px, 3vw, 14px); /* Responsive height */
            background: #FFE4B5;
            border-radius: 1px;
        }

        .coin-counter {
            display: flex;
            align-items: center;
            gap: clamp(4px, 1.5vw, 7px); /* Responsive gap */
            background: rgba(0,0,0,0.2);
            padding: clamp(4px, 1.5vw, 7px) clamp(8px, 2.5vw, 12px); /* Responsive padding */
            border-radius: 10px;
            border: 1px solid rgba(255,255,255,0.2);
            cursor: pointer;
            transition: all 0.3s ease;
            min-height: 44px; /* Minimum touch target */
            min-width: 60px; /* Minimum width for readability */
        }

        .coin-counter:hover {
            background: rgba(0,0,0,0.3);
            transform: translateY(-1px);
        }

        .coin-icon {
            width: clamp(14px, 4vw, 18px); /* Responsive icon size */
            height: clamp(14px, 4vw, 18px);
            font-size: clamp(10px, 3vw, 14px); /* Responsive font */
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .coin-amount {
            font-size: clamp(12px, 3.5vw, 16px); /* Responsive font size */
            font-weight: 600;
            color: #FFE4B5;
            text-shadow: 0 1px 2px rgba(0,0,0,0.4);
            white-space: nowrap; /* Prevent text wrapping */
        }

        /* Timer Mode Indicator */
        .timer-mode-indicator {
            position: absolute;
            top: -5px;
            right: -5px;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            font-size: 8px;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            border: 1px solid rgba(255,255,255,0.3);
        }

        .timer-mode-elapsed {
            background: linear-gradient(135deg, #8B5CF6 0%, #7C3AED 100%);
        }

        .timer-mode-countdown {
            background: linear-gradient(135deg, #EF4444 0%, #DC2626 100%);
        }

        .timer-mode-endlevel {
            background: linear-gradient(135deg, #10B981 0%, #059669 100%);
        }

        /* Docking Area - Shape Selection */
        .docking-area {
            position: absolute;
            top: clamp(70px, 12vh, 90px); /* Match HUD height */
            left: 0;
            right: 0;
            height: clamp(120px, 20vh, 160px); /* Responsive height */
            background: transparent; /* Changed from #34495e to transparent */
            display: grid;
            grid-template-columns: repeat(5, 1fr); /* Equal column distribution */
            grid-template-rows: repeat(2, 1fr); /* Equal row distribution */
            gap: clamp(4px, 1.5vw, 10px); /* Responsive gap */
            padding: clamp(4px, 2vw, 8px); /* Responsive padding */
            /* box-shadow: 0 2px 10px rgba(0,0,0,0.3); */
            z-index: 50;
            align-items: center;
            justify-items: center;
            overflow: visible; /* Allow shapes to extend beyond docking area */
        }

        .docking-area.loading .game-shape {
            opacity: 0;
        }
        
        /* Enhanced loading states for dock */
        .docking-area.loading::before {
            content: "Loading shapes...";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 10;
            animation: pulse 1.5s ease-in-out infinite alternate;
        }
        
        .docking-area.error::before {
            content: "‚ö†Ô∏è Failed to load shapes";
            background: rgba(220, 53, 69, 0.9);
            animation: none;
        }
        
        .docking-area.retrying::before {
            content: "üîÑ Retrying...";
            background: rgba(255, 193, 7, 0.9);
            color: black;
        }
        
        @keyframes pulse {
            from { opacity: 0.6; }
            to { opacity: 1; }
        }

        .shape-slot {
            width: 100%;
            height: 100%;
            min-width: clamp(50px, 12vw, 70px); /* Responsive minimum size */
            min-height: clamp(50px, 12vw, 70px);
            max-width: 80px; /* Prevent too large on desktop */
            max-height: 80px;
            background: rgba(255,255,255,0.1);
            border: 2px dashed rgba(255,255,255,0.3);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            transition: all 0.3s ease;
            padding: 0;
            margin: 0;
            overflow: visible;
            box-sizing: border-box;
            cursor: pointer; /* Indicate interactivity */
        }

        .special-effect-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 65;
        }

        .shape-slot:hover {
            background: rgba(255,255,255,0.15);
            border-color: rgba(255,255,255,0.5);
            transform: scale(1.05);
        }

        .shape-slot.empty {
            border-color: rgba(255,255,255,0.1);
            background: rgba(255,255,255,0.05);
        }

        .shape-slot.empty:hover {
            border-color: rgba(255,255,255,0.2);
            background: rgba(255,255,255,0.1);
        }

        .game-shape {
            cursor: grab;
            transition: all 0.3s ease;
            position: relative;
            z-index: 60;
            width: 100%; /* Fill slot */
            height: 100%;
            min-width: 44px; /* Minimum touch target */
            min-height: 44px;
        }

        .game-shape:active {
            cursor: grabbing;
            transform: scale(1.15); /* Slightly larger feedback on touch */
            filter: drop-shadow(0 5px 15px rgba(0,0,0,0.4));
            transition: all 0.1s ease; /* Quick response for touch */
        }

        .shape-entrance-animation {
            transition-property: transform, opacity;
        }

        .game-shape:hover {
            transform: scale(1.1);
            filter: drop-shadow(0 3px 10px rgba(0,0,0,0.3));
        }

        /* Locked Shape Styles */
        .shape-slot .locked { filter: saturate(0.1) brightness(0.5); cursor: not-allowed; }
        .shape-slot .lock-icon { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 1.75em; height: 1.75em; pointer-events: none; z-index: 70; }

        .game-shape.dragging {
            z-index: 1000;
            transform: scale(1.2); /* Slightly larger when dragging */
            filter: drop-shadow(0 8px 20px rgba(0,0,0,0.4));
        }

        /* Enhanced touch feedback for mobile */
        @media (pointer: coarse) {
            .game-shape {
                transition: all 0.2s ease; /* Longer transitions on touch devices */
            }
            
            .game-shape:active {
                transform: scale(1.2); /* Larger feedback on touch devices */
                transition: all 0.05s ease; /* Very quick response */
            }
            
            .shape-slot:active {
                background: rgba(255,255,255,0.2);
                border-color: rgba(255,255,255,0.7);
                transform: scale(1.02);
                transition: all 0.05s ease;
            }
        }
        
        /* End Level Countdown - 3 Dot Display */
        .countdown-dots {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            padding: 8px 12px;
        }

        .countdown-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: rgba(255,255,255,0.3);
            transition: all 0.3s ease;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }

        .countdown-dot.active {
            background: linear-gradient(135deg, #10B981 0%, #059669 100%);
            transform: scale(1.7);
            box-shadow: 0 0 12px rgba(16, 185, 129, 0.8);
            animation: dotPulse 0.6s ease-in-out;
        }

        .countdown-dot.completed {
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
            transform: scale(1.8);
            box-shadow: 0 0 8px rgba(255, 215, 0, 0.6);
        }

        @keyframes dotPulse {
            0%, 100% { transform: scale(1.3); }
            50% { transform: scale(1.6); }
        }

        /* Particle Effects */
        .particle {
            position: fixed;
            pointer-events: none;
            z-index: 9999;
            font-size: 14px;
            font-weight: bold;
            opacity: 1;
            animation: particleFloat 2s ease-out forwards;
        }

        @keyframes particleFloat {
            0% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
            100% {
                opacity: 0;
                transform: translateY(-40px) scale(0);
            }
        }

        @keyframes starBurst {
            0% {
                opacity: 1;
                transform: scale(0) rotate(0deg);
            }
            50% {
                opacity: 0.8;
                transform: scale(1.5) rotate(180deg);
            }
            100% {
                opacity: 0;
                transform: scale(2) rotate(360deg);
            }
        }

        .progress-animate {
            animation: progressPulse 0.8s ease-out;
        }

        @keyframes progressPulse {
            0% { transform: scaleY(1); }
            50% { transform: scaleY(1.1); box-shadow: 0 0 15px rgba(255, 215, 0, 0.6); }
            100% { transform: scaleY(1); }
        }

        /* Enhanced Star Animations */
        .star.filled {
            animation: starFill 0.5s ease-out;
        }

        @keyframes starFill {
            0% { transform: scale(0) rotate(0deg); opacity: 0; }
            50% { transform: scale(1.3) rotate(180deg); opacity: 1; }
            100% { transform: scale(1) rotate(360deg); opacity: 1; }
        }

        /* Score Text Animation */
        .score-text {
            transition: all 0.3s ease;
        }

        .score-text.score-increase {
            animation: scoreBoost 0.6s ease-out;
        }

        @keyframes scoreBoost {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); color: #FFD700; }
            100% { transform: scale(1); }
        }

        /* Coin Animation */
        .coin-amount {
            transition: all 0.3s ease;
        }

        .coin-amount.coin-increase {
            animation: coinBoost 0.6s ease-out;
        }

        @keyframes coinBoost {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); color: #FFD700; text-shadow: 0 0 10px #FFD700; }
            100% { transform: scale(1); }
        }

        /* Enhanced Coin Animations */
        @keyframes coinShower {
            0% { 
                transform: translateY(0) rotate(0deg); 
                opacity: 1; 
            }
            50% { 
                transform: translateY(-50px) rotate(180deg); 
                opacity: 0.8; 
            }
            100% { 
                transform: translateY(100px) rotate(360deg); 
                opacity: 0; 
            }
        }

        @keyframes coinPulse {
            0%, 100% { 
                transform: scale(1); 
                box-shadow: 0 0 5px rgba(255, 215, 0, 0.3); 
            }
            50% { 
                transform: scale(1.3); 
                box-shadow: 0 0 25px rgba(255, 215, 0, 0.8); 
            }
        }

        @keyframes coinShake {
            0%, 100% { transform: translateX(0); }
            10% { transform: translateX(-2px) rotate(-1deg); }
            20% { transform: translateX(2px) rotate(1deg); }
            30% { transform: translateX(-3px) rotate(-1deg); }
            40% { transform: translateX(3px) rotate(1deg); }
            50% { transform: translateX(-2px) rotate(-1deg); }
            60% { transform: translateX(2px) rotate(1deg); }
            70% { transform: translateX(-1px) rotate(-1deg); }
            80% { transform: translateX(1px) rotate(1deg); }
            90% { transform: translateX(-1px) rotate(-1deg); }
        }

        /* Particle Effects */
        .particle {
            position: fixed;
            pointer-events: none;
            font-size: 18px;
            font-weight: bold;
            z-index: 9999;
            animation: particleFloat 2s ease-out forwards;
        }

        /* Level Complete Effects */
        @keyframes levelCompleteFlash {
            0%, 100% { filter: brightness(1); }
            25% { filter: brightness(1.3) saturate(1.2); }
            50% { filter: brightness(1.1) saturate(1.1); }
            75% { filter: brightness(1.2) saturate(1.15); }
        }

        /* Level Cleared Popup Modal */
        .level-cleared-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            opacity: 0;
            animation: modalFadeIn 0.5s ease-out forwards;
        }

        .level-cleared-content {
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
            transform: scale(0.5);
            animation: modalPopIn 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55) forwards;
        }

        .level-cleared-title {
            font-size: 48px;
            font-weight: bold;
            color: #8B4513;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            animation: titlePulse 1s ease-in-out infinite alternate;
        }

        .level-cleared-subtitle {
            font-size: 24px;
            color: #654321;
            margin-bottom: 30px;
            font-weight: 600;
        }

        .level-cleared-stars {
            font-size: 60px;
            margin: 20px 0;
            animation: starsSparkle 2s ease-in-out infinite;
        }

        /* Level Cleared Button */
        .level-cleared-button {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
            padding: clamp(12px, 3vw, 18px) clamp(24px, 6vw, 36px);
            font-size: clamp(16px, 4vw, 20px);
            border-radius: 12px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            margin: clamp(8px, 2vw, 12px);
            min-height: 44px; /* Minimum touch target */
            min-width: 120px;
            transition: all 0.3s ease;
            font-weight: 600;
            cursor: pointer;
            border: none;
            touch-action: manipulation; /* Prevent zoom on double-tap */
            -webkit-tap-highlight-color: transparent; /* Remove blue highlight on mobile */
        }

        .level-cleared-button:hover {
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
            transform: translateY(-2px);
        }

        .level-cleared-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        /* Game Over Popup Modal */
        .game-over-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10001;
            opacity: 0;
            animation: modalFadeIn 0.45s ease-out forwards;
        }

        .game-over-content {
            background: linear-gradient(135deg, #2c3e50 0%, #8e0e00 100%);
            border-radius: 24px;
            padding: clamp(28px, 6vw, 48px);
            text-align: center;
            box-shadow: 0 24px 48px rgba(0, 0, 0, 0.55);
            transform: scale(0.6);
            animation: modalPopIn 0.55s cubic-bezier(0.68, -0.55, 0.265, 1.55) forwards;
            max-width: min(420px, 90vw);
        }

        .game-over-title {
            font-size: clamp(36px, 9vw, 48px);
            font-weight: 800;
            color: #FFECEC;
            text-transform: uppercase;
            letter-spacing: 4px;
            text-shadow: 0 4px 12px rgba(0, 0, 0, 0.45);
            margin-bottom: clamp(12px, 3vw, 20px);
            animation: titlePulse 1s ease-in-out infinite alternate;
        }

        .game-over-message {
            font-size: clamp(18px, 4.2vw, 22px);
            color: #FFD7D7;
            margin-bottom: clamp(18px, 4vw, 26px);
            font-weight: 600;
        }

        .game-over-stats {
            display: grid;
            gap: 10px;
            color: #FFFFFF;
            font-size: clamp(16px, 4vw, 20px);
            margin-bottom: clamp(22px, 5vw, 32px);
        }

        .game-over-stats strong {
            color: #FFE082;
        }

        .game-over-buttons {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: clamp(12px, 3vw, 18px);
            flex-wrap: wrap;
        }

        /* Game Over Buttons */
        .game-over-button {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            color: #FFFFFF;
            padding: clamp(14px, 3.5vw, 18px) clamp(24px, 6vw, 32px);
            font-size: clamp(16px, 4vw, 18px);
            border-radius: 12px;
            box-shadow: 0 6px 16px rgba(231, 76, 60, 0.45);
            min-width: 150px;
            min-height: 44px; /* Minimum touch target */
            transition: all 0.3s ease;
            font-weight: 600;
            cursor: pointer;
            border: none;
            touch-action: manipulation; /* Prevent zoom on double-tap */
            -webkit-tap-highlight-color: transparent; /* Remove blue highlight on mobile */
        }

        .game-over-button.secondary {
            background: rgba(255, 255, 255, 0.12);
            border: 1px solid rgba(255, 255, 255, 0.4);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.35);
        }

        .game-over-button:hover {
            transform: translateY(-3px); /* Custom hover transform */
            box-shadow: 0 10px 22px rgba(231, 76, 60, 0.55);
        }

        .game-over-button.secondary:hover {
            transform: translateY(-3px); /* Custom hover transform */
            box-shadow: 0 10px 22px rgba(0, 0, 0, 0.4);
        }

        .game-over-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 8px rgba(231, 76, 60, 0.45);
        }

        .game-over-button.secondary:active {
            transform: translateY(0);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.35);
        }

        /* Enhanced touch feedback for popup buttons on mobile */
        @media (pointer: coarse) {
            .game-over-button, .level-cleared-button {
                min-height: 48px; /* Larger touch targets on mobile */
                min-width: 160px;
                padding: clamp(16px, 4vw, 20px) clamp(28px, 7vw, 36px);
                font-size: clamp(18px, 4.5vw, 20px);
                transition: all 0.2s ease; /* Faster response on touch */
            }
            
            .game-over-button:active, .level-cleared-button:active {
                transform: scale(0.95); /* Scale down for immediate feedback */
                transition: all 0.1s ease;
            }
            
            .game-over-buttons {
                gap: clamp(16px, 4vw, 24px); /* More space between buttons on mobile */
                margin-top: clamp(16px, 4vw, 24px);
            }
        }

        /* Additional mobile optimizations for popup modals */
        @media (max-width: 480px) {
            .game-over-content, .level-cleared-content {
                padding: clamp(20px, 5vw, 32px);
                margin: 20px;
                max-width: calc(100vw - 40px);
            }
            
            .game-over-buttons {
                flex-direction: column; /* Stack buttons vertically on small screens */
                width: 100%;
            }
            
            .game-over-button, .level-cleared-button {
                width: 100%; /* Full width buttons on small screens */
                margin: clamp(6px, 1.5vw, 8px) 0;
            }
        }

        /* Prevent mobile scroll issues during popup */
        .modal-open {
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
        }

        /* Ensure popup modals work with mobile keyboards */
        @media (max-height: 500px) {
            .game-over-modal, .level-cleared-modal {
                align-items: flex-start;
                padding-top: 20px;
            }
            
            .game-over-content, .level-cleared-content {
                max-height: calc(100vh - 40px);
                overflow-y: auto;
            }
        }

        @keyframes modalFadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes modalPopIn {
            from { 
                transform: scale(0.5) rotate(-10deg);
                opacity: 0;
            }
            to { 
                transform: scale(1) rotate(0deg);
                opacity: 1;
            }
        }

        @keyframes titlePulse {
            from { transform: scale(1); }
            to { transform: scale(1.05); }
        }

        @keyframes starsSparkle {
            0%, 100% { 
                transform: scale(1) rotate(0deg);
                filter: brightness(1);
            }
            50% { 
                transform: scale(1.1) rotate(5deg);
                filter: brightness(1.3);
            }
        }

        /* Global Drag Overlay - Ensure dragging works across entire viewport */
        #dragOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 9998;
            overflow: visible;
        }

        .ghost-shape {
            position: fixed !important;
            pointer-events: none !important;
            z-index: 10000 !important; /* Increased z-index */
            visibility: visible !important;
            opacity: 0.9 !important;
            display: block !important;
            transition: transform 0.2s ease-out !important;
        }

        .game-shape.ghost-active {
            opacity: 0;
            transform: scale(0.9);
            transition: all 0.3s ease;
        }

        /* Touch Feedback */
        .touch-ripple {
            position: fixed;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.6);
            pointer-events: none;
            z-index: 9998;
            animation: rippleEffect 0.6s ease-out forwards;
        }

        @keyframes rippleEffect {
            0% { transform: scale(0); opacity: 1; }
            100% { transform: scale(4); opacity: 0; }
        }

        .rotation-indicator {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: bold;
            z-index: 10000;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .rotation-indicator.show {
            opacity: 1;
        }

        /* Enhanced Drag Feedback */
        .game-shape.ghost-active {
            opacity: 0;
            transform: scale(0.9);
            transition: all 0.3s ease;
        }

        /* Shape Visual Designs - REMOVED: Now using unified canvas-based system */
        /* All shape appearances now handled by PhysicsShapeRenderer and SHAPE_CONFIG */

        /* Canvas preview styling for dock */
        .shape-preview {
            width: 46px;
            height: 46px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .shape-preview:hover {
            filter: brightness(1.1);
            transform: scale(1.05);
        }

        /* Ghost effect for dragged shapes */
        .shape-preview.ghost-active {
            opacity: 0.3;
            transform: scale(0.9);
            transition: all 0.3s ease;
        }

        /* Mode Toggle Inside HUD */
        .mode-toggle-switch {
            position: relative;
            width: 60px;
            height: 28px;
            background: rgba(52, 73, 94, 0.8);
            border-radius: 14px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .mode-toggle-switch.design-active {
            background: rgba(52, 152, 219, 0.8);
            border-color: #3498db;
        }

        .mode-toggle-slider {
            position: absolute;
            top: 2px;
            left: 2px;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
        }

        .mode-toggle-switch.design-active .mode-toggle-slider {
            transform: translateX(28px);
        }

        .mode-toggle-labels {
            position: absolute;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            white-space: nowrap;
            color: rgba(255, 255, 255, 0.8);
        }

        /* Design Mode Sidebar */
        .design-sidebar {
            position: fixed;
            top: 0;
            left: -350px;
            width: 350px;
            height: 100vh;
            background: linear-gradient(180deg, #2c3e50 0%, #34495e 100%);
            box-shadow: 5px 0 20px rgba(0,0,0,0.3);
            transition: left 0.4s ease;
            z-index: 999;
            overflow-y: auto;
            color: white;
        }

        .design-sidebar.active {
            left: 0;
        }

        .design-mode .game-viewport {
            margin-left: 350px;
            transition: margin-left 0.4s ease;
        }

        .sidebar-header {
            padding: 20px;
            background: rgba(0,0,0,0.2);
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .sidebar-title {
            font-size: 16px;
            font-weight: bold;
            color: #3498db;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .sidebar-section {
            padding: 15px 20px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .config-group {
            margin-bottom: 12px;
        }

        .config-label {
            display: block;
            font-size: 13px;
            font-weight: 500;
            margin-bottom: 5px;
            color: #bdc3c7;
        }

        .config-input, .config-select {
            width: 100%;
            padding: 8px 12px;
            background: rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 6px;
            color: white;
            font-size: 14px;
        }

        .config-input:focus, .config-select:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 5px rgba(52, 152, 219, 0.3);
        }

        .config-sub-group {
            margin-left: 20px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .config-sub-group .config-label {
            min-width: 100px;
            margin-bottom: 0;
            font-size: 12px;
        }

        .config-sub-group input[type="range"] {
            flex: 1;
            margin: 0;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
        }

        .range-value {
            min-width: 50px;
            text-align: right;
            font-size: 12px;
            color: #FFE4B5;
            font-weight: 600;
            background: rgba(0,0,0,0.2);
            padding: 2px 6px;
            border-radius: 4px;
        }

        .config-btn {
            width: 100%;
            padding: 10px;
            background: linear-gradient(135deg, #27ae60 0%, #229954 100%);
            color: white;
            border: none;
            border-radius: 6px;
            font-weight: bold;
            cursor: pointer;
            margin-top: 8px;
            transition: all 0.3s ease;
        }

        .config-btn:hover {
            background: linear-gradient(135deg, #229954 0%, #1e8449 100%);
            transform: translateY(-1px);
        }

        /* Theme Selector Styles */
        .checkbox-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 8px;
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            color: #ecf0f1;
            cursor: pointer;
        }

        .checkbox-label input[type="checkbox"] {
            width: 16px;
            height: 16px;
            accent-color: #27ae60;
        }

        .theme-preview {
            width: 100%;
            height: 40px;
            border-radius: 4px;
            margin: 4px 0 8px 0;
            background: linear-gradient(135deg, #87CEEB 0%, #4ECDC4 50%, #90EE90 100%);
            border: 2px solid transparent;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .theme-preview:hover {
            border-color: #27ae60;
            transform: scale(1.02);
        }

        .theme-preview.active {
            border-color: #27ae60;
            box-shadow: 0 0 10px rgba(39, 174, 96, 0.5);
        }

        .dock-slot-config {
            background: rgba(0,0,0,0.2);
            padding: 8px;
            border-radius: 6px;
            margin-bottom: 8px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .game-canvas-container {
            position: absolute;
            top: calc(clamp(70px, 12vh, 90px) + clamp(120px, 20vh, 160px)); /* HUD + Docking height */ 
            left: 0;
            right: 0;
            bottom: 0; /* Use full available space */
            /* background: linear-gradient(135deg, #87CEEB 0%, #98FB98 100%); */
            background: transparent; /* Changed from gradient to transparent */
            border-radius: 0;
            overflow: visible; /* Allow dragged shapes to extend beyond canvas boundaries */
        }

        #gameCanvas {
            width: 100%;
            height: 100%;
            display: block;
            background: transparent;
            cursor: crosshair;
        }

        /* Debug Info */
        .debug-info {
            position: absolute;
            bottom: clamp(5px, 2vh, 15px); /* Responsive bottom position */
            left: clamp(5px, 2vw, 15px); /* Responsive left position */
            color: white;
            font-size: clamp(10px, 2.5vw, 12px); /* Responsive font size */
            opacity: 0.7;
            font-family: monospace;
            background: rgba(0,0,0,0.7);
            padding: clamp(4px, 1.5vw, 8px); /* Responsive padding */
            border-radius: 6px;
            z-index: 100;
            max-width: 70vw; /* Prevent overflow */
            word-break: break-word;
        }

        /* Event Notifications */
        .event-notification {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: clamp(12px, 3vw, 20px) clamp(16px, 4vw, 24px); /* Responsive padding */
            border-radius: 12px;
            font-size: clamp(14px, 4vw, 18px); /* Responsive font size */
            font-weight: bold;
            z-index: 1000;
            opacity: 0;
            transition: all 0.3s ease;
            pointer-events: none;
            max-width: 80vw; /* Prevent overflow on small screens */
            min-width: 200px; /* Minimum readable width */
            text-align: center;
        }

        .event-notification.show {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1.1);
        }

        .event-notification.fall {
            background: rgba(231, 76, 60, 0.9);
            border: 2px solid #e74c3c;
        }

        .event-notification.collision {
            background: rgba(46, 204, 113, 0.9);
            border: 2px solid #2ecc71;
        }

        .event-notification.balance {
            background: rgba(52, 152, 219, 0.9);
            border: 2px solid #3498db;
        }

        /* Animations */
        @keyframes starPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.3); }
            100% { transform: scale(1.2); }
        }

        /* Test Controls (REMOVED - Debug squares eliminated) */

        /* Responsive Design - Mobile and Tablet First */
        @media (max-width: 1023px) {
            body {
                padding: 0;
            }
            
            .game-viewport {
                width: 100vw;
                height: 100vh;
                height: 100dvh;
                border-radius: 0;
                box-shadow: none;
                max-width: none;
                max-height: none;
                aspect-ratio: unset; /* Allow full screen on mobile/tablet */
                padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
            }
            
            .game-hud {
                height: clamp(60px, 10vh, 70px); /* Slightly smaller on mobile */
                padding: clamp(4px, 1.5vw, 8px);
            }
            
            .docking-area {
                height: clamp(100px, 18vh, 140px); /* Adjust for mobile */
                gap: clamp(3px, 1vw, 6px);
                padding: clamp(3px, 1vw, 6px);
            }
            
            .shape-slot {
                min-width: clamp(45px, 15vw, 60px); /* Optimize for mobile touch */
                min-height: clamp(45px, 15vw, 60px);
            }
            
            .game-canvas-container {
                border-radius: 0;
                top: calc(clamp(60px, 10vh, 70px) + clamp(100px, 18vh, 140px)); /* Updated for mobile HUD + docking */
            }
            
            /* Enhanced touch targets on mobile */
            .settings-button, .reset-button, .theme-button {
                min-width: 48px; /* Larger touch targets */
                min-height: 48px;
            }
            
            .timer-container {
                min-height: 48px; /* Better touch target */
            }
            
            .coin-counter {
                min-height: 48px; /* Better touch target */
                padding: 6px 10px;
            }
            
            /* Hide design mode on mobile */
            .design-sidebar {
                display: none;
            }
        }

        /* Rotation Zones - Mobile Enhancement */
        .rotation-zone {
            position: absolute;
            width: 80px;
            height: 100%;
            top: 0;
            border: 2px dashed rgba(74, 144, 226, 0.4);
            border-radius: 10px;
            transition: all 0.3s ease;
            pointer-events: none;
            opacity: 0.3; /* Make visible for testing */
            z-index: 1000;
            display: block; /* Always visible for testing */
        }

        .rotation-zone.left {
            left: 0;
            background: linear-gradient(to right, rgba(229, 115, 115, 0.2), transparent);
            border-color: rgba(229, 115, 115, 0.4);
        }

        .rotation-zone.right {
            right: 0;
            background: linear-gradient(to left, rgba(129, 199, 132, 0.2), transparent);
            border-color: rgba(129, 199, 132, 0.4);
        }

        .rotation-zone.visible {
            display: block;
            opacity: 1;
        }

        .rotation-zone.active {
            border-color: rgba(74, 144, 226, 1);
            box-shadow: 0 0 20px rgba(74, 144, 226, 0.4);
        }

        .rotation-zone.left.active {
            background: linear-gradient(to right, rgba(229, 115, 115, 0.4), transparent);
            border-color: rgba(229, 115, 115, 1);
            box-shadow: 0 0 20px rgba(229, 115, 115, 0.4);
        }

        .rotation-zone.right.active {
            background: linear-gradient(to left, rgba(129, 199, 132, 0.4), transparent);
            border-color: rgba(129, 199, 132, 1);
            box-shadow: 0 0 20px rgba(129, 199, 132, 0.4);
        }

        .rotation-zone::before {
            content: "‚Ü∫";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2rem;
            color: rgba(255, 255, 255, 0.8);
            animation: zonePulse 2s infinite;
        }

        .rotation-zone.right::before {
            content: "‚Üª";
        }

        .rotation-zone.active::before {
            animation: zoneRotate 1s linear infinite;
            color: rgba(255, 255, 255, 1);
        }

        @keyframes zonePulse {
            0%, 100% { opacity: 0.6; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
        }

        @keyframes zoneRotate {
            from { transform: translate(-50%, -50%) rotate(0deg); }
            to { transform: translate(-50%, -50%) rotate(360deg); }
        }

        /* Mobile-specific HUD adjustments */
        @media (max-width: 600px), (pointer: coarse) {
            /* Hide the play/edit toggle and the purple mobile debug button on mobile devices */
            #modeToggleSwitch,
            #mobileDebugButton {
                display: none !important;
            }
            /* Reflow the right section horizontally and allow the coin counter
               to occupy the space left by the hidden controls. Using flex-start
               ensures the group of remaining buttons and the coin counter starts
               from the left of the right section rather than hugging the far edge. */
            .right-section {
                flex-direction: row;
                align-items: center;
                justify-content: flex-start;
                gap: clamp(6px, 2vw, 12px);
            }
            /* Remove the left margin so the coin counter sits directly next to
               the remaining HUD buttons. The gap on the parent will handle spacing. */
            .coin-counter {
                margin-left: 0;
            }
        }
        
    </style>
</head>
<body>
    <!-- Global drag overlay to prevent clipping -->
    <div id="dragOverlay"></div>
    
    <div class="game-viewport" id="gameContainer">
        <!-- Mobile Rotation Zones -->
        <div id="leftRotationZone" class="rotation-zone left"></div>
        <div id="rightRotationZone" class="rotation-zone right"></div>
            
            <!-- Game HUD -->
            <div class="game-hud">
                <div class="left-section">
                    <div class="score-display">
                        <div class="trophy-icon">üèÜ</div>
                        <span class="score-text" id="scoreText">0</span>
                    </div>
                    <div class="progress-area">
                        <div class="star-progress-container" onclick="initializeProgressBarInteraction()">
                            <div class="star-progress-bar" id="starProgressBar" style="width: 0%;"></div>
                            <div class="progress-markers">
                                <div class="progress-marker"></div>
                                <div class="progress-marker"></div>
                                <div class="progress-marker"></div>
                            </div>
                        </div>
                        <div class="star-markers">
                            <div class="star"></div>
                            <div class="star"></div>
                            <div class="star"></div>
                        </div>
                    </div>
                </div>

                <div class="middle-section">
                    <div class="level-display" id="levelDisplay">World 1-1</div>
                    <div class="timer-container" id="timerContainer" onclick="switchTimerMode()">
                        <span class="timer-text" id="gameTimer">0:00</span>
                        <div class="timer-mode-indicator timer-mode-elapsed" id="timerModeIndicator">‚è±</div>
                    </div>
                </div>

                <div class="right-section">
                    <div class="top-buttons">

                        
                        <!-- Theme cycling button -->
                        <div class="theme-button" id="themeButton" onclick="cycleThemes()" title="Cycle Theme">
                            <div class="theme-icon">üé®</div>
                        </div>
                        
                        <!-- Phase 2: Mode Toggle Switch -->
                        <div class="mode-toggle-switch" id="modeToggleSwitch" onclick="toggleModeSwitch()">
                            <div class="mode-toggle-slider">üéÆ</div>
                            <div class="mode-toggle-labels">Play/Design</div>
                        </div>
                        
                        <div class="reset-button" id="resetButton" onclick="resetLevel()">
                            <div class="reset-icon">‚ü≤</div>
                        </div>
                        
                        <div class="reset-button" id="mobileDebugButton" onclick="toggleMobileDebug()" style="background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%);">
                            <div class="reset-icon">üì±</div>
                        </div>
                    </div>
                    <div class="coin-counter" id="coinCounter" onclick="animateCoin()">
                        <div class="coin-icon">üí∞</div>
                        <span class="coin-amount" id="coinAmount">0</span>
                    </div>
                </div>
            </div>

            <!-- Docking Area -->
            <div class="docking-area loading" id="dockingArea">
                <div class="shape-slot" id="slot-square">
                    <div class="game-shape shape-square" data-shape="square" id="shape-square"></div>
                </div>
                <div class="shape-slot" id="slot-triangle">
                    <div class="game-shape shape-triangle" data-shape="triangle" id="shape-triangle"></div>
                </div>
                <div class="shape-slot" id="slot-circle">
                    <div class="game-shape shape-circle" data-shape="circle" id="shape-circle"></div>
                </div>
                <div class="shape-slot" id="slot-cross2">
                    <div class="game-shape shape-cross2" data-shape="cross2" id="shape-cross2"></div>
                </div>
                <div class="shape-slot" id="slot-l">
                    <div class="game-shape shape-l" data-shape="l" id="shape-l"></div>
                </div>
                <div class="shape-slot" id="slot-cross">
                    <div class="game-shape shape-cross" data-shape="cross" id="shape-cross"></div>
                </div>
                <div class="shape-slot" id="slot-barbell-one">
                    <div class="game-shape shape-barbell-one" data-shape="barbell-one" id="shape-barbell-one"></div>
                </div>
                <div class="shape-slot" id="slot-barbell-two">
                    <div class="game-shape shape-barbell-two" data-shape="barbell-two" id="shape-barbell-two"></div>
                </div>
                <div class="shape-slot" id="slot-diamond-barbell">
                    <div class="game-shape shape-diamond-barbell" data-shape="diamond-barbell" id="shape-diamond-barbell"></div>
                </div>
            </div>

            <!-- Game Canvas Area -->
            <div class="game-canvas-container">
                <canvas id="gameCanvas"></canvas>
            </div>

            <!-- Event Notification System -->
            <div class="event-notification" id="eventNotification"></div>

            <!-- Debug Info -->
            <div class="debug-info" id="debugInfo">
                Shapes: 0/9 | Events: 0 | Collisions: 0 | FPS: 60
            </div>

            <!-- Rotation Indicator -->
            <div class="rotation-indicator" id="rotationIndicator">
                üîÑ R/E or ‚Üê/‚Üí to rotate
            </div>
    </div>

    <!-- Phase 2: Design Mode Sidebar -->
    <div class="design-sidebar" id="designSidebar">
        <div class="sidebar-header">
            <h2>üîß Level Editor</h2>
            <p>Configure level settings and dock layout</p>
        </div>

        <!-- Level Configuration -->
        <div class="sidebar-section">
            <div class="sidebar-title">üìã Level Configuration</div>
            
            <div class="config-group">
                <label class="config-label">World-Level</label>
                <input type="text" class="config-input" id="levelNumber" value="1-1" placeholder="1-1">
            </div>

            <div class="config-group">
                <label class="config-label">Timer Mode</label>
                <select class="config-select" id="timerMode" onchange="updateTimerModeConfig()">
                    <option value="none">No Timer</option>
                    <option value="elapsed" selected>Count-Up Timer</option>
                    <option value="countdown">Count-Down Timer</option>
                </select>
            </div>
            
            <div class="config-group">
                <label class="config-label">Starting Timer Value</label>
                <input type="number" class="config-input" id="timerStart" value="60" min="0" max="3600" placeholder="Seconds">
            </div>
            
            <div class="config-group">
                <label class="config-label">End-Level Countdown</label>
                <input type="number" class="config-input" id="endLevelDuration" value="5" min="3" max="15" placeholder="Seconds">
            </div>
        </div>

        <!-- Theme Selection -->
        <div class="sidebar-section">
            <div class="sidebar-title">üé® Theme Selection</div>
            
            <div class="config-group">
                <label class="config-label">Visual Theme</label>
                <select class="config-select" id="themeSelector" onchange="applyTheme(this.value)">
                    <option value="classic" selected>Classic Puzzle</option>
                    <option value="wood">Wood</option>
                    <option value="stone">Stone</option>
                    <option value="metal">Metal</option>
                </select>
            </div>

            <div class="config-group">
                <label class="config-label">Canvas Enhancements</label>
                <div class="checkbox-group">
                    <label class="checkbox-label">
                        <input type="checkbox" id="enableCanvas" checked onchange="toggleCanvasEnhancements()">
                        Enable Advanced Graphics
                    </label>
                    <label class="checkbox-label">
                        <input type="checkbox" id="enableParticles" checked onchange="toggleParticleEffects()">
                        Particle Effects
                    </label>
                    <label class="checkbox-label">
                        <input type="checkbox" id="enableAnimations" checked onchange="toggleAnimations()">
                        Shape Animations
                    </label>
                </div>
            </div>

            <div class="config-group">
                <label class="config-label">Mobile Touch Offset</label>
                <div class="checkbox-group">
                    <label class="checkbox-label">
                        <input type="checkbox" id="enableTouchOffset" checked onchange="toggleTouchOffset()">
                        Enable Touch Offset
                    </label>
                </div>
                <div class="config-sub-group">
                    <label class="config-label">X Offset (Horizontal)</label>
                    <input type="range" id="touchOffsetX" min="-100" max="100" value="0" 
                           onchange="updateTouchOffset()" oninput="updateTouchOffsetDisplay()">
                    <span class="range-value" id="touchOffsetXValue">0px</span>
                </div>
                <div class="config-sub-group">
                    <label class="config-label">Y Offset (Vertical)</label>
                    <input type="range" id="touchOffsetY" min="-150" max="50" value="-80" 
                           onchange="updateTouchOffset()" oninput="updateTouchOffsetDisplay()">
                    <span class="range-value" id="touchOffsetYValue">-80px</span>
                </div>
            </div>
        </div>

        <!-- Dock Configuration -->
        <div class="sidebar-section">
            <div class="sidebar-title">üîß Dock Configuration</div>
            
            <div class="config-group">
                <label class="config-label">Number of Dock Slots</label>
                <input type="number" class="config-input" id="dockSlotCount" value="9" min="3" max="12" onchange="generateDockSlots()">
            </div>
            
            <div class="config-group">
                <label class="config-label">Barbell Orientation in Dock</label>
                <select class="config-select" id="barbellOrientation" onchange="updateBarbellOrientation()">
                    <option value="vertical" selected>Vertical (90¬∞)</option>
                    <option value="horizontal">Horizontal (0¬∞)</option>
                </select>
            </div>
            
            <div class="config-group">
                <label class="config-label">Shape Assignment</label>
                <div id="dockSlotsContainer">
                    <!-- Dynamic dock slots will be generated here -->
                </div>
            </div>
        </div>

        <!-- Actions -->
        <div class="sidebar-section">
            <div class="sidebar-title">‚ö° Actions</div>
            
            <button class="config-btn" id="applyChangesBtn" onclick="applyLevelChanges()">
                Apply Level Changes
            </button>
            
            <button class="config-btn" onclick="resetLevel()" style="background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);">
                Reset Level
            </button>
            
            <button class="config-btn" onclick="syncDockToDesign()" style="background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);">
                Sync Current Dock
            </button>
        </div>
    </div>



    <!-- Matter.js Physics Engine -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    
    <script>
        // Debug configuration
        const DEBUG_MODE = false; // Set to true for verbose logging (change to true for debugging)
        const debugLog = (...args) => DEBUG_MODE && console.log(...args);
        
        // Logging helpers for different types of messages
        const infoLog = (...args) => DEBUG_MODE && console.log(...args);
        const systemLog = (...args) => DEBUG_MODE && console.log(...args);
        const assetLog = (...args) => DEBUG_MODE && console.log(...args);
        
        // Enhanced debugging for race condition validation
        const raceConditionDebugger = {
            operationTimes: new Map(),
            duplicateCallCount: new Map(),
            
            trackOperation(operationName, source = 'unknown') {
                const timestamp = Date.now();
                const key = `${operationName}-${source}`;
                
                if (this.operationTimes.has(key)) {
                    const count = this.duplicateCallCount.get(key) || 0;
                    this.duplicateCallCount.set(key, count + 1);
                    console.warn(`‚ö†Ô∏è DUPLICATE OPERATION: ${operationName} from ${source} (count: ${count + 1})`);
                } else {
                    this.operationTimes.set(key, timestamp);
                }
                
                console.log(`‚è±Ô∏è [${new Date(timestamp).toISOString()}] ${operationName} started from ${source}`);
            },
            
            getSummary() {
                return {
                    totalOperations: this.operationTimes.size,
                    duplicates: Array.from(this.duplicateCallCount.entries()),
                    operationHistory: Array.from(this.operationTimes.entries())
                };
            },
            
            clear() {
                this.operationTimes.clear();
                this.duplicateCallCount.clear();
            }
        };
        
        // Make globally available for testing
        window.raceConditionDebugger = raceConditionDebugger;
        
        // Race condition validation function
        window.validateRaceConditionFixes = function() {
            console.log('üîç Race Condition Fix Validation Report:');
            console.log('======================================');
            
            const summary = raceConditionDebugger.getSummary();
            console.log(`üìä Total Operations Tracked: ${summary.totalOperations}`);
            
            if (summary.duplicates.length === 0) {
                console.log('‚úÖ NO DUPLICATE OPERATIONS DETECTED - All fixes working correctly!');
            } else {
                console.log('‚ö†Ô∏è DUPLICATE OPERATIONS DETECTED:');
                summary.duplicates.forEach(([operation, count]) => {
                    console.log(`  - ${operation}: ${count} duplicates`);
                });
            }
            
            console.log('\nüìã Operation History:');
            summary.operationHistory.forEach(([operation, timestamp]) => {
                console.log(`  - ${operation}: ${new Date(timestamp).toISOString()}`);
            });
            
            // Check race condition monitor status
            if (typeof raceConditionMonitor !== 'undefined' && raceConditionMonitor.getStats) {
                const stats = raceConditionMonitor.getStats();
                console.log('\nüîß Race Condition Monitor Stats:');
                console.log(`  - Total tracked accesses: ${stats.totalAccesses || 0}`);
                console.log(`  - Potential race conditions: ${stats.potentialRaceConditions || 0}`);
            }
            
            return summary;
        };
        
        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë UNIFIED GAME INITIALIZER - RACE CONDITION FIX
          ‚ïë Single entry point for coordinated startup sequence
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        class GameInitializer {
            static isInitialized = false;
            static isInitializing = false;
            static initPromise = null;
            
            static async initialize() {
                raceConditionDebugger.trackOperation('GameInitializer.initialize', 'main');
                
                if (this.isInitialized) {
                    debugLog('‚ö†Ô∏è GameInitializer already initialized, skipping');
                    return this.initPromise;
                }
                
                if (this.isInitializing) {
                    debugLog('‚ö†Ô∏è GameInitializer already initializing, returning existing promise');
                    return this.initPromise;
                }
                
                this.isInitializing = true;
                
                // Wait for mutexes to be available (they're declared later in the file)
                const waitForMutexes = () => {
                    return new Promise((resolve) => {
                        const checkMutexes = () => {
                            if (typeof assetMutex !== 'undefined' && typeof dockMutex !== 'undefined') {
                                resolve();
                            } else {
                                setTimeout(checkMutexes, 10);
                            }
                        };
                        checkMutexes();
                    });
                };
                
                this.initPromise = (async () => {
                    await waitForMutexes();
                    
                    systemLog('üöÄ Starting unified game initialization...');
                    
                    try {
                        // Phase 1: Create AssetManager
                        await this._createAssetManager();
                        
                        // Phase 2: Load default theme
                        await this._loadDefaultTheme();
                        
                        // Phase 3: Load level data
                        const levelData = await this._loadLevelData();
                        
                        // Phase 4: Initialize game systems
                        await this._initializeGameSystems(levelData);
                        
                        // Phase 5: Apply level theme if specified
                        await this._applyLevelTheme();
                        
                        // Phase 6: Build UI
                        await this._buildUI();
                        
                        this.isInitialized = true;
                        this.isInitializing = false;
                        systemLog('‚úÖ Unified game initialization complete');
                        
                    } catch (error) {
                        this.isInitializing = false;
                        this.initPromise = null;
                        console.error('‚ùå Game initialization failed:', error);
                        throw error;
                    }
                })();
                
                return this.initPromise;
            }
            
            static async _createAssetManager() {
                if (!window.assetManager) {
                    window.assetManager = new AssetManager();
                    debugLog('‚úÖ AssetManager created');
                }
                // Ensure backward compatibility
                window.textureManager = window.assetManager;
            }
            
            static async _loadDefaultTheme() {
                const defaultTheme = CANVAS_CONFIG.defaultTheme || 'classic';
                try {
                    // Check if theme is already loaded
                    if (!window.assetManager.themes[defaultTheme]?.loaded) {
                        await window.assetManager.loadTheme(defaultTheme);
                    }
                    debugLog(`‚úÖ Default theme '${defaultTheme}' loaded`);
                } catch (error) {
                    console.error('‚ùå Failed to load default theme:', error);
                    throw error;
                }
            }
            
            static async _loadLevelData() {
                let levelFile = 'levelData.json';
                try {
                    levelFile = new URL(levelFile, window.location.href).href;
                } catch (e) {
                    console.warn('üîß Using relative path for level data');
                }
                
                const loader = new LevelLoader();
                const ok = await loader.loadFromFile(levelFile);
                if (!ok) {
                    throw new Error('Failed to load level data');
                }
                
                const data = loader.getData();
                window.currentLevelData = data;
                debugLog('‚úÖ Level data loaded');
                return data;
            }
            
            static async _initializeGameSystems(levelData) {
                if (levelData.mode === 'PLAYABLE_AD') {
                    debugLog('üöÄ PLAYABLE_AD mode detected.');
                    window.adSequencer = new AdSequencer(levelData.adConfig);
                    alert('Playable Ad Mode Initialized! (stub).');
                } else if (levelData.mode === 'LEVEL') {
                    debugLog('üéÆ LEVEL mode detected.');
                    
                    const gameManager = new GameManager(levelData);
                    window.gameManager = gameManager;
                    
                    // Wait for GameManager async initialization to complete
                    await gameManager.initPromise;
                    debugLog('‚úÖ GameManager initialized');
                } else {
                    throw new Error(`Unknown mode in level data: ${levelData.mode}`);
                }
            }
            
            static async _applyLevelTheme() {
                if (window.gameManager && typeof window.gameManager.applyLevelTheme === 'function') {
                    await window.gameManager.applyLevelTheme();
                    debugLog('‚úÖ Level theme applied');
                }
            }
            
            static async _buildUI() {
                if (window.gameManager) {
                    // Use dockMutex for coordinated dock building
                    await dockMutex.execute(async () => {
                        await window.gameManager.rebuildDockFromData(true);
                        
                        if (typeof window.gameManager.createPlatformsFromData === 'function') {
                            window.gameManager.createPlatformsFromData();
                        }
                        
                        if (window.gameManager.updateDebugInfo) {
                            window.gameManager.updateDebugInfo();
                        }
                        
                        console.log('‚úÖ Game UI built');
                    }, 'initial-ui-build');
                }
                
                // Initialize UI components
                if (typeof initializeThemeUI === 'function') initializeThemeUI();
                if (typeof updateTouchOffsetDisplay === 'function') updateTouchOffsetDisplay();
                if (typeof startCoinBonusSystem === 'function') startCoinBonusSystem();
                
                debugLog('‚úÖ UI components initialized');
            }
        }
        
        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë BSH GAME - CANVAS2D ARCHITECTURE
          ‚ïë Complete PixiJS Removal & Canvas2D Optimization
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        /*
         * ARCHITECTURAL OVERVIEW:
         * 
         * This version represents the complete removal of PixiJS dependencies,
         * transitioning to a pure Canvas2D rendering architecture for optimal
         * performance, compatibility, and maintainability.
         * 
         * KEY CHANGES FROM PREVIOUS VERSION:
         * ‚Ä¢ Complete PixiJS removal (PixiJS CDN, classes, references)
         * ‚Ä¢ Canvas2D-only rendering system
         * ‚Ä¢ Simplified renderer architecture
         * ‚Ä¢ Reduced bundle size (~200KB smaller)
         * ‚Ä¢ Enhanced browser compatibility
         * ‚Ä¢ Improved performance on older devices
         * 
         * CORE SYSTEMS:
         * ‚Ä¢ RendererManager: Canvas2D-only rendering
         * ‚Ä¢ PhysicsManager: Matter.js with Canvas2D visualization
         * ‚Ä¢ ThemeManager: Canvas-optimized theme system
         * ‚Ä¢ DragDropManager: Canvas-based interaction
         * 
         * PRESERVED FUNCTIONALITY:
         * ‚Ä¢ All physics mechanics (Matter.js)
         * ‚Ä¢ Complete shape library with textures
         * ‚Ä¢ Full theme system (10+ themes)
         * ‚Ä¢ Responsive design and mobile support
         * ‚Ä¢ Settings and customization options
         * ‚Ä¢ Performance monitoring and debug tools
         */

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë LEVEL LOADER & DATA MANAGER
          ‚ïë Fetches and stores level JSON data.
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        class LevelLoader {
            constructor() {
                this.levelData = null;
            }
            async loadFromFile(filePath) {
                try {
                    let response;
                    try {
                        response = await fetch(filePath);
                    } catch (err) {
                        return new Promise((resolve) => {
                            const xhr = new XMLHttpRequest();
                            xhr.overrideMimeType('application/json');
                            xhr.onreadystatechange = () => {
                                if (xhr.readyState === 4) {
                                    if (xhr.status === 200 || xhr.status === 0) {
                                        try {
                                            this.levelData = JSON.parse(xhr.responseText);
                                            console.log(`‚úÖ Level data loaded via XHR from ${filePath}`, this.levelData);
                                            resolve(true);
                                        } catch (parseErr) {
                                            console.error('‚ùå Failed to parse level data via XHR:', parseErr);
                                            this.levelData = null;
                                            resolve(false);
                                        }
                                    } else {
                                        console.error(`‚ùå Failed to load level data via XHR. Status: ${xhr.status}`);
                                        resolve(false);
                                    }
                                }
                            };
                            xhr.open('GET', filePath, true);
                            xhr.send(null);
                        });
                    }
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    this.levelData = await response.json();
                    console.log(`‚úÖ Level data loaded successfully from ${filePath}`, this.levelData);
                    return true;
                } catch (error) {
                    console.error('‚ùå Failed to load or parse level data:', error);
                    this.levelData = null;
                    return false;
                }
            }
            getData() {
                return this.levelData;
            }
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë STUB MANAGERS FOR ADVANCED FEATURES
          ‚ïë Placeholder classes to store additional level data for future implementation.
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        class ObjectiveManager {
            constructor(victoryData, failureData) {
                this.victoryData = victoryData || null;
                this.failureData = failureData || null;
                debugLog('üó∫Ô∏è ObjectiveManager initialized with data:', this.victoryData, this.failureData);
            }
        }
        class StarManager {
            constructor(starData) {
                this.starData = starData || [];
                debugLog(`‚≠ê StarManager initialized with ${this.starData.length} stars.`);
            }
        }
        class OnboardingManager {
            constructor(onboardingData) {
                this.onboardingData = onboardingData || null;
                console.log('üéì OnboardingManager initialized with data:', this.onboardingData);
            }
        }
        /**
         * Helper function to deeply merge two objects. The source object's properties overwrite the target's.
         * @param {object} target - The target object to merge into.
         * @param {object} source - The source object with new properties.
         * @returns {object} The merged object.
         */
        function deepMerge(target, source) {
            const output = { ...target };
            if (isObject(target) && isObject(source)) {
                Object.keys(source).forEach(key => {
                    if (isObject(source[key])) {
                        if (!(key in target)) {
                            Object.assign(output, { [key]: source[key] });
                        } else {
                            output[key] = deepMerge(target[key], source[key]);
                        }
                    } else {
                        Object.assign(output, { [key]: source[key] });
                    }
                });
            }
            return output;
        }

        function isObject(item) {
            return (item && typeof item === 'object' && !Array.isArray(item));
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë AD SEQUENCER (this is for context to find the right location)
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        class AdSequencer {
            constructor(adConfig) {
                this.adConfig = adConfig || null;
                console.log('üì∫ AdSequencer initialized with config:', this.adConfig);
            }
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë CANVAS ENHANCEMENT CONFIGURATION
          ‚ïë Feature flags and settings for texture, theme, and visual enhancement system
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        const CANVAS_CONFIG = {
            // Basic canvas rendering settings
            width: 800,
            height: 500,
            resolution: Math.min(window.devicePixelRatio || 1, 2),
            antialias: true,
            transparent: false,
            powerPreference: 'high-performance',
            backgroundColor: 0x87CEEB,  // Sky blue
            
            // Feature flags
            enabled: true,                    // Master switch for canvas enhancements
            useTextures: true,               // Enable texture system for shapes
            useThemes: true,                 // Enable theme switching
            useParticles: true,              // Enable particle effects
            useAnimations: true,             // Enable shape animations
            useBackgroundTextures: true,     // Enable background textures
            usePlatformTextures: true,       // Enable platform textures
            
            // Performance settings
            maxParticles: 50,                // Maximum particles on screen
            textureQuality: 'high',          // 'low', 'medium', 'high'
            enableLOD: true,                 // Level of detail for small shapes
            cacheTextures: true,             // Cache rendered textures
            
            // Default theme and fallback behavior
            defaultTheme: 'classic',
            fallbackToSolid: true,           // Use solid colors if textures fail
            showLoadingProgress: true,       // Show loading indicators
            
            // Debug options
            debugMode: false,                // Show texture loading info
            showBounds: false,               // Show texture boundaries
            logAssetLoading: true            // Console logging for asset loading
        };

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë UNIFIED CONFIGURATION SYSTEM
          ‚ïë Centralized configuration management for improved code quality
          ‚ïë Single source of truth for all magic numbers and settings
          ‚ïë
          ‚ïë ARCHITECTURE:
          ‚ïë ‚Ä¢ CANVAS_CONFIG: Canvas enhancement features and rendering settings
          ‚ïë ‚Ä¢ UNIFIED_GAME_CONFIG: Core game configuration (shapes, timers, performance)
          ‚ïë
          ‚ïë BENEFITS:
          ‚ïë ‚Ä¢ Eliminates hard-coded magic numbers throughout the codebase
          ‚ïë ‚Ä¢ Provides single source of truth for configuration values
          ‚ïë ‚Ä¢ Maintains backwards compatibility with existing code
          ‚ïë ‚Ä¢ Enables easy configuration management and testing
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        
        // Unified game configuration - single source of truth
        const UNIFIED_GAME_CONFIG = {
            // Core renderer settings
            renderer: {
                engine: 'canvas',
                fallbackEnabled: false, // No fallback needed - Canvas only
                ...CANVAS_CONFIG
            },
            
            // Performance settings
            performance: {
                targetFPS: 60,
                scaleMultiplier: 1.9,
                enableAntialiasing: true,
                enableTransparency: true,
                backgroundAlpha: 0
            },
            
            // Shape and dock configuration
            shapes: {
                dockPreviewSize: 90,
                defaultStrokeWidth: 2,
                defaultFillAlpha: 0.8,
                minShapeSize: 20,
                maxShapeSize: 200
            },
            
            // Timer and level configuration
            timer: {
                defaultStartValue: 60,
                endLevelCountdown: 5,
                min: 0,
                max: 3600
            },
            
            // Theme and visual settings
            theme: {
                enabled: true,
                defaultTheme: 'classic',
                transitions: true,
                colors: {
                    primary: 0xFF6B6B,
                    secondary: 0x4ECDC4,
                    background: 0x87CEEB
                }
            },
            
            // Animation settings
            animations: {
                enabled: true,
                quality: 'high',
                easing: 'default',
                reduceMotion: false
            },
            
            // Debug options
            debug: {
                enabled: false,
                showFPS: false,
                logPerformance: false,
                wireframe: false
            }
        };

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
         ‚ïë UNIFIED TEXTURE AND THEME SYSTEM
         ‚ïë Single source of truth for all texture operations
         ‚ïë Consolidates 4 different texture checking implementations:
         ‚ïë ‚Ä¢ isTextureAvailable() [legacy function]
         ‚ïë ‚Ä¢ AssetManager.isTextureLoaded() 
         ‚ïë ‚Ä¢ PhysicsShapeRenderer.hasTexture()
         ‚ïë ‚Ä¢ window.assetManager.isTextureLoaded()
         ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        class UnifiedTextureSystem {
            /**
             * Master texture availability checker
             * Replaces all scattered texture checking implementations
             */
            static isTextureAvailable(shapeType) {
                if (!window.assetManager) {
                    console.warn('UnifiedTextureSystem: AssetManager not available');
                    return false;
                }
                
                try {
                    const currentTheme = window.assetManager.currentTheme || 'classic';
                    
                    // Get the theme configuration to check if it uses textures
                    const themeConfig = THEME_DEFINITIONS[currentTheme];
                    if (!themeConfig || !themeConfig.shapes || !themeConfig.shapes.useTextures) {
                        return false; // Theme doesn't use textures, use colors instead
                    }
                    
                    // For textured themes, check if texture exists and is loaded
                    const texture = window.assetManager.getShapeTexture(shapeType);
                    return texture !== null && texture !== undefined;
                } catch (error) {
                    console.warn(`UnifiedTextureSystem: Texture check failed for ${shapeType}:`, error);
                    return false;
                }
            }
            
            /**
             * Master texture retrieval method
             * Returns texture if available, null otherwise
             */
            static getShapeTexture(shapeType) {
                if (!this.isTextureAvailable(shapeType)) {
                    return null;
                }
                
                try {
                    return window.assetManager.getShapeTexture(shapeType);
                } catch (error) {
                    console.warn(`UnifiedTextureSystem: Texture retrieval failed for ${shapeType}:`, error);
                    return null;
                }
            }
            
            /**
             * Check if a theme uses textures for shapes
             */
            static themeUsesTextures(themeName = null) {
                const currentTheme = themeName || window.assetManager?.currentTheme || 'classic';
                const themeConfig = THEME_DEFINITIONS[currentTheme];
                return !!(themeConfig?.shapes?.useTextures);
            }
            
            /**
             * Get texture configuration for a shape in current theme
             */
            static getTextureConfig(shapeType) {
                if (!this.isTextureAvailable(shapeType)) {
                    return null;
                }
                
                const currentTheme = window.assetManager.currentTheme || 'classic';
                const themeConfig = THEME_DEFINITIONS[currentTheme];
                
                return {
                    repeat: themeConfig.shapes?.textureRepeat || 'repeat',
                    blend: themeConfig.shapes?.textureBlend || 'multiply', 
                    opacity: themeConfig.shapes?.textureOpacity || 0.7
                };
            }
            
            /**
             * Unified theme application method
             * Consolidates theme switching logic
             */
            static applyTheme(themeName, source = 'unified') {
                return UnifiedThemeController.changeTheme(themeName, { source });
            }
        }

        // Legacy compatibility - gradually replace these calls with UnifiedTextureSystem
        function isTextureAvailable(shapeType) {
            return UnifiedTextureSystem.isTextureAvailable(shapeType);
        }

        // Global access for backward compatibility
        window.UnifiedTextureSystem = UnifiedTextureSystem;

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë THEME DEFINITIONS - VISUAL THEMES FOR THE GAME
          ‚ïë Each theme defines complete visual styling for all game elements
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        
        // Base configurations for inheritance and composition
        const BASE_TEXTURE_CONFIG = {
            repeat: "repeat",
            blend: "multiply",
            opacity: 0.7
        };

        const BASE_IMAGE_CONFIG = {
            repeat: "no-repeat",
            position: "center",
            size: "cover"
        };

        // Factory function to create texture configuration
        function createTextureConfig(overrides = {}) {
            return {
                ...BASE_TEXTURE_CONFIG,
                ...overrides
            };
        }

        // Factory function to create image configuration
        function createImageConfig(overrides = {}) {
            return {
                ...BASE_IMAGE_CONFIG,
                ...overrides
            };
        }

        // Base theme configurations for inheritance and composition
        const BASE_THEME_STRUCTURE = {
            background: {
                type: "gradient",
                texture: null,
                image: createImageConfig()
            },
            platform: {
                texture: null,
                pattern: "solid",
                image: createImageConfig({
                    repeat: "repeat",
                    blend: "multiply",
                    opacity: 0.8
                })
            },
            shapes: {
                useTextures: false,
                baseTexturePath: null,
                specialEffects: ["shadow"],
                animations: ["bounce"]
            },
            particles: {
                style: "geometric"
            }
        };

        // Factory function to create theme configuration
        function createThemeConfig(name, description, customConfig = {}) {
            const theme = {
                name,
                description,
                ...BASE_THEME_STRUCTURE,
                ...customConfig
            };

            // Generate consistent shape texture mappings if not provided
            if (!theme.shapes.textures) {
                const shapeNames = ['square', 'circle', 'triangle', 'cross', 'cross2', 'l', 'barbell-one', 'barbell-two', 'diamond-barbell'];
                theme.shapes.textures = {};
                
                shapeNames.forEach(shapeName => {
                    theme.shapes.textures[shapeName] = createTextureConfig({
                        url: customConfig.shapes?.textureUrl || null,
                        opacity: customConfig.shapes?.textureOpacity || 0.7
                    });
                });
            }

            return theme;
        }

        const THEME_DEFINITIONS = {
            classic: createThemeConfig(
                "Classic Puzzle",
                "Clean, geometric shapes with simple colors",
                {
                    background: {
                        type: "gradient",
                        colors: ["#87CEEB", "#4ECDC4", "#90EE90"],
                        texture: null,
                        gradient: {
                            colors: ['#87CEEB', '#98FB98'],
                            direction: '135deg'
                        },
                        opacity: 1.0,
                        image: createImageConfig()
                    },
                    platform: {
                        texture: null,
                        color: "#8B4513",
                        material: "wood",
                        pattern: "solid",
                        image: createImageConfig({
                            repeat: "repeat",
                            blend: "multiply",
                            opacity: 0.8
                        })
                    },
                    particles: {
                        style: "geometric",
                        colors: ["#FFD700", "#FF6B6B", "#4ECDC4"]
                    }
                }
            ),
            
            wood: createThemeConfig(
                "Wood",
                "Natural wood textures and warm earth tones",
                {
                    background: {
                        type: "image",
                        colors: ["#8B4513", "#A0522D", "#CD853F"],
                        texture: "wood_grain",
                        image: {
                            url: "assets/bkg/bkg1.png",
                            size: "cover",
                            position: "center top",
                            repeat: "no-repeat"
                        },
                        opacity: 0.5,
                        fallbackColor: "#8B4513"
                    },
                    platform: {
                        texture: "wood_grain",
                        color: "#8B4513",
                        material: "wood",
                        pattern: "grain",
                        image: createImageConfig({
                            // repeat: "repeat-x",
                            // blend: "multiply",
                            // opacity: 0.8
            		    url: "assets/textures/stone/stone1.png",  // Add this
                            opacity: 0.9,
                            repeat: "repeat"
                        })
                    },
                    shapes: {
                        useTextures: true,
                        baseTexturePath: "textures/wood/",
                        specialEffects: ["grain", "knot"],
                        animations: ["creak", "sway"],
                        textureUrl: "assets/textures/wood/oak.png"
                    },
                    particles: {
                        style: "sawdust",
                        colors: ["#D2B48C", "#DEB887", "#F4A460"]
                    }
                }
            ),
            
            stone: createThemeConfig(
                "Stone",
                "Ancient stone structures with granite and marble textures",
                {
                    background: {
                        type: "pattern",
                        colors: ["#2F4F4F", "#708090", "#778899"],
                        texture: "granite",
                        pattern: {
                            type: "granite",
                            baseColor: "#696969",
                            accentColors: ["#778899", "#708090", "#2F4F4F", "#A9A9A9"],
                            style: "radial-gradient(circle at 20% 30%, rgba(119, 136, 153, 0.8) 0px, rgba(119, 136, 153, 0.6) 3px, transparent 6px), radial-gradient(circle at 60% 70%, rgba(112, 128, 144, 0.7) 0px, rgba(112, 128, 144, 0.4) 2px, transparent 5px), radial-gradient(circle at 40% 20%, rgba(47, 79, 79, 0.9) 0px, rgba(47, 79, 79, 0.5) 2px, transparent 4px), radial-gradient(circle at 80% 40%, rgba(169, 169, 169, 0.6) 0px, rgba(169, 169, 169, 0.3) 1px, transparent 3px), radial-gradient(circle at 10% 80%, rgba(119, 136, 153, 0.5) 0px, transparent 2px), radial-gradient(circle at 90% 10%, rgba(112, 128, 144, 0.4) 0px, transparent 3px), linear-gradient(135deg, #696969 0%, #708090 50%, #778899 100%)"
                        },
                        image: {
                            url: "assets/textures/stone/granite.txt",
                            size: "cover",
                            position: "center",
                            repeat: "no-repeat"
                        },
                        opacity: 0.7,
                        fallbackColor: "#696969"
                    },
                    platform: {
                        texture: null,
                        color: "#696969",
                        material: "granite",
                        pattern: "rough",
                        image: createImageConfig({
                            repeat: "repeat",
                            blend: "hard-light",
                            opacity: 0.9
                        })
                    },
                    shapes: {
                        useTextures: true,
                        baseTexturePath: "textures/stone/",
                        specialEffects: ["dust", "crack"],
                        animations: ["settle", "crumble"],
                        textureOpacity: 0.8,
                        colors: {
                            square: { color: '#696969', stroke: '#555555', strokeWidth: 2 },      // Dark gray granite
                            triangle: { color: '#778899', stroke: '#556B83', strokeWidth: 2 },   // Light slate gray  
                            circle: { color: '#708090', stroke: '#5F6F7F', strokeWidth: 2 },     // Slate gray
                            cross: { color: '#2F4F4F', stroke: '#1F3F3F', strokeWidth: 2 },      // Dark slate gray
                            'cross2': { color: '#696969', stroke: '#555555', strokeWidth: 2 },   // Granite gray
                            'l': { color: '#A9A9A9', stroke: '#8A8A8A', strokeWidth: 2 },        // Light gray stone
                            'barbell-one': { color: '#778899', stroke: '#556B83', strokeWidth: 2 }, // Slate
                            'barbell-two': { color: '#708090', stroke: '#5F6F7F', strokeWidth: 2 }, // Blue-gray stone
                            'diamond-barbell': { color: '#2F4F4F', stroke: '#1F3F3F', strokeWidth: 2 } // Dark slate
                        }
                    },
                    particles: {
                        style: "dust",
                        colors: ["#A9A9A9", "#D3D3D3", "#C0C0C0"]
                    }
                }
            ),
            
            metal: createThemeConfig(
                "Metal",
                "Industrial metal structures with steel and iron textures",
                {
                    background: {
                        type: "pattern",
                        colors: ["#1e3a4f", "#2d5a7b", "#4682b4", "#5a7aa6"],  // Deep blue steel gradient
                        texture: "brushed-steel",
                        pattern: {
                            type: "brushed-metal",
                            baseColor: "#4A4A4A",
                            accentColors: ["#4682B4", "#1e3a4f", "#2d5a7b", "#87CEEB"],
                            style: "repeating-linear-gradient(90deg, transparent, transparent 1px, rgba(135, 206, 235, 0.1) 1px, rgba(135, 206, 235, 0.1) 2px), repeating-linear-gradient(0deg, transparent, transparent 1px, rgba(70, 130, 180, 0.05) 1px, rgba(70, 130, 180, 0.05) 3px), linear-gradient(45deg, #1e3a4f 0%, #4682B4 25%, #2d5a7b 50%, #5a7aa6 75%, #4682B4 100%)"
                        },
                        image: {
                            url: "assets/textures/metal/steel.txt",
                            size: "cover",
                            position: "center",
                            repeat: "no-repeat"
                        },
                        opacity: 0.4,
                        fallbackColor: "#4A4A4A"
                    },
                    platform: {
                        texture: null,
                        color: "#4682B4",  // Steel blue instead of gray
                        material: "steel",
                        pattern: "brushed",
                        image: createImageConfig({
                            repeat: "repeat",
                            blend: "hard-light",
                            opacity: 0.9
                        })
                    },
                    shapes: {
                        useTextures: true,
                        baseTexturePath: "textures/metal/",
                        specialEffects: ["spark", "gleam"],
                        animations: ["clang", "shine"],
                        textureOpacity: 0.9,
                        colors: {
                            square: { color: '#4169E1', stroke: '#1E3A8A', strokeWidth: 2 },      // Royal blue steel
                            triangle: { color: '#4682B4', stroke: '#2F4F7F', strokeWidth: 2 },   // Steel blue
                            circle: { color: '#6495ED', stroke: '#4169E1', strokeWidth: 2 },     // Cornflower blue
                            cross: { color: '#1E3A8A', stroke: '#1B1F3A', strokeWidth: 2 },      // Dark blue steel
                            'cross2': { color: '#5F8DCE', stroke: '#3A5B94', strokeWidth: 2 },   // Medium blue steel
                            'l': { color: '#87CEEB', stroke: '#5F8DCE', strokeWidth: 2 },        // Sky blue steel
                            'barbell-one': { color: '#4169E1', stroke: '#1E3A8A', strokeWidth: 2 }, // Royal blue
                            'barbell-two': { color: '#4682B4', stroke: '#2F4F7F', strokeWidth: 2 }, // Steel blue
                            'diamond-barbell': { color: '#1E3A8A', stroke: '#0F1F45', strokeWidth: 2 } // Deep blue steel
                        }
                    },
                    particles: {
                        style: "sparks",
                        colors: ["#87CEEB", "#4682B4", "#1E90FF", "#4169E1"]  // Blue spark colors
                    }
                }
            )
        };

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë MASTER SHAPE REGISTRY - UNIFIED SHAPE ATTRIBUTE SYSTEM
          ‚ïë Single source of truth for ALL shape properties across all rendering contexts
          ‚ïë Eliminates inconsistencies between dock, canvas, and physics representations
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/

        // Master shape registry with complete attribute definitions
        const MASTER_SHAPE_REGISTRY = {
            square: {
                geometry: {
                    type: 'rectangle',
                    width: 35,
                    height: 35,
                    borderRadius: 3
                },
                physics: {
                    density: 0.5,
                    friction: 0.7,
                    restitution: 0.2
                },
                visual: {
                    color: '#F39C12',
                    stroke: '#E67E22',
                    strokeWidth: 2
                }
            },

            triangle: {
                geometry: {
                    type: 'polygon',
                    vertices: [
                        { x: 0, y: -15 },
                        { x: -17.5, y: 15 },
                        { x: 17.5, y: 15 }
                    ]
                },
                physics: {
                    density: 0.5,
                    friction: 0.7,
                    restitution: 0.2
                },
                visual: {
                    color: '#9B59B6',
                    stroke: '#8E44AD',
                    strokeWidth: 2
                }
            },

            circle: {
                geometry: {
                    type: 'circle',
                    radius: 17.5
                },
                physics: {
                    density: 0.5,
                    friction: 0.7,
                    restitution: 0.2
                },
                visual: {
                    color: '#1ABC9C',
                    stroke: '#16A085',
                    strokeWidth: 2
                }
            },

            cross: {
                geometry: {
                    type: 'compound',
                    parts: [
                        {
                            type: 'rectangle',
                            width: 15,
                            height: 35,
                            offsetX: 0,
                            offsetY: 0
                        },
                        {
                            type: 'rectangle',
                            width: 35,
                            height: 15,
                            offsetX: 0,
                            offsetY: 0
                        }
                    ]
                },
                physics: {
                    density: 0.5,
                    friction: 0.7,
                    restitution: 0.2
                },
                visual: {
                    color: '#E74C3C',
                    stroke: '#C0392B',
                    strokeWidth: 2
                }
            },

            cross2: {
                geometry: {
                    type: 'compound',
                    parts: [
                        {
                            type: 'rectangle',
                            width: 15,
                            height: 35,
                            offsetX: 0,
                            offsetY: 0
                        },
                        {
                            type: 'rectangle',
                            width: 35,
                            height: 15,
                            offsetX: 0,
                            offsetY: 0
                        }
                    ]
                },
                physics: {
                    density: 0.5,
                    friction: 0.7,
                    restitution: 0.2
                },
                visual: {
                    color: '#3498DB',
                    stroke: '#2980B9',
                    strokeWidth: 2
                }
            },

            l: {
                geometry: {
                    type: 'compound',
                    parts: [
                        {
                            type: 'rectangle',
                            width: 15,
                            height: 35,
                            offsetX: -7.5,
                            offsetY: 0
                        },
                        {
                            type: 'rectangle',
                            width: 15,
                            height: 15,
                            offsetX: 7.5,
                            offsetY: 10
                        }
                    ]
                },
                physics: {
                    density: 0.5,
                    friction: 0.7,
                    restitution: 0.2
                },
                visual: {
                    color: '#8E44AD',
                    stroke: '#732D91',
                    strokeWidth: 2
                }
            },

            'barbell-one': {
                geometry: {
                    type: 'compound',
                    parts: [
                        {
                            type: 'rectangle',
                            width: 31,
                            height: 5,
                            offsetX: -12,
                            offsetY: 0
                        },
                        {
                            type: 'circle',
                            radius: 8,
                            offsetX: 12,
                            offsetY: 0
                        }
                    ]
                },
                physics: {
                    density: 0.5,
                    friction: 0.7,
                    restitution: 0.2
                },
                visual: {
                    color: '#16A085',
                    stroke: '#138D75',
                    strokeWidth: 2
                }
            },

            'barbell-two': {
                geometry: {
                    type: 'compound',
                    parts: [
                        {
                            type: 'rectangle',
                            width: 26,
                            height: 5,
                            offsetX: 0,
                            offsetY: 0
                        },
                        {
                            type: 'circle',
                            radius: 9,
                            offsetX: -17,
                            offsetY: 0
                        },
                        {
                            type: 'circle',
                            radius: 9,
                            offsetX: 17,
                            offsetY: 0
                        }
                    ]
                },
                physics: {
                    density: 0.5,
                    friction: 0.7,
                    restitution: 0.2
                },
                visual: {
                    color: '#D35400',
                    stroke: '#BA4A00',
                    strokeWidth: 2
                }
            },

            'diamond-barbell': {
                geometry: {
                    type: 'compound',
                    parts: [
                        {
                            type: 'rectangle',
                            width: 26,
                            height: 5,
                            offsetX: -10,
                            offsetY: 0
                        },
                        {
                            type: 'diamond',
                            width: 20,
                            height: 20,
                            offsetX: 10,
                            offsetY: 0
                        }
                    ]
                },
                physics: {
                    density: 0.5,
                    friction: 0.7,
                    restitution: 0.2
                },
                visual: {
                    color: '#C0392B',
                    stroke: '#A93226',
                    strokeWidth: 2
                }
            }
        };

        // Simple system test - verify MASTER_SHAPE_REGISTRY is accessible
        debugLog('üîç MASTER_SHAPE_REGISTRY loaded with shapes:', Object.keys(MASTER_SHAPE_REGISTRY));

        // Shape Attribute Propagator - converts master registry to format-specific configs
        class ShapeAttributePropagator {
            // Generate legacy SHAPE_CONFIG format for backward compatibility
            static generateLegacyConfig() {
                const legacyConfig = {};
                
                for (const [shapeType, masterConfig] of Object.entries(MASTER_SHAPE_REGISTRY)) {
                    legacyConfig[shapeType] = {
                        // Merge all properties for backward compatibility
                        ...masterConfig.geometry,
                        ...masterConfig.physics,
                        ...masterConfig.visual,
                        type: masterConfig.geometry.type
                    };

                    // Handle compound shapes
                    if (masterConfig.geometry.type === 'compound' && masterConfig.geometry.parts) {
                        legacyConfig[shapeType].parts = masterConfig.geometry.parts;
                    }
                }
                
                return legacyConfig;
            }

            // Get unified shape attributes for any context
            static getShapeAttributes(shapeType) {
                const master = MASTER_SHAPE_REGISTRY[shapeType];
                if (!master) {
                    console.warn(`‚ö†Ô∏è Shape type '${shapeType}' not found in master registry`);
                    return null;
                }
                return master;
            }

            // Get geometry-specific attributes
            static getGeometry(shapeType) {
                const attributes = this.getShapeAttributes(shapeType);
                return attributes ? attributes.geometry : null;
            }

            // Get physics-specific attributes
            static getPhysics(shapeType) {
                const attributes = this.getShapeAttributes(shapeType);
                return attributes ? attributes.physics : null;
            }

            // Get visual-specific attributes
            static getVisual(shapeType) {
                const attributes = this.getShapeAttributes(shapeType);
                return attributes ? attributes.visual : null;
            }

            // Validate shape registry integrity
            static validateRegistry() {
                const errors = [];
                
                for (const [shapeType, config] of Object.entries(MASTER_SHAPE_REGISTRY)) {
                    if (!config.geometry || !config.physics || !config.visual) {
                        errors.push(`${shapeType}: Missing required sections (geometry/physics/visual)`);
                    }
                    
                    if (!config.geometry.type) {
                        errors.push(`${shapeType}: Missing geometry.type`);
                    }
                    
                    if (config.geometry.type === 'compound' && !config.geometry.parts) {
                        errors.push(`${shapeType}: Compound shape missing parts array`);
                    }
                }
                
                if (errors.length > 0) {
                    console.error('üö® Shape registry validation errors:', errors);
                } else {
                    debugLog('‚úÖ Shape registry validation passed');
                }
                
                return errors.length === 0;
            }
        }

        // Generate backward-compatible SHAPE_CONFIG from master registry
        const SHAPE_CONFIG = ShapeAttributePropagator.generateLegacyConfig();

        // Validate the registry on initialization
        ShapeAttributePropagator.validateRegistry();

        // Utility functions for shape configuration
        function getShapeConfig(shapeType) {
            // Start with MASTER_SHAPE_REGISTRY as base - use visual properties flattened
            const masterConfig = MASTER_SHAPE_REGISTRY[shapeType];
            const baseConfig = masterConfig ? {
                ...masterConfig.geometry,
                ...masterConfig.physics,
                ...masterConfig.visual  // Flatten visual properties to root level for compatibility
            } : {};
            
            // Add legacy SHAPE_CONFIG overrides if they exist
            if (SHAPE_CONFIG[shapeType]) {
                Object.assign(baseConfig, SHAPE_CONFIG[shapeType]);
            }
            
            // Use AssetManager for theme-specific overrides if available
            if (window.assetManager) {
                const currentTheme = window.assetManager.getCurrentTheme();
                
                // Check for theme color overrides in the new structure
                if (currentTheme?.config?.shapes?.colors?.[shapeType]) {
                    const themeColors = currentTheme.config.shapes.colors[shapeType];
                    Object.assign(baseConfig, {
                        color: themeColors.color || baseConfig.color,
                        stroke: themeColors.stroke || baseConfig.stroke,
                        strokeWidth: themeColors.strokeWidth || baseConfig.strokeWidth
                    });
                }
                
                // Legacy theme overrides support
                if (currentTheme?.config?.shapes?.overrides?.[shapeType]) {
                    const themeOverride = currentTheme.config.shapes.overrides[shapeType];
                    Object.assign(baseConfig, {
                        color: themeOverride.color || baseConfig.color,
                        stroke: themeOverride.stroke || baseConfig.stroke
                    });
                }
                
                // Check for texture through AssetManager
                const texture = UnifiedTextureSystem.getShapeTexture(shapeType);
                if (texture) {
                    baseConfig.texture = texture;
                }
            }
            
            return baseConfig;
        }

        function getAllShapeTypes() {
            return Object.keys(MASTER_SHAPE_REGISTRY);
        }

        function validateShapeConfig() {
            // Validation logic can be added here
            return true;
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë ASSET MANAGER - HANDLES TEXTURE LOADING AND THEME ASSETS
          ‚ïë Provides centralized asset management with fallbacks and caching
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        class AssetManager {
            constructor() {
                this.themes = {};
                this.currentTheme = CANVAS_CONFIG.defaultTheme;
                this.loadingProgress = 0;
                this.isLoaded = false;
                this.loadingCallbacks = [];
                this.imageCache = new Map(); // Cache for loaded images
                this.loadingPromises = new Map(); // Track loading promises
                this.backgroundImageCache = new Map(); // New cache for background images
            }

            async loadTheme(themeName) {
                raceConditionDebugger.trackOperation('AssetManager.loadTheme', `theme-${themeName}`);
                
                // Check if theme is already fully loaded
                if (this.themes[themeName]?.loaded && this.currentTheme === themeName) {
                    debugLog(`‚úÖ Theme ${themeName} already loaded and active, skipping`);
                    return;
                }
                
                // Add deduplication check
                const loadingKey = `theme-${themeName}`;
                
                // Check if this theme is already being loaded
                if (this.loadingPromises.has(loadingKey)) {
                    debugLog(`‚ö†Ô∏è Theme ${themeName} already loading, returning existing promise`);
                    return this.loadingPromises.get(loadingKey);
                }
                
                // Track asset loading for race condition monitoring
                raceConditionMonitor.trackAccess('asset-system', 'loadTheme', 'write', {
                    themeName,
                    currentTheme: this.currentTheme
                });
                
                // Create and store the loading promise
                const loadPromise = assetMutex.execute(async () => {
                    if (!CANVAS_CONFIG.enabled || !CANVAS_CONFIG.useThemes) {
                        assetLog('üì¶ Asset Manager: Canvas enhancements disabled');
                        return;
                    }

                    assetLog(`üì¶ Loading theme: ${themeName}`);
                    
                    try {
                        const themeConfig = THEME_DEFINITIONS[themeName];
                        if (!themeConfig) {
                            console.error(`‚ùå Theme not found: ${themeName}`);
                            return;
                        }

                        // Initialize theme structure
                        this.themes[themeName] = {
                            config: themeConfig,
                            assets: {
                                backgroundImage: null,
                                platformImage: null,
                                shapeTextures: {}
                            },
                            loaded: false
                        };

                        // Load all images for this theme
                        await this.loadThemeImages(themeName, themeConfig);
                        
                        // Load background image if specified
                        if (themeConfig.background?.type === 'image' && themeConfig.background.image?.url) {
                            try {
                                const bgImage = await this.loadBackgroundImage(themeConfig.background.image.url);
                                this.themes[themeName].assets.backgroundImage = bgImage;
                                console.log(`‚úÖ Background image loaded for theme: ${themeName}`);
                            } catch (error) {
                                console.warn(`‚ö†Ô∏è Failed to load background image for ${themeName}:`, error);
                                // Mark background as failed but continue with theme loading
                                if (!themeConfig.background) themeConfig.background = {};
                                themeConfig.background.loadFailed = true;
                            }
                        }
                        
                        this.themes[themeName].loaded = true;
                        this.currentTheme = themeName;  // Set this theme as current
                        this.loadingProgress = 100;
                        this.isLoaded = true;
                        
                        // Apply the background to CSS immediately
                        this.applyBackgroundToCSS({ name: themeName, ...themeConfig });
                        
                        assetLog(`‚úÖ Theme loaded: ${themeName}`);
                        debugLog(`üéØ AssetManager current theme set to: ${this.currentTheme}`);
                        this.notifyLoadingComplete(themeName);
                        
                    } catch (error) {
                        console.error(`‚ùå Failed to load theme ${themeName}:`, error);
                        this.loadingProgress = 0;
                    }
                    
                }, `asset-load-theme-${themeName}`);
                
                this.loadingPromises.set(loadingKey, loadPromise);
                
                try {
                    const result = await loadPromise;
                    return result;
                } finally {
                    // Clean up after loading completes
                    this.loadingPromises.delete(loadingKey);
                }
            }

            async loadThemeImages(themeName, themeConfig) {
                const loadPromises = [];
                const theme = this.themes[themeName];

                // Load background image
                if (themeConfig.background.image && themeConfig.background.image.url) {
                    const bgPromise = this.loadImage(themeConfig.background.image.url)
                        .then(img => {
                            theme.assets.backgroundImage = img;
                            debugLog(`üñºÔ∏è Background image loaded for ${themeName}`);
                        })
                        .catch(err => {
                            console.warn(`‚ö†Ô∏è Background image failed for ${themeName}:`, err.message);
                        });
                    loadPromises.push(bgPromise);
                }

                // Load platform image
                if (themeConfig.platform.image && themeConfig.platform.image.url) {
                    const platformPromise = this.loadImage(themeConfig.platform.image.url)
                        .then(img => {
                            theme.assets.platformImage = img;
                            debugLog(`üèóÔ∏è Platform image loaded for ${themeName}`);
                        })
                        .catch(err => {
                            console.warn(`‚ö†Ô∏è Platform image failed for ${themeName}:`, err.message);
                        });
                    loadPromises.push(platformPromise);
                }

                // Load shape textures
                if (themeConfig.shapes.textures) {
                    Object.keys(themeConfig.shapes.textures).forEach(shapeType => {
                        const textureConfig = themeConfig.shapes.textures[shapeType];
                        if (textureConfig.url) {
                            const shapePromise = this.loadImage(textureConfig.url)
                                .then(img => {
                                    theme.assets.shapeTextures[shapeType] = img;
                                    debugLog(`üî∂ Shape texture loaded for ${shapeType} in ${themeName}`);
                                })
                                .catch(err => {
                                    console.warn(`‚ö†Ô∏è Shape texture failed for ${shapeType} in ${themeName}:`, err.message);
                                });
                            loadPromises.push(shapePromise);
                        }
                    });
                } else if (themeConfig.shapes.useTextures && themeConfig.shapes.textureUrl) {
                    // Handle themes that use a single shared texture for all shapes
                    const sharedTextureUrl = themeConfig.shapes.textureUrl;
                    const shapeNames = ['square', 'circle', 'triangle', 'cross', 'cross2', 'l', 'barbell-one', 'barbell-two', 'diamond-barbell'];
                    
                    const sharedPromise = this.loadImage(sharedTextureUrl)
                        .then(img => {
                            // Apply the same texture to all shapes
                            shapeNames.forEach(shapeType => {
                                theme.assets.shapeTextures[shapeType] = img;
                            });
                            debugLog(`üî∂ Shared texture loaded for all shapes in ${themeName} from ${sharedTextureUrl}`);
                        })
                        .catch(err => {
                            console.warn(`‚ö†Ô∏è Shared texture failed for ${themeName}:`, err.message);
                        });
                    loadPromises.push(sharedPromise);
                }

                // Wait for all images to load (or fail)
                await Promise.allSettled(loadPromises);
                
                const successCount = loadPromises.length;
                assetLog(`üì¶ Theme ${themeName}: Attempted to load ${successCount} images`);
            }

            async loadImage(url) {
                // Check cache first
                if (this.imageCache.has(url)) {
                    return this.imageCache.get(url);
                }

                // Check if already loading
                if (this.loadingPromises.has(url)) {
                    return this.loadingPromises.get(url);
                }

                // Create loading promise
                const loadPromise = new Promise((resolve, reject) => {
                    const img = new Image();
                    img.crossOrigin = 'anonymous'; // Enable CORS for external images
                    
                    img.onload = () => {
                        this.imageCache.set(url, img);
                        this.loadingPromises.delete(url);
                        resolve(img);
                    };
                    
                    img.onerror = () => {
                        this.loadingPromises.delete(url);
                        reject(new Error(`Failed to load image: ${url}`));
                    };
                    
                    img.src = url;
                    
                    // Set timeout for image loading
                    setTimeout(() => {
                        if (!img.complete) {
                            this.loadingPromises.delete(url);
                            reject(new Error(`Image load timeout: ${url}`));
                        }
                    }, 10000); // 10 second timeout
                });

                this.loadingPromises.set(url, loadPromise);
                return loadPromise;
            }

            // Get loaded image assets
            getBackgroundImage(themeName = null) {
                const theme = themeName ? this.getTheme(themeName) : this.getCurrentTheme();
                return theme?.assets?.backgroundImage || null;
            }

            getPlatformImage(themeName = null) {
                const theme = themeName ? this.getTheme(themeName) : this.getCurrentTheme();
                return theme?.assets?.platformImage || null;
            }

            getShapeTexture(shapeType, themeName = null) {
                const currentTheme = themeName || this.currentTheme || 'classic';
                const themeData = this.themes[currentTheme];
                
                // Check if theme exists and has assets
                if (!themeData || !themeData.assets) {
                    return null;
                }
                
                // Check for loaded texture assets first (preferred)
                if (themeData.assets.shapeTextures && themeData.assets.shapeTextures.hasOwnProperty(shapeType)) {
                    return themeData.assets.shapeTextures[shapeType];
                }
                
                // Fallback to legacy textures structure if it exists
                if (themeData.textures && themeData.textures.hasOwnProperty(shapeType)) {
                    return themeData.textures[shapeType];
                }
                
                return null;
            }

            // Clear cache (useful for development)
            clearImageCache() {
                this.imageCache.clear();
                this.loadingPromises.clear();
                console.log('üßπ Image cache cleared');
            }
            
            clearThemeImages(themeName) {
                console.log(`üßπ ImageAssetManager: Clearing images for theme: ${themeName}`);
                
                // Get theme configuration
                const themeConfig = THEME_DEFINITIONS[themeName];
                if (!themeConfig) return;
                
                const themeUrls = new Set();
                
                // Add background image URL
                if (themeConfig.background?.image?.url) {
                    themeUrls.add(themeConfig.background.image.url);
                }
                
                // Add platform image URL
                if (themeConfig.platform?.image?.url) {
                    themeUrls.add(themeConfig.platform.image.url);
                }
                
                // Add shape texture URLs
                if (themeConfig.shapes?.textures) {
                    Object.values(themeConfig.shapes.textures).forEach(textureData => {
                        if (textureData?.url) {
                            themeUrls.add(textureData.url);
                        }
                    });
                }
                
                // Remove theme images from cache
                let removedCount = 0;
                for (const url of themeUrls) {
                    if (this.imageCache.has(url)) {
                        this.imageCache.delete(url);
                        removedCount++;
                    }
                    if (this.loadingPromises.has(url)) {
                        this.loadingPromises.delete(url);
                    }
                }
                
                // Clear the theme data as well
                if (this.themes[themeName]) {
                    delete this.themes[themeName];
                }
                
                console.log(`üßπ ImageAssetManager: Removed ${removedCount} images for theme: ${themeName}`);
            }

            getTheme(themeName) {
                return this.themes[themeName] || null;
            }

            getCurrentTheme() {
                // Only log when theme actually changes to avoid spam
                if (!this._lastLoggedCurrentTheme || this._lastLoggedCurrentTheme !== this.currentTheme) {
                    debugLog(`üîç AssetManager.getCurrentTheme() - this.currentTheme: '${this.currentTheme}'`);
                    const theme = this.getTheme(this.currentTheme);
                    debugLog(`üîç AssetManager.getCurrentTheme() - found theme:`, theme?.config?.name || 'null');
                    debugLog(`üîç Available themes:`, Object.keys(this.themes));
                    this._lastLoggedCurrentTheme = this.currentTheme;
                    return theme;
                }
                return this.getTheme(this.currentTheme);
            }

            getBackgroundStyle(themeName = null) {
                const theme = themeName ? this.getTheme(themeName) : this.getCurrentTheme();
                if (!theme) return null;
                
                const bgConfig = theme.config.background;
                const bgImage = this.getBackgroundImage(themeName);
                
                return {
                    type: bgConfig.type,
                    colors: bgConfig.colors,
                    image: bgImage,
                    imageConfig: bgConfig.image || null
                };
            }

            getPlatformStyle(themeName = null) {
                const theme = themeName ? this.getTheme(themeName) : this.getCurrentTheme();
                if (!theme) return null;
                
                const platformConfig = theme.config.platform;
                const platformImage = this.getPlatformImage(themeName);
                
                return {
                    ...platformConfig,
                    image: platformImage,
                    imageConfig: platformConfig.image || null
                };
            }

            getShapeStyle(shapeType, themeName = null) {
                const theme = themeName ? this.getTheme(themeName) : this.getCurrentTheme();
                if (!theme) return null;
                
                const shapeConfig = theme.config.shapes;
                const shapeTexture = this.getShapeTexture(shapeType, themeName);
                
                if (shapeConfig.textures && shapeConfig.textures[shapeType]) {
                    return {
                        useTextures: shapeConfig.useTextures,
                        texture: shapeTexture,
                        textureConfig: shapeConfig.textures[shapeType]
                    };
                }
                
                return {
                    useTextures: false,
                    texture: null,
                    textureConfig: null
                };
            }

            getParticleStyle(themeName = null) {
                const theme = themeName ? this.getTheme(themeName) : this.getCurrentTheme();
                if (!theme) return null;
                
                return theme.config.particles;
            }

            notifyLoadingComplete(themeName) {
                this.loadingCallbacks.forEach(callback => {
                    try {
                        callback(themeName);
                    } catch (error) {
                        console.error('‚ùå Error in loading callback:', error);
                    }
                });
            }

            onThemeLoaded(callback) {
                this.loadingCallbacks.push(callback);
            }

            getTextureUrl(shapeType) {
                const theme = this.getCurrentTheme();
                if (!theme) return null;
                
                const themeConfig = theme.config;
                if (themeConfig && themeConfig.shapes && themeConfig.shapes.textures) {
                    const textureConfig = themeConfig.shapes.textures[shapeType];
                    if (textureConfig && textureConfig.url) {
                        return textureConfig.url;
                    }
                }
                return null;
            }

            // Texture cache getter for compatibility
            get textureCache() {
                return this.imageCache;
            }

            // Method to apply texture themes (compatibility)
            async applyTextureTheme(themeName) {
                debugLog(`üé® Applying texture theme: ${themeName}`);
                // Check if theme is already loaded before loading
                if (!this.themes[themeName]?.loaded) {
                    await this.loadTheme(themeName);
                }
                return true;
            }

            // Property for loaded textures compatibility
            get loadedTextures() {
                return this.imageCache;
            }

            /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
              ‚ïë BACKGROUND IMAGE MANAGEMENT METHODS
              ‚ïë Handles CSS background image loading and application
              ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
            
            async loadBackgroundImage(url) {
                if (this.backgroundImageCache.has(url)) {
                    return this.backgroundImageCache.get(url);
                }

                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.onload = () => {
                        this.backgroundImageCache.set(url, img);
                        console.log(`üñºÔ∏è Background image loaded: ${url}`);
                        resolve(img);
                    };
                    img.onerror = () => {
                        console.error(`‚ùå Failed to load background image: ${url}`);
                        reject(new Error(`Failed to load background image: ${url}`));
                    };
                    img.src = url;
                });
            }

            applyBackgroundToCSS(theme) {
                const viewport = document.querySelector('.game-viewport');
                if (!viewport) return;

                const backgroundConfig = theme.background;
                
                // Clear previous pattern classes
                viewport.classList.remove('stone-pattern', 'metal-pattern', 'theme-background');
                
                if (backgroundConfig?.type === 'image' && backgroundConfig.image?.url) {
                    // Apply image background
                    const imageConfig = backgroundConfig.image;
                    
                    // Set CSS custom properties
                    viewport.style.setProperty('--background-image', `url(${imageConfig.url})`);
                    viewport.style.setProperty('--background-opacity', backgroundConfig.opacity || 0.5);
                    
                    // Add theme background class
                    viewport.classList.add('theme-background');
                    
                    console.log(`üé® Applied background image for theme: ${theme.name}`);
                } else if (backgroundConfig?.type === 'pattern' && backgroundConfig.pattern?.type) {
                    // Apply pattern background using CSS classes
                    const patternType = backgroundConfig.pattern.type;
                    
                    console.log(`üîç Pattern debug - Type: ${patternType}, Theme: ${theme.name}`);
                    console.log(`üîç Pattern config:`, backgroundConfig.pattern);
                    
                    if (patternType === 'granite') {
                        viewport.classList.add('stone-pattern');
                        console.log(`üé® Applied granite pattern for theme: ${theme.name} - Class added: stone-pattern`);
                        console.log(`üîç Viewport classes:`, viewport.className);
                    } else if (patternType === 'brushed-metal') {
                        viewport.classList.add('metal-pattern');
                        console.log(`üé® Applied brushed metal pattern for theme: ${theme.name}`);
                    } else {
                        // Fallback to custom pattern style
                        viewport.style.setProperty('--background-image', backgroundConfig.pattern.style);
                        viewport.classList.add('theme-background');
                        console.log(`üé® Applied custom ${patternType} pattern for theme: ${theme.name}`);
                    }
                    
                    // Set opacity
                    viewport.style.setProperty('--background-opacity', backgroundConfig.opacity || 0.6);
                    console.log(`üîç Background opacity set to:`, backgroundConfig.opacity || 0.6);
                } else if (backgroundConfig?.type === 'gradient') {
                    // Apply gradient background
                    const gradientConfig = backgroundConfig.gradient;
                    if (gradientConfig) {
                        const gradientCSS = `linear-gradient(${gradientConfig.direction}, ${gradientConfig.colors.join(', ')})`;
                        
                        viewport.style.setProperty('--background-image', gradientCSS);
                        viewport.style.setProperty('--background-opacity', backgroundConfig.opacity || 1.0);
                        viewport.classList.add('theme-background');
                        
                        console.log(`üé® Applied gradient background for theme: ${theme.name}`);
                    }
                } else {
                    // Fallback or clear background
                    this.clearBackgroundCSS();
                    
                    // Apply fallback color if specified
                    if (backgroundConfig?.fallbackColor) {
                        viewport.style.backgroundColor = backgroundConfig.fallbackColor;
                    }
                }
            }

            clearBackgroundCSS() {
                const viewport = document.querySelector('.game-viewport');
                if (!viewport) return;

                viewport.style.removeProperty('--background-image');
                viewport.style.removeProperty('--background-opacity');
                viewport.classList.remove('theme-background', 'stone-pattern', 'metal-pattern');
                viewport.style.removeProperty('background-color');
                
                console.log('üßπ Cleared CSS background');
            }
        }

        /*
         * RendererManager - Canvas2D-Only Rendering System
         * 
         * Simplified from dual-renderer architecture to Canvas2D-only implementation.
         * Provides high-performance 2D rendering with full feature support including
         * textures, themes, animations, and responsive design.
         * 
         * Key Features:
         * ‚Ä¢ Canvas2D rendering optimization
         * ‚Ä¢ Texture and theme system integration
         * ‚Ä¢ Performance monitoring and metrics
         * ‚Ä¢ Mobile and responsive design support
         */
        class RendererManager {
            constructor(canvas) {
                this.canvas = canvas;
                this.currentRenderer = 'canvas'; // Start with canvas
                this.canvasContext = canvas.getContext('2d');
                
                // Performance tracking
                this.performanceMetrics = {
                    fps: UNIFIED_GAME_CONFIG.performance.targetFPS,
                    drawCalls: 0,
                    lastFrameTime: performance.now()
                };
                
            }

            async initialize() {
                // Always initialize Canvas (it's our fallback)
                this.initializeCanvas();
                
                return true;
            }

            initializeCanvas() {
                if (!this.canvasContext) {
                    this.canvasContext = this.canvas.getContext('2d');
                }
            }


            updatePerformanceMetrics() {
                const now = performance.now();
                const deltaTime = now - this.performanceMetrics.lastFrameTime;
                this.performanceMetrics.fps = 1000 / deltaTime;
                this.performanceMetrics.lastFrameTime = now;
            }

            destroy() {
                // No cleanup needed for Canvas
            }
        }

        // Theme Manager - Canvas-only theme system
        class ThemeManager {
            constructor(assetManager, gameManager) {
                this.assetManager = assetManager;
                this.gameManager = gameManager;
                
                // Support both unified and legacy configuration
                this.currentTheme = this.getDefaultTheme();
                this.isTransitioning = false;
                this.transitionCallbacks = [];
                
                // Track configuration source
                this.useUnifiedConfig = typeof UNIFIED_GAME_CONFIG !== 'undefined';

                // Read base theme id and overrides from level data for future use
                this.baseThemeId = this.gameManager?.levelData?.theme?.baseThemeId || null;
                this.themeOverrides = this.gameManager?.levelData?.theme?.overrides || null;
                

            }
            
            // Smart default theme resolution
            getDefaultTheme() {
                if (typeof UNIFIED_GAME_CONFIG !== 'undefined' && UNIFIED_GAME_CONFIG.theme) {
                    return UNIFIED_GAME_CONFIG.theme.defaultTheme;
                }
                return CANVAS_CONFIG.defaultTheme;
            }
            
            // Smart theme enabled check
            isThemeSystemEnabled() {
                if (this.useUnifiedConfig && UNIFIED_GAME_CONFIG.theme) {
                    return UNIFIED_GAME_CONFIG.theme.enabled;
                }
                return CANVAS_CONFIG.enabled && CANVAS_CONFIG.useThemes;
            }

            async switchTheme(themeName, animated = true) {
                if (!this.isThemeSystemEnabled()) {
                    return;
                }

                if (this.isTransitioning || !THEME_DEFINITIONS[themeName]) {
                    return;
                }

                this.isTransitioning = true;

                if (this.gameManager) {
                    this.gameManager.dockAnimationPlayed = false;
                }

                try {
                    // --- NEW OVERRIDE LOGIC ---
                    // 1. Create a deep copy of the base theme to avoid modifying the original constant.
                    let finalThemeConfig = JSON.parse(JSON.stringify(THEME_DEFINITIONS[themeName]));

                    // 2. Check for level-specific overrides and merge them.
                    if (this.gameManager && this.gameManager.themeOverrides) {
                        finalThemeConfig = deepMerge(finalThemeConfig, this.gameManager.themeOverrides);
                    }
                    // --- END NEW LOGIC ---

                    // The asset manager now uses the final, potentially merged, theme configuration.
                    this.assetManager.themes[themeName] = {
                        config: finalThemeConfig,
                        assets: { backgroundImage: null, platformImage: null, shapeTextures: {} },
                        loaded: false
                    };

                    await this.assetManager.loadThemeImages(themeName, finalThemeConfig);
                    this.assetManager.themes[themeName].loaded = true;

                    this.updateBackgroundStyle(themeName);
                    this.updatePlatformStyle(themeName);
                    
                    if (typeof this.gameManager.rebuildDockFromData === 'function') {
                        // This rebuild is premature. The final rebuild should happen after textures are loaded.
                        // console.log('üé® Refreshing dock with new theme colors...');
                        // this.gameManager.rebuildDockFromData();
                    }

                    this.currentTheme = themeName;
                    this.assetManager.currentTheme = themeName;
                    console.log(`üîÑ ThemeManager: Set currentTheme to '${themeName}' on both ThemeManager and AssetManager`);

                    this.notifyThemeChanged(themeName);

                } catch (error) {
                    console.error(`Failed to switch theme to ${themeName}:`, error);
                } finally {
                    this.isTransitioning = false;
                }
            }

            updateBackgroundStyle(themeName) {
                const bgStyle = this.assetManager.getBackgroundStyle(themeName);
                if (!bgStyle || !this.gameManager?.physicsManager) return;

                if (bgStyle.type === 'gradient') {
                    this.gameManager.physicsManager.backgroundGradient = bgStyle.colors;
                }
            }

            updatePlatformStyle(themeName) {
                const platformStyle = this.assetManager.getPlatformStyle(themeName);
                if (!platformStyle || !this.gameManager?.physicsManager) return;

                this.gameManager.physicsManager.platformColor = platformStyle.color;
            }

            getAvailableThemes() {
                return Object.keys(THEME_DEFINITIONS);
            }

            getCurrentTheme() {
                return this.currentTheme;
            }

            onThemeChanged(callback) {
                this.transitionCallbacks.push(callback);
            }

            notifyThemeChanged(themeName) {
                this.transitionCallbacks.forEach(callback => {
                    try {
                        callback(themeName);
                    } catch (error) {
                        console.error('‚ùå Error in theme change callback:', error);
                    }
                });
            }
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë PARTICLE SYSTEM - THEME-BASED VISUAL EFFECTS
          ‚ïë Creates and manages particle effects based on current theme
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        class ParticleSystem {
            constructor(canvas, assetManager) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.assetManager = assetManager;
                this.particles = [];
                this.maxParticles = CANVAS_CONFIG.maxParticles;
                this.ambientParticleTimer = 0;
                this.ambientParticleInterval = 1000; // Spawn ambient particle every 1 second
            }

            createThemeParticles(type, x, y, count = 5) {
                if (!CANVAS_CONFIG.enabled || !CANVAS_CONFIG.useParticles) return;

                const particleStyle = this.assetManager.getParticleStyle();
                if (!particleStyle) return;

                for (let i = 0; i < Math.min(count, this.maxParticles - this.particles.length); i++) {
                    this.particles.push(this.createParticle(particleStyle, x, y, type));
                }
            }

            createParticle(style, x, y, type) {
                // New particle effect for weighted shape explosions
                if (type === 'explosion') {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * 6 + 2; // Explosion speed from 2 to 8
                    return {
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: Math.random() * 0.5 + 0.5, // Lifetime 0.5s to 1.0s
                        decay: 0.015 + Math.random() * 0.01, // Slower decay for a bigger effect
                        size: 3 + Math.random() * 4, // Larger particles
                        color: ['#ff471a', '#ff7a33', '#ffc300', '#ffffff'][Math.floor(Math.random() * 4)],
                        style: 'explosion'
                    };
                }

                if (style.style === 'flame') {
                    return {
                        x: x,
                        y: y,
                        vx: (Math.random() - 0.5) * 1.5, // Less horizontal spread
                        vy: -Math.random() * 2 - 1,   // Move upwards
                        life: Math.random() * 0.4 + 0.2, // Very short life (0.2s to 0.6s)
                        decay: 0.05, // Faster decay
                        size: 2 + Math.random() * 4,
                        color: ['#FF4500', '#FFA500', '#FFD700'][Math.floor(Math.random() * 3)],
                        style: 'flame'
                    };
                }

                const colors = style.colors;
                const color = colors[Math.floor(Math.random() * colors.length)];

                return {
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4 - 2,
                    life: 1.0,
                    decay: 0.02 + Math.random() * 0.02,
                    size: 2 + Math.random() * 3,
                    color: color,
                    style: style.style
                };
            }

            createAmbientParticle() {
                if (!CANVAS_CONFIG.enabled || !CANVAS_CONFIG.useParticles) return;
                if (this.particles.length >= this.maxParticles) return;

                const particleStyle = this.assetManager.getParticleStyle();
                if (!particleStyle) return;

                // Create particles from random positions around the canvas edges
                const side = Math.floor(Math.random() * 4); // 0=top, 1=right, 2=bottom, 3=left
                let x, y, vx, vy;

                switch(side) {
                    case 0: // Top
                        x = Math.random() * this.canvas.width;
                        y = -10;
                        vx = (Math.random() - 0.5) * 2;
                        vy = Math.random() * 2 + 1;
                        break;
                    case 1: // Right  
                        x = this.canvas.width + 10;
                        y = Math.random() * this.canvas.height;
                        vx = -Math.random() * 2 - 1;
                        vy = (Math.random() - 0.5) * 2;
                        break;
                    case 2: // Bottom
                        x = Math.random() * this.canvas.width;
                        y = this.canvas.height + 10;
                        vx = (Math.random() - 0.5) * 2;
                        vy = -Math.random() * 2 - 1;
                        break;
                    case 3: // Left
                        x = -10;
                        y = Math.random() * this.canvas.height;
                        vx = Math.random() * 2 + 1;
                        vy = (Math.random() - 0.5) * 2;
                        break;
                }

                const colors = particleStyle.colors;
                const color = colors[Math.floor(Math.random() * colors.length)];
                
                this.particles.push({
                    x: x,
                    y: y,
                    vx: vx,
                    vy: vy,
                    life: 1.0,
                    decay: 0.01 + Math.random() * 0.01, // Slower decay for ambient particles
                    size: 1 + Math.random() * 2, // Smaller ambient particles
                    color: color,
                    style: particleStyle.style,
                    isAmbient: true
                });
            }

            update(deltaTime) {
                if (!CANVAS_CONFIG.useParticles) return;

                // Spawn ambient background particles periodically
                this.ambientParticleTimer += deltaTime;
                if (this.ambientParticleTimer >= this.ambientParticleInterval) {
                    this.createAmbientParticle();
                    this.ambientParticleTimer = 0;
                }

                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const particle = this.particles[i];
                    
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.vy += 0.1; // Gravity
                    particle.life -= particle.decay;
                    
                    if (particle.life <= 0) {
                        this.particles.splice(i, 1);
                    }
                }
            }

            render() {
                if (!CANVAS_CONFIG.useParticles) return;

                this.particles.forEach(particle => {
                    this.ctx.save();
                    this.ctx.globalAlpha = particle.life;
                    this.ctx.fillStyle = particle.color;
                    
                    if (particle.style === 'bubbles') {
                        this.ctx.strokeStyle = particle.color;
                        this.ctx.lineWidth = 1;
                        this.ctx.beginPath();
                        this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        this.ctx.stroke();
                    } else {
                        this.ctx.beginPath();
                        this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                    
                    this.ctx.restore();
                });
            }
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë PHYSICS-BASED SHAPE RENDERER
          ‚ïë Renders shapes consistently using physics configuration
          ‚ïë Used for both dock previews and physics simulation
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        class PhysicsShapeRenderer {
            constructor() {
                // Initialize caches for performance optimization
                this.pathCache = new Map(); // Cache Path2D objects by shape type
                this.matrixPool = []; // Pool of transformation matrices
                this.canvasPool = []; // Pool of canvas elements for dock previews
                this.lastCacheCleanup = 0;
            }
            
            // Get or create cached Path2D for a shape
            getCachedPath(shapeType) {
                if (!this.pathCache.has(shapeType)) {
                    const config = getShapeConfig(shapeType);
                    if (config) {
                        const path = new Path2D();
                        this.createShapePath(path, config);
                        this.pathCache.set(shapeType, path);
                    }
                }
                return this.pathCache.get(shapeType);
            }
            
            // Get transformation matrix from pool or create new one
            getMatrixFromPool() {
                return this.matrixPool.pop() || new DOMMatrix();
            }
            
            // Return matrix to pool for reuse
            returnMatrixToPool(matrix) {
                matrix.setMatrixValue('matrix(1, 0, 0, 1, 0, 0)'); // Reset to identity
                if (this.matrixPool.length < 20) { // Limit pool size
                    this.matrixPool.push(matrix);
                }
            }
            
            // Get canvas from pool or create new one
            getCanvasFromPool(width, height) {
                const canvas = this.canvasPool.pop() || document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                return canvas;
            }
            
            // Return canvas to pool for reuse
            returnCanvasToPool(canvas) {
                if (this.canvasPool.length < 10) { // Limit pool size
                    // Clear the canvas
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    this.canvasPool.push(canvas);
                }
            }
            
            // Ensure AssetManager and theme are ready for rendering
            async ensureReady() {
                // Wait for AssetManager to be available
                if (!window.assetManager) {
                    console.log('‚è≥ PhysicsShapeRenderer waiting for AssetManager...');
                    await new Promise(resolve => {
                        const checkAssetManager = () => {
                            if (window.assetManager) {
                                resolve();
                            } else {
                                setTimeout(checkAssetManager, 50);
                            }
                        };
                        checkAssetManager();
                    });
                }
                
                // Ensure a theme is loaded
                let currentTheme = window.assetManager.getCurrentTheme();
                if (!currentTheme || !currentTheme.name) {
                    const themeSelector = document.getElementById('themeSelector');
                    const themeName = themeSelector?.value || CANVAS_CONFIG.defaultTheme;
                    
                    // Check if theme is already loaded to prevent duplicates
                    if (!window.assetManager.themes[themeName]?.loaded) {
                        console.log(`‚è≥ PhysicsShapeRenderer loading theme: ${themeName}`);
                        await window.assetManager.loadTheme(themeName);
                    }
                }
                
                return true;
            }
            
            // Clean caches periodically
            cleanCaches() {
                const now = performance.now();
                if (now - this.lastCacheCleanup > 10000) { // Every 10 seconds
                    // Clear path cache if it gets too large
                    if (this.pathCache.size > 50) {
                        this.pathCache.clear();
                    }
                    this.lastCacheCleanup = now;
                    debugLog('üßπ PhysicsShapeRenderer caches cleaned');
                }
            }
            
            renderShapeOnCanvas(ctx, shapeType, x, y, rotation = 0, scale = 1, forcedTexture = null, unifiedConfig = null) {
                // Use unified config if provided, otherwise fallback to legacy system
                const config = unifiedConfig || getShapeConfig(shapeType);
                if (!config) {
                    console.error(`‚ùå No config found for renderShapeOnCanvas: ${shapeType}`);
                    return;
                }

                // Clean caches periodically
                this.cleanCaches();

                // --- NEW: Get renderStyle from the current theme ---
                let renderStyle = { type: 'FLAT' }; // Default fallback
                if (window.gameManager && window.gameManager.themeManager) {
                    const currentThemeName = window.gameManager.themeManager.getCurrentTheme();
                    const currentTheme = window.gameManager.themeManager.assetManager.getTheme(currentThemeName);
                    if (currentTheme?.config?.shapes?.renderStyle) {
                        renderStyle = currentTheme.config.shapes.renderStyle;
                    }
                }
                // --- END NEW ---

                // Check for renderStyle overrides specified directly in level data theme overrides
                if (window.gameManager && window.gameManager.levelData && window.gameManager.levelData.theme && window.gameManager.levelData.theme.overrides && window.gameManager.levelData.theme.overrides.shapes && window.gameManager.levelData.theme.overrides.shapes.renderStyle) {
                    renderStyle = window.gameManager.levelData.theme.overrides.shapes.renderStyle;
                }

                // --- UNIFIED: Retrieve texture image and config if not provided ---
                let textureConfig = null;
                if (!forcedTexture) {
                    const textureImage = UnifiedTextureSystem.getShapeTexture(shapeType);
                    if (textureImage) {
                        forcedTexture = textureImage;
                        textureConfig = UnifiedTextureSystem.getTextureConfig(shapeType);
                    }
                }
                // --- END UNIFIED ---

                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.scale(scale, scale);

                // Use cached Path2D object instead of creating new one
                const path = this.getCachedPath(shapeType);
                if (!path) {
                    console.error(`‚ùå Failed to create path for shape: ${shapeType}`);
                    ctx.restore();
                    return;
                }

                // The unified rendering method with texture configuration
                this.renderPathWithStyle(ctx, path, config, renderStyle, forcedTexture, textureConfig);

                ctx.restore();
            }

            createDockPreview(shapeType, size = UNIFIED_GAME_CONFIG.shapes.dockPreviewSize) {
                // Commented out verbose dock preview logging
                // console.log(`üé® createDockPreview called for: ${shapeType}, size: ${size}`);
                const config = getShapeConfig(shapeType);
                if (!config) {
                    console.error(`‚ùå No config found for shape: ${shapeType}`);
                    return null;
                }
                
                debugLog(`üîç Shape config for ${shapeType}:`, config);
                
                // Use unified texture checking
                const hasTexture = UnifiedTextureSystem.isTextureAvailable(shapeType);
                
                debugLog(`üîç Texture availability for ${shapeType}:`, {
                    hasTexture,
                    textureManagerReady: !!window.textureManager,
                    assetManagerReady: !!window.assetManager
                });
                
                // Always use Canvas preview
                if (hasTexture) {
                    debugLog(`üé® Creating Canvas preview for ${shapeType} with texture`);
                } else {
                    debugLog(`üé® Creating Canvas preview for ${shapeType} (no texture available)`);
                }
                return this.createCanvasDockPreview(shapeType, config, size);
            }

            createCanvasDockPreview(shapeType, config, size = 90) {
                // Use SHAPE_CONFIG for theme-aware colors instead of master registry
                const legacyConfig = SHAPE_CONFIG[shapeType];
                const unifiedConfig = MASTER_SHAPE_REGISTRY[shapeType];
                
                if (!unifiedConfig || !legacyConfig) {
                    console.error(`‚ùå Shape ${shapeType} not found in registries for dock preview`);
                    // Return a fallback canvas so dock doesn't break
                    const canvas = this.getCanvasFromPool(size, size);
                    canvas.className = `shape-preview`;
                    canvas.dataset.shape = shapeType;
                    return canvas;
                }
                
                // Merge unified config with theme-aware colors from SHAPE_CONFIG
                const mergedConfig = {
                    ...unifiedConfig,
                    visual: {
                        ...unifiedConfig.visual,
                        color: legacyConfig.color || unifiedConfig.visual.color,
                        stroke: legacyConfig.stroke || unifiedConfig.visual.stroke,
                        strokeWidth: legacyConfig.strokeWidth || unifiedConfig.visual.strokeWidth
                    }
                };
                
                debugLog(`üé® Merged config for ${shapeType}:`, {
                    originalColor: unifiedConfig.visual.color,
                    themeColor: legacyConfig.color,
                    finalColor: mergedConfig.visual.color
                });
                
                // Use canvas pool for better performance
                const canvas = this.getCanvasFromPool(size, size);
                canvas.className = `shape-preview`;
                canvas.dataset.shape = shapeType;

                const ctx = canvas.getContext('2d');
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';

                // Use unified texture checking
                const hasTexture = UnifiedTextureSystem.isTextureAvailable(shapeType);
                
                if (hasTexture) {
                    debugLog(`üé® Canvas preview for ${shapeType} - texture available`);
                    // Add a subtle texture indicator border
                    // RdW TODO: leave the following statements commented out in the new version
                    // canvas.style.border = '2px solid #DAA520';
                    // canvas.style.boxShadow = '0 0 8px rgba(218, 165, 32, 0.5)';
                    canvas.title = `${shapeType} - Textured`;
                } else {
                    debugLog(`üé® Canvas preview for ${shapeType} - using themed colors only`);
                    canvas.style.border = '1px solid #ccc';
                    canvas.title = `${shapeType} - Themed colors`;
                }

                // Use 2x scale for full-size display, matching 2x physics scale (30‚Üí60)
                const scale = UNIFIED_GAME_CONFIG.performance.scaleMultiplier;
                debugLog(`üìê Shape ${shapeType}: using enlarged scale=${scale} for full-size display`);
                
                // Check barbell orientation setting for dock preview rotation
                let rotation = 0;
                if (shapeType && shapeType.includes('barbell')) {
                    const barbellOrientationSelect = document.getElementById('barbellOrientation');
                    if (barbellOrientationSelect && barbellOrientationSelect.value === 'vertical') {
                        rotation = Math.PI / 2; // 90 degrees for vertical orientation
                        debugLog(`üîÑ Applying vertical rotation (90¬∞) to ${shapeType}`);
                    }
                }
                
                // Get texture for rendering if available
                const textureImage = UnifiedTextureSystem.getShapeTexture(shapeType);
                
                // Render the shape in the center of the preview canvas with theme-aware colors
                this.renderShapeOnCanvas(ctx, shapeType, size / 2, size / 2, rotation, scale, textureImage, mergedConfig);
                
                debugLog(`‚úÖ Canvas preview created for: ${shapeType} with scale ${scale}, rotation ${(rotation * 180 / Math.PI).toFixed(0)}¬∞, textured: ${!!textureImage}`);
                return canvas;
            }

            /* --- Begin new bevel-capable rendering engine --- */
            createShapePath(path, config) {
                switch (config.type) {
                    case 'rectangle':
                        path.rect(-config.width / 2, -config.height / 2, config.width, config.height);
                        break;
                    case 'circle':
                        path.arc(0, 0, config.radius, 0, Math.PI * 2);
                        break;
                    case 'polygon':
                        if (config.vertices) {
                            path.moveTo(config.vertices[0].x, config.vertices[0].y);
                            for (let i = 1; i < config.vertices.length; i++) {
                                path.lineTo(config.vertices[i].x, config.vertices[i].y);
                            }
                            path.closePath();
                        }
                        break;
                    case 'diamond':
                        // Render a diamond using width and height (rotated square)
                        {
                            const halfW = (config.width ?? config.height ?? 0) / 2;
                            const halfH = (config.height ?? config.width ?? 0) / 2;
                            path.moveTo(0, -halfH);
                            path.lineTo(halfW, 0);
                            path.lineTo(0, halfH);
                            path.lineTo(-halfW, 0);
                            path.closePath();
                        }
                        break;
                    case 'compound':
                        if (config.parts) {
                            config.parts.forEach(part => {
                                // Create a Path2D for the sub-part
                                const partPath = new Path2D();
                                const partConfigWithOffset = { ...config, ...part };
                                this.createShapePath(partPath, partConfigWithOffset);
                                
                                // Add the sub-path to the main path, applying its offset
                                path.addPath(partPath, new DOMMatrix().translate(part.offsetX || 0, part.offsetY || 0));
                            });
                        }
                        break;
                }
            }

            renderPathWithStyle(ctx, path, shapeConfig, renderStyle, forcedTexture = null, textureConfig = null) {
                // If a forced texture is provided, render with texture
                if (forcedTexture) {
                    this.renderWithTexture(ctx, path, shapeConfig, forcedTexture, textureConfig);
                } else {
                    switch (renderStyle.type) {
                        case 'BEVEL_STANDARD':
                        case 'BEVEL_ROUNDED':
                            this.renderBevel(ctx, path, shapeConfig, renderStyle);
                            break;
                        case 'FLAT':
                        default:
                            this.renderFlat(ctx, path, shapeConfig);
                            break;
                    }
                }
            }

            renderWithTexture(ctx, path, config, textureImage, textureConfig = null) {
                if (!textureImage) {
                    this.renderFlat(ctx, path, config);
                    return;
                }

                // Save the context state before applying texture
                ctx.save();
                
                // Apply texture configuration if provided
                if (textureConfig) {
                    if (textureConfig.opacity && textureConfig.opacity < 1) {
                        ctx.globalAlpha = textureConfig.opacity;
                    }
                    if (textureConfig.blend && textureConfig.blend !== 'source-over') {
                        ctx.globalCompositeOperation = textureConfig.blend;
                    }
                }
                
                // Create and apply the texture pattern
                const repeatPattern = textureConfig?.repeat || 'repeat';
                const pattern = ctx.createPattern(textureImage, repeatPattern);
                if (pattern) {
                    ctx.fillStyle = pattern;
                    // Fill the path with the texture pattern
                    ctx.fill(path);
                }
                
                ctx.restore();
                
                // Add stroke if configured - handle both old and new structure
                const strokeWidth = config.visual?.strokeWidth || config.strokeWidth || 0;
                const stroke = config.visual?.stroke || config.stroke || '#666666';
                if (strokeWidth > 0) {
                    ctx.strokeStyle = stroke;
                    ctx.lineWidth = strokeWidth;
                    ctx.stroke(path);
                }
            }

            renderFlat(ctx, path, config) {
                // Handle both old flat structure and new nested structure
                const color = config.visual?.color || config.color || '#808080';
                const stroke = config.visual?.stroke || config.stroke || '#666666';
                const strokeWidth = config.visual?.strokeWidth || config.strokeWidth || 0;
                
                ctx.fillStyle = color;
                ctx.fill(path);
                if (strokeWidth > 0) {
                    ctx.strokeStyle = stroke;
                    ctx.lineWidth = strokeWidth;
                    ctx.stroke(path);
                }
            }

            renderBevel(ctx, path, config, style) {
                // Read parameters with sensible defaults
                const depth = style.depth || 4;
                const lightAngleRad = (style.lightAngle || 135) * (Math.PI / 180); // Convert angle to radians
                const highlightOpacity = style.highlightOpacity || 0.8;
                const shadowOpacity = style.shadowOpacity || 0.6;
                const softness = style.softness || 0;

                // Calculate offsets for highlight and shadow based on light angle
                const offsetX = Math.cos(lightAngleRad) * depth / 2;
                const offsetY = Math.sin(lightAngleRad) * depth / 2;

                // 1. Render Shadow Layer
                ctx.save();
                ctx.translate(-offsetX, -offsetY); // Offset opposite to the light source
                ctx.fillStyle = 'black';
                ctx.globalAlpha = shadowOpacity;
                if (softness > 0) {
                    ctx.filter = `blur(${softness}px)`;
                }
                ctx.fill(path);
                ctx.restore();

                // 2. Render Highlight Layer
                ctx.save();
                ctx.translate(offsetX, offsetY); // Offset towards the light source
                ctx.fillStyle = 'white';
                ctx.globalAlpha = highlightOpacity;
                if (softness > 0) {
                    ctx.filter = `blur(${softness}px)`;
                }
                ctx.fill(path);
                ctx.restore();

                // 3. Render Main Body Color - handle both old and new structure
                const color = config.visual?.color || config.color || '#808080';
                const stroke = config.visual?.stroke || config.stroke || '#666666';
                const strokeWidth = config.visual?.strokeWidth || config.strokeWidth || 0;
                
                ctx.fillStyle = color;
                ctx.fill(path);
                
                // 4. Render Stroke on top for crisp edges
                if (strokeWidth > 0) {
                    ctx.strokeStyle = stroke;
                    ctx.lineWidth = strokeWidth;
                    ctx.stroke(path);
                }
            }
            /* --- End new bevel-capable rendering engine --- */
        }

        // Global shape renderer instance
        const shapeRenderer = new PhysicsShapeRenderer();

        const WEIGHTED_DEFAULTS = {
            maxWeight: 3,
            overloadDelayMs: 1000,
            indicatorColors: {
                safe: '#2ecc71',
                warning: '#f1c40f',
                danger: '#e74c3c'
            }
        };

        class DockingSpecialEffectsManager {
            constructor() {
                this.entries = [];
                this.animationFrameId = null;
                this.lastTimestamp = 0;
                this.renderFrame = this.renderFrame.bind(this);
            }

            reset() {
                this.entries.forEach(entry => {
                    if (entry.overlay && entry.overlay.parentElement) {
                        entry.overlay.parentElement.removeChild(entry.overlay);
                    }
                    if (entry.sourceElement && entry.sourceElement.dataset) {
                        delete entry.sourceElement.dataset.specialEffectId;
                    }
                });
                this.entries = [];
                if (this.animationFrameId !== null) {
                    cancelAnimationFrame(this.animationFrameId);
                    this.animationFrameId = null;
                }
                this.lastTimestamp = 0;
            }

            sanitizeSpecialConfig(specialConfig) {
                const sanitized = { ...specialConfig };

                if (sanitized.type === 'WEIGHTED') {
                    sanitized.maxWeight = (typeof sanitized.maxWeight === 'number' && sanitized.maxWeight > 0)
                        ? sanitized.maxWeight
                        : WEIGHTED_DEFAULTS.maxWeight;
                    sanitized.overloadDelayMs = (typeof sanitized.overloadDelayMs === 'number' && sanitized.overloadDelayMs >= 0)
                        ? sanitized.overloadDelayMs
                        : WEIGHTED_DEFAULTS.overloadDelayMs;
                    sanitized.indicatorColors = {
                        ...WEIGHTED_DEFAULTS.indicatorColors,
                        ...(sanitized.indicatorColors || {})
                    };
                }

                if (sanitized.type === 'TIMER') {
                    const duration = typeof sanitized.countdownSeconds === 'number'
                        ? sanitized.countdownSeconds
                        : sanitized.duration;
                    sanitized.countdownSeconds = Math.max(duration || 3, 0.1);
                }

                return sanitized;
            }

            getEntryByElement(element) {
                if (!element) return null;
                const effectId = element.dataset?.specialEffectId;
                for (let i = 0; i < this.entries.length; i++) {
                    const entry = this.entries[i];
                    if (entry.sourceElement === element) {
                        return entry;
                    }
                    if (effectId && entry.id === effectId) {
                        return entry;
                    }
                }
                return null;
            }

            setEffectVisibility(element, visible) {
                const entry = this.getEntryByElement(element);
                if (entry && entry.overlay) {
                    entry.overlay.style.display = visible ? 'block' : 'none';
                }
            }

            unregisterByElement(element) {
                if (!element) return;
                const effectId = element.dataset?.specialEffectId;
                for (let i = this.entries.length - 1; i >= 0; i--) {
                    const entry = this.entries[i];
                    if (entry.sourceElement === element || (effectId && entry.id === effectId)) {
                        if (entry.overlay && entry.overlay.parentElement) {
                            entry.overlay.parentElement.removeChild(entry.overlay);
                        }
                        this.entries.splice(i, 1);
                    }
                }
                if (effectId) {
                    delete element.dataset.specialEffectId;
                }
            }

            register(canvas, specialConfig) {
                console.log(`üé® DockingSpecialEffectsManager.register called:`, { canvas, specialConfig });
                if (!canvas || !specialConfig || !specialConfig.type) {
                    console.log(`‚ùå Registration failed - missing data:`, { hasCanvas: !!canvas, hasSpecialConfig: !!specialConfig, hasType: !!specialConfig?.type });
                    return;
                }

                const parent = canvas.parentElement;
                if (!parent) {
                    console.log(`‚ùå Registration failed - no parent element for canvas`);
                    return;
                }

                this.unregisterByElement(canvas);

                const overlay = document.createElement('canvas');
                overlay.width = canvas.width;
                overlay.height = canvas.height;
                
                // Copy all styles from the original canvas
                const computedStyle = window.getComputedStyle(canvas);
                overlay.style.cssText = canvas.style.cssText;
                
                // Override with overlay-specific styles
                overlay.className = 'special-effect-overlay';
                overlay.style.position = 'absolute';
                overlay.style.top = '0';
                overlay.style.left = '0';
                overlay.style.zIndex = '65';
                overlay.style.pointerEvents = 'none';
                overlay.style.display = 'block';
                parent.appendChild(overlay);

                const sanitizedConfig = this.sanitizeSpecialConfig(specialConfig);
                const entryId = `effect-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;

                if (!sanitizedConfig.currentStatus) {
                    sanitizedConfig.currentStatus = 'safe';
                }
                if (typeof sanitizedConfig.currentWeight !== 'number') {
                    sanitizedConfig.currentWeight = 0;
                }

                const entry = {
                    id: entryId,
                    type: sanitizedConfig.type,
                    overlay,
                    ctx: overlay.getContext('2d'),
                    specialParams: sanitizedConfig,
                    particles: [],
                    timerElapsed: 0,
                    timerDuration: Math.max(sanitizedConfig.countdownSeconds || sanitizedConfig.duration || 3, 0.1),
                    indicatorColors: sanitizedConfig.indicatorColors || {
                        safe: '#2ecc71',
                        warning: '#f1c40f',
                        danger: '#e74c3c'
                    },
                    sourceElement: canvas
                };

                overlay.dataset.specialEffectId = entryId;
                canvas.dataset.specialEffectId = entryId;

                this.entries.push(entry);
                console.log(`‚úÖ Special effect registered successfully:`, { 
                    id: entryId, 
                    type: sanitizedConfig.type,
                    canvas: canvas.id || 'unnamed',
                    overlaySize: { width: overlay.width, height: overlay.height }
                });

                if (!this.animationFrameId) {
                    this.lastTimestamp = performance.now();
                    this.animationFrameId = requestAnimationFrame(this.renderFrame);
                    console.log(`üé¨ Started special effects animation loop`);
                }
            }

            renderFrame(timestamp) {
                if (this.entries.length === 0) {
                    this.animationFrameId = null;
                    this.lastTimestamp = 0;
                    return;
                }

                const delta = this.lastTimestamp ? (timestamp - this.lastTimestamp) : 16.67;
                this.lastTimestamp = timestamp;
                const deltaMultiplier = delta / 16.67;

                for (let i = this.entries.length - 1; i >= 0; i--) {
                    const entry = this.entries[i];
                    if (!entry.overlay || !entry.overlay.isConnected) {
                        this.entries.splice(i, 1);
                        continue;
                    }

                    const ctx = entry.ctx;
                    if (!ctx) {
                        this.entries.splice(i, 1);
                        continue;
                    }

                    ctx.clearRect(0, 0, entry.overlay.width, entry.overlay.height);

                    // console.log(`üé¨ Rendering special effect:`, { id: entry.id, type: entry.type, canvasSize: { width: entry.overlay.width, height: entry.overlay.height } });

                    switch (entry.type) {
                        case 'FIRE':
                            this.renderFire(entry, deltaMultiplier);
                            break;
                        case 'TIMER':
                            this.renderTimer(entry, delta);
                            break;
                        case 'WEIGHTED':
                            this.renderWeighted(entry);
                            break;
                        default:
                            console.log(`‚ö†Ô∏è Unknown special effect type: ${entry.type}`);
                            break;
                    }
                }

                if (this.entries.length > 0) {
                    this.animationFrameId = requestAnimationFrame(this.renderFrame);
                } else {
                    this.animationFrameId = null;
                    this.lastTimestamp = 0;
                }
            }

            renderFire(entry, deltaMultiplier) {
                // console.log(`üî• renderFire called for entry:`, { id: entry.id, particles: entry.particles.length });
                const { overlay, ctx, particles } = entry;
                const centerX = overlay.width / 2;
                const centerY = overlay.height / 2;
                const maxParticles = 40;

                if (Math.random() > 0.4 && particles.length < maxParticles) {
                    const spawnCount = Math.random() > 0.7 ? 2 : 1;
                    for (let i = 0; i < spawnCount && particles.length < maxParticles; i++) {
                        particles.push({
                            x: centerX + (Math.random() - 0.5) * 6,
                            y: centerY + 10 + Math.random() * 4,
                            vx: (Math.random() - 0.5) * 1.2,
                            vy: -Math.random() * 1.8 - 0.4,
                            life: Math.random() * 0.4 + 0.2,
                            decay: 0.05,
                            size: 2 + Math.random() * 3,
                            color: ['#FF4500', '#FFA500', '#FFD700'][Math.floor(Math.random() * 3)]
                        });
                    }
                }

                for (let i = particles.length - 1; i >= 0; i--) {
                    const particle = particles[i];
                    particle.x += particle.vx * deltaMultiplier;
                    particle.y += particle.vy * deltaMultiplier;
                    particle.life -= particle.decay * deltaMultiplier;

                    if (particle.life <= 0) {
                        particles.splice(i, 1);
                        continue;
                    }

                    ctx.save();
                    ctx.globalAlpha = Math.max(particle.life, 0);
                    ctx.fillStyle = particle.color;
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
            }

            renderWeighted(entry) {
                // console.log(`‚öñÔ∏è renderWeighted called for entry:`, { id: entry.id, status: entry.specialParams?.currentStatus });
                const { overlay, ctx, indicatorColors, specialParams } = entry;
                const centerX = overlay.width / 2;
                const centerY = overlay.height / 2;

                ctx.save();
                ctx.translate(centerX, centerY);
                ctx.fillStyle = '#333';
                ctx.fillRect(-8, -4, 16, 8);

                ctx.beginPath();
                ctx.arc(0, 0, 5, 0, Math.PI * 2);
                const status = specialParams?.currentStatus || 'safe';
                const lightColor = indicatorColors[status] || indicatorColors.safe;
                ctx.fillStyle = lightColor;
                ctx.fill();
                ctx.strokeStyle = '#555';
                ctx.lineWidth = 1;
                ctx.stroke();
                ctx.restore();
            }

            renderTimer(entry, delta) {
                // console.log(`‚è±Ô∏è renderTimer called for entry:`, { id: entry.id, elapsed: entry.timerElapsed });
                const { overlay, ctx, timerDuration } = entry;
                const centerX = overlay.width / 2;
                const centerY = overlay.height / 2;

                entry.timerElapsed += delta / 1000;
                const progress = timerDuration > 0 ? (entry.timerElapsed % timerDuration) / timerDuration : 0;
                const angle = progress * Math.PI * 2;

                ctx.save();
                ctx.translate(centerX, centerY);

                ctx.beginPath();
                ctx.arc(0, 0, 8, 0, Math.PI * 2);
                ctx.fillStyle = '#E0E0E0';
                ctx.fill();
                ctx.strokeStyle = '#757575';
                ctx.lineWidth = 1.5;
                ctx.stroke();

                ctx.fillRect(-1.5, -11, 3, 3);

                ctx.save();
                ctx.rotate(angle);
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(0, -6);
                ctx.lineWidth = 1;
                ctx.strokeStyle = '#d32f2f';
                ctx.stroke();
                ctx.restore();

                ctx.restore();
            }
        }

        const dockingSpecialEffectsManager = new DockingSpecialEffectsManager();

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë ASYNC MUTEX - STATE MANAGEMENT SYNCHRONIZATION
          ‚ïë Prevents concurrent state mutations that could cause race conditions.
          ‚ïë Provides exclusive access to critical game state updates.
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        class AsyncMutex {
            constructor(name = 'unnamed') {
                this.name = name;
                this.locked = false;
                this.queue = [];
                this.lockCount = 0;
                this.maxWaitTime = 5000; // 5 seconds
            }
            
            // Acquire lock with timeout
            async acquire(operation = 'unknown') {
                return new Promise((resolve, reject) => {
                    const lockRequest = {
                        operation,
                        resolve,
                        reject,
                        timestamp: Date.now()
                    };
                    
                    if (!this.locked) {
                        this.locked = true;
                        this.lockCount++;
                        debugLog(`üîí AsyncMutex '${this.name}' acquired for: ${operation}`);
                        resolve();
                    } else {
                        debugLog(`‚è≥ AsyncMutex '${this.name}' queued: ${operation} (queue: ${this.queue.length + 1})`);
                        this.queue.push(lockRequest);
                        
                        // Set timeout for waiting
                        setTimeout(() => {
                            const index = this.queue.indexOf(lockRequest);
                            if (index !== -1) {
                                this.queue.splice(index, 1);
                                reject(new Error(`AsyncMutex '${this.name}' timeout for operation: ${operation}`));
                            }
                        }, this.maxWaitTime);
                    }
                });
            }
            
            // Release lock and process queue
            release(operation = 'unknown') {
                if (!this.locked) {
                    console.warn(`‚ö†Ô∏è AsyncMutex '${this.name}' release called but not locked`);
                    return;
                }
                
                debugLog(`üîì AsyncMutex '${this.name}' released by: ${operation}`);
                this.locked = false;
                
                if (this.queue.length > 0) {
                    const next = this.queue.shift();
                    this.locked = true;
                    this.lockCount++;
                    debugLog(`üîí AsyncMutex '${this.name}' acquired for: ${next.operation} (from queue)`);
                    next.resolve();
                }
            }
            
            // Execute operation with automatic lock management
            async execute(operation, operationName = 'anonymous') {
                try {
                    await this.acquire(operationName);
                    const result = await operation();
                    return result;
                } finally {
                    this.release(operationName);
                }
            }
            
            // Check if currently locked
            isLocked() {
                return this.locked;
            }
            
            // Get queue status
            getStatus() {
                return {
                    name: this.name,
                    locked: this.locked,
                    queueLength: this.queue.length,
                    lockCount: this.lockCount
                };
            }
            
            // Force unlock (emergency use only)
            forceUnlock(reason = 'forced') {
                console.warn(`‚ö†Ô∏è AsyncMutex '${this.name}' force unlocked: ${reason}`);
                this.locked = false;
                
                // Reject all queued operations
                while (this.queue.length > 0) {
                    const request = this.queue.shift();
                    request.reject(new Error(`Mutex force unlocked: ${reason}`));
                }
            }
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë DOCK LOADING MANAGER - ERROR HANDLING & LOADING STATES
          ‚ïë Manages loading states, error boundaries, and graceful fallbacks for dock
          ‚ïë initialization. Provides visual feedback during asset loading.
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        class DockLoadingManager {
            constructor() {
                this.maxRetries = 3;
                this.retryDelay = 1000; // 1 second
                this.currentRetries = 0;
                this.isLoading = false;
                this.loadingTimeout = null;
            }
            
            // Show loading state
            showLoading(message = 'Loading shapes...') {
                const dockingArea = document.getElementById('dockingArea');
                if (dockingArea) {
                    dockingArea.classList.add('loading');
                    dockingArea.classList.remove('error', 'retrying');
                    this.isLoading = true;
                    
                    // Set timeout for loading state
                    this.clearLoadingTimeout();
                    this.loadingTimeout = setTimeout(() => {
                        console.warn('‚ö†Ô∏è Dock loading taking longer than expected');
                        this.showError('Loading timeout - check network connection');
                    }, 10000); // 10 second timeout
                    
                    console.log(`üîÑ Dock loading: ${message}`);
                }
            }
            
            // Show error state
            showError(errorMessage = 'Failed to load shapes') {
                const dockingArea = document.getElementById('dockingArea');
                if (dockingArea) {
                    dockingArea.classList.add('error');
                    dockingArea.classList.remove('loading', 'retrying');
                    this.isLoading = false;
                    this.clearLoadingTimeout();
                    console.error(`‚ùå Dock error: ${errorMessage}`);
                }
            }
            
            // Show retry state
            showRetrying(attempt) {
                const dockingArea = document.getElementById('dockingArea');
                if (dockingArea) {
                    dockingArea.classList.add('retrying');
                    dockingArea.classList.remove('loading', 'error');
                    console.log(`üîÑ Dock retry attempt ${attempt}/${this.maxRetries}`);
                }
            }
            
            // Hide all loading states
            hideLoading() {
                const dockingArea = document.getElementById('dockingArea');
                if (dockingArea) {
                    dockingArea.classList.remove('loading', 'error', 'retrying');
                    this.isLoading = false;
                    this.clearLoadingTimeout();
                    debugLog('‚úÖ Dock loading complete');
                }
            }
            
            // Clear loading timeout
            clearLoadingTimeout() {
                if (this.loadingTimeout) {
                    clearTimeout(this.loadingTimeout);
                    this.loadingTimeout = null;
                }
            }
            
            // Retry mechanism with exponential backoff
            async retryOperation(operation, context = 'dock operation') {
                this.currentRetries = 0;
                
                while (this.currentRetries < this.maxRetries) {
                    try {
                        if (this.currentRetries > 0) {
                            this.showRetrying(this.currentRetries + 1);
                            const delay = this.retryDelay * Math.pow(2, this.currentRetries); // Exponential backoff
                            await new Promise(resolve => setTimeout(resolve, delay));
                        }
                        
                        const result = await operation();
                        this.currentRetries = 0; // Reset on success
                        return result;
                        
                    } catch (error) {
                        this.currentRetries++;
                        console.warn(`‚ö†Ô∏è ${context} failed (attempt ${this.currentRetries}/${this.maxRetries}):`, error.message);
                        
                        if (this.currentRetries >= this.maxRetries) {
                            this.showError(`${context} failed after ${this.maxRetries} attempts`);
                            throw new Error(`${context} failed after ${this.maxRetries} attempts: ${error.message}`);
                        }
                    }
                }
            }
            
            // Create fallback shape if asset loading fails
            createFallbackShape(shapeType, size = 90) {
                const canvas = document.createElement('canvas');
                canvas.width = size;
                canvas.height = size;
                canvas.className = 'shape-preview fallback';
                canvas.dataset.shape = shapeType;
                canvas.title = `${shapeType} (fallback)`;
                
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#f0f0f0';
                ctx.strokeStyle = '#999';
                ctx.lineWidth = 2;
                
                // Draw simple geometric fallback based on shape type
                const center = size / 2;
                const radius = size * 0.3;
                
                ctx.beginPath();
                if (shapeType.includes('circle')) {
                    ctx.arc(center, center, radius, 0, Math.PI * 2);
                } else if (shapeType.includes('triangle')) {
                    ctx.moveTo(center, center - radius);
                    ctx.lineTo(center - radius, center + radius);
                    ctx.lineTo(center + radius, center + radius);
                    ctx.closePath();
                } else {
                    // Default to square
                    ctx.rect(center - radius, center - radius, radius * 2, radius * 2);
                }
                
                ctx.fill();
                ctx.stroke();
                
                // Add shape type label
                ctx.fillStyle = '#666';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(shapeType, center, size - 5);
                
                console.log(`üîß Created fallback shape for: ${shapeType}`);
                return canvas;
            }
        }
        
        // Create global dock loading manager instance
        const dockLoadingManager = new DockLoadingManager();

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë GLOBAL MUTEX INSTANCES - CRITICAL OPERATION SYNCHRONIZATION
          ‚ïë Create mutex instances for different types of critical operations to
          ‚ïë prevent race conditions and ensure proper synchronization.
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        
        // Dock operations (rebuild, initialization, shape loading)
        const dockMutex = new AsyncMutex('dock-operations');
        
        // Theme operations (theme switching, asset loading, texture management)
        const themeMutex = new AsyncMutex('theme-operations');
        
        // Game state operations (level changes, resets, score updates)
        const gameStateMutex = new AsyncMutex('game-state');
        
        // Asset loading operations (texture loading, level data)
        const assetMutex = new AsyncMutex('asset-loading');
        
        // Global mutex manager for monitoring and debugging
        const mutexManager = {
            mutexes: { dockMutex, themeMutex, gameStateMutex, assetMutex },
            
            getStatus() {
                const status = {};
                for (const [name, mutex] of Object.entries(this.mutexes)) {
                    status[name] = mutex.getStatus();
                }
                return status;
            },
            
            logStatus() {
                console.log('üîí Mutex Status:', this.getStatus());
            },
            
            forceUnlockAll(reason = 'emergency') {
                console.warn(`‚ö†Ô∏è Force unlocking all mutexes: ${reason}`);
                for (const mutex of Object.values(this.mutexes)) {
                    if (mutex.isLocked()) {
                        mutex.forceUnlock(reason);
                    }
                }
            }
        };
        
        // Make mutex manager globally available for debugging
        window.mutexManager = mutexManager;

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë RACE CONDITION MONITOR - DEVELOPMENT DEBUGGING TOOL
          ‚ïë Detects and logs potential race conditions by tracking read/write access
          ‚ïë to shared resources. Helps identify concurrent access patterns.
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        class RaceConditionMonitor {
            constructor() {
                this.accessLog = [];
                this.resourceTracking = new Map();
                this.maxLogSize = 1000;
                this.warningThreshold = 5; // ms between conflicting operations
                this.enabled = true; // Can be disabled in production
            }
            
            // Track resource access
            trackAccess(resourceName, operation, operationType = 'read', metadata = {}) {
                if (!this.enabled) return;
                
                const timestamp = performance.now();
                const access = {
                    resourceName,
                    operation,
                    operationType, // 'read', 'write', 'modify'
                    timestamp,
                    stackTrace: this.getStackTrace(),
                    metadata
                };
                
                // Add to access log
                this.accessLog.push(access);
                if (this.accessLog.length > this.maxLogSize) {
                    this.accessLog.shift(); // Remove oldest entry
                }
                
                // Check for potential race conditions
                this.checkForRaceConditions(access);
                
                // Update resource tracking
                if (!this.resourceTracking.has(resourceName)) {
                    this.resourceTracking.set(resourceName, []);
                }
                const resourceAccesses = this.resourceTracking.get(resourceName);
                resourceAccesses.push(access);
                
                // Keep only recent accesses for each resource
                const cutoffTime = timestamp - 1000; // 1 second
                this.resourceTracking.set(resourceName, 
                    resourceAccesses.filter(a => a.timestamp > cutoffTime)
                );
            }
            
            // Check for potential race conditions
            checkForRaceConditions(currentAccess) {
                const { resourceName, operationType, timestamp } = currentAccess;
                const resourceAccesses = this.resourceTracking.get(resourceName) || [];
                
                // Look for conflicting operations within the warning threshold
                const recentAccesses = resourceAccesses.filter(access => 
                    access.timestamp > timestamp - this.warningThreshold &&
                    access.timestamp < timestamp
                );
                
                for (const recentAccess of recentAccesses) {
                    if (this.isConflictingOperation(recentAccess.operationType, operationType)) {
                        this.logRaceConditionWarning(recentAccess, currentAccess);
                    }
                }
            }
            
            // Determine if two operations conflict
            isConflictingOperation(op1, op2) {
                // Write-Write conflicts
                if (op1 === 'write' && op2 === 'write') return true;
                // Write-Read conflicts
                if ((op1 === 'write' && op2 === 'read') || (op1 === 'read' && op2 === 'write')) return true;
                // Write-Modify conflicts
                if ((op1 === 'write' && op2 === 'modify') || (op1 === 'modify' && op2 === 'write')) return true;
                // Modify-Modify conflicts
                if (op1 === 'modify' && op2 === 'modify') return true;
                
                return false;
            }
            
            // Log race condition warning
            logRaceConditionWarning(access1, access2) {
                const timeDiff = access2.timestamp - access1.timestamp;
                // Only log race conditions that are not properly handled by mutexes
                // If both operations are using mutexes, they're properly synchronized
                const isMutexProtected = access1.stackTrace?.includes('AsyncMutex') && access2.stackTrace?.includes('AsyncMutex');
                
                if (!isMutexProtected) {
                    console.warn(`‚ö†Ô∏è POTENTIAL RACE CONDITION DETECTED:`, {
                        resource: access1.resourceName,
                        timeDifference: `${timeDiff.toFixed(2)}ms`,
                        operations: [
                            { type: access1.operationType, operation: access1.operation },
                            { type: access2.operationType, operation: access2.operation }
                        ],
                        stackTraces: [access1.stackTrace, access2.stackTrace]
                    });
                } else {
                    // Just log a debug message for mutex-protected operations
                    console.log(`üîí Concurrent access detected but properly synchronized via mutex:`, {
                        resource: access1.resourceName,
                        timeDifference: `${timeDiff.toFixed(2)}ms`
                    });
                }
            }
            
            // Get stack trace for debugging
            getStackTrace() {
                try {
                    throw new Error();
                } catch (e) {
                    return e.stack?.split('\n').slice(2, 5).join('\n') || 'Stack trace unavailable';
                }
            }
            
            // Get access report for a resource
            getResourceReport(resourceName) {
                const accesses = this.resourceTracking.get(resourceName) || [];
                return {
                    resourceName,
                    accessCount: accesses.length,
                    recentAccesses: accesses.slice(-10), // Last 10 accesses
                    operations: [...new Set(accesses.map(a => a.operation))]
                };
            }
            
            // Get overall monitoring report
            getMonitoringReport() {
                const resources = Array.from(this.resourceTracking.keys());
                return {
                    totalResources: resources.length,
                    totalAccesses: this.accessLog.length,
                    monitoredResources: resources.map(r => this.getResourceReport(r)),
                    recentWarnings: this.getRecentWarnings()
                };
            }
            
            // Get recent race condition warnings
            getRecentWarnings() {
                // This would need to be implemented to track warnings separately
                // For now, just return a placeholder
                return [];
            }
            
            // Enable/disable monitoring
            setEnabled(enabled) {
                this.enabled = enabled;
                console.log(`üîç Race Condition Monitor: ${enabled ? 'ENABLED' : 'DISABLED'}`);
            }
            
            // Clear all tracking data
            clear() {
                this.accessLog = [];
                this.resourceTracking.clear();
                console.log('üßπ Race Condition Monitor: Cleared all tracking data');
            }
        }
        
        // Create global race condition monitor
        const raceConditionMonitor = new RaceConditionMonitor();
        window.raceConditionMonitor = raceConditionMonitor;
        
        // Helper function for easy race condition tracking
        window.trackResourceAccess = (resource, operation, type = 'read', metadata = {}) => {
            raceConditionMonitor.trackAccess(resource, operation, type, metadata);
        };

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë UNIFIED DOCK SYSTEM
          ‚ïë Replaces CSS-based dock with canvas-rendered previews matching physics
          ‚ïë Maintains existing functionality while implementing unified appearance
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        function rebuildGameDock() {
            return rebuildGameDockAsync();
        }

        // Dock rebuild protection variables
        let dockRebuildInProgress = false;
        let pendingDockRebuild = null;

        async function rebuildGameDockAsync() {
            raceConditionDebugger.trackOperation('rebuildGameDockAsync', 'dock-system');
            
            // If already rebuilding, queue this request
            if (dockRebuildInProgress) {
                debugLog('‚ö†Ô∏è Dock rebuild already in progress, queueing request');
                
                if (!pendingDockRebuild) {
                    pendingDockRebuild = new Promise((resolve) => {
                        const checkInterval = setInterval(() => {
                            if (!dockRebuildInProgress) {
                                clearInterval(checkInterval);
                                rebuildGameDockAsync().then(resolve);
                            }
                        }, 100);
                    });
                }
                return pendingDockRebuild;
            }
            
            dockRebuildInProgress = true;
            
            try {
                debugLog('üî® Starting dock rebuild...');
            
            // Track dock access for race condition monitoring
            raceConditionMonitor.trackAccess('dock-system', 'rebuildGameDock', 'write', {
                source: 'rebuildGameDockAsync'
            });
            
            // Use dock mutex to prevent concurrent dock operations
            return await dockMutex.execute(async () => {
                // Show initial loading state
                dockLoadingManager.showLoading('Initializing dock...');
                
                const dockingArea = document.getElementById('dockingArea');
            if (!dockingArea) {
                dockLoadingManager.showError('Docking area not found in DOM');
                console.error('‚ùå Docking area not found!');
                return;
            }

            // Wait for AssetManager to be ready
            if (!window.assetManager) {
                dockLoadingManager.showLoading('Waiting for AssetManager...');
                debugLog('‚ö†Ô∏è AssetManager not available, deferring dock rebuild');
                setTimeout(() => rebuildGameDock(), 100);
                return;
            }

            // Ensure current theme is loaded - check multiple sources for current theme
            let currentTheme = window.assetManager.getCurrentTheme();
            let currentThemeName = currentTheme?.name;
            
            // If AssetManager doesn't have current theme, check theme selector dropdown
            if (!currentThemeName) {
                const themeSelector = document.getElementById('themeSelector');
                if (themeSelector && themeSelector.value) {
                    currentThemeName = themeSelector.value;
                    debugLog(`üîç Using theme from selector: ${currentThemeName}`);
                }
            }
            
            // If still no theme, use default
            if (!currentThemeName) {
                currentThemeName = CANVAS_CONFIG.defaultTheme;
                debugLog(`üîç Falling back to default theme: ${currentThemeName}`);
            }
            
            // Load the theme if not already loaded
            if (!currentTheme || currentTheme.name !== currentThemeName) {
                // Additional check to prevent duplicate loading
                if (!window.assetManager.themes[currentThemeName]?.loaded) {
                    debugLog(`‚è≥ Loading theme '${currentThemeName}' before building dock...`);
                    await window.assetManager.loadTheme(currentThemeName);
                }
                currentTheme = window.assetManager.getCurrentTheme();
            }

            dockingSpecialEffectsManager.reset();
            
            debugLog('üîß Building dock with loaded theme:', currentTheme?.name);

            // Always use current configuration instead of delegating to GameManager
            // This ensures design mode changes are preserved
            debugLog('üéØ Building dock from current configuration (not delegating to GameManager)');

            // Get current dock shapes from level config or fallback to all shapes
            const dockShapes = window.currentLevelConfig ? window.currentLevelConfig.dockShapes : getAllShapeTypes();
            debugLog('üì¶ Building dock with shapes:', dockShapes);

            let levelSlotData = [];
            if (window.gameManager && window.gameManager.levelData &&
                window.gameManager.levelData.dock && Array.isArray(window.gameManager.levelData.dock.slots)) {
                levelSlotData = window.gameManager.levelData.dock.slots.slice();
            }

            // Clear existing dock
            dockingArea.innerHTML = '';
            dockingArea.classList.remove('loading');
            
            // Build dock slots with shapes
            dockShapes.forEach((shapeType, index) => {
                const slot = document.createElement('div');
                slot.className = 'shape-slot';
                slot.dataset.slotIndex = index;
                
                // Find corresponding level slot data for special effects
                const levelSlot = levelSlotData.find(slotData => slotData.slotIndex === index);
                
                // Set special type data attribute if available
                if (levelSlot && levelSlot.specialType && levelSlot.specialType.type) {
                    slot.dataset.specialType = levelSlot.specialType.type;
                }
                
                // Create shape preview
                const shapePreview = shapeRenderer.createDockPreview(shapeType, 90);
                if (shapePreview) {
                    shapePreview.classList.add('game-shape');
                    shapePreview.dataset.shape = shapeType;
                    
                    // Add shape ID if available from level data
                    if (levelSlot && levelSlot.shapeId) {
                        shapePreview.dataset.shapeId = levelSlot.shapeId;
                        shapePreview.id = `shape-${levelSlot.shapeId}`;
                    }
                    
                    // Handle LOCKED shapes
                    if (levelSlot && levelSlot.specialType && levelSlot.specialType.type === 'LOCKED') {
                        shapePreview.classList.add('locked');
                        const lockIcon = document.createElement('div');
                        lockIcon.className = 'lock-icon';
                        lockIcon.innerHTML = `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" style="filter: drop-shadow(0 0 2px rgba(0,0,0,0.7));"><rect x="5" y="11" width="14" height="10" rx="2" fill="white" fill-opacity="0.9"/><path d="M8 11V7C8 4.79086 9.79086 3 12 3C14.2091 3 16 4.79086 16 7V11" stroke="white" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" stroke-opacity="0.9"/></svg>`;
                        slot.appendChild(lockIcon);
                    }
                    
                    slot.appendChild(shapePreview);
                    
                    // Register special effects for non-LOCKED special types
                    if (levelSlot && levelSlot.specialType && levelSlot.specialType.type && levelSlot.specialType.type !== 'LOCKED') {
                        console.log(`üé® Registering special effect for slot ${index}:`, { shapeType: shapeType, specialType: levelSlot.specialType });
                        dockingSpecialEffectsManager.register(shapePreview, levelSlot.specialType);
                    } else if (levelSlot && levelSlot.specialType) {
                        console.log(`‚ö™ Skipping special effect registration for slot ${index}:`, { 
                            shapeType: shapeType, 
                            specialType: levelSlot.specialType.type,
                            reason: levelSlot.specialType.type === 'LOCKED' ? 'LOCKED type uses CSS styling' : 'No special type'
                        });
                    }
                } else {
                    console.warn(`‚ö†Ô∏è Failed to create shape preview for ${shapeType}`);
                }
                
                dockingArea.appendChild(slot);
                debugLog(`ÔøΩ Added ${shapeType} to dock slot ${index}`);
            });

            console.log(`‚úÖ Dock rebuilt with ${dockShapes.length} shapes`);
            
            // Hide loading state when complete
            dockLoadingManager.hideLoading();
            
            }, 'dock-rebuild'); // Close dockMutex.execute
            } finally {
                dockRebuildInProgress = false;
                pendingDockRebuild = null;
            }
        }

        // Initialize unified dock system (called after level config is ready)
        function initializeUnifiedDockSystem() {
            console.log('ÔøΩ Initializing Unified Dock System...');
            rebuildGameDock();
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë ENHANCED PHYSICS MANAGER WITH EVENT SYSTEM
          ‚ïë Phase 4.1: Implements collision detection, fall detection, and physics events
          ‚ïë Integrates physics events with game state for advanced game mechanics.
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        /*
         * PhysicsManager - Matter.js + Canvas2D Integration
         * 
         * Core physics engine management with Canvas2D-only visualization.
         * Handles all physics simulation, collision detection, and visual rendering
         * through optimized Canvas2D operations.
         * 
         * Architecture:
         * ‚Ä¢ Matter.js physics engine
         * ‚Ä¢ Canvas2D shape rendering and visualization
         * ‚Ä¢ Event-driven collision and interaction system
         * ‚Ä¢ Performance-optimized rendering pipeline
         */
        class PhysicsManager {
            constructor(canvas, physicsData = {}) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                
                // Matter.js aliases for cleaner code
                this.Engine = Matter.Engine;
                this.World = Matter.World;
                this.Bodies = Matter.Bodies;
                this.Body = Matter.Body;
                this.Events = Matter.Events;
                
                // Event tracking
                this.eventCount = 0;
                this.collisionCount = 0;
                this.fallCount = 0;
                
                // Canvas Enhancement System
                // Use shared AssetManager to ensure theme synchronization
                this.assetManager = window.assetManager || new AssetManager();
                if (!window.assetManager) {
                    window.assetManager = this.assetManager;
                }
                console.log('üîó PhysicsManager: Using shared AssetManager for theme synchronization');
                
                // Use the existing global texture management system
                debugLog('üñºÔ∏è PhysicsManager: Using global texture management system');
                this.particleSystem = new ParticleSystem(canvas, this.assetManager);
                
                // Canvas-only renderer system
                this.rendererManager = new RendererManager(canvas);
                
                console.log('üéÆ PhysicsManager with Canvas renderer initialized');
                
                // Theme-based rendering properties
                this.backgroundGradient = null;
                this.platformColor = '#8B4513';
                
                console.log('üé® Canvas Enhancement System initialized');
                
                // Initialize with default theme
                this.initializeDefaultTheme();
                
                // Resize canvas to container
                this.resizeCanvas();
                
                // Create Matter.js world with physics engine
                this.engine = this.Engine.create();
                this.world = this.engine.world;
                
                // Set gravity from physics data or fallback to defaults
                this.engine.world.gravity.x = physicsData.gravity?.x || 0;
                this.engine.world.gravity.y = physicsData.gravity?.y || 1;
                
                // Track all dynamic bodies for rendering and cleanup
                this.dynamicBodies = [];
                // Track platform bodies for clearing when loading from data
                this.platformBodies = [];
                // Store shape defaults and materials for future use
                this.shapeDefaults = physicsData.shapeDefaults || {};
                this.materials = physicsData.materials || {};
                
                // Explosion timer system
                this.explosionTimers = [];
                this.lastExplosionId = 0;

                /*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                  ‚ïë PULSE MANAGEMENT SYSTEM
                  ‚ïë Handles accelerating pulse effects for fire and timer shapes
                  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
                this.pulseManager = {
                    activePulses: new Map(), // bodyId -> pulseState
                    lastPulseId: 0
                };

                // Camera shake system
                this.cameraShake = {
                    active: false,
                    intensity: 0,
                    duration: 0,
                    elapsed: 0,
                    frequencyX: 0.1,
                    frequencyY: 0.1,
                    offsetX: 0,
                    offsetY: 0
                };
                
                // Setup physics event listeners
                this.setupPhysicsEvents();
                
                // Create game platform and boundaries
                this.createPlatform();
                this.createBoundaries();
                
                // Start render loop
                this.startRenderLoop();
                
                console.log('üåç Enhanced Physics Manager with Events initialized');
            }

            // Canvas Enhancement: Initialize default theme
            async initializeDefaultTheme() {
                try {
                    // Check if default theme is already loaded
                    if (!this.assetManager.themes[CANVAS_CONFIG.defaultTheme]?.loaded) {
                        await this.assetManager.loadTheme(CANVAS_CONFIG.defaultTheme);
                    }
                    const bgStyle = this.assetManager.getBackgroundStyle();
                    if (bgStyle && bgStyle.type === 'gradient') {
                        this.backgroundGradient = bgStyle.colors;
                    }
                    const platformStyle = this.assetManager.getPlatformStyle();
                    if (platformStyle) {
                        this.platformColor = platformStyle.color;
                    }
                    console.log(`üé® Default theme initialized: ${CANVAS_CONFIG.defaultTheme}`);
                } catch (error) {
                    console.error('‚ùå Failed to initialize default theme:', error);
                }
            }


            setupPhysicsEvents() {
                // Matter.js collision detection - when shapes start touching
                this.Events.on(this.engine, 'collisionStart', (event) => {
                    event.pairs.forEach(pair => {
                        this.handleBeginContact(pair);
                    });
                });
                
                // Matter.js collision end - when shapes stop touching  
                this.Events.on(this.engine, 'collisionEnd', (event) => {
                    event.pairs.forEach(pair => {
                        this.handleEndContact(pair);
                    });
                });
                
                console.log('üéØ Matter.js event listeners configured');
            }

            handleBeginContact(pair) {
                const bodyA = pair.bodyA;
                const bodyB = pair.bodyB;
                const userDataA = bodyA.userData || {};
                const userDataB = bodyB.userData || {};

                console.log(`üîç RAW COLLISION: bodyA.userData =`, userDataA, `bodyB.userData =`, userDataB);

                // VALIDATION: Check userData integrity
                if (Object.keys(userDataA).length === 0 && Object.keys(userDataB).length === 0) {
                    console.error(`‚ùå CRITICAL: Both collision bodies have empty userData!`);
                    console.error(`  BodyA:`, { id: bodyA.id, label: bodyA.label, parts: bodyA.parts?.length });
                    console.error(`  BodyB:`, { id: bodyB.id, label: bodyB.label, parts: bodyB.parts?.length });
                } else if (Object.keys(userDataA).length === 0) {
                    console.warn(`‚ö†Ô∏è Body A has empty userData:`, { id: bodyA.id, label: bodyA.label, parts: bodyA.parts?.length });
                } else if (Object.keys(userDataB).length === 0) {
                    console.warn(`‚ö†Ô∏è Body B has empty userData:`, { id: bodyB.id, label: bodyB.label, parts: bodyB.parts?.length });
                }

                const isFireA = userDataA.specialType?.type === 'FIRE';
                const isFireB = userDataB.specialType?.type === 'FIRE';
                if (isFireA && isFireB) {
                    // Check if either body is already part of a countdown
                    const existingTimerA = this.explosionTimers.find(t => t.shapes.has(bodyA));
                    const existingTimerB = this.explosionTimers.find(t => t.shapes.has(bodyB));

                    if (!existingTimerA && !existingTimerB) {
                        // Neither is ticking, create a new timer
                        const delayA = userDataA.specialType.explosionDelaySeconds || 1;
                        const delayB = userDataB.specialType.explosionDelaySeconds || 1;
                        const delay = Math.min(delayA, delayB); // Use the shorter delay

                        const newTimer = {
                            id: ++this.lastExplosionId,
                            timeRemaining: delay * 1000,
                            shapes: new Set([bodyA, bodyB])
                        };
                        this.explosionTimers.push(newTimer);
                        bodyA.userData.explosionTimerId = newTimer.id;
                        bodyB.userData.explosionTimerId = newTimer.id;
                        
                        // üî• START FIRE PULSING for both shapes
                        this.startPulsing(bodyA, 'fire');
                        this.startPulsing(bodyB, 'fire');
                        console.log(`üî• Started pulsing for fire collision: ${bodyA.id} & ${bodyB.id}`);
                        
                    } else if (existingTimerA && !existingTimerB) {
                        // Add bodyB to timerA
                        existingTimerA.shapes.add(bodyB);
                        bodyB.userData.explosionTimerId = existingTimerA.id;
                        
                        // üî• START PULSING for newly added shape
                        this.startPulsing(bodyB, 'fire');
                        
                    } else if (!existingTimerA && existingTimerB) {
                        // Add bodyA to timerB
                        existingTimerB.shapes.add(bodyA);
                        bodyA.userData.explosionTimerId = existingTimerB.id;
                        
                        // üî• START PULSING for newly added shape
                        this.startPulsing(bodyA, 'fire');
                    } else if (existingTimerA && existingTimerB && existingTimerA.id !== existingTimerB.id) {
                        // Merge timers, keep the one with less time remaining
                        const timerToKeep = existingTimerA.timeRemaining < existingTimerB.timeRemaining ? existingTimerA : existingTimerB;
                        const timerToMerge = existingTimerA === timerToKeep ? existingTimerB : existingTimerA;

                        timerToMerge.shapes.forEach(shape => {
                            timerToKeep.shapes.add(shape);
                            shape.userData.explosionTimerId = timerToKeep.id;
                        });

                        // Remove the merged timer
                        this.explosionTimers = this.explosionTimers.filter(t => t.id !== timerToMerge.id);
                    }
                }


                this.collisionCount++;
                this.eventCount++;
                
                // Check for shape-platform collision
                if (this.isShapePlatformCollision(userDataA, userDataB)) {
                    console.log('üéØ PLATFORM COLLISION DETECTED!');
                    this.onShapeLandedOnPlatform(bodyA, bodyB);
                }
                
                // Check for shape-shape collision
                if (this.isShapeShapeCollision(userDataA, userDataB)) {
                    console.log('üîÑ SHAPE-SHAPE COLLISION DETECTED!');
                    this.onShapeShapeCollision(bodyA, bodyB);
                }
                
                // Check for ground collision (fall detection)
                console.log('üß™ Testing ground collision...');
                if (this.isGroundCollision(userDataA, userDataB)) {
                    console.log('üî• GROUND COLLISION DETECTED! Triggering shape fall...');
                    this.onShapeFellOffPlatform(bodyA, bodyB);
                } else {
                    console.log('‚ùå Ground collision test failed');
                }
                
                console.log(`üìç Collision detected: ${userDataA.type || 'unknown'} vs ${userDataB.type || 'unknown'}`);
            }

            handleEndContact(pair) {
                const bodyA = pair.bodyA;
                const bodyB = pair.bodyB;
                const userDataA = bodyA.userData || {};
                const userDataB = bodyB.userData || {};

            }

            triggerExplosion(position, radius = 50) {
                // Only create particle effects, no force application, as per user request.
                // The radius parameter is kept for potential future use by the particle system.
                this.particleSystem.createThemeParticles('explosion', position.x, position.y, 30);
            }

            cleanupRemovedShapeFromWeighted(removedBodyId) {
                // Clean up references in all weighted shapes
                this.dynamicBodies.forEach(body => {
                    if (body.userData?.specialType?.type === 'WEIGHTED' &&
                        body.userData.shapesOnTop?.has(removedBodyId)) {
                        body.userData.shapesOnTop.delete(removedBodyId);
                        console.log(`‚öñÔ∏è Cleaned up shape ${removedBodyId} from weighted tracking`);
                    }
                });
            }

            updateSpecialShapes(deltaTime) {
                const bodiesToRemove = [];
                this.dynamicBodies.forEach(body => {
                    const specialType = body.userData.specialType?.type;
                    if (!specialType) return;

                    if (specialType === 'TIMER') {
                        const timerState = body.userData.timerState;
                        if (!timerState) return;
                        if (typeof timerState.initialCountdown !== 'number' || timerState.initialCountdown <= 0) {
                            timerState.initialCountdown = timerState.countdown;
                        }
                        const isWeightOnTop = this.dynamicBodies.some(otherBody =>
                            otherBody.id !== body.id &&
                            Math.abs(otherBody.position.x - body.position.x) < 20 &&
                            otherBody.position.y < body.position.y &&
                            Matter.Query.collides(body, [otherBody]).length > 0
                        );
                        if (isWeightOnTop && !timerState.isTicking) { 
                            timerState.isTicking = true;
                            // üî• START TIMER PULSING when timer starts ticking
                            this.startPulsing(body, 'timer');
                            console.log(`‚è∞ Started timer pulsing for body ${body.id} - countdown: ${timerState.countdown}s`);
                        }
                        if (timerState.isTicking) {
                            timerState.countdown -= deltaTime / 1000;
                            if (timerState.countdown < 0) {
                                timerState.countdown = 0;
                            }
                            if (timerState.countdown <= 0) {
                                this.triggerExplosion(body.position, body.userData.specialType.explosionRadius);
                                bodiesToRemove.push(body);
                                // üî• CLEANUP: Stop pulsing when timer explodes
                                this.stopPulsing(body.id);
                            }
                        }
                    }
                    
                    if (specialType === 'WEIGHTED') {
                        const weightState = body.userData.weightState;
                        if (!weightState) return;

                        const specialParams = body.userData.specialType || {};
                        const maxWeight = (typeof specialParams.maxWeight === 'number' && specialParams.maxWeight > 0)
                            ? specialParams.maxWeight
                            : WEIGHTED_DEFAULTS.maxWeight;
                        const overloadDelay = (typeof specialParams.overloadDelayMs === 'number' && specialParams.overloadDelayMs >= 0)
                            ? specialParams.overloadDelayMs
                            : WEIGHTED_DEFAULTS.overloadDelayMs;

                        specialParams.maxWeight = maxWeight;
                        specialParams.overloadDelayMs = overloadDelay;

                        const colors = {
                            ...WEIGHTED_DEFAULTS.indicatorColors,
                            ...(specialParams.indicatorColors || {})
                        };
                        specialParams.indicatorColors = colors;

                        // Use a spatial query to find all bodies stacked on top
                        const bodiesOnTop = this.getBodiesOnTop(body);
                        weightState.currentWeight = this.getRecursiveDescendants(body, this.dynamicBodies).size;
                        weightState.maxWeight = maxWeight;

                        const previousStatus = weightState.status;
                        let newStatus;
                        const currentWeight = weightState.currentWeight;

                        if (currentWeight === 0) {
                            newStatus = 'safe';
                        } else if (currentWeight === 1) {
                            newStatus = 'warning';
                        } else if (currentWeight === 2) {
                            newStatus = 'danger';
                        } else { // currentWeight >= 3
                            newStatus = 'overloaded';
                        }

                        weightState.status = newStatus;
                        specialParams.currentStatus = newStatus;
                        specialParams.currentWeight = weightState.currentWeight;

                        if (previousStatus !== newStatus) {
                            const statusColor = colors[newStatus] || (newStatus === 'overloaded' ? colors.danger : '#FFFFFF');
                            console.log(
                                `‚öñÔ∏è WEIGHTED status changed to ${newStatus.toUpperCase()} (${statusColor}). ` +
                                `Current weight: ${weightState.currentWeight}/${maxWeight} (Max Weight: ${maxWeight}). ` +
                                `Ranges -> SAFE[0] (${colors.safe}), WARNING[1] (${colors.warning}), DANGER[2] (${colors.danger}), OVERLOADED[${maxWeight}+] (${colors.danger}). ` +
                                `Overload delay: ${(overloadDelay / 1000).toFixed(2)}s.`
                            );
                        }

                        const hasReachedMax = maxWeight > 0 && weightState.currentWeight >= maxWeight;

                        if (hasReachedMax) {
                            if (!weightState.overloadActive) {
                                weightState.overloadActive = true;
                                weightState.overweightTimer = 0;
                                console.log(`‚è±Ô∏è WEIGHTED overload timer started (Max Weight: ${maxWeight}, Delay: ${(overloadDelay / 1000).toFixed(2)}s).`);
                            }
                            weightState.overweightTimer += deltaTime;
                            if (weightState.overweightTimer >= overloadDelay) {
                                console.log(`üí• WEIGHTED shape exceeded Max Weight ${maxWeight}. Triggering explosion.`);
                                this.triggerExplosion(body.position, specialParams.explosionRadius);
                                bodiesToRemove.push(body);
                                weightState.overloadActive = false;
                                weightState.overweightTimer = 0;
                            }
                        } else if (weightState.overloadActive) {
                            console.log(`‚úÖ WEIGHTED overload timer cancelled. Current weight ${weightState.currentWeight}/${maxWeight}.`);
                            weightState.overloadActive = false;
                            weightState.overweightTimer = 0;
                        } else {
                            weightState.overweightTimer = 0;
                        }
                    }
                });
                
                if (bodiesToRemove.length > 0) {
                    bodiesToRemove.forEach(body => {
                        this.World.remove(this.world, body);
                        this.cleanupRemovedShapeFromWeighted(body.id);
                    });
                    this.dynamicBodies = this.dynamicBodies.filter(b => !bodiesToRemove.some(rem => rem.id === b.id));
                }
            }

            getBodiesOnTop(body) {
                const bodyBounds = body.bounds;
                const queryBounds = {
                    min: { x: bodyBounds.min.x, y: 0 },
                    max: { x: bodyBounds.max.x, y: bodyBounds.min.y }
                };

                // Query for bodies that are in the vertical column above the weighted shape
                const bodiesInRegion = Matter.Query.region(this.dynamicBodies, queryBounds);

                // Filter out the weighted body itself
                return bodiesInRegion.filter(otherBody => otherBody.id !== body.id);
            }

            updateExplosionTimers(deltaTime) {
                for (let i = this.explosionTimers.length - 1; i >= 0; i--) {
                    const timer = this.explosionTimers[i];
                    timer.timeRemaining -= deltaTime;

                    if (timer.timeRemaining <= 0) {
                        // Time's up, explode all shapes in the set
                        timer.shapes.forEach(shapeBody => {
                            // Ensure the body still exists in the world before trying to explode it
                            if (this.dynamicBodies.includes(shapeBody)) {
                                this.triggerExplosion(shapeBody.position, shapeBody.userData.specialType.explosionRadius);
                                this.World.remove(this.world, shapeBody);
                                this.cleanupRemovedShapeFromWeighted(shapeBody.id);
                                this.dynamicBodies = this.dynamicBodies.filter(b => b.id !== shapeBody.id);
                                
                                // üî• CLEANUP: Stop pulsing for exploded shape
                                this.stopPulsing(shapeBody.id);
                            }
                        });

                        // Remove this timer
                        this.explosionTimers.splice(i, 1);
                    }
                }
            }

            /*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
              ‚ïë PULSE MANAGEMENT SYSTEM METHODS  
              ‚ïë Handles accelerating pulse effects for fire and timer shapes
              ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/

            getCurrentPulseInterval(progress) {
                const initialInterval = 3050; // 3.05 seconds
                const finalInterval = 200;    // 0.2 seconds (extremely fast at the end)
    
                // Exponential decrease for more dramatic effect
                const easedProgress = 1 - Math.pow(1 - progress, 3);
                return initialInterval - (initialInterval - finalInterval) * easedProgress;
            }

            calculateTimerPulse(pulseState, currentTime) {
                if (!pulseState.isTicking) return { isPulsing: false, pulseIntensity: 0 };
    
                const totalDuration = pulseState.initialCountdown || 1;
                const remaining = Math.max(pulseState.countdown || 0, 0);
                const progress = Math.min(1 - (remaining / totalDuration), 1); // 0 = start, 1 = expired
    
                // Get current pulse interval in milliseconds
                const currentInterval = this.getCurrentPulseInterval(progress);
    
                // Initialize pulse tracking if not exists
                if (!pulseState.lastPulseTime) {
                    pulseState.lastPulseTime = currentTime;
                    pulseState.pulseStartTime = currentTime;
                    pulseState.isPulseActive = false;
                }
    
                // Check if we should start a new pulse
                const timeSinceLastPulse = currentTime - pulseState.lastPulseTime;
    
                if (!pulseState.isPulseActive && timeSinceLastPulse >= currentInterval) {
                    // Start new pulse
                    pulseState.isPulseActive = true;
                    pulseState.pulseStartTime = currentTime;
                    pulseState.lastPulseTime = currentTime;
                }
    
                // Handle active pulse
                let isPulsing = false;
                let pulseIntensity = 0;
    
                if (pulseState.isPulseActive) {
                    const pulseDuration = 200; // Duration of each pulse in ms
                    const pulseProgress = (currentTime - pulseState.pulseStartTime) / pulseDuration;
        
                    if (pulseProgress >= 1) {
                        // End current pulse
                        pulseState.isPulseActive = false;
                        isPulsing = false;
                        pulseIntensity = 0;
                    } else {
                        // Calculate smooth pulse intensity using sine wave
                        isPulsing = true;
                        pulseIntensity = Math.sin(pulseProgress * Math.PI); // Smooth 0->1->0 curve
                    }
                }
    
                return {
                    isPulsing,
                    pulseIntensity,
                    progress,
                    currentInterval,
                    pulsesPerSecond: 1000 / currentInterval // For debugging/display
                };
            }

            // Calculate fire collision pulse (based on proximity or countdown)
            calculateFirePulse(fireState, currentTime) {
                if (!fireState.isCountingDown) return { isPulsing: false, pulseIntensity: 0 };

                const totalDuration = fireState.explosionDelay || 1000; // Default 1 second
                const elapsed = currentTime - fireState.countdownStartTime;
                const remaining = Math.max(totalDuration - elapsed, 0);
                const progress = Math.min(elapsed / totalDuration, 1); // 0 = start, 1 = explosion

                // Use same pulse interval calculation as timers
                const currentInterval = this.getCurrentPulseInterval(progress);

                // Initialize pulse tracking if not exists
                if (!fireState.lastPulseTime) {
                    fireState.lastPulseTime = currentTime;
                    fireState.pulseStartTime = currentTime;
                    fireState.isPulseActive = false;
                }

                // Check if we should start a new pulse
                const timeSinceLastPulse = currentTime - fireState.lastPulseTime;

                if (!fireState.isPulseActive && timeSinceLastPulse >= currentInterval) {
                    // Start new pulse
                    fireState.isPulseActive = true;
                    fireState.pulseStartTime = currentTime;
                    fireState.lastPulseTime = currentTime;
                }

                // Handle active pulse
                let isPulsing = false;
                let pulseIntensity = 0;

                if (fireState.isPulseActive) {
                    const pulseDuration = 200; // Duration of each pulse in ms
                    const pulseProgress = (currentTime - fireState.pulseStartTime) / pulseDuration;

                    if (pulseProgress >= 1) {
                        // End current pulse
                        fireState.isPulseActive = false;
                        isPulsing = false;
                        pulseIntensity = 0;
                    } else {
                        // Calculate smooth pulse intensity using sine wave
                        isPulsing = true;
                        pulseIntensity = Math.sin(pulseProgress * Math.PI); // Smooth 0->1->0 curve
                    }
                }

                return {
                    isPulsing,
                    pulseIntensity,
                    progress,
                    currentInterval,
                    pulsesPerSecond: 1000 / currentInterval // For debugging/display
                };
            }

            // Update all active pulse states
            updatePulseStates(currentTime) {
                this.pulseManager.activePulses.forEach((pulseState, bodyId) => {
                    const body = this.dynamicBodies.find(b => b.id === bodyId);
                    if (!body) {
                        // Body no longer exists, clean up pulse state
                        this.pulseManager.activePulses.delete(bodyId);
                        return;
                    }

                    const userData = body.userData;
                    if (userData.specialType?.type === 'FIRE') {
                        // Update fire pulse state
                        const pulseResult = this.calculateFirePulse(pulseState, currentTime);
                        Object.assign(pulseState, pulseResult);
                    } else if (userData.specialType?.type === 'TIMER') {
                        // Sync timer data from body's timerState to pulseState
                        const timerState = userData.timerState;
                        if (timerState) {
                            pulseState.isTicking = timerState.isTicking;
                            pulseState.countdown = timerState.countdown;
                            pulseState.initialCountdown = timerState.initialCountdown;
                        }
                        
                        // Update timer pulse state  
                        const pulseResult = this.calculateTimerPulse(pulseState, currentTime);
                        Object.assign(pulseState, pulseResult);
                    }
                });
            }

            // Start pulsing for a shape
            startPulsing(body, pulseType = 'fire') {
                const bodyId = body.id;
                if (this.pulseManager.activePulses.has(bodyId)) {
                    return; // Already pulsing
                }

                const currentTime = performance.now();
                const pulseState = {
                    id: ++this.pulseManager.lastPulseId,
                    bodyId: bodyId,
                    type: pulseType,
                    startTime: currentTime,
                    lastPulseTime: 0,
                    pulseStartTime: 0,
                    isPulseActive: false,
                    isPulsing: false,
                    pulseIntensity: 0,
                    progress: 0,
                    currentInterval: 3050,
                    // Fire-specific
                    isCountingDown: pulseType === 'fire',
                    explosionDelay: body.userData.specialType?.explosionDelaySeconds * 1000 || 1000,
                    countdownStartTime: currentTime,
                    // Timer-specific - get from actual timer state
                    isTicking: pulseType === 'timer' ? (body.userData.timerState?.isTicking || false) : false,
                    initialCountdown: pulseType === 'timer' ? (body.userData.timerState?.initialCountdown || body.userData.timerState?.countdown || 10) : 10000,
                    countdown: pulseType === 'timer' ? (body.userData.timerState?.countdown || 10) : 10000
                };

                this.pulseManager.activePulses.set(bodyId, pulseState);
                console.log(`‚ú® Started ${pulseType} pulsing for body ${bodyId}`);
            }

            // Stop pulsing for a shape
            stopPulsing(bodyId) {
                if (this.pulseManager.activePulses.has(bodyId)) {
                    this.pulseManager.activePulses.delete(bodyId);
                    console.log(`‚èπÔ∏è Stopped pulsing for body ${bodyId}`);
                }
            }

            // Apply visual pulse effects to canvas context
            applyPulseEffects(pulseIntensity, hasTexture = false) {
                if (pulseIntensity <= 0) return;

                // Different effects for texture vs fallback colors
                if (hasTexture) {
                    // For textures, use composite operations and filters
                    
                    // 1. Brightness pulse - makes texture flash brighter
                    const brightness = 1 + (pulseIntensity * 0.5); // 0.5x boost at peak
                    this.ctx.filter = `brightness(${brightness})`;
                    
                    // 2. Add white overlay for dramatic effect
                    const overlayAlpha = pulseIntensity * 0.3; // Max 30% white overlay
                    this.ctx.globalCompositeOperation = 'screen';
                    this.ctx.globalAlpha = overlayAlpha;
                    
                } else {
                    // For solid colors, apply white tint overlay
                    const whiteIntensity = pulseIntensity * 0.8; // Strong white pulse
                    this.ctx.globalCompositeOperation = 'screen';
                    this.ctx.globalAlpha = whiteIntensity;
                    this.ctx.fillStyle = 'white';
                }
            }

            // Reset pulse effects after rendering
            resetPulseEffects() {
                this.ctx.filter = 'none';
                this.ctx.globalCompositeOperation = 'source-over';
                this.ctx.globalAlpha = 1.0;
            }

            getRecursiveDescendants(body, allBodies) {
                return this._getRecursiveDescendants(body, allBodies, new Set());
            }

            _getRecursiveDescendants(body, allBodies, visited) {
                if (visited.has(body.id)) {
                    return new Set();
                }
                visited.add(body.id);

                const bodiesOnTop = this.getBodiesOnTop(body);
                let descendants = new Set(bodiesOnTop);

                for (const topBody of bodiesOnTop) {
                    const topBodyDescendants = this._getRecursiveDescendants(topBody, allBodies, visited);
                    for (const d of topBodyDescendants) {
                        descendants.add(d);
                    }
                }
                return descendants;
            }

            isShapePlatformCollision(dataA, dataB) {
                const shapeTypes = ['shape', 'compound', 'rectangle', 'polygon', 'circle'];
                const isAShape = shapeTypes.includes(dataA.type);
                const isBShape = shapeTypes.includes(dataB.type);
                
                return (isAShape && dataB.type === 'platform') ||
                       (dataA.type === 'platform' && isBShape);
            }

            isShapeShapeCollision(dataA, dataB) {
                const shapeTypes = ['shape', 'compound', 'rectangle', 'polygon', 'circle'];
                const isAShape = shapeTypes.includes(dataA.type);
                const isBShape = shapeTypes.includes(dataB.type);
                
                return isAShape && isBShape;
            }

            isGroundCollision(dataA, dataB) {
                // More robust shape type detection
                const shapeTypes = ['shape', 'compound', 'rectangle', 'polygon', 'circle'];
                const isAShape = shapeTypes.includes(dataA.type) || dataA.shapeType;
                const isBShape = shapeTypes.includes(dataB.type) || dataB.shapeType;
                
                // Check for ground collision
                const isAGround = dataA.type === 'ground' || dataA.name === 'fallDetectionBoundary';
                const isBGround = dataB.type === 'ground' || dataB.name === 'fallDetectionBoundary';
                
                const result = (isAShape && isBGround) || (isAGround && isBShape);
                              
                if (result) {
                    console.log(`üéØ Ground collision detected: ${dataA.type || dataA.shapeType || 'unknown'} vs ${dataB.type || dataB.shapeType || 'unknown'}`);
                    console.log(`  - A: type="${dataA.type}", shapeType="${dataA.shapeType}", name="${dataA.name}"`);
                    console.log(`  - B: type="${dataB.type}", shapeType="${dataB.shapeType}", name="${dataB.name}"`);
                } else {
                    console.log(`‚ùå Not a ground collision: A(${dataA.type || dataA.shapeType || 'unknown'}) vs B(${dataB.type || dataB.shapeType || 'unknown'})`);
                }
                
                return result;
            }

            onShapeLandedOnPlatform(bodyA, bodyB) {
                console.log('üéØ Shape landed on platform!');
                this.showEventNotification('Shape Landed!', 'collision');
                
                // Phase 3: Trigger platform landing animation
                this.triggerCollisionAnimation(bodyA, bodyB, 'platform');
                
                // Trigger game event
                if (window.gameManager) {
                    window.gameManager.onShapeLandedOnPlatform();
                }
            }

            onShapeShapeCollision(bodyA, bodyB) {
                console.log('üîÑ Shape collision detected!');
                this.showEventNotification('Shape Contact!', 'balance');
                
                // Phase 3: Trigger collision flash animation
                this.triggerCollisionAnimation(bodyA, bodyB, 'collision');
                
                // Trigger game event
                if (window.gameManager) {
                    window.gameManager.onShapeCollision();
                }
            }

            // Phase 3: Animation trigger helper - PixiJS removed
            triggerCollisionAnimation(bodyA, bodyB, animationType) {
                // PixiJS animation system removed - no animations available
                console.log(`üé¨ Animation skipped: ${animationType} (PixiJS removed)`);
                return;
            }

            findShapeBody(bodyA, bodyB) {
                // Return the body that represents a shape (not platform/ground/boundary)
                const userDataA = bodyA.userData || {};
                const userDataB = bodyB.userData || {};
                
                if (userDataA.shapeType && userDataA.type !== 'platform' && userDataA.type !== 'ground' && userDataA.type !== 'boundary') {
                    return bodyA;
                }
                
                if (userDataB.shapeType && userDataB.type !== 'platform' && userDataB.type !== 'ground' && userDataB.type !== 'boundary') {
                    return bodyB;
                }
                
                return null;
            }

            onShapeFellOffPlatform(bodyA, bodyB) {
                console.log('üí• Shape fell off platform!');
                this.fallCount++;
                
                this.showEventNotification('Shape Fell!', 'fall');
                
                // Trigger game event
                if (window.gameManager) {
                    window.gameManager.onShapeFell();
                }
            }

            showEventNotification(message, type) {
                const notification = document.getElementById('eventNotification');
                notification.textContent = message;
                notification.className = `event-notification ${type} show`;
                
                setTimeout(() => {
                    notification.classList.remove('show');
                }, 2000);
            }

            resizeCanvas() {
                const container = this.canvas.parentElement;
                this.canvas.width = container.clientWidth;
                this.canvas.height = container.clientHeight;
                console.log(`üìê Canvas resized to: ${this.canvas.width}x${this.canvas.height}`);
            }

            createBoundaries() {
                // Create invisible ground boundary for fall detection
                const groundY = this.canvas.height + 150; // Extended to +150 (was +50) for longer fall distance
                const groundWidth = this.canvas.width;
                
                const ground = this.Bodies.rectangle(
                    this.canvas.width / 2, 
                    groundY, 
                    groundWidth, 
                    100, 
                    {
                        isStatic: true,
                        render: { visible: false }
                    }
                );
                
                // Set user data for collision detection
                ground.userData = {
                    type: 'ground',
                    name: 'fallDetectionBoundary'
                };
                
                this.World.add(this.world, ground);
                console.log('üöß Matter.js boundaries created');
            }

            createPlatform() {
                // Restore original angled platform (-50 degrees)
                const platformX = this.canvas.width / 2 - 30;  // Pixel coordinates
                const platformY = this.canvas.height - 20;     // Moved down 100px (was -120, now -20)
                const platformWidth = 200;
                const platformHeight = 20;
                const platformAngle = -0.873; // -50 degrees
                
                // Create angled platform with Matter.js
                const platform = this.Bodies.rectangle(
                    platformX, 
                    platformY, 
                    platformWidth, 
                    platformHeight,
                    {
                        isStatic: true,
                        angle: platformAngle,
                        render: {
                            fillStyle: '#95A5A6',
                            strokeStyle: '#7F8C8D',
                            lineWidth: 2
                        },
                        friction: 0.9,
                        restitution: 0
                    }
                );
                
                // Set user data for collision detection
                platform.userData = {
                    type: 'platform',
                    visible: true,
                    color: '#95A5A6',
                    stroke: '#7F8C8D',
                    strokeWidth: 2,
                    width: platformWidth,
                    height: platformHeight
                };
                
                this.World.add(this.world, platform);
                console.log(`üèóÔ∏è Matter.js angled platform created: -50¬∞ at (${platformX}, ${platformY})`);
            }

            /**
             * Clear all existing platforms from the physics world.
             */
            clearAllPlatforms() {
                if (!this.platformBodies) {
                    this.platformBodies = [];
                }
                this.platformBodies.forEach((body) => {
                    this.World.remove(this.world, body);
                    this.cleanupRemovedShapeFromWeighted(body.id);
                });
                this.platformBodies = [];
                console.log('üßπ Cleared all existing platforms.');
            }

            /**
             * Create a platform from the provided data configuration.
             * Supports position, scale, rotation, and fallback appearance color.
             * @param {Object} platformData
             */
            createPlatformFromData(platformData) {
                const pos = platformData.transform.position;
                const scale = platformData.transform.scale || { x: 1, y: 1 };
                const rotationDeg = platformData.transform.rotation || 0;
                const rotationRad = rotationDeg * (Math.PI / 180);
                const width = 200 * scale.x;
                const height = 20 * scale.y;
                const platform = this.Bodies.rectangle(
                    pos.x,
                    pos.y,
                    width,
                    height,
                    {
                        isStatic: true,
                        angle: rotationRad,
                        render: {
                            fillStyle: platformData.appearance?.fallbackColor || '#95A5A6',
                            strokeStyle: '#7F8C8D',
                            lineWidth: 2
                        },
                        friction: 0.9,
                        restitution: 0
                    }
                );
                platform.userData = {
                    type: 'platform',
                    id: platformData.id,
                    ...platformData
                };
                this.World.add(this.world, platform);
                if (!this.platformBodies) this.platformBodies = [];
                this.platformBodies.push(platform);
            }

            createCompoundShape(x, y, type, rotation = 0, shapeId = null) {
                // Forward to unified createShape method for consistency
                return this.createShape(x, y, type, rotation, shapeId);
            }

            createShape(x, y, type, rotation = 0, shapeId = null) {
                console.log(`üéØ Creating shape using unified system: ${type} at (${x}, ${y})`);

                // Get dock slot data FIRST to determine userData
                let dockSlotData = null;
                if (shapeId) {
                    dockSlotData = this.gameManager.levelData.dock.slots.find(slot => slot.shapeId === shapeId);
                } else {
                    // Fallback for old behavior (e.g. keyboard shortcuts for testing)
                    dockSlotData = this.gameManager.levelData.dock.slots.find(slot => slot.shapePrefabId === type && !this.dynamicBodies.some(b => b.userData.shapeId === slot.shapeId));
                }

                // Prepare userData BEFORE creating the body
                const shapeUserData = {
                    type: 'shape',
                    shapeType: type,
                    shapeId: dockSlotData?.shapeId || `shape_${Date.now()}`,
                    specialType: dockSlotData?.specialType || { type: 'REGULAR' }
                };

                // Use unified shape creation from master registry
                let body = this.createShapeFromRegistry(x, y, type, rotation, shapeUserData);

                if (!body) {
                    console.error(`‚ùå UNIFIED SYSTEM FAILED: Could not create shape ${type} - this should not happen!`);
                    return null;
                }

                // Get physics properties from master registry
                const physics = ShapeAttributePropagator.getPhysics(type);
                if (!physics) {
                    console.error(`‚ùå UNIFIED SYSTEM FAILED: No physics properties found for ${type}`);
                    return null;
                }
                
                // Set Matter.js physics properties from master registry
                body.restitution = physics.restitution;
                body.friction = physics.friction;       
                body.frictionAir = 0.02;   // Reduced air resistance to maintain manual rotation
                
                // Stabilize rotation for a brief moment after drop
                const originalAngularVelocity = body.angularVelocity;
                body.angularVelocity = 0; // Stop any spinning from collision
                
                // After a short delay, allow normal physics
                setTimeout(() => {
                    if (body && body.angularVelocity === 0) {
                        body.frictionAir = 0.05; // Restore normal air resistance
                    }
                }, 100); // Brief stabilization period

                // Initialize special type states
                if (body.userData.specialType.type === 'TIMER') {
                    body.userData.timerState = {
                        countdown: body.userData.specialType.countdownSeconds,
                        initialCountdown: body.userData.specialType.countdownSeconds,
                        isTicking: false
                    };
                }
                if (body.userData.specialType.type === 'WEIGHTED') {
                    const weightedConfig = body.userData.specialType;
                    const maxWeight = (typeof weightedConfig.maxWeight === 'number' && weightedConfig.maxWeight > 0)
                        ? weightedConfig.maxWeight
                        : WEIGHTED_DEFAULTS.maxWeight;
                    const overloadDelay = (typeof weightedConfig.overloadDelayMs === 'number' && weightedConfig.overloadDelayMs >= 0)
                        ? weightedConfig.overloadDelayMs
                        : WEIGHTED_DEFAULTS.overloadDelayMs;

                    weightedConfig.maxWeight = maxWeight;
                    weightedConfig.overloadDelayMs = overloadDelay;
                    weightedConfig.indicatorColors = {
                        ...WEIGHTED_DEFAULTS.indicatorColors,
                        ...(weightedConfig.indicatorColors || {})
                    };

                    body.userData.weightState = {
                        currentWeight: 0,
                        status: 'safe',
                        maxWeight,
                        overweightTimer: 0,
                        overloadActive: false
                    };
                    console.log(`‚öñÔ∏è Weighted shape initialized with Max Weight ${maxWeight} and overload delay ${(overloadDelay / 1000).toFixed(2)}s.`);
                    if (body.userData.specialType?.type === 'WEIGHTED') {
                        // Initialize shapes tracking
                        body.userData.shapesOnTop = new Set();
                        console.log(`‚öñÔ∏è Initialized collision tracking for weighted shape`);
                    }
                }
                console.log(`üè∑Ô∏è Shape userData set:`, body.userData);

                this.World.add(this.world, body);
                this.dynamicBodies.push(body);

                console.log(`‚úÖ Matter.js ${type} created successfully`);
                return body;
            }

            createMatterCompoundShape(x, y, type, rotation, config) {
                console.log(`üéØ Creating Matter.js compound shape: ${type} using SHAPE_CONFIG`);
                
                if (!config.parts || config.parts.length === 0) {
                    console.error(`‚ùå No parts defined for compound shape: ${type}`);
                    return null;
                }
                
                const bodyParts = [];
                
                // Create each part based on SHAPE_CONFIG specification
                config.parts.forEach((partConfig, index) => {
                    // Use relative positioning for compound body parts
                    const partX = x + (partConfig.offsetX || 0);
                    const partY = y + (partConfig.offsetY || 0);
                    let bodyPart = null;
                    
                    if (partConfig.type === 'rectangle') {
                        bodyPart = this.Bodies.rectangle(partX, partY, partConfig.width, partConfig.height, {
                            render: {
                                fillStyle: partConfig.color || config.color,
                                strokeStyle: partConfig.stroke || config.stroke,
                                lineWidth: config.strokeWidth || 2
                            }
                        });
                    } else if (partConfig.type === 'circle') {
                        bodyPart = this.Bodies.circle(partX, partY, partConfig.radius, {
                            render: {
                                fillStyle: partConfig.color || config.color,
                                strokeStyle: partConfig.stroke || config.stroke,
                                lineWidth: config.strokeWidth || 2
                            }
                        });
                    } else if (partConfig.type === 'diamond') {
                        // Create diamond as a rotated square
                        // For a diamond with width/height, we need to calculate the proper radius
                        const width = partConfig.width || 12;
                        const height = partConfig.height || 12;
                        // Use the smaller dimension and adjust for the rotated square geometry
                        const effectiveSize = Math.min(width, height);
                        const radius = effectiveSize / 2; // Half the size for proper diamond dimensions
                        
                        bodyPart = this.Bodies.polygon(partX, partY, 4, radius, {
                            angle: Math.PI / 4, // 45 degree rotation for diamond
                            render: {
                                fillStyle: partConfig.color || config.color,
                                strokeStyle: partConfig.stroke || config.stroke,
                                lineWidth: config.strokeWidth || 2
                            }
                        });
                    }
                    
                    if (bodyPart) {
                        bodyParts.push(bodyPart);
                        console.log(`‚úÖ Created ${partConfig.type} part at offset (${partConfig.offsetX}, ${partConfig.offsetY})`);
                    }
                });
                
                if (bodyParts.length === 0) {
                    console.error(`‚ùå No body parts created for compound shape: ${type}`);
                    return null;
                }
                
                // Create compound body and then rotate it smoothly
                const compoundBody = this.Body.create({
                    parts: bodyParts
                });
                
                // Apply rotation after creation to prevent snapping
                if (rotation !== 0) {
                    this.Body.setAngle(compoundBody, rotation);
                }
                
                // CRITICAL: Set userData on compound body AND all parts
                const userData = {
                    type: 'compound',
                    shapeType: type,
                    ...config
                };
                
                compoundBody.userData = userData;
                
                // Also set userData on all parts so collision detection works
                bodyParts.forEach(part => {
                    part.userData = userData;
                });
                
                console.log(`üè∑Ô∏è Compound shape userData set on main body and ${bodyParts.length} parts:`, userData);
                console.log(`‚úÖ Matter.js compound shape ${type} created with ${bodyParts.length} parts, rotated ${(rotation * 180 / Math.PI).toFixed(1)}¬∞`);
                return compoundBody;
            }

            createMatterSimpleShape(x, y, type, rotation, config) {
                console.log(`üéØ Creating Matter.js simple shape: ${type}`);
                
                let body = null;

                // Create shape based on type
                if (type === 'square') {
                    body = this.Bodies.rectangle(x, y, config.width || 50, config.height || 50, {
                        angle: rotation,
                        render: {
                            fillStyle: config.color || '#FFD700',
                            strokeStyle: config.stroke || '#FFA500',
                            lineWidth: config.strokeWidth || 2
                        }
                    });
                } else if (type === 'triangle') {
                    // Create triangle using polygon but fix the default orientation
                    // Matter.js Bodies.polygon(x, y, 3, radius) creates triangle with different default rotation
                    const sides = 3;
                    const radius = 20; // Match approximate size of our config vertices
                    
                    // Add Math.PI/2 (90 degrees) to align with our triangle config (point up)
                    const adjustedRotation = rotation + Math.PI/2;
                    
                    body = this.Bodies.polygon(x, y, sides, radius, {
                        angle: adjustedRotation,
                        render: {
                            fillStyle: config.color || '#9B59B6',
                            strokeStyle: config.stroke || '#8E44AD',
                            lineWidth: config.strokeWidth || 2
                        }
                    });
                    
                    console.log(`üî∫ Triangle created with 90¬∞ adjustment, final rotation ${(adjustedRotation * 180 / Math.PI).toFixed(1)}¬∞`);
                } else if (type === 'circle') {
                    body = this.Bodies.circle(x, y, config.radius || 25, {
                        render: {
                            fillStyle: config.color || '#1ABC9C',
                            strokeStyle: config.stroke || '#16A085',
                            lineWidth: config.strokeWidth || 2
                        }
                    });
                }

                if (body) {
                    // Set userData on simple shape body  
                    body.userData = {
                        type: config.type || 'rectangle', // Use config type (rectangle, polygon, circle)
                        shapeType: type,
                        ...config
                    };
                    console.log(`üè∑Ô∏è Simple shape userData set:`, body.userData);
                }

                console.log(`‚úÖ Matter.js simple shape ${type} created`);
                return body;
            }

            // Unified shape creation using master registry
            createShapeFromRegistry(x, y, shapeType, rotation = 0, userData = null) {
                console.log(`üéØ Creating shape from master registry: ${shapeType}`);
                
                // Debug: Check if MASTER_SHAPE_REGISTRY exists and has the shape
                if (!MASTER_SHAPE_REGISTRY) {
                    console.error(`‚ùå MASTER_SHAPE_REGISTRY is not defined!`);
                    return null;
                }
                
                if (!MASTER_SHAPE_REGISTRY[shapeType]) {
                    console.error(`‚ùå Shape type '${shapeType}' not found in master registry. Available shapes:`, Object.keys(MASTER_SHAPE_REGISTRY));
                    return null;
                }
                
                const masterConfig = MASTER_SHAPE_REGISTRY[shapeType];
                console.log(`üîç DEBUG: Master config for ${shapeType}:`, masterConfig);

                const geometry = masterConfig.geometry;
                const physics = masterConfig.physics;
                const visual = masterConfig.visual;
                
                if (!geometry || !physics || !visual) {
                    console.error(`‚ùå Incomplete master config for ${shapeType}:`, { geometry, physics, visual });
                    return null;
                }
                
                // Get themed visual properties (colors/textures) for current theme
                const themedShapeConfig = getShapeConfig(shapeType);
                const themedVisual = {
                    color: themedShapeConfig?.color || visual.color,
                    stroke: themedShapeConfig?.stroke || visual.stroke,
                    strokeWidth: themedShapeConfig?.strokeWidth || visual.strokeWidth
                };
                
                console.log(`üé® Using themed visual for ${shapeType}:`, themedVisual);
                
                let body = null;

                // Create physics body based on geometry type
                console.log(`üîç DEBUG: Creating ${geometry.type} body for ${shapeType}`);
                switch (geometry.type) {
                    case 'rectangle':
                        body = this.Bodies.rectangle(x, y, geometry.width, geometry.height, {
                            angle: rotation,
                            density: physics.density,
                            friction: physics.friction,
                            restitution: physics.restitution,
                            render: {
                                fillStyle: themedVisual.color,
                                strokeStyle: themedVisual.stroke,
                                lineWidth: themedVisual.strokeWidth
                            }
                        });
                        break;

                    case 'circle':
                        body = this.Bodies.circle(x, y, geometry.radius, {
                            angle: rotation,
                            density: physics.density,
                            friction: physics.friction,
                            restitution: physics.restitution,
                            render: {
                                fillStyle: themedVisual.color,
                                strokeStyle: themedVisual.stroke,
                                lineWidth: themedVisual.strokeWidth
                            }
                        });
                        break;

                    case 'polygon':
                        if (geometry.vertices) {
                            // Create from vertices (like triangle)
                            body = this.Bodies.fromVertices(x, y, [geometry.vertices], {
                                angle: rotation,
                                density: physics.density,
                                friction: physics.friction,
                                restitution: physics.restitution,
                                render: {
                                    fillStyle: themedVisual.color,
                                    strokeStyle: themedVisual.stroke,
                                    lineWidth: themedVisual.strokeWidth
                                }
                            });
                        }
                        break;

                    case 'compound':
                        if (geometry.parts) {
                            body = this.createCompoundFromRegistry(x, y, shapeType, rotation, masterConfig, themedVisual, userData);
                        }
                        break;

                    default:
                        console.error(`‚ùå Unsupported geometry type: ${geometry.type}`);
                        return null;
                }

                if (body) {
                    // Set userData - use provided userData or create fallback
                    if (userData) {
                        body.userData = userData;
                        console.log(`üè∑Ô∏è Applied provided userData to ${shapeType}:`, userData);
                    } else {
                        // Fallback for backward compatibility
                        body.userData = {
                            shapeType: shapeType,
                            type: geometry.type,
                            geometry: { ...geometry },
                            physics: { ...physics },
                            visual: { ...themedVisual }  // Use themed visual
                        };
                        console.log(`üè∑Ô∏è Applied fallback userData to ${shapeType}`);
                    }

                    console.log(`‚úÖ Unified shape ${shapeType} created from master registry with theme colors`);
                } else {
                    console.error(`‚ùå Failed to create shape ${shapeType} from master registry`);
                }

                return body;
            }

            // Create compound shape from master registry
            createCompoundFromRegistry(x, y, shapeType, rotation, masterConfig, themedVisual, userData = null) {
                const geometry = masterConfig.geometry;
                const physics = masterConfig.physics;
                const visual = themedVisual || masterConfig.visual; // Use themed visual if provided
                const bodyParts = [];

                // Create each part using master registry specifications
                geometry.parts.forEach((partSpec, index) => {
                    const partX = x + (partSpec.offsetX || 0);
                    const partY = y + (partSpec.offsetY || 0);
                    let bodyPart = null;

                    switch (partSpec.type) {
                        case 'rectangle':
                            bodyPart = this.Bodies.rectangle(partX, partY, partSpec.width, partSpec.height, {
                                density: physics.density,
                                friction: physics.friction,
                                restitution: physics.restitution,
                                render: {
                                    fillStyle: visual.color,
                                    strokeStyle: visual.stroke,
                                    lineWidth: visual.strokeWidth
                                }
                            });
                            break;

                        case 'circle':
                            bodyPart = this.Bodies.circle(partX, partY, partSpec.radius, {
                                density: physics.density,
                                friction: physics.friction,
                                restitution: physics.restitution,
                                render: {
                                    fillStyle: visual.color,
                                    strokeStyle: visual.stroke,
                                    lineWidth: visual.strokeWidth
                                }
                            });
                            break;

                        case 'diamond':
                            // Use consistent diamond creation from master registry
                            const width = partSpec.width || 12;
                            const height = partSpec.height || 12;
                            const effectiveSize = Math.min(width, height);
                            const radius = effectiveSize / 2;
                            
                            bodyPart = this.Bodies.polygon(partX, partY, 4, radius, {
                                angle: Math.PI / 4, // 45 degree rotation for diamond
                                density: physics.density,
                                friction: physics.friction,
                                restitution: physics.restitution,
                                render: {
                                    fillStyle: visual.color,
                                    strokeStyle: visual.stroke,
                                    lineWidth: visual.strokeWidth
                                }
                            });
                            break;

                        default:
                            console.warn(`‚ö†Ô∏è Unsupported part type: ${partSpec.type}`);
                            break;
                    }

                    if (bodyPart) {
                        bodyParts.push(bodyPart);
                        console.log(`‚úÖ Created ${partSpec.type} part for ${shapeType} with themed colors`);
                    }
                });

                if (bodyParts.length === 0) {
                    console.error(`‚ùå No parts created for compound shape: ${shapeType}`);
                    return null;
                }

                // Create compound body
                const compoundBody = this.Body.create({
                    parts: bodyParts
                });

                // Apply physics properties to compound body
                this.Body.setDensity(compoundBody, physics.density);
                compoundBody.friction = physics.friction;
                compoundBody.restitution = physics.restitution;

                // Apply rotation to the entire compound body after creation
                if (rotation !== 0) {
                    this.Body.setAngle(compoundBody, rotation);
                }

                // Set userData for compound body
                if (userData) {
                    compoundBody.userData = userData;
                    console.log(`üè∑Ô∏è Applied provided userData to compound ${shapeType}:`, userData);
                    
                    // CRITICAL FIX: Apply userData to all parts of the compound body
                    // Access the parts from the compound body's parts array
                    if (compoundBody.parts && compoundBody.parts.length > 1) {
                        // Skip index 0 as it's the main body itself
                        for (let i = 1; i < compoundBody.parts.length; i++) {
                            const part = compoundBody.parts[i];
                            part.userData = { ...userData, partIndex: i };
                            console.log(`üè∑Ô∏è Applied userData to part ${i} of compound ${shapeType}:`, part.userData);
                        }
                    }
                } else {
                    // Fallback for backward compatibility
                    const fallbackUserData = {
                        shapeType: shapeType,
                        type: 'compound',
                        geometry: { ...geometry },
                        physics: { ...physics },
                        visual: { ...visual }
                    };
                    compoundBody.userData = fallbackUserData;
                    console.log(`üè∑Ô∏è Applied fallback userData to compound ${shapeType}`);
                    
                    // Apply fallback userData to all parts
                    if (compoundBody.parts && compoundBody.parts.length > 1) {
                        for (let i = 1; i < compoundBody.parts.length; i++) {
                            const part = compoundBody.parts[i];
                            part.userData = { ...fallbackUserData, partIndex: i };
                            console.log(`üè∑Ô∏è Applied fallback userData to part ${i} of compound ${shapeType}`);
                        }
                    }
                }

                return compoundBody;
            }

            startRenderLoop() {
                let lastTime = 0;
                let frameSkipCounter = 0;
                const targetFPS = 60;
                const minFPS = 30;
                const maxFrameTime = 1000 / minFPS; // 33.33ms
                
                // Cache for gradients and patterns to avoid recreation
                this.renderCache = {
                    gradients: new Map(),
                    patterns: new Map(),
                    lastCacheCleanup: 0
                };
                
                const render = (currentTime) => {
                    const deltaTime = currentTime - lastTime;
                    
                    // Frame skipping for performance when FPS drops below 30
                    if (deltaTime < maxFrameTime || frameSkipCounter === 0) {
                        lastTime = currentTime;
                        frameSkipCounter = 0;

                        // Update camera shake
                        this.updateCameraShake(deltaTime);

                        this.updateSpecialShapes(deltaTime);
                        this.updateExplosionTimers(deltaTime);
                        
                        // Update pulse states for all pulsing shapes
                        this.updatePulseStates(performance.now());

                        // Step Matter.js physics simulation
                        this.Engine.update(this.engine, 1000 / 60); // 60 FPS
                        
                        // Clear canvas (optimized with dirty rectangle if possible)
                        this.clearCanvas();
                        
                        // Enhanced rendering with themes (no camera shake transforms needed)
                        this.renderBackground();
                        this.renderWorld();
                        this.particleSystem.update(16); // ~16ms per frame at 60fps
                        this.particleSystem.render();
                    } else {
                        // Skip frame but increment counter
                        frameSkipCounter++;
                        if (frameSkipCounter > 2) { // Don't skip more than 2 consecutive frames
                            frameSkipCounter = 0;
                        }
                    }
                    
                    // Clean cache periodically (every 5 seconds)
                    if (currentTime - this.renderCache.lastCacheCleanup > 5000) {
                        this.cleanRenderCache();
                        this.renderCache.lastCacheCleanup = currentTime;
                    }
                    
                    requestAnimationFrame(render);
                };
                render(performance.now());
                console.log('üé¨ Optimized Matter.js render loop with frame skipping and caching started');
            }
            
            // Optimized canvas clearing with dirty rectangle support
            clearCanvas() {
                // For now, clear entire canvas (dirty rectangle optimization would require tracking changed areas)
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            }
            
            // Clean up cached gradients and patterns
            cleanRenderCache() {
                // Keep cache size reasonable
                if (this.renderCache.gradients.size > 50) {
                    this.renderCache.gradients.clear();
                }
                if (this.renderCache.patterns.size > 20) {
                    this.renderCache.patterns.clear();
                }
                debugLog('üßπ Render cache cleaned');
            }
            
            // Get or create cached gradient
            getCachedGradient(key, createFn) {
                if (!this.renderCache.gradients.has(key)) {
                    this.renderCache.gradients.set(key, createFn());
                }
                return this.renderCache.gradients.get(key);
            }
            
            // Get or create cached pattern
            getCachedPattern(key, createFn) {
                if (!this.renderCache.patterns.has(key)) {
                    this.renderCache.patterns.set(key, createFn());
                }
                return this.renderCache.patterns.get(key);
            }

            // Enhanced background rendering with theme support
            renderBackground() {
                // Clear the canvas background
                this.clearCanvas();
                
                // Get current theme
                const currentTheme = this.assetManager?.getCurrentTheme();
                if (!currentTheme) {
                    // Fallback: render simple gradient
                    this.renderFallbackBackground();
                    return;
                }

                const backgroundConfig = currentTheme.config?.background;
                
                if (backgroundConfig?.type === 'image' && backgroundConfig.image?.url && !backgroundConfig.loadFailed) {
                    // Background image is handled by CSS, but we can add canvas effects if needed
                    this.renderCanvasBackgroundEffects(backgroundConfig);
                } else if (backgroundConfig?.type === 'pattern' && backgroundConfig.pattern?.style) {
                    // Pattern background is handled by CSS, but we can add canvas effects if needed
                    this.renderCanvasBackgroundEffects(backgroundConfig);
                } else if (backgroundConfig?.type === 'gradient') {
                    // Gradient is handled by CSS, but we can add canvas effects if needed
                    this.renderCanvasBackgroundEffects(backgroundConfig);
                } else {
                    // Render fallback on canvas
                    this.renderFallbackBackground(backgroundConfig?.fallbackColor);
                }
            }

            // Helper method for canvas background effects over CSS backgrounds
            renderCanvasBackgroundEffects(backgroundConfig) {
                // This method can be used to add additional canvas-based effects
                // over the CSS background, such as particles, overlays, or animations
                
                // Example: Add subtle texture overlay
                if (backgroundConfig.canvasOverlay) {
                    this.ctx.save();
                    this.ctx.globalAlpha = 0.1;
                    this.ctx.fillStyle = backgroundConfig.canvasOverlay;
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                    this.ctx.restore();
                }
            }

            // Helper method for fallback background rendering
            renderFallbackBackground(fallbackColor = '#2c3e50') {
                // Render a simple background when theme loading fails
                this.ctx.save();
                this.ctx.fillStyle = fallbackColor;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.restore();
            }

            // Render background image
            renderBackgroundImage(backgroundStyle) {
                const image = backgroundStyle.image;
                const config = backgroundStyle.imageConfig;
                
                this.ctx.save();
                
                // Apply image based on configuration
                switch(config.size) {
                    case 'cover':
                        this.drawImageCover(image);
                        break;
                    case 'contain':
                        this.drawImageContain(image);
                        break;
                    case 'auto':
                        this.ctx.drawImage(image, 0, 0);
                        break;
                    default: // "100% 100%" or similar
                        this.ctx.drawImage(image, 0, 0, this.canvas.width, this.canvas.height);
                }
                
                // If there are gradient colors too, overlay them with reduced opacity
                if (backgroundStyle.colors && backgroundStyle.colors.length >= 2) {
                    this.ctx.globalAlpha = 0.3; // Reduce opacity for overlay
                    this.renderBackgroundGradient(backgroundStyle);
                }
                
                this.ctx.restore();
            }

            // Helper to draw image with 'cover' behavior
            drawImageCover(image) {
                const canvasRatio = this.canvas.width / this.canvas.height;
                const imageRatio = image.width / image.height;
                
                let drawWidth, drawHeight, drawX, drawY;
                
                if (imageRatio > canvasRatio) {
                    // Image is wider than canvas ratio
                    drawHeight = this.canvas.height;
                    drawWidth = drawHeight * imageRatio;
                    drawX = (this.canvas.width - drawWidth) / 2;
                    drawY = 0;
                } else {
                    // Image is taller than canvas ratio
                    drawWidth = this.canvas.width;
                    drawHeight = drawWidth / imageRatio;
                    drawX = 0;
                    drawY = (this.canvas.height - drawHeight) / 2;
                }
                
                this.ctx.drawImage(image, drawX, drawY, drawWidth, drawHeight);
            }

            // Helper to draw image with 'contain' behavior
            drawImageContain(image) {
                const canvasRatio = this.canvas.width / this.canvas.height;
                const imageRatio = image.width / image.height;
                
                let drawWidth, drawHeight, drawX, drawY;
                
                if (imageRatio > canvasRatio) {
                    // Fit to canvas width
                    drawWidth = this.canvas.width;
                    drawHeight = drawWidth / imageRatio;
                    drawX = 0;
                    drawY = (this.canvas.height - drawHeight) / 2;
                } else {
                    // Fit to canvas height
                    drawHeight = this.canvas.height;
                    drawWidth = drawHeight * imageRatio;
                    drawX = (this.canvas.width - drawWidth) / 2;
                    drawY = 0;
                }
                
                this.ctx.drawImage(image, drawX, drawY, drawWidth, drawHeight);
            }

            // Render gradient background (extracted from previous method) - Optimized with caching
            renderBackgroundGradient(backgroundStyle) {
                const colors = backgroundStyle.colors;
                if (!colors || colors.length < 2) return;

                // Create cache key for this gradient
                const gradientKey = `bg_${colors.join('_')}_${this.canvas.width}x${this.canvas.height}`;
                
                // Use cached gradient or create new one
                const gradient = this.getCachedGradient(gradientKey, () => {
                    const grad = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
                    const colorStep = 1 / (colors.length - 1);
                    colors.forEach((color, index) => {
                        grad.addColorStop(index * colorStep, color);
                    });
                    return grad;
                });
                
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            }

            // Add subtle texture to background
            renderBackgroundTexture() {
                const currentTheme = this.assetManager.getCurrentTheme();
                if (!currentTheme) {
                    debugLog('üö´ No current theme found for background texture');
                    return;
                }
                
                // Only log texture details when theme changes, not every frame
                if (!this._lastLoggedTextureTheme || this._lastLoggedTextureTheme !== currentTheme.config?.name) {
                    debugLog(`üé® Background texture - Theme: ${currentTheme.config?.name}, Material: ${currentTheme.config?.platform?.material}`);
                    this._lastLoggedTextureTheme = currentTheme.config?.name;
                }
                
                this.ctx.save();
                this.ctx.globalAlpha = 0.1;
                
                // Add theme-specific background patterns
                const material = currentTheme.config.platform.material;
                
                // Debug log material detection when theme changes
                if (!this._lastLoggedTextureTheme || this._lastLoggedTextureTheme !== currentTheme.config?.name) {
                    console.log(`üîç Material detected: '${material}' for theme '${currentTheme.config?.name}'`);
                }
                
                switch(material) {
                    case 'wood':
                        if (this._lastLoggedTextureTheme === currentTheme.config?.name) {
                           // console.log('üå≥ Rendering wood texture background');
                        }
                        this.renderWoodTexture();
                        break;
                    case 'metal':
                        if (!this._lastLoggedTextureTheme || this._lastLoggedTextureTheme !== currentTheme.config?.name) {
                            debugLog('üî© Rendering metal texture background (corrugated)');
                        }
                        this.renderMetalTexture();
                        break;
                    case 'steel':  // Added steel material for Metal theme
                        if (!this._lastLoggedTextureTheme || this._lastLoggedTextureTheme !== currentTheme.config?.name) {
                            debugLog('üî© Rendering steel texture background (corrugated)');
                        }
                        this.renderMetalTexture();
                        break;
                    case 'coral':
                        if (this._lastLoggedTextureTheme === currentTheme.config?.name) {
                            debugLog('ü™∏ Rendering coral texture background');
                        }
                        this.renderCoralTexture();
                        break;
                    default:
                        if (!this._lastLoggedTextureTheme || this._lastLoggedTextureTheme !== currentTheme.config?.name) {
                            debugLog(`üî≤ Rendering default geometric texture (material: '${material}')`);
                        }
                        this.renderGeometricTexture();
                }
                
                this.ctx.restore();
            }

            renderWoodTexture() {
                // Simple wood grain effect
                this.ctx.strokeStyle = '#8B4513';
                this.ctx.lineWidth = 0.5;
                for (let i = 0; i < 20; i++) {
                    const y = (this.canvas.height / 20) * i;
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.canvas.width, y + Math.sin(i) * 5);
                    this.ctx.stroke();
                }
            }

            renderMetalTexture() {
                // Corrugated metal pattern with blue steel tones
                const corrugationWidth = 20;  // Increased width for better visibility
                const corrugationHeight = 4;   // Increased height
                
                this.ctx.save();
                this.ctx.globalAlpha = 0.25;  // Increased opacity for better visibility
                
                console.log(`üî© Creating corrugated metal pattern: ${this.canvas.width}x${this.canvas.height}`);
                
                // Create horizontal corrugated pattern
                for (let y = 0; y < this.canvas.height; y += corrugationWidth) {
                    // Light ridge
                    this.ctx.fillStyle = '#6495ED';
                    this.ctx.fillRect(0, y, this.canvas.width, corrugationHeight);
                    
                    // Dark valley
                    this.ctx.fillStyle = '#1E3A8A';
                    this.ctx.fillRect(0, y + corrugationHeight, this.canvas.width, corrugationHeight);
                    
                    // Medium transition
                    this.ctx.fillStyle = '#4682B4';
                    this.ctx.fillRect(0, y + corrugationHeight * 2, this.canvas.width, corrugationWidth - corrugationHeight * 2);
                }
                
                // Add subtle diagonal lines for extra texture
                this.ctx.globalAlpha = 0.1;
                this.ctx.strokeStyle = '#87CEEB';
                this.ctx.lineWidth = 1;  // Increased line width
                for (let i = -this.canvas.width; i < this.canvas.width + this.canvas.height; i += 30) {  // Increased spacing
                    this.ctx.beginPath();
                    this.ctx.moveTo(i, 0);
                    this.ctx.lineTo(i + this.canvas.height, this.canvas.height);
                    this.ctx.stroke();
                }
                
                debugLog('‚úÖ Metal texture pattern completed');
                this.ctx.restore();
            }

            renderCoralTexture() {
                // Organic bubble pattern
                this.ctx.fillStyle = '#2E8B57';
                for (let i = 0; i < 50; i++) {
                    const x = Math.random() * this.canvas.width;
                    const y = Math.random() * this.canvas.height;
                    const radius = Math.random() * 3 + 1;
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, radius, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }

            renderGeometricTexture() {
                // Simple dot pattern
                this.ctx.fillStyle = '#cccccc';
                for (let x = 10; x < this.canvas.width; x += 20) {
                    for (let y = 10; y < this.canvas.height; y += 20) {
                        this.ctx.beginPath();
                        this.ctx.arc(x, y, 1, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                }
            }

            // =============================================================================
            // CAMERA SHAKE SYSTEM
            // =============================================================================

            /**
             * Trigger camera shake effect
             * @param {number} intensity - Shake intensity (1-10)
             * @param {number} duration - Duration in milliseconds
             */
            startCameraShake(intensity = 5, duration = 500) {
                console.log(`üö® startCameraShake called with intensity=${intensity}, duration=${duration}ms`);
                
                this.cameraShake.active = true;
                this.cameraShake.intensity = intensity;
                this.cameraShake.duration = duration;
                this.cameraShake.elapsed = 0;
                this.cameraShake.frequencyX = 0.1 + Math.random() * 0.1; // Randomize frequency
                this.cameraShake.frequencyY = 0.1 + Math.random() * 0.1;
                
                console.log(`‚úÖ Camera shake activated - state:`, this.cameraShake);
                console.log(`üéØ Canvas element:`, this.canvas);
                
                // Immediate test shake to verify it works
                this.canvas.style.transform = `translate(${intensity}px, ${intensity}px)`;
                setTimeout(() => {
                    this.canvas.style.transform = 'translate(0px, 0px)';
                }, 100);
                
                console.log(`üìπ Camera shake started: intensity=${intensity}, duration=${duration}ms`);
            }

            /**
             * Update camera shake effect - applies shake directly to canvas element
             * @param {number} deltaTime - Time since last update
             */
            updateCameraShake(deltaTime) {
                if (!this.cameraShake.active) {
                    // Reset canvas position when not shaking
                    this.canvas.style.transform = 'translate(0px, 0px)';
                    return;
                }

                console.log(`üîÑ updateCameraShake: elapsed=${this.cameraShake.elapsed}, duration=${this.cameraShake.duration}, intensity=${this.cameraShake.intensity}`);

                this.cameraShake.elapsed += deltaTime;

                if (this.cameraShake.elapsed >= this.cameraShake.duration) {
                    // Shake finished
                    this.cameraShake.active = false;
                    this.canvas.style.transform = 'translate(0px, 0px)';
                    console.log('‚úÖ Camera shake completed');
                    return;
                }

                // Calculate shake progress (1.0 at start, 0.0 at end)
                const progress = 1.0 - (this.cameraShake.elapsed / this.cameraShake.duration);
                const currentIntensity = this.cameraShake.intensity * progress * progress; // Quadratic falloff

                // Generate shake offset using sine waves with different frequencies
                const time = this.cameraShake.elapsed * 0.01; // Convert to suitable time scale
                let offsetX = Math.sin(time * this.cameraShake.frequencyX * 50) * currentIntensity;
                let offsetY = Math.sin(time * this.cameraShake.frequencyY * 47) * currentIntensity; // Different frequency for variety

                // Add random jitter for more chaotic feel
                offsetX += (Math.random() - 0.5) * currentIntensity * 0.5;
                offsetY += (Math.random() - 0.5) * currentIntensity * 0.5;

                console.log(`üì≥ Applying shake: offsetX=${offsetX.toFixed(1)}, offsetY=${offsetY.toFixed(1)}, currentIntensity=${currentIntensity.toFixed(1)}`);

                // Apply transform to canvas element
                this.canvas.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
            }

            /**
             * Apply camera shake to canvas transform (legacy method - now unused)
             */
            applyCameraShake() {
                // This method is no longer used - shake is applied directly to canvas element
            }

            /**
             * Reset camera shake transform (legacy method - now unused)
             */
            resetCameraShake() {
                // This method is no longer used - shake is applied directly to canvas element
            }

            renderWorld() {
                // Render all Matter.js bodies in the world with optimizations
                const bodies = this.world.bodies;
                const canvasWidth = this.canvas.width;
                const canvasHeight = this.canvas.height;
                const padding = 50; // Extra padding for objects near edge
                
                // Single save/restore for all rendering operations
                this.ctx.save();
                
                for (let i = 0; i < bodies.length; i++) {
                    const body = bodies[i];
                    
                    // Frustum culling - skip off-screen bodies
                    if (this.isBodyOffScreen(body, canvasWidth, canvasHeight, padding)) {
                        continue;
                    }
                    
                    this.renderBody(body);
                    this.renderSpecialEffects(body);
                }
                
                this.ctx.restore();
            }
            
            // Check if a body is off-screen (frustum culling)
            isBodyOffScreen(body, canvasWidth, canvasHeight, padding) {
                const bounds = body.bounds;
                return (
                    bounds.max.x < -padding ||
                    bounds.min.x > canvasWidth + padding ||
                    bounds.max.y < -padding ||
                    bounds.min.y > canvasHeight + padding
                );
            }

            renderBody(body) {
                // Skip rendering invisible bodies
                if (body.render && body.render.visible === false) return;

                // Render Matter.js body parts directly (no coordinate transformation)
                if (body.parts && body.parts.length > 1) {
                    // Compound body - render each part separately
                    for (let i = 1; i < body.parts.length; i++) { // Skip first part (it's the parent)
                        this.renderMatterPart(body.parts[i], body);
                    }
                } else {
                    // Simple body - render directly
                    this.renderMatterPart(body, body);
                }
            }

            renderSpecialEffects(body) {
                const userData = body.userData || {};
                const specialType = userData.specialType?.type;
                if (!specialType) return;

                // This will act as a router for different effects
                switch (specialType) {
                    case 'FIRE':
                        // Spawn 1-2 flame particles per frame for a continuous effect
                        if (this.particleSystem && Math.random() > 0.4) { // 60% chance per frame
                            const flameStyle = { style: 'flame', colors: [] }; // Style object for the particle system
                            if (this.particleSystem.particles.length < this.particleSystem.maxParticles) {
                                this.particleSystem.particles.push(
                                    this.particleSystem.createParticle(flameStyle, body.position.x, body.position.y, 'flame')
                                );
                            }
                        }
                        break;
                    case 'TIMER':
                        this.drawTimerDecal(body);
                        break;
                    case 'WEIGHTED':
                        this.drawWeightedDecal(body);
                        break;
                }
            }

            drawWeightedDecal(body) {
                const ctx = this.ctx;
                const weightState = body.userData.weightState;
                const colors = body.userData.specialType?.indicatorColors;

                if (!weightState || !colors) return;

                const status = weightState.status || 'safe';

                let lightColor = colors.safe;
                if (status === 'warning') {
                    lightColor = colors.warning;
                } else if (status === 'danger') {
                    lightColor = colors.danger;
                } else if (status === 'overloaded') {
                    // Make the light flash when overloaded
                    const flash = Math.sin(performance.now() / 150) > 0;
                    lightColor = flash ? colors.danger : '#333'; // Flash between red and dark gray
                }
                
                ctx.save();
                ctx.translate(body.position.x, body.position.y);
                ctx.rotate(body.angle);

                // Draw traffic light body
                ctx.fillStyle = '#333';
                ctx.fillRect(-8, -4, 16, 8);
                
                // Draw the light
                ctx.beginPath();
                ctx.arc(0, 0, 5, 0, Math.PI * 2);
                ctx.fillStyle = lightColor;
                ctx.fill();
                ctx.strokeStyle = '#555';
                ctx.lineWidth = 1;
                ctx.stroke();

                ctx.restore();
            }

            drawTimerDecal(body) {
                const ctx = this.ctx;
                const timerState = body.userData.timerState;

                if (!timerState) return;

                ctx.save();
                ctx.translate(body.position.x, body.position.y);
                ctx.rotate(body.angle);

                // Draw stopwatch body
                ctx.beginPath();
                ctx.arc(0, 0, 8, 0, Math.PI * 2);
                ctx.fillStyle = '#E0E0E0';
                ctx.fill();
                ctx.strokeStyle = '#757575';
                ctx.lineWidth = 1.5;
                ctx.stroke();

                // Draw stopwatch plunger
                ctx.fillRect(-1.5, -11, 3, 3);

                let totalDuration = timerState.initialCountdown;
                if (typeof totalDuration !== 'number' || totalDuration <= 0) {
                    const fallback = body.userData.specialType?.countdownSeconds;
                    totalDuration = (typeof fallback === 'number' && fallback > 0) ? fallback : 1;
                }
                const remaining = Math.max(typeof timerState.countdown === 'number' ? timerState.countdown : totalDuration, 0);
                const elapsed = Math.min(Math.max(totalDuration - remaining, 0), totalDuration);
                const progress = totalDuration > 0 ? (elapsed / totalDuration) : 0;
                const needleAngle = timerState.isTicking ? progress * Math.PI * 2 : 0;

                ctx.save();
                ctx.rotate(needleAngle);
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(0, -6);
                ctx.lineWidth = 1;
                ctx.strokeStyle = timerState.isTicking ? '#d32f2f' : '#333';
                ctx.stroke();
                ctx.restore();

                ctx.restore();
            }

            renderMatterPart(part, parentBody) {
                // Get render properties from Matter.js body
                const render = part.render || {};
                const userData = parentBody.userData || {};
                
                // Skip invisible parts
                if (render.visible === false) return;
                
                // Theme-based color selection
                let fillColor = render.fillStyle || userData.color || '#95A5A6';
                let strokeColor = render.strokeStyle || userData.stroke || '#7F8C8D';

                // NEW: Add strobe effect for ticking fire shapes
                if (userData.explosionTimerId) {
                    // Flash between white and the original color
                    const flash = Math.floor(performance.now() / 100) % 2 === 0;
                    if (flash) {
                        fillColor = '#FFFFFF'; // White
                    }
                }
                
                // Apply theme colors for platform
                if (userData.type === 'platform' && this.platformColor) {
                    fillColor = this.platformColor;
                    strokeColor = this.darkenColor(this.platformColor, 20);
                }
                
                // Check for image textures
                let textureImage = null;
                let textureConfig = null;
                
                // Use consolidated AssetManager for texture lookup
                if (userData.shapeType && window.assetManager) {
                    debugLog(`üîç Checking texture for physics body shapeType: ${userData.shapeType}`);
                    
                    // Try direct texture retrieval first
                    textureImage = UnifiedTextureSystem.getShapeTexture(userData.shapeType);
                    if (textureImage) {
                        textureConfig = {
                            repeat: 'repeat',
                            blend: 'multiply',
                            opacity: 0.7
                        };
                        debugLog(`üñºÔ∏è Direct AssetManager texture retrieval for ${userData.shapeType}: SUCCESS`);
                    }
                    // Unified fallback check using consolidated texture management
                    else if (UnifiedTextureSystem.isTextureAvailable(userData.shapeType)) {
                        textureImage = UnifiedTextureSystem.getShapeTexture(userData.shapeType);
                        textureConfig = {
                            repeat: 'repeat',
                            blend: 'multiply',
                            opacity: 0.7
                        };
                        debugLog(`üñºÔ∏è Unified texture check for ${userData.shapeType}: SUCCESS`);
                    }
                    
                    if (!textureImage) {
                        debugLog(`‚ö†Ô∏è No texture found for physics body ${userData.shapeType}. AssetManager available: ${!!window.assetManager}, Current theme: ${window.assetManager?.currentTheme}`);
                        
                        // Debug: Check what's actually in the assets
                        const currentTheme = window.assetManager?.getCurrentTheme();
                        if (currentTheme) {
                            debugLog(`üîç Current theme assets:`, currentTheme.assets);
                            debugLog(`üîç Shape textures available:`, Object.keys(currentTheme.assets?.shapeTextures || {}));
                        }
                    }
                }
                
                // Fallback to legacy system only if no unified texture found
                const shouldUseTexture = CANVAS_CONFIG.enabled && CANVAS_CONFIG.useBackgroundTextures;
                if (!textureImage && shouldUseTexture) {
                    if (userData.type === 'platform') {
                        const platformStyle = this.assetManager.getPlatformStyle();
                        textureImage = platformStyle?.image;
                        textureConfig = platformStyle?.imageConfig;
                    } else if (userData.shapeType) {
                        const shapeStyle = this.assetManager.getShapeStyle(userData.shapeType);
                        textureImage = shapeStyle?.texture;
                        textureConfig = shapeStyle?.textureConfig;
                    }
                }
                
                // Set drawing style
                this.ctx.fillStyle = fillColor;
                this.ctx.strokeStyle = strokeColor;
                this.ctx.lineWidth = render.lineWidth || userData.strokeWidth || 2;
                
                // Render based on shape type
                if (part.circleRadius !== undefined && part.circleRadius > 0) {
                    // Circle - use part's own position (already in world coordinates)
                    this.renderCircleWithTexture(part, textureImage, textureConfig);
                } else if (part.vertices && part.vertices.length > 0) {
                    // Polygon (including rectangles) - vertices are in world coordinates
                    this.renderPolygonWithTexture(part, textureImage, textureConfig);
                } else {
                    console.log(`‚ö†Ô∏è Unknown body type - circleRadius: ${part.circleRadius}, vertices: ${part.vertices ? part.vertices.length : 'none'} for ${userData.type || 'unknown'}`);
                }
            }

// ...existing code...

            renderCircleWithTexture(part, textureImage, textureConfig) {
                // Check if this shape should be pulsing
                const bodyId = part.parent ? part.parent.id : part.id;
                const pulseState = this.pulseManager.activePulses.get(bodyId);
                
                // Apply transformations and fill the circle in local coordinate space so that the texture moves with the shape.
                this.ctx.save();
                
                // Apply pulse effects if active
                if (pulseState && pulseState.isPulsing) {
                    this.applyPulseEffects(pulseState.pulseIntensity, textureImage);
                }
                
                // Apply shape transformations first
                this.ctx.translate(part.position.x, part.position.y);
                if (part.angle) {
                    this.ctx.rotate(part.angle);
                }
                
                // Create the path for the circle with origin at (0,0)
                this.ctx.beginPath();
                this.ctx.arc(0, 0, part.circleRadius, 0, Math.PI * 2);
                
                // Apply texture pattern in transformed space if available
                if (textureImage) {
                    const pattern = this.ctx.createPattern(textureImage, 'repeat');
                    if (pattern) {
                        this.ctx.fillStyle = pattern;
                    }
                }
                // fillStyle is already set to color in renderMatterPart if no texture
                
                this.ctx.fill();
                this.ctx.restore();
                
                // Reset any pulse effects
                if (pulseState && pulseState.isPulsing) {
                    this.resetPulseEffects();
                }
                
                // Draw stroke in world coordinates
                this.ctx.beginPath();
                this.ctx.arc(part.position.x, part.position.y, part.circleRadius, 0, Math.PI * 2);
                this.ctx.stroke();
            }

            renderPolygonWithTexture(part, textureImage, textureConfig) {
                const vertices = part.vertices;
                if (!vertices || vertices.length === 0) return;
                
                // Check if this shape should be pulsing
                const bodyId = part.parent ? part.parent.id : part.id;
                const pulseState = this.pulseManager.activePulses.get(bodyId);
                
                this.ctx.save();
                
                // Apply pulse effects if active
                if (pulseState && pulseState.isPulsing) {
                    this.applyPulseEffects(pulseState.pulseIntensity, textureImage);
                }
                
                // Apply transformations for texture coordinate space
                this.ctx.translate(part.position.x, part.position.y);
                if (part.angle) {
                    this.ctx.rotate(part.angle);
                }
                
                // Create path in local coordinate space
                this.ctx.beginPath();
                const localVertices = vertices.map(v => ({
                    x: v.x - part.position.x,
                    y: v.y - part.position.y
                }));
                
                // Rotate vertices back to local space
                if (part.angle) {
                    const cos = Math.cos(-part.angle);
                    const sin = Math.sin(-part.angle);
                    localVertices.forEach(v => {
                        const x = v.x * cos - v.y * sin;
                        const y = v.x * sin + v.y * cos;
                        v.x = x;
                        v.y = y;
                    });
                }
                
                this.ctx.moveTo(localVertices[0].x, localVertices[0].y);
                for (let i = 1; i < localVertices.length; i++) {
                    this.ctx.lineTo(localVertices[i].x, localVertices[i].y);
                }
                this.ctx.closePath();
                
                // Apply texture in transformed space
                if (textureImage) {
                    const pattern = this.ctx.createPattern(textureImage, 'repeat');
                    if (pattern) {
                        this.ctx.fillStyle = pattern;
                    }
                }
                
                this.ctx.fill();
                this.ctx.restore();
                
                // Reset any pulse effects
                if (pulseState && pulseState.isPulsing) {
                    this.resetPulseEffects();
                }
                
                // Draw stroke in world coordinates
                this.ctx.beginPath();
                this.ctx.moveTo(vertices[0].x, vertices[0].y);
                for (let i = 1; i < vertices.length; i++) {
                    this.ctx.lineTo(vertices[i].x, vertices[i].y);
                }
                this.ctx.closePath();
                this.ctx.stroke();
            }

// ...existing code...

            applyTextureToShape(x, y, width, height, image, textureConfig) {
                if (!image) return;
                
                this.ctx.save();
                
                // Apply blend mode
                if (textureConfig.blend && textureConfig.blend !== 'normal') {
                    this.ctx.globalCompositeOperation = textureConfig.blend;
                }
                
                // Apply opacity
                if (textureConfig.opacity !== undefined) {
                    this.ctx.globalAlpha = textureConfig.opacity;
                }
                
                // Handle texture repeat patterns
                switch(textureConfig.repeat) {
                    case 'repeat':
                        this.drawRepeatedTexture(x, y, width, height, image);
                        break;
                    case 'repeat-x':
                        this.drawRepeatedTextureX(x, y, width, height, image);
                        break;
                    case 'repeat-y':
                        this.drawRepeatedTextureY(x, y, width, height, image);
                        break;
                    case 'no-repeat':
                    default:
                        this.ctx.drawImage(image, x, y, width, height);
                        break;
                }
                
                this.ctx.restore();
            }

            drawRepeatedTexture(x, y, width, height, image) {
                const pattern = this.ctx.createPattern(image, 'repeat');
                if (pattern) {
                    this.ctx.fillStyle = pattern;
                    this.ctx.fillRect(x, y, width, height);
                } else {
                    // Fallback: manual tiling
                    this.manualTileTexture(x, y, width, height, image);
                }
            }

            drawRepeatedTextureX(x, y, width, height, image) {
                const aspectRatio = image.width / image.height;
                const tileHeight = height;
                const tileWidth = tileHeight * aspectRatio;
                
                for (let tx = x; tx < x + width; tx += tileWidth) {
                    const drawWidth = Math.min(tileWidth, x + width - tx);
                    this.ctx.drawImage(image, 0, 0, image.width * (drawWidth / tileWidth), image.height,
                                     tx, y, drawWidth, tileHeight);
                }
            }

            drawRepeatedTextureY(x, y, width, height, image) {
                const aspectRatio = image.width / image.height;
                const tileWidth = width;
                const tileHeight = tileWidth / aspectRatio;
                
                for (let ty = y; ty < y + height; ty += tileHeight) {
                    const drawHeight = Math.min(tileHeight, y + height - ty);
                    this.ctx.drawImage(image, 0, 0, image.width, image.height * (drawHeight / tileHeight),
                                     x, ty, tileWidth, drawHeight);
                }
            }

            manualTileTexture(x, y, width, height, image) {
                const tileWidth = image.width;
                const tileHeight = image.height;
                
                for (let ty = y; ty < y + height; ty += tileHeight) {
                    for (let tx = x; tx < x + width; tx += tileWidth) {
                        const drawWidth = Math.min(tileWidth, x + width - tx);
                        const drawHeight = Math.min(tileHeight, y + height - ty);
                        
                        this.ctx.drawImage(image, 0, 0, 
                                         image.width * (drawWidth / tileWidth), 
                                         image.height * (drawHeight / tileHeight),
                                         tx, ty, drawWidth, drawHeight);
                    }
                }
            }

            getPolygonBounds(vertices) {
                let minX = Infinity, minY = Infinity;
                let maxX = -Infinity, maxY = -Infinity;
                
                vertices.forEach(vertex => {
                    minX = Math.min(minX, vertex.x);
                    minY = Math.min(minY, vertex.y);
                    maxX = Math.max(maxX, vertex.x);
                    maxY = Math.max(maxY, vertex.y);
                });
                
                return {
                    x: minX,
                    y: minY,
                    width: maxX - minX,
                    height: maxY - minY
                };
            }

            getEventStats() {
                return {
                    events: this.eventCount,
                    collisions: this.collisionCount,
                    falls: this.fallCount
                };
            }

            darkenColor(color, amount = 30) {
                // Enhanced color darkening with configurable amount
                if (!color) return '#7F8C8D';
                
                // Convert hex to RGB and darken by specified amount
                const hex = color.replace('#', '');
                const r = Math.max(0, parseInt(hex.substr(0, 2), 16) - amount);
                const g = Math.max(0, parseInt(hex.substr(2, 2), 16) - amount);
                const b = Math.max(0, parseInt(hex.substr(4, 2), 16) - amount);
                
                return `rgb(${r}, ${g}, ${b})`;
            }

            /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
              ‚ïë CLEAR ALL SHAPES
              ‚ïë Removes all dynamic bodies (shapes) from the physics world while preserving
              ‚ïë static bodies (platform, walls). Used for level resets and shape management.
              ‚ïë Essential for providing a fresh start without recreating the entire world.
              ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
            clearAllShapes() {
                // Remove all dynamic bodies from Matter.js world
                this.dynamicBodies.forEach(body => {
                    this.World.remove(this.world, body);
                    this.cleanupRemovedShapeFromWeighted(body.id);
                });
                this.dynamicBodies = [];
                
                console.log('üßπ Cleared all shapes from playfield');
            }

            cleanup() {
                // Remove all dynamic bodies from Matter.js world
                this.dynamicBodies.forEach(body => {
                    this.World.remove(this.world, body);
                    this.cleanupRemovedShapeFromWeighted(body.id);
                });
                this.dynamicBodies = [];
                
                // PixiJS shape clearing removed with PixiJS elimination
                
                // Reset event counters
                this.eventCount = 0;
                this.collisionCount = 0;
                this.fallCount = 0;
                
                console.log('üßπ Matter.js physics cleanup complete');
            }
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë ENHANCED DRAG AND DROP MANAGER WITH ROTATION
          ‚ïë Task 4.2b: Adds rotation functionality during drag and drop operations
          ‚ïë Maintains existing drag & drop functionality while adding rotation controls
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        class DragDropManager {
            constructor(physicsManager, gameManager) {
                this.physicsManager = physicsManager;
                this.gameManager = gameManager;
                this.isDragging = false;
                this.draggedElement = null;
                this.draggedShapeType = null;
                this.ghostElement = null;
                
                // Touch offset configuration for mobile devices
                this.touchOffset = {
                    x: 0,      // Horizontal offset (positive = right, negative = left)
                    y: -80,    // Vertical offset (positive = down, negative = up)
                    enabled: true // Enable/disable offset system
                };
                
                // Rotation system
                this.currentRotation = 0; // Current rotation in radians
                this.rotationStep = Math.PI / 6; // 30 degrees per step
                
                // Throttling for smooth dragging - reduce jerkiness
                this.lastMoveTime = 0;
                this.moveThrottleMs = 16; // ~60fps throttling
                this.pendingMove = null;
                
                // Track if drag started from dock
                this.dragStartedFromDock = false;
                
                this.setupEventListeners();
                console.log('üñ±Ô∏è Streamlined Drag & Drop Manager with touch offset support initialized');
            }

            setupEventListeners() {
                // Mouse events - use throttled movement for smoother dragging
                document.addEventListener('mousedown', (e) => this.handlePointerDown(e));
                document.addEventListener('mousemove', (e) => this.throttledHandlePointerMove(e));
                document.addEventListener('mouseup', (e) => this.handlePointerUp(e));
                
                // Touch events handled by MobileEnhancementManager if present
                // No need for direct touch handling - unified handlers provide better experience
                
                // Keyboard controls
                document.addEventListener('keydown', (e) => this.handleRotationKey(e));
                
                // Desktop rotation zone click handlers
                const leftRotationZone = document.getElementById('leftRotationZone');
                const rightRotationZone = document.getElementById('rightRotationZone');
                
                if (leftRotationZone) {
                    leftRotationZone.addEventListener('click', (e) => {
                        if (this.isDragging) {
                            this.rotateShape(-this.rotationStep); // Counter-clockwise
                            e.preventDefault();
                        }
                    });
                }
                
                if (rightRotationZone) {
                    rightRotationZone.addEventListener('click', (e) => {
                        if (this.isDragging) {
                            this.rotateShape(this.rotationStep); // Clockwise
                            e.preventDefault();
                        }
                    });
                }
                
                debugLog('üñ±Ô∏è Drag & Drop Manager initialized with unified pointer support');
            }
            
            // Throttled mouse movement to reduce jerkiness
            throttledHandlePointerMove(e) {
                if (!this.isDragging) return;
                
                const now = performance.now();
                if (now - this.lastMoveTime < this.moveThrottleMs) {
                    // Store the most recent event for later processing
                    this.pendingMove = e;
                    return;
                }
                
                this.lastMoveTime = now;
                this.handlePointerMove(e);
                
                // Process any pending move after throttle delay
                if (this.pendingMove && this.pendingMove !== e) {
                    setTimeout(() => {
                        if (this.pendingMove && this.isDragging) {
                            this.handlePointerMove(this.pendingMove);
                            this.pendingMove = null;
                        }
                    }, this.moveThrottleMs);
                }
            }

            handleRotationKey(e) {
                if (!this.isDragging) return;
                
                switch(e.key) {
                    case 'r':
                    case 'R':
                    case 'ArrowRight':
                        this.rotateShape(this.rotationStep); // Rotate clockwise
                        e.preventDefault();
                        break;
                    case 'e':
                    case 'E':
                    case 'ArrowLeft':
                        this.rotateShape(-this.rotationStep); // Rotate counter-clockwise
                        e.preventDefault();
                        break;
                }
            }

            rotateShape(deltaRotation) {
                this.currentRotation += deltaRotation;
                
                // Sound effect integration point
                this.gameManager.playSound('shapeRotation');
                
                if (this.ghostElement) {
                    // Apply both scale, centering translation, and rotation to the ghost element
                    this.ghostElement.style.transform = `translate(-50%, -50%) scale(1.1) rotate(${this.currentRotation}rad)`;
                }
                
                // Update rotation indicator with current angle
                const degrees = Math.round(this.currentRotation * 180 / Math.PI);
                this.updateRotationIndicator(degrees);
                
                console.log(`üîÑ Shape rotated: ${degrees}¬∞`);
            }

            handlePointerDown(pointer) {
                if (!this.gameManager?.gameState?.isGameActive) {
                    return;
                }

                const element = document.elementFromPoint(pointer.clientX, pointer.clientY);

                if (element && element.classList.contains('locked')) { return; }

                if (element && element.classList.contains('game-shape')) {
                    // Check if drag started from docking area
                    this.dragStartedFromDock = element.closest('.docking-area') !== null;
                    console.log(`üñ±Ô∏è Starting drag, from dock: ${this.dragStartedFromDock}`);
                    this.startDrag(element, pointer);
                }
            }

            startDrag(element, pointer) {
                this.isDragging = true;
                this.draggedElement = element;
                this.draggedShapeType = element.dataset.shape;
                this.draggedShapeId = element.dataset.shapeId;
                
                // Initialize rotation based on shape type and dock settings
                if (this.draggedShapeType && this.draggedShapeType.includes('barbell')) {
                    // For barbells, preserve dock orientation setting
                    const barbellOrientationSelect = document.getElementById('barbellOrientation');
                    if (barbellOrientationSelect && barbellOrientationSelect.value === 'vertical') {
                        this.currentRotation = Math.PI / 2; // 90 degrees for vertical barbells
                        console.log(`üîÑ Starting barbell drag with vertical dock orientation (90¬∞)`);
                    } else {
                        this.currentRotation = 0; // Horizontal for barbells
                        console.log(`üîÑ Starting barbell drag with horizontal dock orientation (0¬∞)`);
                    }
                } else {
                    // For non-barbell shapes, always start at 0
                    this.currentRotation = 0;
                }
                
                // Add visual feedback with ghost effect
                element.classList.add('ghost-active');
                console.log(`üëª Added ghost-active class to element:`, element.className, 'Should be invisible now');

                // --- NEW: Ensure dock shape is properly hidden when dragging ---
                if (this.dragStartedFromDock) {
                    element.style.visibility = 'hidden';
                    element.style.opacity = '0';
                    console.log(`üôà Hiding dock shape during drag`);
                }
                // --- END NEW ---

                if (this.dragStartedFromDock) {
                    dockingSpecialEffectsManager.setEffectVisibility(element, false);
                }

                // Show rotation indicator
                this.showRotationIndicator();
                
                // Update rotation indicator with initial rotation
                this.updateRotationIndicator(Math.round(this.currentRotation * 180 / Math.PI));
                
                // Create ghost element for dragging
                this.createGhostElement(element, pointer);
                
                console.log(`üü¢ Started dragging: ${this.draggedShapeType} with initial rotation ${(this.currentRotation * 180 / Math.PI).toFixed(1)}¬∞ (R/E or ‚Üê/‚Üí to rotate)`);
            }

            createGhostElement(element, pointer) {
                // Create ghost element like Planck version - using CSS transform rotation
                this.ghostElement = this.createGhostPreview(this.draggedShapeType, 90);
                
                // Add ghost-shape class for CSS styling
                this.ghostElement.classList.add('ghost-shape');
                
                // Apply comprehensive ghost styling to prevent clipping
                this.ghostElement.style.position = 'fixed';
                this.ghostElement.style.pointerEvents = 'none';
                this.ghostElement.style.zIndex = '10000'; // Higher z-index to ensure visibility
                this.ghostElement.style.filter = 'drop-shadow(0 5px 15px rgba(0,0,0,0.3))';
                this.ghostElement.style.visibility = 'visible';
                this.ghostElement.style.opacity = '0.9';
                this.ghostElement.style.display = 'block';
                
                // Use CSS transform with consistent centering, scale, and rotation
                const initialTransform = `translate(-50%, -50%) scale(1.1) rotate(${this.currentRotation}rad)`;
                this.ghostElement.style.transform = initialTransform;
                console.log(`üëª Ghost element created with CSS rotation: ${(this.currentRotation * 180 / Math.PI).toFixed(1)}¬∞`);
                
                // Position at pointer
                this.updateGhostPosition(pointer);
                
                // Append to drag overlay instead of document.body to prevent clipping
                const dragOverlay = document.getElementById('dragOverlay');
                if (dragOverlay) {
                    dragOverlay.appendChild(this.ghostElement);
                    console.log(`üëª Ghost element created in drag overlay for ${this.draggedShapeType}`);
                } else {
                    document.body.appendChild(this.ghostElement);
                    console.log(`üëª Ghost element created in document body for ${this.draggedShapeType} (fallback)`);
                }
            }

            createGhostPreview(shapeType, size) {
                const config = getShapeConfig(shapeType);

                // Create canvas element for ghost preview
                const canvas = document.createElement('canvas');
                canvas.width = size;
                canvas.height = size;
                canvas.className = 'shape-preview ghost-preview';
                canvas.dataset.shape = shapeType;

                const ctx = canvas.getContext('2d');
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';

                const scale = UNIFIED_GAME_CONFIG.performance.scaleMultiplier;

                // Use unified texture checking and retrieval
                const textureImage = UnifiedTextureSystem.isTextureAvailable(shapeType) ? 
                    UnifiedTextureSystem.getShapeTexture(shapeType) : null;

                // Render the ghost with or without texture using the unified rendering system
                shapeRenderer.renderShapeOnCanvas(ctx, shapeType, size / 2, size / 2, 0, scale, textureImage);

                debugLog(`üëª Ghost preview created for: ${shapeType} with scale ${scale}, rotation handled by CSS, textured: ${!!textureImage}`);
                return canvas;
            }

            updateGhostPosition(pointer) {
                if (this.ghostElement) {
                    let x = pointer.clientX;
                    let y = pointer.clientY;
                    
                    // Apply touch offset if dragging from dock and offset is enabled
                    if (this.dragStartedFromDock && this.touchOffset.enabled) {
                        x += this.touchOffset.x;
                        y += this.touchOffset.y;
                    }
                    
                    // Set position using left/top
                    this.ghostElement.style.left = `${x}px`;
                    this.ghostElement.style.top = `${y}px`;
                    
                    // Preserve scale (1.1 during drag) and rotation with centering
                    this.ghostElement.style.transform = `translate(-50%, -50%) scale(1.1) rotate(${this.currentRotation}rad)`;
                }
            }

            handlePointerMove(pointer) {
                if (this.isDragging && this.ghostElement) {
                    // Streamlined: Only update ghost position for optimal performance
                    this.updateGhostPosition(pointer);
                }
            }

            handlePointerUp(pointer) {
                if (!this.isDragging) return;
                
                // Check if dropped in game area
                const gameCanvas = document.getElementById('gameCanvas');
                const canvasRect = gameCanvas.getBoundingClientRect();
                
                // Calculate the actual drop position from ghost element if it exists
                let dropX, dropY;
                if (this.ghostElement) {
                    // Get ghost element's center position
                    const ghostRect = this.ghostElement.getBoundingClientRect();
                    dropX = ghostRect.left + ghostRect.width / 2;
                    dropY = ghostRect.top + ghostRect.height / 2;
                } else {
                    // Fallback to pointer position
                    dropX = pointer.clientX;
                    dropY = pointer.clientY;
                }
                
                if (dropX >= canvasRect.left && 
                    dropX <= canvasRect.right &&
                    dropY >= canvasRect.top && 
                    dropY <= canvasRect.bottom) {
                    
                    // Calculate position relative to canvas using ghost position
                    const x = dropX - canvasRect.left;
                    const y = dropY - canvasRect.top;
                    
                    // Use current rotation as-is (it already includes barbell orientation from dock/ghost)
                    const totalRotation = this.currentRotation;
                    console.log(`üîÑ Physics: Using current rotation ${(totalRotation * 180 / Math.PI).toFixed(1)}¬∞ for ${this.draggedShapeType}`);
                    
                    // Create physics shape at drop position with total rotation
                    const result = this.physicsManager.createCompoundShape(x, y, this.draggedShapeType, totalRotation, this.draggedShapeId);
                    
                    // Update game state
                    this.gameManager.onShapePlaced(this.draggedShapeType);
                    
                    // --- NEW: Mark slot as empty only when dragging from dock ---
                    if (this.dragStartedFromDock) {
                        // Mark this slot as empty since shape was successfully placed
                        this.markSlotAsEmpty(this.draggedElement);
                        console.log(`üóëÔ∏è Removing shape from dock after successful placement`);
                    }
                    // --- END NEW ---
                    
                    console.log(`üéØ Shape dropped: ${this.draggedShapeType} at (${x}, ${y}) with ${(totalRotation * 180 / Math.PI).toFixed(0)}¬∞ total rotation`);
                } else {
                    // Shape was not dropped in game area, restore it to dock
                    this.restoreShapeToDock();
                    console.log(`‚Ü©Ô∏è Shape returned to dock: ${this.draggedShapeType}`);
                }
                
                this.endDrag();
            }

            markSlotAsEmpty(shapeElement) {
                if (!shapeElement) return;
                // Remove the shape from dock and mark slot as empty
                const slot = shapeElement.parentElement;
                dockingSpecialEffectsManager.unregisterByElement(shapeElement);
                shapeElement.remove();
                if (slot) {
                    slot.classList.add('empty');
                }

                console.log(`üì¶ Dock slot emptied: ${this.draggedShapeType}`);
            }

            restoreShapeToDock() {
                // Restore the shape visibility in the dock
                if (this.draggedElement) {
                    // --- UPDATED: Properly restore visibility and remove ghost effect ---
                    this.draggedElement.style.visibility = 'visible';
                    this.draggedElement.style.opacity = '1';
                    this.draggedElement.classList.remove('ghost-active');
                    console.log(`üëÅÔ∏è Restoring shape visibility in dock`);
                    // --- END UPDATED ---
                    
                    if (this.dragStartedFromDock) {
                        dockingSpecialEffectsManager.setEffectVisibility(this.draggedElement, true);
                    }
                }
                
                // --- UPDATED: Ensure ghost element is immediately cleaned up when returning to dock ---
                this.cleanupGhostElement();
                
                // --- NEW: Run safety cleanup to prevent any orphaned elements ---
                this.ensureCleanDockRestore();
                // --- END NEW ---
            }

            cleanupGhostElement() {
                if (this.ghostElement) {
                    try {
                        // Remove from drag overlay if it exists, otherwise from document.body
                        const dragOverlay = document.getElementById('dragOverlay');
                        if (dragOverlay && dragOverlay.contains(this.ghostElement)) {
                            dragOverlay.removeChild(this.ghostElement);
                            console.log(`üßπ Ghost element removed from drag overlay`);
                        } else if (this.ghostElement.parentNode) {
                            this.ghostElement.parentNode.removeChild(this.ghostElement);
                            console.log(`üßπ Ghost element removed from parent node`);
                        }
                    } catch (error) {
                        console.warn(`‚ö†Ô∏è Error removing ghost element:`, error);
                    }
                    
                    // Clear the reference to ensure garbage collection
                    this.ghostElement = null;
                    console.log(`üóëÔ∏è Ghost element reference cleared for garbage collection`);
                }
            }

            // --- NEW: Safety method to ensure complete cleanup on dock restoration ---
            ensureCleanDockRestore() {
                // Remove any orphaned ghost elements that might exist
                const dragOverlay = document.getElementById('dragOverlay');
                if (dragOverlay) {
                    const orphanedGhosts = dragOverlay.querySelectorAll('.ghost-shape, .ghost-preview');
                    orphanedGhosts.forEach(ghost => {
                        if (ghost && ghost.parentNode) {
                            ghost.parentNode.removeChild(ghost);
                            console.log(`üßπ Removed orphaned ghost element`);
                        }
                    });
                }
                
                // Clear any ghost-active classes from dock elements
                const dockShapes = document.querySelectorAll('.docking-area .shape-preview.ghost-active');
                dockShapes.forEach(shape => {
                    shape.classList.remove('ghost-active');
                    shape.style.visibility = 'visible';
                    shape.style.opacity = '1';
                });
                
                console.log(`‚úÖ Dock restoration safety cleanup completed`);
            }
            // --- END NEW ---

            showRotationIndicator() {
                const indicator = document.getElementById('rotationIndicator');
                if (indicator) {
                    indicator.classList.add('show');
                }
            }

            hideRotationIndicator() {
                const indicator = document.getElementById('rotationIndicator');
                if (indicator) {
                    indicator.classList.remove('show');
                }
            }

            updateRotationIndicator(angle) {
                const indicator = document.getElementById('rotationIndicator');
                if (indicator) {
                    indicator.textContent = `üîÑ Rotation: ${angle}¬∞`;
                }
            }

            /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
              ‚ïë STREAMLINED DRAG MANAGEMENT (KEYBOARD ONLY)
              ‚ïë Removed mobile gestures and auto-rotation for optimal performance
              ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/

            endDrag() {
                // --- UPDATED: Removed redundant visibility restoration to prevent conflicts ---
                // The restoreShapeToDock() method already handles visibility restoration
                // Only clean up ghost-active class if element still exists and wasn't handled by restoreShapeToDock
                if (this.draggedElement && this.draggedElement.classList.contains('ghost-active')) {
                    this.draggedElement.classList.remove('ghost-active');
                }
                // --- END UPDATED ---
                
                // --- UPDATED: Use centralized ghost cleanup method ---
                this.cleanupGhostElement();
                // --- END UPDATED ---
                
                // Hide rotation indicator
                this.hideRotationIndicator();
                
                // Reset all drag state variables
                this.isDragging = false;
                this.draggedElement = null;
                this.draggedShapeType = null;
                this.draggedShapeId = null;
                this.currentRotation = 0;
                this.dragStartedFromDock = false;
            }

            // Configuration method for touch offset
            setTouchOffset(x, y, enabled = true) {
                this.touchOffset.x = x;
                this.touchOffset.y = y;
                this.touchOffset.enabled = enabled;
                console.log(`üì± Touch offset updated: x=${x}, y=${y}, enabled=${enabled}`);
            }

            // Get current touch offset settings
            getTouchOffset() {
                return { ...this.touchOffset };
            }

        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë MOBILE ENHANCEMENT MANAGER 
          ‚ïë Adds mobile touch support and rotation zones while preserving mouse/keyboard
          ‚ïë Detects mobile devices and provides touch-optimized interactions
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        class MobileEnhancementManager {
            constructor(dragDropManager) {
                this.dragDropManager = dragDropManager;
                this.isMobileDevice = this.detectMobileDevice();
                this.touchStartTime = 0;
                this.touchThreshold = 10; // Minimum movement for drag
                this.rotationTimer = null;
                this.rotationInterval = 1000; // 1 second intervals for mobile rotation
                this.rotationIncrement = Math.PI / 4; // 45 degrees for mobile
                
                // Rotation zones
                this.rotationZones = {
                    left: {
                        element: document.getElementById('leftRotationZone'),
                        direction: -1, // CCW
                        active: false,
                        bounds: null
                    },
                    right: {
                        element: document.getElementById('rightRotationZone'), 
                        direction: 1, // CW
                        active: false,
                        bounds: null
                    }
                };
                
                if (this.isMobileDevice) {
                    this.setupTouchEnhancements();
                    console.log('üì± Mobile enhancements activated');
                } else {
                    console.log('üñ•Ô∏è Desktop mode - mobile enhancements disabled');
                }
            }
            
            detectMobileDevice() {
                return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                       (navigator.maxTouchPoints && navigator.maxTouchPoints > 2) ||
                       window.innerWidth <= 768;
            }
            
            setupTouchEnhancements() {
                // Set reference in DragDropManager to prevent duplicate touch handlers
                this.dragDropManager.mobileEnhancementManager = this;
                
                // Unified touch event listeners for mobile-specific features
                document.addEventListener('touchstart', (e) => this.handleUnifiedTouchStart(e), { passive: false });
                document.addEventListener('touchmove', (e) => this.handleUnifiedTouchMove(e), { passive: false });
                document.addEventListener('touchend', (e) => this.handleUnifiedTouchEnd(e), { passive: false });
                
                // Update rotation zone bounds
                this.updateRotationZoneBounds();
                window.addEventListener('resize', () => this.updateRotationZoneBounds());
                
                // Hook into DragDropManager to add mobile features
                this.originalStartDrag = this.dragDropManager.startDrag.bind(this.dragDropManager);
                this.dragDropManager.startDrag = (element, event) => {
                    this.originalStartDrag(element, event);
                    this.showRotationZones();
                };
                
                this.originalEndDrag = this.dragDropManager.endDrag.bind(this.dragDropManager);
                this.dragDropManager.endDrag = () => {
                    this.hideRotationZones();
                    this.stopRotationTimer();
                    this.originalEndDrag();
                };
            }
            
            updateRotationZoneBounds() {
                const canvas = document.getElementById('gameCanvas');
                const canvasRect = canvas.getBoundingClientRect();
                
                this.rotationZones.left.bounds = {
                    left: canvasRect.left,
                    right: canvasRect.left + 80,
                    top: canvasRect.top,
                    bottom: canvasRect.bottom
                };
                
                this.rotationZones.right.bounds = {
                    left: canvasRect.right - 80,
                    right: canvasRect.right,
                    top: canvasRect.top,
                    bottom: canvasRect.bottom
                };
            }
            
            // Unified touch handlers that coordinate drag and rotation functionality
            handleUnifiedTouchStart(event) {
                if (event.touches.length !== 1) return;
                
                const touch = event.touches[0];
                this.touchStartTime = Date.now();
                
                // First check if touching a draggable shape
                const targetShape = touch.target.closest('.game-shape');
                if (targetShape) {
                    // Haptic feedback on touch down for shapes
                    if (navigator.vibrate) {
                        navigator.vibrate(50);
                    }
                    
                    // Delegate to DragDropManager for shape handling
                    const mouseEvent = new MouseEvent('mousedown', {
                        clientX: touch.clientX,
                        clientY: touch.clientY,
                        button: 0
                    });
                    this.dragDropManager.handlePointerDown(mouseEvent);
                    event.preventDefault();
                } else {
                    // Check rotation zones for non-shape touches
                    this.checkRotationZones(touch.clientX, touch.clientY);
                }
            }
            
            handleUnifiedTouchMove(event) {
                if (event.touches.length !== 1) return;
                
                const touch = event.touches[0];
                
                // If dragging, delegate to DragDropManager AND handle rotation zones
                if (this.dragDropManager.isDragging) {
                    // Handle drag movement
                    const mouseEvent = new MouseEvent('mousemove', {
                        clientX: touch.clientX,
                        clientY: touch.clientY
                    });
                    this.dragDropManager.throttledHandlePointerMove(mouseEvent);
                    
                    // Check rotation zones with haptic feedback
                    const wasInZone = this.currentRotationZone;
                    this.checkRotationZones(touch.clientX, touch.clientY);
                    
                    // Haptic feedback when entering rotation zone
                    if (this.currentRotationZone && !wasInZone && navigator.vibrate) {
                        navigator.vibrate(30);
                    }
                    
                    event.preventDefault();
                }
            }

            handleUnifiedTouchEnd(event) {
                const touch = event.changedTouches[0];
                
                // Handle rotation if in rotation zone while dragging
                if (this.currentRotationZone && this.dragDropManager.isDragging) {
                    const rotationDirection = this.currentRotationZone === 'left' ? -1 : 1;
                    this.dragDropManager.rotateShape(rotationDirection * this.dragDropManager.rotationStep);
                    
                    // Stronger haptic feedback for rotation
                    if (navigator.vibrate) {
                        navigator.vibrate([50, 50, 50]);
                    }
                }
                
                // If dragging, delegate to DragDropManager
                if (this.dragDropManager.isDragging) {
                    // Light haptic feedback on drop
                    if (navigator.vibrate) {
                        navigator.vibrate(25);
                    }
                    
                    const mouseEvent = new MouseEvent('mouseup', {
                        clientX: touch.clientX,
                        clientY: touch.clientY,
                        button: 0
                    });
                    this.dragDropManager.handlePointerUp(mouseEvent);
                }
                
                // Clean up rotation zones
                this.hideRotationZones();
                this.stopRotationTimer();
                this.currentRotationZone = null;
                
                event.preventDefault();
            }            checkRotationZones(x, y) {
                let inZone = null;
                
                // Check left zone
                if (this.isPointInZone(x, y, this.rotationZones.left.bounds)) {
                    inZone = 'left';
                }
                // Check right zone
                else if (this.isPointInZone(x, y, this.rotationZones.right.bounds)) {
                    inZone = 'right';
                }
                
                // Update current rotation zone
                this.currentRotationZone = inZone;
                
                // Handle zone entry/exit
                if (inZone && !this.rotationZones[inZone].active) {
                    this.enterRotationZone(inZone);
                } else if (!inZone) {
                    this.exitAllRotationZones();
                }
            }
            
            isPointInZone(x, y, bounds) {
                return bounds && x >= bounds.left && x <= bounds.right && 
                       y >= bounds.top && y <= bounds.bottom;
            }
            
            enterRotationZone(zoneName) {
                const zone = this.rotationZones[zoneName];
                if (!zone || !zone.element) return;
                
                // Exit other zones first
                this.exitAllRotationZones();
                
                // Activate this zone
                zone.active = true;
                zone.element.classList.add('active');
                
                // Start rotation timer
                this.rotationTimer = setInterval(() => {
                    if (this.dragDropManager.isDragging) {
                        this.dragDropManager.currentRotation += zone.direction * this.rotationIncrement;
                        
                        // Update ghost element rotation
                        if (this.dragDropManager.ghostElement) {
                            this.dragDropManager.ghostElement.style.transform = 
                                `translate(-50%, -50%) scale(1.1) rotate(${this.dragDropManager.currentRotation}rad)`;
                        }
                        
                        // Haptic feedback
                        this.playHapticFeedback();
                    }
                }, this.rotationInterval);
                
                console.log(`üì± Entered ${zoneName} rotation zone`);
            }
            
            exitAllRotationZones() {
                Object.keys(this.rotationZones).forEach(zoneName => {
                    const zone = this.rotationZones[zoneName];
                    if (zone.active && zone.element) {
                        zone.active = false;
                        zone.element.classList.remove('active');
                    }
                });
                
                this.stopRotationTimer();
            }
            
            stopRotationTimer() {
                if (this.rotationTimer) {
                    clearInterval(this.rotationTimer);
                    this.rotationTimer = null;
                }
            }
            
            showRotationZones() {
                // Show rotation zones during drag for both mobile and desktop
                Object.values(this.rotationZones).forEach(zone => {
                    if (zone.element) {
                        zone.element.classList.add('visible');
                    }
                });
                console.log('üì± Rotation zones shown');
            }
            
            hideRotationZones() {
                Object.values(this.rotationZones).forEach(zone => {
                    if (zone.element) {
                        zone.element.classList.remove('visible', 'active');
                    }
                });
            }
            
            playHapticFeedback() {
                if (navigator.vibrate) {
                    navigator.vibrate(50); // Short vibration
                }
            }
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë ENHANCED GAME STATE WITH END-LEVEL COUNTDOWN
          ‚ïë Task 4.2c: Implements end-level countdown timer and level failure conditions
          ‚ïë Level fails if any piece falls off screen before countdown expires
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        class GameState {
            constructor() {
                this.shapes = [];
                this.placedShapes = [];
                this.isGameActive = true;
                this.isCountdownActive = false;
                this.countdownTime = 3;
                
                // HUD State
                this.level = 1;
                this.score = 0;
                this.coins = 0;
                this.progress = 0; // 0-100%
                
                // Timer System
                this.timerMode = 'elapsed'; // 'elapsed', 'countdown', 'endlevel'
                this.gameTime = 0; // Elapsed seconds
                this.endLevelTime = currentLevelConfig.endLevelDuration; // End level countdown duration from config
                this.endLevelDots = 0;
                
                // Physics Event Tracking
                this.shapeCollisions = 0;
                this.platformLandings = 0;
                this.shapeFalls = 0;
                this.stability = 100; // Stability percentage
                
                // End-Level State
                this.endLevelStarted = false;
                this.levelFailed = false;
                this.levelCompleted = false;
                this.isGameOver = false;
            }

            startEndLevelCountdown() {
                this.endLevelStarted = true;
                this.timerMode = 'endlevel';
                this.endLevelTime = currentLevelConfig.endLevelDuration; // Use configured duration
                this.isCountdownActive = true;
                
                console.log(`‚è∞ End-level countdown started: ${currentLevelConfig.endLevelDuration} seconds`);
            }

            checkLevelFailure() {
                // Level fails if any shape falls during end-level countdown
                if (this.endLevelStarted && !this.levelCompleted && this.shapeFalls > 0) {
                    this.levelFailed = true;
                    this.isGameActive = false;
                    return true;
                }
                return false;
            }

            resetLevel() {
                this.shapes = [];
                this.placedShapes = [];
                this.isGameActive = true;
                this.isCountdownActive = false;
                this.countdownTime = 3;
                this.gameTime = 0;
                this.timerMode = 'elapsed';
                this.endLevelTime = currentLevelConfig.endLevelDuration;
                this.endLevelDots = 0;
                
                // Reset score and coins to zero for fresh start
                this.score = 0;
                this.coins = 0;
                this.progress = 0;
                
                // Reset physics event tracking
                this.shapeCollisions = 0;
                this.platformLandings = 0;
                this.shapeFalls = 0;
                this.stability = 100;
                
                // Reset end-level state
                this.endLevelStarted = false;
                this.levelFailed = false;
                this.levelCompleted = false;
                this.isGameOver = false;
                
                console.log('üîÑ Game state reset for new level');
            }

            addPlacedShape(shapeType) {
                this.placedShapes.push({
                    type: shapeType,
                    timestamp: Date.now()
                });
                
                const totalShapes = currentLevelConfig.dockShapes.length;
                console.log(`üìä Shape placed: ${shapeType} (${this.placedShapes.length}/${totalShapes})`);
            }

            recordPhysicsEvent(eventType) {
                switch(eventType) {
                    case 'collision':
                        this.shapeCollisions++;
                        break;
                    case 'landing':
                        this.platformLandings++;
                        break;
                    case 'fall':
                        this.shapeFalls++;
                        this.stability = Math.max(0, this.stability - 10); // Reduce stability on falls
                        
                        // Check if this fall causes level failure
                        if (this.checkLevelFailure()) {
                            console.log('üí• LEVEL FAILED: Shape fell during end-level countdown!');
                        }
                        break;
                }
            }
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë ENHANCED GAME MANAGER WITH PHYSICS EVENT INTEGRATION
          ‚ïë Phase 4.1: Integrates physics events with game logic and UI updates
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        class GameManager {
            constructor(levelData) {
                console.log('üîß GameManager initialization started with level data:', levelData);
                
                this.levelData = levelData;
                this.gameState = new GameState();
                
                // Store configuration
                this.currentWorld = levelData?.meta?.worldNumber ?? 1;
                this.currentLevel = levelData?.meta?.levelNumber ?? 1;
                
                // Gameplay settings (rotation zones, auto rotation, unlock thresholds, etc.)
                this.gameplaySettings = this.levelData?.gameplay || {};
                
                // Stub managers for unsupported systems
                this.objectiveManager = new ObjectiveManager(this.levelData?.victory, this.levelData?.failure);
                this.starManager = new StarManager(this.levelData?.entities?.stars || []);
                this.onboardingManager = new OnboardingManager(this.levelData?.onboarding);
                
                // Theme overrides and base theme id
                this.baseThemeId = this.levelData?.theme?.baseThemeId || null;
                this.themeOverrides = this.levelData?.theme?.overrides || null;
                
                // Add a flag to ensure the dock animation only plays once
                this.dockAnimationPlayed = false;
                
                // Add flag to prevent duplicate theme applications
                this.levelThemeApplied = false;
                
                // Initialize subsystems in correct order
                this.initPromise = this.initializeAsync();
            }
            
            async initializeAsync() {
                debugLog('‚è≥ Starting async GameManager initialization...');
                
                // Create initialization chain with proper dependencies
                const initSteps = [
                    { name: 'AssetManager', fn: () => this.ensureAssetManager() },
                    { name: 'Physics', fn: () => this.initializePhysics() },
                    { name: 'DefaultTheme', fn: () => this.physicsManager.initializeDefaultTheme() },
                    { name: 'UI', fn: () => this.setupUI() },
                    { name: 'Events', fn: () => this.setupEventListeners() },
                    { name: 'DragDrop', fn: () => this.initializeDragDrop() },
                    { name: 'Theme', fn: () => this.initializeThemeManager() },
                    { name: 'LevelTheme', fn: () => this.conditionallyApplyLevelTheme() }
                ];
                
                for (const step of initSteps) {
                    try {
                        debugLog(`‚öôÔ∏è Initializing ${step.name}...`);
                        await step.fn();
                        debugLog(`‚úÖ ${step.name} initialized`);
                    } catch (error) {
                        console.error(`‚ùå Failed to initialize ${step.name}:`, error);
                        throw error;
                    }
                }
                
                // Make this globally available only after all components are ready
                window.gameManager = this;
                if (this.physicsManager) {
                    this.physicsManager.gameManager = this;
                }
                
                debugLog('‚úÖ GameManager initialization complete');
                debugLog(`üéÆ Game Manager initialized for level: "${this.levelData?.meta?.displayName ?? 'Unknown'}"`);
            }
            
            ensureAssetManager() {
                if (!window.assetManager) {
                    window.assetManager = new AssetManager();
                }
            }
            
            initializePhysics() {
                const gameCanvas = document.getElementById('gameCanvas');
                this.canvas = gameCanvas;
                this.physicsManager = new PhysicsManager(gameCanvas, this.levelData.physics || {});
            }
            
            initializeDragDrop() {
                this.dragDropManager = new DragDropManager(this.physicsManager, this);
                this.mobileEnhancementManager = new MobileEnhancementManager(this.dragDropManager);
            }
            
            initializeThemeManager() {
                this.themeManager = new ThemeManager(window.assetManager, this);
            }
            
            async conditionallyApplyLevelTheme() {
                if (this.levelData.theme) {
                    await this.applyLevelTheme();
                }
            }
            
            async rebuildDockFromData(isInitialLoad = false) {
                console.log('üîß Rebuilding dock from level data...');
                
                // Wait for initialization if needed
                if (this.initPromise && isInitialLoad) {
                    await this.initPromise;
                }
                
                // Set configuration
                window.currentLevelConfig = {
                    dockShapes: this.levelData.dockSlots || getAllShapeTypes()
                };
                
                // Rebuild dock
                await rebuildGameDock();
                
                // Apply appearance
                this.applyDockAppearance();
            }

            triggerDockAnimation() {
                debugLog('Attempting to trigger dock animation...');
                if (this.dockAnimationPlayed) {
                    debugLog('Animation already played. Skipping.');
                    return;
                }

                // Double-check that dock is actually ready for animation
                const dockingArea = document.getElementById('dockingArea');
                if (!dockingArea) {
                    debugLog('Docking area not found. Skipping animation.');
                    return;
                }

                const animConfig = this.levelData?.dock?.animation;
                if (!animConfig || !animConfig.enabled) {
                    debugLog('Animation is disabled in config. Skipping.');
                    dockingArea.classList.remove('loading');
                    return;
                }

                debugLog('Animation config found:', animConfig);

                const shapes = document.querySelectorAll('.docking-area .game-shape');
                if (!shapes.length) {
                    debugLog('No shapes found in the dock to animate. Skipping.');
                    dockingArea.classList.remove('loading');
                    return;
                }

                debugLog(`Found ${shapes.length} shapes to animate.`);

                // Mark animation as started to prevent multiple triggers
                this.dockAnimationPlayed = true;

                const lastShape = shapes[shapes.length - 1];

                const onAnimationEnd = (event) => {
                    // Ensure we only react to the opacity transition to avoid multiple triggers
                    if (event.propertyName !== 'opacity') {
                        return;
                    }
                    const dockingArea = document.getElementById('dockingArea');
                    if (dockingArea) {
                        dockingArea.classList.remove('loading');
                        debugLog('Dock animation complete, removed loading class.');
                    }
                    lastShape.removeEventListener('transitionend', onAnimationEnd);
                };

                lastShape.addEventListener('transitionend', onAnimationEnd);

                shapes.forEach((shape, index) => {
                    // console.log(`Applying animation to shape ${index}`);
                    // Set initial state
                    shape.style.opacity = '0';
                    shape.style.transform = `scale(${animConfig.minScale || 0.1})`;

                    // Stagger the animation start
                    setTimeout(() => {
                        // Add the class to enable transitions
                        shape.classList.add('shape-entrance-animation');

                        // Set transition properties from config
                        shape.style.transitionDuration = `${animConfig.durationMs || 2000}ms`;
                        shape.style.transitionTimingFunction = animConfig.easing || 'cubic-bezier(0.175, 0.885, 0.32, 1.275)';

                        // Trigger the animation by setting the final state
                        // Use a tiny timeout to ensure the initial styles are applied before the transition starts
                        setTimeout(() => {
                            shape.style.opacity = '1';
                            shape.style.transform = 'scale(1)';
                        }, 20);

                    }, index * (animConfig.staggerMs || 100));
                });
            }

            setupUI() {
                // Initialize HUD displays
                this.updateScoreDisplay();
                this.updateCoinDisplay();
                this.updateLevelDisplay();
                this.updateStars(0);
                this.updateDebugInfo();

                // Initialize HUD timer system
                this.startTimer();

                // Event listeners are handled by onclick in HTML - no need for duplicate listener
                debugLog('üéÆ GameManager initialized with unified reset system');
            }

            setupEventListeners() {
                // Keyboard controls for testing (fallback)
                document.addEventListener('keydown', (e) => {
                    if (!this.gameState.isGameActive) return;
                    
                    const centerX = this.canvas.width / 2;
                    const dropY = 100;
                    
                    switch(e.key) {
                        case '1':
                            this.physicsManager.createShape(centerX, dropY, 'square');
                            this.onShapePlaced('square');
                            break;
                        case '2':
                            this.physicsManager.createShape(centerX, dropY, 'triangle');
                            this.onShapePlaced('triangle');
                            break;
                        case '3':
                            this.physicsManager.createShape(centerX, dropY, 'circle');
                            this.onShapePlaced('circle');
                            break;
                        case '4':
                            this.physicsManager.createShape(centerX, dropY, 'cross2');
                            this.onShapePlaced('cross2');
                            break;
                        case '5':
                            this.physicsManager.createShape(centerX, dropY, 'l');
                            this.onShapePlaced('l');
                            break;
                        case '6':
                            this.physicsManager.createShape(centerX, dropY, 'cross');
                            this.onShapePlaced('cross');
                            break;
                        case '7':
                            this.physicsManager.createShape(centerX, dropY, 'barbell-one');
                            this.onShapePlaced('barbell-one');
                            break;
                        case '8':
                            this.physicsManager.createShape(centerX, dropY, 'barbell-two');
                            this.onShapePlaced('barbell-two');
                            break;
                        case '9':
                            this.physicsManager.createShape(centerX, dropY, 'diamond-barbell');
                            this.onShapePlaced('diamond-barbell');
                            break;
                    }
                });
            }

            startTimer() {
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                }
                this.timerInterval = setInterval(() => this.updateTimer(), 1000);
            }

            stopTimer() {
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                    this.timerInterval = null;
                }
            }

            // UI Update Methods
            updateScoreDisplay() {
                const scoreElement = document.getElementById('scoreText');
                if (scoreElement) {
                    scoreElement.textContent = this.gameState.score.toLocaleString();
                    
                    // Add animation for score increase
                    scoreElement.classList.add('score-increase');
                    setTimeout(() => {
                        scoreElement.classList.remove('score-increase');
                    }, 600);
                }
            }

            updateCoinDisplay() {
                const coinElement = document.getElementById('coinAmount');
                if (coinElement) {
                    coinElement.textContent = this.gameState.coins.toString();
                    
                    // Add animation for coin increase
                    coinElement.classList.add('coin-increase');
                    setTimeout(() => {
                        coinElement.classList.remove('coin-increase');
                    }, 600);
                }
            }

            updateLevelDisplay() {
                const levelElement = document.getElementById('levelDisplay');
                if (levelElement) {
                    // Use displayName from level data if available
                    if (this.levelData && this.levelData.meta && this.levelData.meta.displayName) {
                        levelElement.textContent = this.levelData.meta.displayName;
                    } else {
                        levelElement.textContent = `World ${this.currentWorld}-${this.currentLevel}`;
                    }
                }
            }

            // Level progression methods
            nextLevel() {
                this.currentLevel++;
                this.updateLevelDisplay();
                console.log(`üèÅ Advanced to World ${this.currentWorld}-${this.currentLevel}`);
            }

            nextWorld() {
                this.currentWorld++;
                this.currentLevel = 1;
                this.updateLevelDisplay();
                console.log(`üåç Advanced to World ${this.currentWorld}-${this.currentLevel}`);
            }

            setLevel(world, level) {
                this.currentWorld = world;
                this.currentLevel = level;
                this.updateLevelDisplay();
                console.log(`üìç Set level to World ${this.currentWorld}-${this.currentLevel}`);
            }

            // Physics Event Handlers
            onShapeLandedOnPlatform() {
                if (!this.gameState.isGameActive) {
                    return;
                }

                console.log('üéØ GameManager: Shape landed on platform - triggering camera shake!');
                this.gameState.recordPhysicsEvent('landing');
                
                // Track consecutive landings for streak bonuses
                this.gameState.consecutiveLandings = (this.gameState.consecutiveLandings || 0) + 1;
                this.gameState.lastAction = 'landing';
                
                // Base rewards
                let scoreBonus = 50;
                let coinBonus = 1;
                
                // Streak multipliers
                if (this.gameState.consecutiveLandings >= 5) {
                    coinBonus += 5; // +5 coins for 5+ streak
                    scoreBonus += 100;
                    this.createCoinShower('LANDING MASTER!', 5);
                } else if (this.gameState.consecutiveLandings >= 3) {
                    coinBonus += 2; // +2 coins for 3+ streak
                    scoreBonus += 50;
                    this.createFloatingText(`üî• ${this.gameState.consecutiveLandings}x STREAK!`, 
                        document.getElementById('coinAmount'), '#FF6B35');
                }
                
                this.gameState.score += scoreBonus;
                this.gameState.coins += coinBonus;
                this.updateScoreDisplay();
                this.updateCoinDisplay();
                
                // Sound effect integration point
                this.playSound('shapeLanding');
                
                // Create enhanced particle effects
                if (this.physicsManager && this.physicsManager.particleSystem) {
                    const canvasRect = this.physicsManager.canvas.getBoundingClientRect();
                    const platformY = canvasRect.height * 0.85;
                    const x = Math.random() * canvasRect.width * 0.6 + canvasRect.width * 0.2;
                    const particleCount = Math.min(12 + this.gameState.consecutiveLandings * 2, 24);
                    this.physicsManager.particleSystem.createThemeParticles('landing', x, platformY, particleCount);
                }
                
                // Enhanced visual feedback
                const scoreElement = document.getElementById('scoreText');
                const coinElement = document.getElementById('coinAmount');
                
                this.createFloatingText(`+${scoreBonus}`, scoreElement, '#10B981');
                this.createFloatingText(`+${coinBonus}`, coinElement, '#FFD700');
                
                // Extra visual effects for big bonuses
                if (coinBonus > 3) {
                    this.createFloatingText('üí∞üí∞üí∞', coinElement, '#FFD700');
                    this.pulseElement(coinElement, 3);
                }
                

            }

            onShapeCollision() {
                if (!this.gameState.isGameActive) {
                    return;
                }


                this.gameState.recordPhysicsEvent('collision');
                
                // Reset landing streak on collision
                this.gameState.consecutiveLandings = 0;
                
                // Track collision chains for bonus coins
                this.gameState.recentCollisions = (this.gameState.recentCollisions || 0) + 1;
                
                // Base rewards
                let scoreBonus = 25;
                let coinBonus = 0;
                
                // Collision-based coin rewards
                if (this.gameState.recentCollisions % 1 === 0) { // Every collision now gives coins!
                    coinBonus = 1;
                    
                    // Bonus for rapid collisions
                    if (this.gameState.recentCollisions >= 3) {
                        coinBonus += 2; // +2 extra for collision chains
                        scoreBonus += 25;
                        this.createFloatingText('üí• CHAIN REACTION!', document.getElementById('scoreText'), '#FF6B35');
                    }
                }
                
                // Random coin jackpots (5% chance)
                if (Math.random() < 0.05) {
                    const jackpot = Math.floor(Math.random() * 10) + 5; // 5-14 coins
                    coinBonus += jackpot;
                    this.createCoinShower('JACKPOT!', jackpot);
                    
                    // Small celebratory shake for big jackpots
                    if (jackpot >= 10 && this.physicsManager) {
                        this.physicsManager.startCameraShake(4, 300);
                    }
                }
                
                this.gameState.score += scoreBonus;
                this.gameState.coins += coinBonus;
                
                // Sound effect integration point
                this.playSound('shapeCollision');
                
                // Create enhanced particle effects
                if (this.physicsManager && this.physicsManager.particleSystem) {
                    const canvasRect = this.physicsManager.canvas.getBoundingClientRect();
                    const x = Math.random() * canvasRect.width * 0.8 + canvasRect.width * 0.1;
                    const y = Math.random() * canvasRect.height * 0.6 + canvasRect.height * 0.2;
                    const particleCount = Math.min(8 + this.gameState.recentCollisions, 20);
                    this.physicsManager.particleSystem.createThemeParticles('collision', x, y, particleCount);
                }
                
                this.updateScoreDisplay();
                if (coinBonus > 0) {
                    this.updateCoinDisplay();
                    const coinElement = document.getElementById('coinAmount');
                    this.createFloatingText(`+${coinBonus}`, coinElement, '#FFD700');
                }
                
                // Add visual feedback for collision bonuses
                const scoreElement = document.getElementById('scoreText');
                this.createFloatingText(`+${scoreBonus}`, scoreElement, '#4ECDC4');
                
                // Reset collision counter after a pause
                setTimeout(() => {
                    if (this.gameState.lastAction !== 'collision') {
                        this.gameState.recentCollisions = 0;
                    }
                }, 2000);
                
                this.gameState.lastAction = 'collision';
                

            }

            onShapeFell() {
                if (this.gameState.isGameOver) {
                    return;
                }

                
                this.gameState.recordPhysicsEvent('fall');
                
                // Track fall time for stability bonuses
                this.gameState.lastFallTime = Date.now();
                
                // Reset all streaks on fall
                this.gameState.consecutiveLandings = 0;
                this.gameState.recentCollisions = 0;
                
                // Dramatic penalties based on current coin count
                let scorePenalty = 100;
                let coinPenalty = 3; // Increased base penalty
                
                // Scale penalties with current wealth (more coins = bigger penalty)
                if (this.gameState.coins >= 50) {
                    coinPenalty += 7; // -10 coins total for wealthy players
                    scorePenalty += 200;
                    this.createFloatingText('üí∏ MAJOR LOSS!', document.getElementById('coinAmount'), '#FF4444');
                } else if (this.gameState.coins >= 20) {
                    coinPenalty += 2; // -5 coins total
                    scorePenalty += 100;
                }
                
                // Apply penalties with minimums
                this.gameState.score = Math.max(0, this.gameState.score - scorePenalty);
                this.gameState.coins = Math.max(0, this.gameState.coins - coinPenalty);
                
                this.updateScoreDisplay();
                this.updateCoinDisplay();
                
                // Dramatic visual effects
                const coinElement = document.getElementById('coinAmount');
                const scoreElement = document.getElementById('scoreText');
                
                this.createFloatingText(`-${coinPenalty}`, coinElement, '#FF6B6B');
                this.createFloatingText(`-${scorePenalty}`, scoreElement, '#FF6B6B');
                
                // Shake effect for major losses
                if (coinPenalty >= 5) {
                    this.shakeElement(coinElement, 5);
                    this.createFloatingText('üíÄüíÄÔøΩ', coinElement, '#FF4444');
                }
                
                // Camera shake effect for dramatic falls
                const randomIntensity = Math.floor(Math.random() * 10) + 10;
                const duration = 800;
                
                if (this.physicsManager) {
                    this.physicsManager.startCameraShake(randomIntensity, duration);
                }
                
                this.playSound('shapeFall');

                if (this.gameState.levelFailed) {
                    this.onLevelFailed();
                }

                this.onGameOver('Ground Collision!');
            }

            onShapePlaced(shapeType) {
                if (!this.gameState.isGameActive) {
                    return;
                }

                this.gameState.addPlacedShape(shapeType);
                this.updateDebugInfo();
                
                // Update score
                this.gameState.score += 100;
                document.getElementById('scoreText').textContent = this.gameState.score.toLocaleString();
                
                // Update progress bar using current dock configuration
                const totalShapes = currentLevelConfig.dockShapes.length;
                const progress = (this.gameState.placedShapes.length / totalShapes) * 100;
                document.getElementById('starProgressBar').style.width = progress + '%';
                
                // Update stars based on progress
                this.updateStars(this.gameState.placedShapes.length);
                
                // Check for level completion (start end-level countdown)
                if (this.gameState.placedShapes.length >= totalShapes) {


                    // Coin reward for successfully placing all shapes
                    this.gameState.coins += 5;
                    this.updateCoinDisplay();

                    // Show coin reward particle
                    const coinElement = document.getElementById('coinAmount');
                    this.createFloatingText('+5 All Shapes!', coinElement, '#FFD700');

                    this.gameState.startEndLevelCountdown();
                    this.physicsManager.showEventNotification('End-Level Countdown!', 'balance');
                }

                this.checkUnlockConditions();
            }

            updateStars(shapesPlaced) {
                const stars = document.querySelectorAll('.star');
                const totalShapes = currentLevelConfig.dockShapes.length;
                const progressPercent = (shapesPlaced / totalShapes) * 100;
                
                // Star thresholds: 33.33%, 66.66%, 100%
                const starThresholds = [33.33, 66.66, 100];
                
                stars.forEach((star, index) => {
                    const threshold = starThresholds[index];
                    const shouldBeFilled = progressPercent >= threshold;
                    
                    if (shouldBeFilled && !star.classList.contains('filled')) {
                        // Star should be filled and isn't yet
                        const wasEmpty = !star.classList.contains('filled');
                        star.classList.add('filled');
                        
                        // Add particle effect for newly filled star
                        if (wasEmpty) {
                            setTimeout(() => {
                                this.createFloatingText('‚≠ê', star, '#FFD700');
                            }, 100);
                        }
                    } else if (!shouldBeFilled && star.classList.contains('filled')) {
                        // Star should not be filled but is
                        star.classList.remove('filled');
                    }
                });
                
                // Update progress bar with animation using current dock configuration
                const progressBar = document.getElementById('starProgressBar');
                
                // Smooth progress bar animation
                progressBar.style.transition = 'width 0.5s ease-out';
                progressBar.style.width = progressPercent + '%';
                
                if (shapesPlaced > 0) {
                    this.animateProgressBar(progressBar);
                }
            }

            updateTimer() {
                if (!this.gameState.isGameActive) return;
                
                const timerElement = document.getElementById('gameTimer');
                
                switch(this.gameState.timerMode) {
                    case 'elapsed':
                        this.updateElapsedTimer(timerElement);
                        break;
                    case 'countdown':
                        this.updateCountdownTimer(timerElement);
                        break;
                    case 'endlevel':
                        this.updateEndLevelTimer(timerElement);
                        break;
                }
            }

            updateElapsedTimer(element) {
                const minutes = Math.floor(this.gameState.gameTime / 60);
                const seconds = this.gameState.gameTime % 60;
                element.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                this.gameState.gameTime++;
                
                // Remove any warning classes
                element.classList.remove('timer-warning', 'timer-critical');
            }

            updateCountdownTimer(element) {
                // Use gameTime for countdown timer (starts from configured time and counts down)
                const minutes = Math.floor(this.gameState.gameTime / 60);
                const seconds = this.gameState.gameTime % 60;
                element.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                
                // Remove previous warning classes
                element.classList.remove('timer-warning', 'timer-critical');
                
                // Add warning effects based on time remaining
                if (this.gameState.gameTime <= 5 && this.gameState.gameTime > 0) {
                    element.classList.add('timer-critical');
                } else if (this.gameState.gameTime <= 10) {
                    element.classList.add('timer-warning');
                }
                
                // Countdown: decrease time
                this.gameState.gameTime--;
                
                // Check if countdown reached zero
                if (this.gameState.gameTime < 0) {
                    this.gameState.gameTime = 0; // Prevent negative display
                    element.textContent = '0:00';
                    
                    // Trigger game over due to time up
                    console.log('‚è∞ Countdown timer reached zero - Game Over!');
                    this.onGameTimeUp();
                }
            }

            updateEndLevelTimer(element) {
                // Create 3-dot display if it doesn't exist
                if (!element.querySelector('.countdown-dots')) {
                    console.log('üî¥ Creating dramatic 3-dot countdown display...');
                    element.innerHTML = '';
                    const dotsContainer = document.createElement('div');
                    dotsContainer.className = 'countdown-dots';
                    
                    for (let i = 0; i < 3; i++) {
                        const dot = document.createElement('div');
                        dot.className = 'countdown-dot';
                        dot.id = `countdown-dot-${i}`;
                        dotsContainer.appendChild(dot);
                    }
                    
                    element.appendChild(dotsContainer);
                    this.gameState.endLevelDots = 0;
                    console.log('‚úÖ 3-dot countdown display created!');
                }
                
                // Update dots based on time remaining using configured duration
                const totalDuration = currentLevelConfig.endLevelDuration;
                const timeElapsed = totalDuration - this.gameState.endLevelTime;
                const dotsToShow = Math.min(3, Math.ceil((timeElapsed / totalDuration) * 3));
                console.log(`üîµ Updating dots: ${dotsToShow} active dots, ${this.gameState.endLevelTime}s remaining (total: ${totalDuration}s)`);
                
                for (let i = 0; i < 3; i++) {
                    const dot = document.getElementById(`countdown-dot-${i}`);
                    if (dot) {
                        if (i < dotsToShow) {
                            if (i === dotsToShow - 1 && this.gameState.endLevelTime > 0) {
                                dot.className = 'countdown-dot active';
                            } else {
                                dot.className = 'countdown-dot completed';
                            }
                        } else {
                            dot.className = 'countdown-dot';
                        }
                    }
                }
                
                this.gameState.endLevelTime--;
                
                if (this.gameState.endLevelTime < 0) {
                    console.log('üèÜ End level countdown complete! Level finished!');
                    this.triggerLevelCompleteEffects();
                    this.onLevelComplete();
                }
            }

            updateDebugInfo() {
                const debugInfo = document.getElementById('debugInfo');
                const physicsStats = this.physicsManager.getEventStats();
                // Determine total shapes based on loaded level data (for v2.2+ files)
                let totalShapes = 0;
                if (this.levelData && this.levelData.dock && Array.isArray(this.levelData.dock.slots)) {
                    totalShapes = this.levelData.dock.slots.length;
                } else if (window.currentLevelConfig && Array.isArray(window.currentLevelConfig.dockShapes)) {
                    totalShapes = window.currentLevelConfig.dockShapes.length;
                }
                // Count available shapes (not being dragged)
                const availableShapes = document.querySelectorAll('.game-shape:not(.dragging)').length;
                if (debugInfo) {
                    debugInfo.textContent = `Placed: ${this.gameState.placedShapes.length}/${totalShapes} | Dock: ${availableShapes}/${totalShapes} | Events: ${physicsStats.events} | FPS: 60`;
                }
            }

            /**
             * Rebuild the docking area from level data, generating slots and previews.
             */
            rebuildDockFromData(isInitialLoad = false) {
                const dockData = this.levelData?.dock;
                if (!dockData || !Array.isArray(dockData.slots)) {
                    console.error('‚ùå Dock data is missing or invalid in level file.');
                    return;
                }
                if (window.currentLevelConfig) {
                    window.currentLevelConfig.dockShapes = dockData.slots
                        .map(slot => slot.shapePrefabId)
                        .filter(shape => !!shape);
                    window.currentLevelConfig.dockSlots = dockData.slots.length;
                }
                const dockingArea = document.getElementById('dockingArea');
                if (!dockingArea) {
                    console.error('‚ùå dockingArea not found!');
                    return;
                }
                dockingSpecialEffectsManager.reset();
                dockingArea.innerHTML = '';
                if (dockData.layout) {
                    dockingArea.style.gridTemplateColumns = `repeat(${dockData.layout.columns}, 1fr)`;
                    dockingArea.style.gridTemplateRows = `repeat(${dockData.layout.rows}, 1fr)`;
                }
                dockData.slots.forEach((slotData) => {
                    const slotDiv = document.createElement('div');
                    slotDiv.className = 'shape-slot';
                    slotDiv.dataset.slotIndex = slotData.slotIndex;
                    if (slotData.specialType && slotData.specialType.type) {
                        slotDiv.dataset.specialType = slotData.specialType.type;
                    }
                    if (slotData.shapePrefabId && typeof shapeRenderer !== 'undefined') {
                        const preview = shapeRenderer.createDockPreview(slotData.shapePrefabId, 90);
                        if (preview) {
                            preview.id = `shape-${slotData.shapeId || slotData.shapePrefabId}`;
                            preview.dataset.shape = slotData.shapePrefabId;
                            preview.dataset.shapeId = slotData.shapeId;
                            preview.className = 'game-shape shape-preview';
                            // Mark locked shapes visually
                            if (slotData.specialType && slotData.specialType.type === 'LOCKED') {
                                preview.classList.add('locked');
                                const lockIcon = document.createElement('div');
                                lockIcon.className = 'lock-icon';
                                lockIcon.innerHTML = `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" style="filter: drop-shadow(0 0 2px rgba(0,0,0,0.7));"><rect x="5" y="11" width="14" height="10" rx="2" fill="white" fill-opacity="0.9"/><path d="M8 11V7C8 4.79086 9.79086 3 12 3C14.2091 3 16 4.79086 16 7V11" stroke="white" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" stroke-opacity="0.9"/></svg>`;
                                slotDiv.appendChild(lockIcon);
                            }
                            slotDiv.appendChild(preview);
                            if (slotData.specialType && slotData.specialType.type && slotData.specialType.type !== 'LOCKED') {
                                console.log(`üé® Registering special effect for slot ${slotData.slotIndex}:`, { shapeType: slotData.shapePrefabId, specialType: slotData.specialType });
                                dockingSpecialEffectsManager.register(preview, slotData.specialType);
                            } else {
                                console.log(`‚ö™ Skipping special effect registration for slot ${slotData.slotIndex}:`, { 
                                    shapeType: slotData.shapePrefabId, 
                                    hasSpecialType: !!slotData.specialType,
                                    specialType: slotData.specialType?.type,
                                    isLocked: slotData.specialType?.type === 'LOCKED'
                                });
                            }
                        } else {
                            slotDiv.classList.add('empty');
                        }
                    } else {
                        slotDiv.classList.add('empty');
                    }
                    dockingArea.appendChild(slotDiv);
                });
                console.log(`‚úÖ Dock rebuilt from level data with ${dockData.slots.length} slots.`);

                // Only trigger animation if this is truly a new rebuild
                if (isInitialLoad || !this.dockAnimationPlayed) {
                    if (isInitialLoad) {
                        this.dockAnimationPlayed = false;
                        setTimeout(() => this.triggerDockAnimation(), 100);
                    } else {
                        this.triggerDockAnimation();
                    }
                } else {
                    console.log('Dock animation already played, skipping trigger');
                }
            }

            /**
             * Applies custom appearance styles to the docking area from level data.
             */
            applyDockAppearance() {
                const dockData = this.levelData?.dock;
                if (!dockData || !dockData.appearance) {
                    console.log('üé® No custom dock appearance found in level data. Using default styles.');
                    return;
                }

                const appearance = dockData.appearance;
                const dockingArea = document.getElementById('dockingArea');
                if (!dockingArea) {
                    console.error('‚ùå Could not find dockingArea element to apply styles.');
                    return;
                }

                console.log('üé® Applying custom dock appearance styles...', appearance);

                // Apply styles to the main docking area
                if (appearance.backgroundColor) {
                    dockingArea.style.background = appearance.backgroundColor;
                }
                if (appearance.borderColor) dockingArea.style.borderColor = appearance.borderColor;
                if (appearance.borderWidth) dockingArea.style.borderWidth = appearance.borderWidth;
                if (appearance.borderStyle) dockingArea.style.borderStyle = appearance.borderStyle;
                if (appearance.cornerRadius) dockingArea.style.borderRadius = appearance.cornerRadius;

                if (appearance.position) {
                    if (appearance.position.top) dockingArea.style.top = appearance.position.top;
                    if (appearance.position.left) dockingArea.style.left = appearance.position.left;
                    if (appearance.position.right) dockingArea.style.right = appearance.position.right;
                    if (appearance.position.bottom) dockingArea.style.bottom = appearance.position.bottom;
                }
                if (appearance.size) {
                    if (appearance.size.height) dockingArea.style.height = appearance.size.height;
                }
                if (appearance.spacing) {
                    if (appearance.spacing.padding) dockingArea.style.padding = appearance.spacing.padding;
                    if (appearance.spacing.gap) dockingArea.style.gap = appearance.spacing.gap;
                }

                // Apply styles to the shape slots
                if (appearance.slotAppearance) {
                    const slotAppearance = appearance.slotAppearance;
                    const slots = dockingArea.querySelectorAll('.shape-slot');
                    slots.forEach(slot => {
                        if (slotAppearance.backgroundColor) slot.style.background = slotAppearance.backgroundColor;
                        if (slotAppearance.borderColor) slot.style.borderColor = slotAppearance.borderColor;
                        if (slotAppearance.borderWidth) slot.style.borderWidth = slotAppearance.borderWidth;
                        if (slotAppearance.borderStyle) slot.style.borderStyle = slotAppearance.borderStyle;
                        if (slotAppearance.cornerRadius) slot.style.borderRadius = slotAppearance.cornerRadius;
                    });
                }
                 console.log('‚úÖ Custom dock appearance applied.');
            }

            checkUnlockConditions() {
                if (!this.gameplaySettings.unlockThresholds) return;
                const placedCount = this.gameState.placedShapes.length;
                this.gameplaySettings.unlockThresholds.forEach(threshold => {
                    if (placedCount === threshold.shapesPlayed) {
                        threshold.unlocksShapeInSlot.forEach(slotIndex => {
                            const slot = document.querySelector(`[data-slot-index='${slotIndex}']`);
                            if (slot) {
                                const shapeEl = slot.querySelector('.game-shape');
                                const lockIcon = slot.querySelector('.lock-icon');
                                if (shapeEl && shapeEl.classList.contains('locked')) {
                                    shapeEl.classList.remove('locked');
                                    if (lockIcon) lockIcon.remove();
                                }
                            }
                        });
                    }
                });
            }

            /**
             * Create static platforms from level data.
             */
            createPlatformsFromData() {
                const platforms = this.levelData?.entities?.platforms;
                if (!platforms || !Array.isArray(platforms)) {
                    console.warn('‚ö†Ô∏è No platform data found in level file. Using default single platform.');
                    if (typeof this.physicsManager.createPlatform === 'function') {
                        this.physicsManager.createPlatform();
                    }
                    return;
                }
                if (typeof this.physicsManager.clearAllPlatforms === 'function') {
                    this.physicsManager.clearAllPlatforms();
                }
                platforms.forEach((p) => {
                    if (typeof this.physicsManager.createPlatformFromData === 'function') {
                        this.physicsManager.createPlatformFromData(p);
                    }
                });
                console.log(`‚úÖ Created ${platforms.length} platforms from level data.`);
            }

            /**
             * Applies the theme specified in the level data on initial load.
             */
            async applyLevelTheme() {
                if (this.levelThemeApplied) {
                    debugLog('‚ö†Ô∏è Level theme already applied, skipping');
                    return;
                }
                
                this.levelThemeApplied = true;
                const baseTheme = this.baseThemeId || 'classic';
                console.log(`üé® Applying level's base theme on load: ${baseTheme}`);
                await UnifiedThemeController.changeTheme(baseTheme, { 
                    source: 'level-theme', 
                    animated: false 
                });
            }

            onGameTimeUp() {
                this.gameState.isGameActive = false;
                console.log('‚è∞ Time Up! Level Failed!');
            }

            onGameOver(reason = 'Game Over!') {
                if (this.gameState.isGameOver) {
                    return;
                }

                this.gameState.isGameOver = true;
                this.gameState.isGameActive = false;
                this.gameState.isCountdownActive = false;
                this.gameState.endLevelStarted = false;
                this.gameState.levelFailed = true;

                this.stopTimer();

                if (this.dragDropManager) {
                    this.dragDropManager.endDrag();
                }

                if (this.physicsManager) {
                    this.physicsManager.showEventNotification('Game Over!', 'fall');
                }

                console.log(`üíÄ Game Over! ${reason}`);

                this.showGameOverPopup(reason);
            }

            /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
              ‚ïë SHOW LEVEL CLEARED POPUP
              ‚ïë Displays a celebratory popup modal when the level is successfully cleared.
              ‚ïë Includes animated title, stars, and button to continue or replay level.
              ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
            showLevelClearedPopup() {
                // Create modal overlay
                const modal = document.createElement('div');
                modal.className = 'level-cleared-modal';
                modal.id = 'levelClearedModal';
                
                // Create modal content
                const content = document.createElement('div');
                content.className = 'level-cleared-content';
                
                // Title
                const title = document.createElement('div');
                title.className = 'level-cleared-title';
                title.textContent = 'Level Cleared!';
                
                // Subtitle with score info
                const subtitle = document.createElement('div');
                subtitle.className = 'level-cleared-subtitle';
                subtitle.textContent = `Score: ${this.gameState.score} | Coins: ${this.gameState.coins}`;
                
                // Animated stars
                const stars = document.createElement('div');
                stars.className = 'level-cleared-stars';
                stars.textContent = '‚≠ê ‚≠ê ‚≠ê';
                
                // Continue button
                const continueBtn = document.createElement('button');
                continueBtn.className = 'level-cleared-button';
                continueBtn.textContent = 'Continue';
                continueBtn.onclick = () => this.closeLevelClearedPopup();
                
                // Enhanced mobile touch support
                continueBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault(); // Prevent double-tap zoom
                    continueBtn.style.transform = 'scale(0.95)';
                }, { passive: false });
                
                continueBtn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    continueBtn.style.transform = '';
                    // Trigger click after a brief delay to ensure visual feedback
                    setTimeout(() => continueBtn.click(), 50);
                }, { passive: false });
                
                // Replay button
                const replayBtn = document.createElement('button');
                replayBtn.className = 'level-cleared-button';
                replayBtn.textContent = 'Replay Level';
                replayBtn.style.background = 'linear-gradient(135deg, #2196F3 0%, #1976D2 100%)';
                replayBtn.onclick = () => {
                    this.closeLevelClearedPopup();
                    resetLevel();
                };
                
                // Enhanced mobile touch support
                replayBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault(); // Prevent double-tap zoom
                    replayBtn.style.transform = 'scale(0.95)';
                }, { passive: false });
                
                replayBtn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    replayBtn.style.transform = '';
                    // Trigger click after a brief delay to ensure visual feedback
                    setTimeout(() => replayBtn.click(), 50);
                }, { passive: false });
                
                // Assemble modal
                content.appendChild(title);
                content.appendChild(subtitle);
                content.appendChild(stars);
                content.appendChild(continueBtn);
                content.appendChild(replayBtn);
                modal.appendChild(content);
                
                // Add to page
                document.body.appendChild(modal);
                
                // Prevent background scrolling on mobile
                document.body.classList.add('modal-open');
                
                console.log('üéâ Level Cleared popup displayed!');
            }

            closeLevelClearedPopup() {
                const modal = document.getElementById('levelClearedModal');
                if (modal) {
                    modal.style.animation = 'modalFadeIn 0.3s ease-out reverse';
                    // Re-enable background scrolling
                    document.body.classList.remove('modal-open');
                    setTimeout(() => {
                        modal.remove();
                    }, 300);
                }
            }

            showGameOverPopup(reason = 'Game Over!') {
                this.closeGameOverPopup();

                const modal = document.createElement('div');
                modal.className = 'game-over-modal';
                modal.id = 'gameOverModal';

                const content = document.createElement('div');
                content.className = 'game-over-content';

                const title = document.createElement('div');
                title.className = 'game-over-title';
                title.textContent = 'Game Over';

                const message = document.createElement('div');
                message.className = 'game-over-message';
                message.textContent = reason;

                const stats = document.createElement('div');
                stats.className = 'game-over-stats';
                stats.innerHTML = `
                    <div>Score: <strong>${this.gameState.score.toLocaleString()}</strong></div>
                    <div>Coins: <strong>${this.gameState.coins.toLocaleString()}</strong></div>
                    <div>Shapes Placed: <strong>${this.gameState.placedShapes.length}</strong></div>
                `;

                const buttons = document.createElement('div');
                buttons.className = 'game-over-buttons';

                const retryButton = document.createElement('button');
                retryButton.className = 'game-over-button';
                retryButton.textContent = 'Retry Level';
                retryButton.onclick = () => {
                    this.closeGameOverPopup();
                    resetLevel();
                };
                
                // Enhanced mobile touch support
                retryButton.addEventListener('touchstart', (e) => {
                    e.preventDefault(); // Prevent double-tap zoom
                    retryButton.style.transform = 'scale(0.95)';
                }, { passive: false });
                
                retryButton.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    retryButton.style.transform = '';
                    // Trigger click after a brief delay to ensure visual feedback
                    setTimeout(() => retryButton.click(), 50);
                }, { passive: false });

                const closeButton = document.createElement('button');
                closeButton.className = 'game-over-button secondary';
                closeButton.textContent = 'Close';
                closeButton.onclick = () => this.closeGameOverPopup();
                
                // Enhanced mobile touch support  
                closeButton.addEventListener('touchstart', (e) => {
                    e.preventDefault(); // Prevent double-tap zoom
                    closeButton.style.transform = 'scale(0.95)';
                }, { passive: false });
                
                closeButton.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    closeButton.style.transform = '';
                    // Trigger click after a brief delay to ensure visual feedback
                    setTimeout(() => closeButton.click(), 50);
                }, { passive: false });

                buttons.appendChild(retryButton);
                buttons.appendChild(closeButton);

                content.appendChild(title);
                content.appendChild(message);
                content.appendChild(stats);
                content.appendChild(buttons);
                modal.appendChild(content);

                document.body.appendChild(modal);
                
                // Prevent background scrolling on mobile
                document.body.classList.add('modal-open');
            }

            closeGameOverPopup() {
                const modal = document.getElementById('gameOverModal');
                if (modal) {
                    modal.style.animation = 'modalFadeIn 0.3s ease-out reverse';
                    // Re-enable background scrolling
                    document.body.classList.remove('modal-open');
                    setTimeout(() => {
                        if (modal.parentNode) {
                            modal.parentNode.removeChild(modal);
                        }
                    }, 300);
                }
            }

            /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
              ‚ïë TRIGGER LEVEL COMPLETE EFFECTS
              ‚ïë Creates spectacular visual effects when level is completed successfully.
              ‚ïë Includes cascading star effects, screen flash, and celebration particles.
              ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
            triggerLevelCompleteEffects() {
                // Flash effect for completion
                const screen = document.querySelector('.screen');
                if (screen) {
                    screen.style.animation = 'levelCompleteFlash 1s ease-out';
                    setTimeout(() => {
                        screen.style.animation = '';
                    }, 1000);
                }

                // Cascade star effects
                const stars = document.querySelectorAll('.star');
                stars.forEach((star, index) => {
                    setTimeout(() => {
                        star.style.animation = 'starBurst 0.8s ease-out';
                        this.createFloatingText('‚òÖ', star, '#FFD700');
                    }, index * 150);
                });

                // Multiple celebration particles
                setTimeout(() => {
                    const scoreElement = document.getElementById('scoreText');
                    const coinElement = document.getElementById('coinAmount');

                    if (scoreElement) {
                        this.createFloatingText('üéâ', scoreElement, '#FF6B6B');
                    }
                    if (coinElement) {
                        this.createFloatingText('üéä', coinElement, '#4ECDC4');
                    }

                    setTimeout(() => {
                        if (scoreElement) {
                            this.createFloatingText('üèÜ', scoreElement, '#FFD700');
                        }
                    }, 300);
                }, 500);
            }

            onLevelComplete() {
                this.gameState.isGameActive = false;
                this.gameState.levelCompleted = true;
                console.log('üéØ Level Complete! Score: ' + this.gameState.score);
                
                // Sound effect integration point
                this.playSound('levelComplete');
                
                // Bonus points for completion with particle effects
                this.gameState.score += 500;
                this.gameState.coins += 25; // Increased completion bonus
                
                // Show Level Cleared popup immediately
                this.showLevelClearedPopup();
                
                // Advance to next level after a delay
                setTimeout(() => {
                    this.nextLevel();
                }, 3000); // Increased delay to account for popup
                
                // Create floating text for completion bonus
                const scoreElement = document.getElementById('scoreText');
                this.createFloatingText('+500', scoreElement, '#FFD700');
                
                const coinElement = document.getElementById('coinAmount');
                this.createFloatingText('+25 Complete!', coinElement, '#4ECDC4');
                
                // Stability bonus
                const stabilityBonus = Math.floor(this.gameState.stability * 2);
                this.gameState.score += stabilityBonus;
                
                // Stability coin bonus for high stability (80%+)
                if (this.gameState.stability >= 80) {
                    const coinBonus = Math.floor(this.gameState.stability / 10);
                    this.gameState.coins += coinBonus;
                    
                    setTimeout(() => {
                        this.createFloatingText(`+${coinBonus} Stability`, coinElement, '#10B981');
                    }, 750);
                }
                
                if (stabilityBonus > 0) {
                    setTimeout(() => {
                        this.createFloatingText(`+${stabilityBonus} Stability`, scoreElement, '#10B981');
                    }, 500);
                }
                
                // Update display
                this.updateScoreDisplay();
                this.updateCoinDisplay();
                
                // All stars should be filled with animation
                this.updateStars(3);
                const progressBar = document.getElementById('starProgressBar');
                this.animateProgressBar(progressBar);
                
                this.physicsManager.showEventNotification('Level Complete!', 'collision');
            }

            onLevelFailed() {
                this.gameState.isGameActive = false;
                console.log('üíÄ Level Failed! Shape fell during countdown.');
                this.physicsManager.showEventNotification('Level Failed!', 'fall');
            }

            resetLevel() {
                console.log('üîÑ Resetting level...');

                this.closeGameOverPopup();
                this.stopTimer();

                // Clear all dynamic physics bodies
                this.physicsManager.cleanup();
                
                // Recreate the platform and boundaries
                this.physicsManager.createPlatform();
                this.physicsManager.createBoundaries();
                
                // Reset game state
                this.gameState.resetLevel();
                
                // Restore all shapes to docking area
                this.restoreAllShapesToDock();
                
                // Reset HUD to initial values
                this.updateScoreDisplay();
                this.updateCoinDisplay();
                document.getElementById('starProgressBar').style.width = '0%';
                document.getElementById('gameTimer').textContent = '0:00';
                
                // Reset timer mode to elapsed
                const modeIndicator = document.getElementById('timerModeIndicator');
                modeIndicator.className = 'timer-mode-indicator timer-mode-elapsed';
                modeIndicator.textContent = '‚è±';
                
                // Reset all stars
                document.querySelectorAll('.star').forEach(star => {
                    star.classList.remove('filled');
                });
                
                // Update debug info
                this.updateDebugInfo();

                this.startTimer();

                console.log('‚úÖ Level reset complete');
            }

            /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
              ‚ïë CREATE FLOATING TEXT PARTICLE
              ‚ïë Generates animated floating text particles for visual feedback. Creates
              ‚ïë temporary DOM elements positioned relative to target elements that float
              ‚ïë upward and fade out. Used for score/coin increase notifications.
              ‚ïë Parameters: text - Text to display, element - Reference element, color - Text color
              ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
            createFloatingText(text, element, color = '#FFD700') {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.textContent = text;
                particle.style.color = color;
                
                const rect = element.getBoundingClientRect();
                particle.style.left = (rect.left + rect.width / 2) + 'px';
                particle.style.top = rect.top + 'px';
                
                document.body.appendChild(particle);
                
                setTimeout(() => {
                    if (particle.parentNode) {
                        document.body.removeChild(particle);
                    }
                }, 2000);
            }

            /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
              ‚ïë CREATE COIN SHOWER EFFECT
              ‚ïë Creates a spectacular shower of coin particles for major achievements.
              ‚ïë Multiple floating coins rain down from the coin counter element.
              ‚ïë Used for jackpots, streaks, and other exciting coin-earning events.
              ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
            createCoinShower(message, coinCount) {
                const coinElement = document.getElementById('coinAmount');
                const rect = coinElement.getBoundingClientRect();
                
                // Create the main message
                this.createFloatingText(message, coinElement, '#FFD700');
                
                // Create shower of individual coins
                for (let i = 0; i < Math.min(coinCount, 15); i++) {
                    setTimeout(() => {
                        const coin = document.createElement('div');
                        coin.className = 'particle';
                        coin.textContent = 'üí∞';
                        coin.style.fontSize = '20px';
                        coin.style.left = (rect.left + Math.random() * rect.width) + 'px';
                        coin.style.top = rect.top + 'px';
                        coin.style.transform = `translate(${(Math.random() - 0.5) * 200}px, ${Math.random() * -100}px)`;
                        coin.style.opacity = '0';
                        coin.style.transition = 'all 2s ease-out';
                        
                        document.body.appendChild(coin);
                        
                        // Animate the coin
                        setTimeout(() => {
                            coin.style.transform += ` translateY(${Math.random() * 200 + 100}px)`;
                            coin.style.opacity = '1';
                        }, 50);
                        
                        // Remove after animation
                        setTimeout(() => {
                            if (coin.parentNode) {
                                document.body.removeChild(coin);
                            }
                        }, 2500);
                    }, i * 100); // Stagger the coins
                }
            }

            /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
              ‚ïë PULSE ELEMENT EFFECT
              ‚ïë Makes an element pulse with a glowing effect to draw attention.
              ‚ïë Used for significant coin increases and achievements.
              ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
            pulseElement(element, pulses = 3) {
                let count = 0;
                const originalTransform = element.style.transform;
                const originalBoxShadow = element.style.boxShadow;
                
                const pulse = () => {
                    if (count >= pulses) {
                        element.style.transform = originalTransform;
                        element.style.boxShadow = originalBoxShadow;
                        return;
                    }
                    
                    element.style.transform = 'scale(1.2)';
                    element.style.boxShadow = '0 0 20px #FFD700';
                    element.style.transition = 'all 0.2s ease-in-out';
                    
                    setTimeout(() => {
                        element.style.transform = 'scale(1)';
                        element.style.boxShadow = originalBoxShadow;
                        count++;
                        setTimeout(pulse, 300);
                    }, 200);
                };
                
                pulse();
            }

            /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
              ‚ïë SHAKE ELEMENT EFFECT
              ‚ïë Makes an element shake violently to show dramatic losses or penalties.
              ‚ïë Used when players lose significant amounts of coins.
              ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
            shakeElement(element, intensity = 3) {
                const originalTransform = element.style.transform;
                let shakeCount = 0;
                const maxShakes = intensity * 4; // More shakes for higher intensity
                
                const shake = () => {
                    if (shakeCount >= maxShakes) {
                        element.style.transform = originalTransform;
                        element.style.transition = '';
                        return;
                    }
                    
                    const x = (Math.random() - 0.5) * intensity * 4;
                    const y = (Math.random() - 0.5) * intensity * 4;
                    element.style.transform = `translate(${x}px, ${y}px)`;
                    element.style.transition = 'none';
                    
                    shakeCount++;
                    setTimeout(shake, 50);
                };
                
                shake();
            }

            /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
              ‚ïë ANIMATE PROGRESS BAR
              ‚ïë Provides visual feedback when the progress bar fills. Adds temporary 
              ‚ïë animation class that causes the bar to pulse/glow, then removes it.
              ‚ïë Enhances the user experience when star progress increases.
              ‚ïë Parameters: progressBar - The progress bar DOM element to animate
              ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
            animateProgressBar(progressBar) {
                progressBar.classList.add('progress-animate');
                setTimeout(() => progressBar.classList.remove('progress-animate'), 800);
            }

            /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
              ‚ïë SOUND SYSTEM INTEGRATION POINTS
              ‚ïë Placeholder functions for easy sound effect integration. These functions
              ‚ïë can be enhanced later with actual audio implementation using Web Audio API
              ‚ïë or HTML5 audio elements. Currently logs sound events for development.
              ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
            playSound(soundType) {
                // Integration point for sound effects
                // Future enhancement: Load and play actual audio files
                
                switch (soundType) {
                    case 'shapeLanding':
                        // Soft landing sound - positive feedback
                        break;
                    case 'shapeCollision':
                        // Click/tap sound - interaction feedback  
                        break;
                    case 'shapeRotation':
                        // Quick whoosh sound - rotation feedback
                        break;
                    case 'coinEarned':
                        // Coin pickup sound - reward feedback
                        break;
                    case 'starFilled':
                        // Bright ding sound - progress feedback
                        break;
                    case 'levelComplete':
                        // Victory fanfare - completion feedback
                        break;
                    case 'levelFailed':
                        // Disappointment sound - failure feedback
                        break;
                    case 'endLevelCountdown':
                        // Ticking sound - tension building
                        break;
                    default:
                        // Unknown sound type
                }
            }

            restoreAllShapesToDock() {
                // Restore all nine shapes to their dock positions
                const shapes = [
                    { id: 'shape-square', type: 'square', slot: 'slot-square' },
                    { id: 'shape-triangle', type: 'triangle', slot: 'slot-triangle' },
                    { id: 'shape-circle', type: 'circle', slot: 'slot-circle' },
                    { id: 'shape-cross2', type: 'cross2', slot: 'slot-cross2' },
                    { id: 'shape-l', type: 'l', slot: 'slot-l' },
                    { id: 'shape-cross', type: 'cross', slot: 'slot-cross' },
                    { id: 'shape-barbell-one', type: 'barbell-one', slot: 'slot-barbell-one' },
                    { id: 'shape-barbell-two', type: 'barbell-two', slot: 'slot-barbell-two' },
                    { id: 'shape-diamond-barbell', type: 'diamond-barbell', slot: 'slot-diamond-barbell' }
                ];
                
                shapes.forEach(shapeInfo => {
                    const slot = document.getElementById(shapeInfo.slot);
                    if (slot) {
                        slot.classList.remove('empty');
                        
                        // Remove any existing shape in the slot
                        const existingShape = slot.querySelector('.game-shape');
                        if (existingShape) {
                            existingShape.remove();
                        }
                        
                        // Create new shape element
                        const shapeElement = document.createElement('div');
                        shapeElement.className = `game-shape shape-${shapeInfo.type}`;
                        shapeElement.dataset.shape = shapeInfo.type;
                        shapeElement.id = shapeInfo.id;
                        
                        slot.appendChild(shapeElement);
                    }
                });
                

            }
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë PHASE 2: MODE TOGGLE SYSTEM - LEVEL EDITOR FUNCTIONALITY
          ‚ïë Implements the level editor mode toggle system allowing users to switch
          ‚ïë between Play Mode (normal gameplay) and Design Mode (level configuration).
          ‚ïë Includes dock configuration, timer settings, and level parameters.
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/

        // Level configuration state
        let currentMode = 'play';
        let currentLevelConfig = {
            world: 1,
            level: 1,
            timerMode: 'elapsed',
            timerStart: 60,
            endLevelDuration: 5,
            dockSlots: 9,
            barbellOrientation: 'vertical',
            dockShapes: ['square', 'triangle', 'circle', 'cross2', 'l', 'cross', 'barbell-one', 'barbell-two', 'diamond-barbell']
        };

        // Make level config globally available for dock system
        window.currentLevelConfig = currentLevelConfig;

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë TOGGLE MODE SWITCH FUNCTION
          ‚ïë New toggle switch function that switches between Play Mode and Design Mode
          ‚ïë using a compact toggle switch in the HUD instead of separate buttons.
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        function toggleModeSwitch() {
            const toggleSwitch = document.getElementById('modeToggleSwitch');
            const slider = toggleSwitch.querySelector('.mode-toggle-slider');
            
            if (currentMode === 'play') {
                toggleMode('design');
                toggleSwitch.classList.add('design-active');
                slider.textContent = 'üîß';
            } else {
                toggleMode('play');
                toggleSwitch.classList.remove('design-active');
                slider.textContent = 'üéÆ';
            }
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë TOGGLE MODE FUNCTION (UPDATED)
          ‚ïë Updated to work with new toggle switch instead of separate buttons.
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        function toggleMode(mode) {
            const gameContainer = document.getElementById('gameContainer');
            const designSidebar = document.getElementById('designSidebar');
            
            if (mode === 'design') {
                gameContainer.classList.add('design-mode');
                designSidebar.classList.add('active');
                currentMode = 'design';
                
                console.log('üîß Entered Design Mode - Level Editor Active');
                
                // Sync current dock configuration to design sidebar
                syncDockToDesign();
                generateDockSlots();
            } else {
                gameContainer.classList.remove('design-mode');
                designSidebar.classList.remove('active');
                currentMode = 'play';
                
                console.log('üéÆ Entered Play Mode - Game Active');
                
                // Apply design changes before switching back to play mode
                applyDesignChangesToConfig();
                
                // Apply any design changes to the play dock
                rebuildGameDock();
            }
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë APPLY DESIGN CHANGES TO CONFIG
          ‚ïë Automatically applies design mode changes when switching back to play mode.
          ‚ïë Collects all design sidebar values and updates currentLevelConfig.
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        function applyDesignChangesToConfig() {
            // Collect dock slot changes from design sidebar
            const dockSlotsContainer = document.getElementById('dockSlotsContainer');
            
            if (dockSlotsContainer) {
                const slotSelectors = dockSlotsContainer.querySelectorAll('select');
                const newDockShapes = [];
                
                slotSelectors.forEach(select => {
                    if (select.value && select.value !== 'none') {
                        newDockShapes.push(select.value);
                    }
                });
                
                // Apply the new dock configuration (even if empty - user may want to remove shapes)
                currentLevelConfig.dockShapes = newDockShapes;
                currentLevelConfig.dockSlots = newDockShapes.length;
                console.log('üîß Applied dock configuration from design mode:', newDockShapes);
            }
            
            // Collect other level configuration changes
            const worldLevelValue = document.getElementById('levelNumber')?.value;
            if (worldLevelValue) {
                const parts = worldLevelValue.split('-');
                currentLevelConfig.world = parseInt(parts[0]) || 1;
                currentLevelConfig.level = parseInt(parts[1]) || 1;
            }
            
            const timerMode = document.getElementById('timerMode')?.value;
            if (timerMode) {
                currentLevelConfig.timerMode = timerMode;
            }
            
            const timerStart = document.getElementById('timerStart')?.value;
            if (timerStart) {
                currentLevelConfig.timerStart = parseInt(timerStart);
            }
            
            const endLevelDuration = document.getElementById('endLevelDuration')?.value;
            if (endLevelDuration) {
                currentLevelConfig.endLevelDuration = parseInt(endLevelDuration);
            }
            
            // Apply barbell orientation setting
            const barbellOrientation = document.getElementById('barbellOrientation')?.value;
            if (barbellOrientation) {
                currentLevelConfig.barbellOrientation = barbellOrientation;
                console.log('üîß Applied barbell orientation from design mode:', barbellOrientation);
            }
            
            console.log('‚úÖ Auto-applied design changes to config:', currentLevelConfig);
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë SYNC DOCK TO DESIGN
          ‚ïë Reads the current dock configuration from the game and updates the design
          ‚ïë sidebar to match. Ensures design mode reflects the actual game state.
          ‚ïë Used when entering design mode to show current level configuration.
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        function syncDockToDesign() {
            // Use the configuration as the source of truth instead of reading from DOM
            // This ensures design mode shows the current configuration, not the DOM state
            
            // Update UI controls to match current configuration
            const slotCountInput = document.getElementById('dockSlotCount');
            if (slotCountInput) {
                slotCountInput.value = currentLevelConfig.dockSlots || currentLevelConfig.dockShapes.length;
            }
            
            // Sync barbell orientation dropdown to match current config
            const barbellOrientationSelect = document.getElementById('barbellOrientation');
            if (barbellOrientationSelect && currentLevelConfig.barbellOrientation) {
                barbellOrientationSelect.value = currentLevelConfig.barbellOrientation;
                debugLog('üîß Synced barbell orientation dropdown to:', currentLevelConfig.barbellOrientation);
            }
            
            debugLog('üîÑ Synced design UI to current config - dock shapes:', currentLevelConfig.dockShapes);
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë GENERATE DOCK SLOTS
          ‚ïë Creates the dynamic dock slot configuration UI in the design sidebar.
          ‚ïë Generates dropdown selectors for each dock slot allowing shape assignment.
          ‚ïë Preserves existing shape assignments when slot count changes.
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        function generateDockSlots() {
            const dockContainer = document.getElementById('dockSlotsContainer');
            const slotCount = parseInt(document.getElementById('dockSlotCount').value);
            
            if (!dockContainer) return;
            
            dockContainer.innerHTML = '';
            
            // Ensure we have enough shapes in the configuration
            const allShapes = ['square', 'triangle', 'circle', 'l', 'cross', 'cross2', 
                              'barbell-one', 'barbell-two', 'diamond-barbell'];
            
            // Preserve existing shapes or use defaults
            if (currentLevelConfig.dockShapes.length !== slotCount) {
                const newShapes = [];
                for (let i = 0; i < slotCount; i++) {
                    if (i < currentLevelConfig.dockShapes.length) {
                        newShapes.push(currentLevelConfig.dockShapes[i]);
                    } else {
                        newShapes.push(allShapes[i % allShapes.length]);
                    }
                }
                currentLevelConfig.dockShapes = newShapes;
            }
            
            // Generate configuration UI for each slot
            for (let i = 0; i < slotCount; i++) {
                const slotDiv = document.createElement('div');
                slotDiv.className = 'dock-slot-config';
                const selectedShape = currentLevelConfig.dockShapes[i];
                
                slotDiv.innerHTML = `
                    <div style="font-weight: bold; margin-bottom: 3px;">Slot ${i + 1}</div>
                    <select onchange="updateDockShape(${i}, this.value)" style="width: 100%; background: rgba(0,0,0,0.3); color: white; border: 1px solid rgba(255,255,255,0.3); padding: 2px;">
                        <option value="square" ${selectedShape === 'square' ? 'selected' : ''}>Square</option>
                        <option value="triangle" ${selectedShape === 'triangle' ? 'selected' : ''}>Triangle</option>
                        <option value="circle" ${selectedShape === 'circle' ? 'selected' : ''}>Circle</option>
                        <option value="l" ${selectedShape === 'l' ? 'selected' : ''}>L-Shape</option>
                        <option value="cross" ${selectedShape === 'cross' ? 'selected' : ''}>Green Cross</option>
                        <option value="cross2" ${selectedShape === 'cross2' ? 'selected' : ''}>Pink Cross</option>
                        <option value="barbell-one" ${selectedShape === 'barbell-one' ? 'selected' : ''}>One-Ended Barbell</option>
                        <option value="barbell-two" ${selectedShape === 'barbell-two' ? 'selected' : ''}>Two-Ended Barbell</option>
                        <option value="diamond-barbell" ${selectedShape === 'diamond-barbell' ? 'selected' : ''}>Diamond Barbell</option>
                    </select>
                `;
                dockContainer.appendChild(slotDiv);
            }
            
            currentLevelConfig.dockSlots = slotCount;
            console.log('üéõÔ∏è Generated dock slots configuration:', slotCount);
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë UPDATE DOCK SHAPE
          ‚ïë Updates a specific dock slot's shape assignment in the level configuration.
          ‚ïë Called when user changes shape selection in design sidebar dropdown.
          ‚ïë Parameters: slotIndex - Index of slot to update, shape - New shape type
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        function updateDockShape(slotIndex, shape) {
            if (slotIndex < currentLevelConfig.dockShapes.length) {
                currentLevelConfig.dockShapes[slotIndex] = shape;
                console.log(`üîÑ Updated slot ${slotIndex + 1} to ${shape}`);
            }
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë UPDATE BARBELL ORIENTATION
          ‚ïë Changes the barbell orientation in the dock (vertical vs horizontal).
          ‚ïë Applies CSS classes to the docking area to control barbell display.
          ‚ïë Called when user changes barbell orientation setting in design sidebar.
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        function updateBarbellOrientation() {
            const orientation = document.getElementById('barbellOrientation').value;
            currentLevelConfig.barbellOrientation = orientation;
            
            // Rebuild the dock to apply rotation changes to barbell previews
            rebuildGameDock();
            
            console.log(`üîÑ Updated barbell orientation to ${orientation} - dock rebuilt with rotated previews`);
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë APPLY LEVEL CHANGES
          ‚ïë Applies all design sidebar configuration changes to the active game.
          ‚ïë Updates level info, timer settings, and rebuilds the dock layout.
          ‚ïë Provides visual feedback to confirm changes were applied.
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        function applyLevelChanges() {
            // Save current configuration from sidebar
            const worldLevelValue = document.getElementById('levelNumber').value;
            const parts = worldLevelValue.split('-');
            currentLevelConfig.world = parseInt(parts[0]) || 1;
            currentLevelConfig.level = parseInt(parts[1]) || 1;
            currentLevelConfig.timerMode = document.getElementById('timerMode').value;
            currentLevelConfig.timerStart = parseInt(document.getElementById('timerStart').value);
            currentLevelConfig.endLevelDuration = parseInt(document.getElementById('endLevelDuration').value);
            
            // Update game UI
            updateGameUI();
            
            // Apply timer changes if countdown mode is selected
            if (currentLevelConfig.timerMode === 'countdown' && window.gameManager && window.gameManager.gameState) {
                const startTime = currentLevelConfig.timerStart || 60;
                window.gameManager.gameState.gameTime = startTime;
                
                // Update timer display
                const timerElement = document.getElementById('gameTimer');
                if (timerElement) {
                    const minutes = Math.floor(startTime / 60);
                    const seconds = startTime % 60;
                    timerElement.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                }
                
                console.log('‚è≥ Applied countdown timer start value:', startTime);
            }
            
            // Rebuild dock with new configuration
            rebuildGameDock();
            
            // Show feedback
            const btn = document.getElementById('applyChangesBtn');
            const originalText = btn.textContent;
            btn.textContent = 'Applied!';
            btn.style.background = 'linear-gradient(135deg, #27ae60 0%, #229954 100%)';
            setTimeout(() => {
                btn.textContent = originalText;
                btn.style.background = 'linear-gradient(135deg, #27ae60 0%, #229954 100%)';
            }, 1500);
            
            console.log('‚úÖ Applied level changes:', currentLevelConfig);
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë UPDATE TIMER MODE CONFIG
          ‚ïë Updates timer mode configuration when user changes dropdown in design sidebar.
          ‚ïë Immediately applies the new timer mode to current level configuration and UI.
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        function updateTimerModeConfig() {
            // Update current level config with new timer mode
            const timerModeSelect = document.getElementById('timerMode');
            currentLevelConfig.timerMode = timerModeSelect.value;
            
            // Update game state if game manager exists
            if (window.gameManager && window.gameManager.gameState) {
                window.gameManager.gameState.timerMode = timerModeSelect.value;
                
                // Initialize timer based on mode
                if (timerModeSelect.value === 'countdown') {
                    // Set countdown timer to start value
                    const startTime = currentLevelConfig.timerStart || 60;
                    window.gameManager.gameState.gameTime = startTime;
                    
                    // Update timer display immediately
                    const timerElement = document.getElementById('gameTimer');
                    if (timerElement) {
                        const minutes = Math.floor(startTime / 60);
                        const seconds = startTime % 60;
                        timerElement.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                    }
                } else if (timerModeSelect.value === 'elapsed') {
                    // Reset to 0 for elapsed timer
                    window.gameManager.gameState.gameTime = 0;
                    
                    // Update timer display immediately
                    const timerElement = document.getElementById('gameTimer');
                    if (timerElement) {
                        timerElement.textContent = '0:00';
                    }
                }
            }
            
            // Update timer UI to reflect new mode
            const modeIndicator = document.getElementById('timerModeIndicator');
            if (modeIndicator && timerModeSelect.value === 'countdown') {
                modeIndicator.className = 'timer-mode-indicator timer-mode-countdown';
                modeIndicator.textContent = '‚è≥';
            } else if (modeIndicator && timerModeSelect.value === 'elapsed') {
                modeIndicator.className = 'timer-mode-indicator timer-mode-elapsed';
                modeIndicator.textContent = '‚è±';
            } else if (modeIndicator && timerModeSelect.value === 'none') {
                modeIndicator.className = 'timer-mode-indicator timer-mode-elapsed';
                modeIndicator.textContent = '‚ö™';
            }
            
            console.log('üïí Updated timer mode to:', timerModeSelect.value);
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë UPDATE GAME UI
          ‚ïë Updates the game's UI elements to reflect current level configuration.
          ‚ïë Updates level display and other HUD elements based on design settings.
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        function updateGameUI() {
            const levelDisplay = document.getElementById('levelDisplay');
            if (levelDisplay) {
                levelDisplay.textContent = `World ${currentLevelConfig.world}-${currentLevelConfig.level}`;
            }
            
            console.log(`üéÆ Updated game UI for World ${currentLevelConfig.world}-${currentLevelConfig.level}`);
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë THEME CYCLING (GLOBAL WRAPPER) - SIMPLIFIED
          ‚ïë Simple theme cycling that uses the existing dropdown functionality.
          ‚ïë Just cycles through the dropdown options and triggers applyTheme().
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        function cycleThemes() {
            debugLog('üé® Cycling themes via button');
            
            const themeSelector = document.getElementById('themeSelector');
            const enhancedSelector = document.getElementById('enhancedThemeSelect');
            
            if (enhancedSelector && enhancedSelector.style.display !== 'none') {
                // Enhanced themes are active - cycle through them
                const themes = ['wood', 'metal', 'stone', 'neon', 'paper', 'candy'];
                const currentIndex = themes.indexOf(enhancedSelector.value);
                const nextIndex = (currentIndex + 1) % themes.length;
                const nextTheme = themes[nextIndex];
                
                enhancedSelector.value = nextTheme;
                // Use ThemeChangeQueue
                window.themeChangeQueue.changeTheme(nextTheme, 'cycle-button-enhanced');
            } else if (themeSelector) {
                // Classic themes - cycle through them
                const options = Array.from(themeSelector.options);
                const currentIndex = themeSelector.selectedIndex;
                const nextIndex = (currentIndex + 1) % options.length;
                
                themeSelector.selectedIndex = nextIndex;
                const nextTheme = options[nextIndex].value;
                // Use ThemeChangeQueue
                window.themeChangeQueue.changeTheme(nextTheme, 'cycle-button-classic');
            }
        }
        
        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë RESET LEVEL (GLOBAL WRAPPER) - ENHANCED
          ‚ïë Enhanced reset function that properly resets timer, restores shapes to dock,
          ‚ïë and clears physics simulation. Handles both design mode and play mode resets.
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        function resetLevel() {
            debugLog('üîÑ Resetting level...');

            if (window.gameManager) {
                window.gameManager.dockAnimationPlayed = false;
            }
            
            // Clear all shapes from playfield
            if (window.gameManager && window.gameManager.physicsManager) {
                window.gameManager.physicsManager.clearAllShapes();
                debugLog('üßπ Cleared physics shapes');
            }
            
            // Reset timer and game state
            if (window.gameManager && window.gameManager.gameState) {
                // Reset timer to 0:00
                window.gameManager.gameState.gameTime = 0;
                window.gameManager.gameState.endLevelTime = currentLevelConfig.endLevelDuration;
                
                // Apply current timer mode from config
                window.gameManager.gameState.timerMode = currentLevelConfig.timerMode || 'elapsed';
                
                // Update timer display
                const timerElement = document.getElementById('gameTimer');
                if (timerElement) {
                    if (currentLevelConfig.timerMode === 'countdown') {
                        // For countdown, start from configured start time
                        const startTime = currentLevelConfig.timerStart || 60;
                        window.gameManager.gameState.gameTime = startTime;
                        const minutes = Math.floor(startTime / 60);
                        const seconds = startTime % 60;
                        timerElement.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                    } else {
                        // For elapsed timer, start at 0:00
                        timerElement.textContent = '0:00';
                    }
                }
                
                // Update timer mode indicator based on current config
                const modeIndicator = document.getElementById('timerModeIndicator');
                if (modeIndicator) {
                    if (currentLevelConfig.timerMode === 'countdown') {
                        modeIndicator.className = 'timer-mode-indicator timer-mode-countdown';
                        modeIndicator.textContent = '‚è≥';
                    } else if (currentLevelConfig.timerMode === 'elapsed') {
                        modeIndicator.className = 'timer-mode-indicator timer-mode-elapsed';
                        modeIndicator.textContent = '‚è±';
                    } else if (currentLevelConfig.timerMode === 'none') {
                        modeIndicator.className = 'timer-mode-indicator timer-mode-elapsed';
                        modeIndicator.textContent = '‚ö™';
                    }
                }
                
                debugLog('‚è∞ Reset timer and game state with mode:', currentLevelConfig.timerMode);
            }
            
            // Rebuild dock with current configuration (preserves design mode settings)
            rebuildGameDock();
            
            // Trigger dock animation after reset (only if not already played)
            if (window.gameManager && typeof window.gameManager.triggerDockAnimation === 'function' && !window.gameManager.dockAnimationPlayed) {
                setTimeout(() => {
                    console.log('üé¨ Triggering dock animation after level reset');
                    window.gameManager.triggerDockAnimation();
                }, 100); // Small delay to ensure dock is fully rebuilt
            }
            
            // Force reinitialize drag and drop system after dock rebuild
            if (window.gameManager && window.gameManager.dragDropManager) {
                console.log('üîÑ Drag and drop system already initialized');
                
                // Verify all shapes are interactive
                const dockShapes = document.querySelectorAll('.game-shape');
                console.log(`üéØ Found ${dockShapes.length} shapes after reset:`, 
                    Array.from(dockShapes).map(s => s.dataset.shape));
                    
                // Ensure all shapes are visible and interactive
                dockShapes.forEach(shape => {
                    shape.style.visibility = 'visible';
                    shape.classList.remove('dragging', 'ghost-active');
                });
            }
            
            // Reset additional game state elements
            if (window.gameManager) {
                // Reset shape counters
                if (window.gameManager.gameState) {
                    window.gameManager.gameState.shapesPlaced = 0;
                    window.gameManager.gameState.isGameActive = true;
                    window.gameManager.gameState.isLevelComplete = false;
                    window.gameManager.gameState.isGameOver = false;
                    
                    // Reset placed shapes array - this fixes the "placed" count not resetting
                    window.gameManager.gameState.placedShapes = [];
                    
                    // Fix #2: Reset score and coins to zero
                    window.gameManager.gameState.score = 0;
                    window.gameManager.gameState.coins = 0;
                    
                    // Update displays
                    document.getElementById('scoreText').textContent = '0';
                    document.getElementById('coinAmount').textContent = '0';
                }
                
                // Reset progress bar
                const progressBar = document.getElementById('starProgressBar');
                if (progressBar) {
                    progressBar.style.width = '0%';
                }
                
                // Reset stars
                document.querySelectorAll('.star').forEach(star => {
                    star.classList.remove('filled');
                });
                
                console.log('üéÆ Reset game state elements including score and coins');
            }
            
            // Update debug info to reflect reset state
            if (window.gameManager && window.gameManager.updateDebugInfo) {
                window.gameManager.updateDebugInfo();
            }

            if (window.gameManager) {
                window.gameManager.closeGameOverPopup();
                window.gameManager.startTimer();
            }

            console.log('‚úÖ Level reset completed');
        }

        // Mobile Debug Toggle for Testing
        let mobileDebugMode = false;
        let originalMobileDetection = null;
        function toggleMobileDebug() {
            mobileDebugMode = !mobileDebugMode;
            const button = document.getElementById('mobileDebugButton');
            
            if (!window.gameManager?.mobileEnhancementManager) {
                console.log('‚ùå Mobile enhancement manager not found');
                console.log('Available gameManager properties:', Object.keys(window.gameManager || {}));
                return;
            }
            
            const mobileManager = window.gameManager.mobileEnhancementManager;
            
            if (mobileDebugMode) {
                // Store original detection result
                if (originalMobileDetection === null) {
                    originalMobileDetection = mobileManager.detectMobileDevice();
                }
                
                // Force mobile mode for testing
                window.gameManager.dragDropManager.isMobileDevice = true;
                mobileManager.isMobileDevice = true;
                
                // Update rotation zone bounds and show zones
                mobileManager.updateRotationZoneBounds();
                mobileManager.showRotationZones();
                
                button.style.background = 'linear-gradient(135deg, #27ae60 0%, #2ecc71 100%)';
                button.title = 'Mobile Debug: ON (Click to disable)';
                console.log('üì± Mobile Debug Mode: ON - Rotation zones should be visible');
                console.log('üì± Rotation zones bounds:', {
                    left: mobileManager.rotationZones.left.bounds,
                    right: mobileManager.rotationZones.right.bounds
                });
            } else {
                // Restore original device detection
                const originalDetection = originalMobileDetection || mobileManager.detectMobileDevice();
                window.gameManager.dragDropManager.isMobileDevice = originalDetection;
                mobileManager.isMobileDevice = originalDetection;
                
                if (!originalDetection) {
                    mobileManager.hideRotationZones();
                }
                
                button.style.background = 'linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%)';
                button.title = 'Mobile Debug: OFF (Click to enable)';
                console.log('üì± Mobile Debug Mode: OFF');
            }
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë CANVAS ENHANCEMENT THEME MANAGEMENT FUNCTIONS
          ‚ïë User interface functions for theme switching and canvas configuration
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/

        // Toggle canvas enhancements on/off
        function toggleCanvasEnhancements() {
            const enableCanvas = document.getElementById('enableCanvas');
            CANVAS_CONFIG.enabled = enableCanvas.checked;
            
            console.log(`üé® Canvas enhancements: ${CANVAS_CONFIG.enabled ? 'ON' : 'OFF'}`);
            
            // Apply change immediately
            if (window.gameManager) {
                if (CANVAS_CONFIG.enabled) {
                    // Re-initialize current theme
                    const currentTheme = window.gameManager.themeManager.getCurrentTheme();
                    UnifiedThemeController.changeTheme(currentTheme, { 
                        source: 'canvas-enhancement', 
                        animated: false 
                    });
                } else {
                    // Reset to basic appearance
                    window.gameManager.physicsManager.backgroundGradient = null;
                }
            }
        }

        // Toggle particle effects
        function toggleParticleEffects() {
            const enableParticles = document.getElementById('enableParticles');
            CANVAS_CONFIG.useParticles = enableParticles.checked;
            
            console.log(`üé® Particle effects: ${CANVAS_CONFIG.useParticles ? 'ON' : 'OFF'}`);
            
            if (!CANVAS_CONFIG.useParticles && window.gameManager) {
                // Clear existing particles
                window.gameManager.physicsManager.particleSystem.particles = [];
            }
        }

        // Touch offset configuration functions
        function toggleTouchOffset() {
            const enableTouchOffset = document.getElementById('enableTouchOffset');
            if (window.gameManager && window.gameManager.dragDropManager) {
                const currentOffset = window.gameManager.dragDropManager.getTouchOffset();
                window.gameManager.dragDropManager.setTouchOffset(
                    currentOffset.x, 
                    currentOffset.y, 
                    enableTouchOffset.checked
                );
                console.log(`üì± Touch offset: ${enableTouchOffset.checked ? 'ON' : 'OFF'}`);
            }
        }

        function updateTouchOffset() {
            const offsetX = parseInt(document.getElementById('touchOffsetX').value);
            const offsetY = parseInt(document.getElementById('touchOffsetY').value);
            const enabled = document.getElementById('enableTouchOffset').checked;
            
            if (window.gameManager && window.gameManager.dragDropManager) {
                window.gameManager.dragDropManager.setTouchOffset(offsetX, offsetY, enabled);
                updateTouchOffsetDisplay();
                console.log(`üì± Touch offset updated: X=${offsetX}px, Y=${offsetY}px`);
            }
        }

        function updateTouchOffsetDisplay() {
            const offsetX = document.getElementById('touchOffsetX').value;
            const offsetY = document.getElementById('touchOffsetY').value;
            
            document.getElementById('touchOffsetXValue').textContent = `${offsetX}px`;
            document.getElementById('touchOffsetYValue').textContent = `${offsetY}px`;
        }

        // Toggle shape animations  
        function toggleAnimations() {
            const enableAnimations = document.getElementById('enableAnimations');
            CANVAS_CONFIG.useAnimations = enableAnimations.checked;
            
            console.log(`üé® Shape animations: ${CANVAS_CONFIG.useAnimations ? 'ON' : 'OFF'}`);
        }

        // Initialize theme selector UI state
        function initializeThemeUI() {
            // Set initial checkbox states
            document.getElementById('enableCanvas').checked = CANVAS_CONFIG.enabled;
            document.getElementById('enableParticles').checked = CANVAS_CONFIG.useParticles;
            document.getElementById('enableAnimations').checked = CANVAS_CONFIG.useAnimations;
            
            // Set initial theme
            document.getElementById('themeSelector').value = CANVAS_CONFIG.defaultTheme;
            
            console.log('üé® Theme UI initialized');
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë UNIFIED THEME CONTROLLER - SINGLE ENTRY POINT FOR ALL THEME CHANGES
          ‚ïë Centralized theme management to replace scattered theme application calls
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        class UnifiedThemeController {
            static currentThemeChange = null;
            static themeChangeQueue = new Map();
            
            static async changeTheme(themeName, options = {}) {
                raceConditionDebugger.trackOperation('UnifiedThemeController.changeTheme', `${themeName}-${options.source || 'unknown'}`);
                
                const {
                    source = 'unified',
                    animated = true,
                    priority = 'normal',
                    overrides = null
                } = options;

                // Check if we're already changing to this theme
                const changeKey = `${themeName}-${source}`;
                
                if (this.themeChangeQueue.has(changeKey)) {
                    debugLog(`‚ö†Ô∏è Theme change to ${themeName} from ${source} already in progress`);
                    return this.themeChangeQueue.get(changeKey);
                }

                console.log(`üé® UnifiedThemeController: Starting theme change to ${themeName} from ${source}`);
                
                // Create the change promise
                const changePromise = themeMutex.execute(async () => {
                    // Check if theme is already active
                    if (window.assetManager?.currentTheme === themeName && 
                        window.gameManager?.themeManager?.currentTheme === themeName) {
                        debugLog(`‚úÖ Theme ${themeName} already active, skipping change`);
                        return true;
                    }
                    
                    try {
                        // Phase 1: Clear previous theme
                        await this._clearPreviousTheme();
                        
                        // Phase 2: Load new theme assets
                        await this._loadThemeAssets(themeName);
                        
                        // Phase 3: Apply theme to all subsystems
                        await this._applyToAllSystems(themeName, animated);
                        
                        // Phase 4: Apply overrides if provided
                        if (overrides) {
                            await this._applyThemeOverrides(themeName, overrides);
                        }
                        
                        // Phase 5: Rebuild UI
                        await this._rebuildUI();
                        
                        // Phase 6: Sync UI controls
                        this._syncUIControls(themeName);
                        
                        console.log(`‚úÖ UnifiedThemeController: Successfully changed theme to ${themeName}`);
                        
                    } catch (error) {
                        console.error(`‚ùå UnifiedThemeController: Failed to change theme to ${themeName}:`, error);
                        throw error;
                    }
                }, `unified-theme-change-${themeName}`);
                
                // Store in queue
                this.themeChangeQueue.set(changeKey, changePromise);
                
                try {
                    const result = await changePromise;
                    return result;
                } finally {
                    // Clean up
                    this.themeChangeQueue.delete(changeKey);
                }
            }

            static async _clearPreviousTheme() {
                try {
                    if (typeof clearPreviousThemeTextures === 'function') {
                        clearPreviousThemeTextures();
                    }
                    console.log('‚úÖ Previous theme cleared');
                } catch (error) {
                    console.warn('‚ö†Ô∏è Error clearing previous theme:', error);
                }
            }

            static async _loadThemeAssets(themeName) {
                try {
                    // Check if theme is already loaded to avoid redundant loading
                    if (!window.assetManager.themes[themeName]?.loaded) {
                        await window.assetManager.loadTheme(themeName);
                    }
                    console.log(`‚úÖ Theme assets loaded for ${themeName}`);
                } catch (error) {
                    console.warn(`‚ö†Ô∏è Failed to load theme assets for ${themeName}:`, error);
                    // Continue with fallback colors
                }
            }

            static async _applyToAllSystems(themeName, animated) {
                try {
                    // Load the theme first through AssetManager
                    if (window.assetManager && typeof window.assetManager.loadTheme === 'function') {
                        await window.assetManager.loadTheme(themeName);
                        debugLog(`üé® Theme loaded through AssetManager: ${themeName}`);
                    }
                    
                    // Apply background to CSS (handled by AssetManager.loadTheme, but ensure it's applied)
                    if (window.assetManager && typeof window.assetManager.applyBackgroundToCSS === 'function') {
                        const theme = window.assetManager.getCurrentTheme();
                        if (theme) {
                            window.assetManager.applyBackgroundToCSS({ name: themeName, ...theme.config });
                        }
                    }
                    
                    // Update physics manager if needed
                    if (window.gameManager?.physicsManager) {
                        // Trigger background re-render on next frame
                        window.gameManager.physicsManager.backgroundUpdateNeeded = true;
                    }
                    
                    // Apply theme colors to SHAPE_CONFIG for fallback colors
                    if (typeof applyThemeColorsToShapeConfig === 'function') {
                        applyThemeColorsToShapeConfig(themeName);
                    }

                    // Apply to ThemeManager if available
                    const themeManager = window.gameManager?.themeManager;
                    if (themeManager && typeof themeManager.switchTheme === 'function') {
                        await themeManager.switchTheme(themeName, animated);
                    }

                    // Apply material textures for non-classic themes
                    if (themeName !== 'classic') {
                        const textureManager = window.textureManager;
                        if (textureManager && typeof textureManager.applyTextureTheme === 'function') {
                            await textureManager.applyTextureTheme(themeName);
                        }
                    }

                    // Rebuild dock with new theme
                    if (typeof rebuildGameDock === 'function') {
                        await rebuildGameDock();
                    }

                    // Update current theme reference
                    if (!window.currentTheme) {
                        window.currentTheme = { shapes: {}, platform: {}, background: {} };
                    }
                    window.currentTheme.name = themeName;

                    debugLog(`‚úÖ Theme applied to all systems: ${themeName}`);
                } catch (error) {
                    console.error(`‚ùå Error applying theme to systems:`, error);
                    throw error;
                }
            }

            static async _applyThemeOverrides(themeName, overrides) {
                try {
                    // This method will be implemented in todo #9
                    console.log(`üîÑ Theme overrides will be applied for ${themeName}:`, overrides);
                } catch (error) {
                    console.warn('‚ö†Ô∏è Error applying theme overrides:', error);
                }
            }

            static async _rebuildUI() {
                try {
                    // Only rebuild dock once
                    if (typeof rebuildGameDock === 'function') {
                        await rebuildGameDock();
                    }

                    // Only trigger animation if not already played
                    if (window.gameManager && !window.gameManager.dockAnimationPlayed) {
                        setTimeout(() => {
                            if (window.gameManager && !window.gameManager.dockAnimationPlayed) {
                                console.log('üé¨ Triggering dock animation after theme rebuild');
                                window.gameManager.triggerDockAnimation();
                                window.gameManager.dockAnimationPlayed = true;
                            }
                        }, 100);
                    }

                    console.log('‚úÖ UI rebuilt after theme change');
                } catch (error) {
                    console.error('‚ùå Error rebuilding UI:', error);
                    throw error;
                }
            }

            static _syncUIControls(themeName) {
                try {
                    const selectors = ['themeSelector', 'enhancedThemeSelect'];
                    selectors.forEach(id => {
                        const select = document.getElementById(id);
                        if (select && select.value !== themeName) {
                            select.value = themeName;
                        }
                    });
                    console.log('‚úÖ UI controls synced');
                } catch (error) {
                    console.warn('‚ö†Ô∏è Error syncing UI controls:', error);
                }
            }

            // Legacy compatibility methods
            static async applyTheme(themeName, source = 'legacy') {
                return this.changeTheme(themeName, { source });
            }

            static async loadTheme(themeName) {
                return window.assetManager.loadTheme(themeName);
            }
        }

        // Make globally available
        window.UnifiedThemeController = UnifiedThemeController;

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë THEME CHANGE QUEUE - RACE CONDITION PREVENTION
          ‚ïë Centralized theme change management to prevent multiple theme change 
          ‚ïë sources from causing conflicts and race conditions
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        class ThemeChangeQueue {
            constructor() {
                this.isChanging = false;
                this.pendingChange = null;
            }
            
            async changeTheme(themeName, source = 'unknown') {
                // Track theme access for race condition monitoring
                raceConditionMonitor.trackAccess('theme-system', 'changeTheme', 'write', {
                    themeName,
                    source
                });
                
                // Delegate to UnifiedThemeController for coordinated theme changes
                return await UnifiedThemeController.changeTheme(themeName, { source });
            }
        }

        // Create global instance
        window.themeChangeQueue = new ThemeChangeQueue();

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë RENDERER CONTROL FUNCTIONS
          ‚ïë Canvas-only rendering system controls
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        
        // Switch renderer based on selection (Canvas only)
        function switchRenderer() {
            const rendererSelect = document.getElementById('rendererSelect');
            const selectedRenderer = rendererSelect.value;
            
            if (!window.gameManager || !window.gameManager.physicsManager.rendererManager) {
                console.warn('‚ö†Ô∏è Game not initialized yet');
                return;
            }
            
            const rendererManager = window.gameManager.physicsManager.rendererManager;
            
            // Force Canvas only since PixiJS has been removed
            let success = rendererManager.switchRenderer('canvas');
            
            if (success) {
                const currentRenderer = rendererManager.getCurrentRenderer();
                console.log(`‚úÖ Switched to: ${currentRenderer.toUpperCase()}`);
            } else {
                console.warn('‚ö†Ô∏è Renderer switch failed');
            }
        }

        // Initialize and synchronize both theme dropdowns
        function initializeThemeSync() {
            const visualThemeSelect = document.getElementById('themeSelector');
            const enhancedThemeSelect = document.getElementById('enhancedThemeSelect');
            
            if (visualThemeSelect && enhancedThemeSelect) {
                // Ensure both dropdowns have the same default value
                const defaultTheme = 'classic';
                visualThemeSelect.value = defaultTheme;
                enhancedThemeSelect.value = defaultTheme;
                
                console.log(`üîÑ Initialized both theme dropdowns to: ${defaultTheme}`);
            }
            
            // Initialize theme button icon
            console.log('üé® Theme button initialized');
        }

        // Update applyTheme function to use ThemeChangeQueue
        async function applyTheme(themeName, source = 'visual') {
            await window.themeChangeQueue.changeTheme(themeName, source);
        }

        
        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë CLEAR PREVIOUS THEME TEXTURES - GLOBAL TEXTURE UNLOADING
          ‚ïë Clears all texture data from previous themes to prevent texture persistence.
          ‚ïë This ensures clean transitions between all themes (Wood‚ÜíStone, Metal‚ÜíClassic, etc.)
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        function clearPreviousThemeTextures() {
            try {
                if (window.currentTheme) {
                    if (window.currentTheme.shapes && window.currentTheme.shapes.textures) {
                        delete window.currentTheme.shapes.textures;
                    }
                    if (window.currentTheme.background && window.currentTheme.background.image) {
                        delete window.currentTheme.background.image;
                    }
                    if (window.currentTheme.platform && window.currentTheme.platform.image) {
                        delete window.currentTheme.platform.image;
                    }
                }
                
                if (window.textureManager && window.textureManager.textureCache && window.textureManager.textureCache.size !== undefined) {
                    const cacheSize = window.textureManager.textureCache.size;
                    if (cacheSize > 0) {
                        window.textureManager.textureCache.clear();
                        
                        Object.keys(SHAPE_CONFIG).forEach(shapeType => {
                            if (SHAPE_CONFIG[shapeType].texture) {
                                delete SHAPE_CONFIG[shapeType].texture;
                            }
                            if (SHAPE_CONFIG[shapeType].hasTexture) {
                                delete SHAPE_CONFIG[shapeType].hasTexture;
                            }
                            if (SHAPE_CONFIG[shapeType].textureUrl) {
                                delete SHAPE_CONFIG[shapeType].textureUrl;
                            }
                        });
                    }
                }
            } catch (error) {
                console.error('Error clearing previous theme textures:', error);
            }
        }
        
        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë APPLY THEME COLORS TO SHAPE CONFIG
          ‚ïë Applies the appropriate theme colors to SHAPE_CONFIG after texture clearing.
          ‚ïë Ensures shapes show correct fallback colors for each theme.
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        function applyThemeColorsToShapeConfig(themeName) {
            try {
                // Get colors from THEME_DEFINITIONS instead of hardcoded palettes
                let colors = null;
                
                // Try to get colors from the theme definition first
                if (THEME_DEFINITIONS[themeName] && THEME_DEFINITIONS[themeName].shapes && THEME_DEFINITIONS[themeName].shapes.colors) {
                    colors = THEME_DEFINITIONS[themeName].shapes.colors;
                    console.log(`üé® Using theme definition colors for ${themeName}:`, colors);
                } else {
                    // Fallback to hardcoded colors if theme definition doesn't have shape colors
                    const fallbackColors = {
                        classic: {
                            square: { color: '#F39C12', stroke: '#E67E22' },
                            triangle: { color: '#9B59B6', stroke: '#8E44AD' },
                            circle: { color: '#1ABC9C', stroke: '#16A085' },
                            cross2: { color: '#3498DB', stroke: '#2980B9' },
                            l: { color: '#8E44AD', stroke: '#732D91' },
                            cross: { color: '#E74C3C', stroke: '#C0392B' },
                            'barbell-one': { color: '#16A085', stroke: '#138D75' },
                            'barbell-two': { color: '#D35400', stroke: '#BA4A00' },
                            'diamond-barbell': { color: '#C0392B', stroke: '#A93226' }
                        },
                        wood: {
                            square: { color: '#D2691E', stroke: '#8B4513' },
                            triangle: { color: '#CD853F', stroke: '#A0522D' },
                            circle: { color: '#DEB887', stroke: '#D2691E' },
                            cross2: { color: '#F4A460', stroke: '#CD853F' },
                            l: { color: '#8B4513', stroke: '#A0522D' },
                            cross: { color: '#CD7F32', stroke: '#DAA520' },
                            'barbell-one': { color: '#D2691E', stroke: '#8B4513' },
                            'barbell-two': { color: '#CD853F', stroke: '#A0522D' },
                            'diamond-barbell': { color: '#DAA520', stroke: '#B8860B' }
                        }
                    };
                    
                    colors = fallbackColors[themeName] || fallbackColors.classic;
                    console.log(`‚ö†Ô∏è Using fallback colors for ${themeName}, theme definition colors not found`);
                }
                
                // Apply colors to SHAPE_CONFIG
                Object.keys(colors).forEach(shapeType => {
                    if (SHAPE_CONFIG[shapeType]) {
                        SHAPE_CONFIG[shapeType].color = colors[shapeType].color;
                        SHAPE_CONFIG[shapeType].stroke = colors[shapeType].stroke;
                        if (colors[shapeType].strokeWidth) {
                            SHAPE_CONFIG[shapeType].strokeWidth = colors[shapeType].strokeWidth;
                        }
                        console.log(`üé® Applied ${themeName} colors to ${shapeType}: ${colors[shapeType].color}`);
                    }
                });
                
                console.log(`‚úÖ Successfully applied ${themeName} theme colors to SHAPE_CONFIG`);
                
            } catch (error) {
                console.error(`Error applying ${themeName} theme colors:`, error);
            }
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë VERSION CHANGELOG - BSH GAME V18
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        /*
         * V18 CHANGELOG (September 2025):
         * 
         * MAJOR CHANGES:
         * ‚úÖ Complete PixiJS removal (8-phase process)
         * ‚úÖ Canvas2D-only rendering architecture
         * ‚úÖ Code optimization: 1,932 lines removed (18.6% reduction)
         * ‚úÖ Eliminated external CDN dependencies
         * ‚úÖ Improved performance on older devices
         * ‚úÖ Enhanced browser compatibility
         * 
         * REMOVED COMPONENTS:
         * ‚Ä¢ PixiJS CDN script import (~200KB)
         * ‚Ä¢ PixiManager class and all PixiJS integration
         * ‚Ä¢ PixiShapeRenderer and PixiJS shape system
         * ‚Ä¢ PIXI_CONFIG configuration object
         * ‚Ä¢ All PixiJS UI controls and settings
         * ‚Ä¢ Dual-renderer architecture complexity
         * 
         * PRESERVED FEATURES:
         * ‚Ä¢ Complete physics system (Matter.js)
         * ‚Ä¢ All 15+ shape types with textures
         * ‚Ä¢ 10+ theme system with visual customization
         * ‚Ä¢ Responsive design and mobile support
         * ‚Ä¢ Drag & drop mechanics
         * ‚Ä¢ Performance monitoring
         * ‚Ä¢ Debug and development tools
         * 
         * PERFORMANCE IMPROVEMENTS:
         * ‚Ä¢ ~200KB smaller bundle size
         * ‚Ä¢ Faster initialization (no PixiJS loading)
         * ‚Ä¢ Reduced memory usage
         * ‚Ä¢ Better compatibility with older browsers
         * ‚Ä¢ Simplified maintenance and debugging
         */

        // Initialize theme synchronization on page load
        document.addEventListener('DOMContentLoaded', function() {
            initializeThemeSync();
            
            // Mobile-friendly handlers for HUD icon buttons
            // Helper to attach touch handlers without interfering with existing click handlers
            function addTouchHandler(element, callback) {
                if (!element) return;
                element.addEventListener('touchstart', (e) => {
                    // Prevent default to avoid triggering the delayed click event on mobile
                    e.preventDefault();
                    e.stopPropagation();
                    callback();
                }, { passive: false });
            }
            // Cycle themes on touch
            addTouchHandler(document.getElementById('themeButton'), () => {
                try {
                    if (typeof cycleThemes === 'function') cycleThemes();
                } catch (err) {
                    console.error('Error cycling themes via touch:', err);
                }
            });
            // Reset level on touch
            addTouchHandler(document.getElementById('resetButton'), () => {
                try {
                    if (typeof resetLevel === 'function') resetLevel();
                } catch (err) {
                    console.error('Error resetting level via touch:', err);
                }
            });
        });


        // =============================================================================
        // DYNAMIC COIN BONUS SYSTEM
        // =============================================================================

        function startCoinBonusSystem() {
            // Random coin bonuses every 15-30 seconds
            setInterval(() => {
                if (!gameManager || !gameManager.gameState.isGameActive) return;
                
                const randomEvent = Math.random();
                const coinElement = document.getElementById('coinAmount');
                
                if (randomEvent < 0.3) { // 30% chance
                    // Small bonus coins
                    const bonus = Math.floor(Math.random() * 3) + 1; // 1-3 coins
                    gameManager.gameState.coins += bonus;
                    gameManager.updateCoinDisplay();
                    gameManager.createFloatingText(`üéÅ +${bonus}`, coinElement, '#32CD32');
                    console.log(`üéÅ Random coin bonus: +${bonus}`);
                    
                } else if (randomEvent < 0.35) { // 5% chance
                    // Medium jackpot
                    const jackpot = Math.floor(Math.random() * 8) + 5; // 5-12 coins
                    gameManager.gameState.coins += jackpot;
                    gameManager.updateCoinDisplay();
                    gameManager.createCoinShower('LUCKY BONUS!', jackpot);
                    console.log(`üçÄ Lucky bonus: +${jackpot} coins`);
                    
                } else if (randomEvent < 0.37) { // 2% chance  
                    // Big jackpot
                    const megaJackpot = Math.floor(Math.random() * 15) + 10; // 10-24 coins
                    gameManager.gameState.coins += megaJackpot;
                    gameManager.updateCoinDisplay();
                    gameManager.createCoinShower('MEGA JACKPOT!', megaJackpot);
                    gameManager.pulseElement(coinElement, 5);
                    console.log(`üíé MEGA JACKPOT: +${megaJackpot} coins`);
                }
            }, Math.random() * 15000 + 15000); // Every 15-30 seconds
            
            // Stability bonus system - rewards for keeping shapes stable
            setInterval(() => {
                if (!gameManager || !gameManager.gameState.isGameActive) return;
                if (gameManager.gameState.placedShapes.length === 0) return;
                
                // Check if shapes haven't fallen recently
                const timeSinceLastFall = Date.now() - (gameManager.gameState.lastFallTime || 0);
                if (timeSinceLastFall > 30000) { // 30 seconds of stability
                    const stabilityBonus = Math.floor(Math.random() * 4) + 2; // 2-5 coins
                    gameManager.gameState.coins += stabilityBonus;
                    gameManager.updateCoinDisplay();
                    
                    const coinElement = document.getElementById('coinAmount');
                    gameManager.createFloatingText(`‚öñÔ∏è STABLE +${stabilityBonus}`, coinElement, '#4ECDC4');
                    console.log(`‚öñÔ∏è Stability bonus: +${stabilityBonus} coins`);
                }
            }, 30000); // Check every 30 seconds
            
            console.log('üé∞ Dynamic coin bonus system activated!');
        }




        // Initialize game when page loads
        let gameManager;
        
        // Consolidate texture management to use AssetManager as the single source
        if (!window.assetManager) {
            window.assetManager = new AssetManager();
            debugLog('üñºÔ∏è Global AssetManager initialized');
        }
        // Ensure backward compatibility with textureManager references
        window.textureManager = window.assetManager;
        
        // Use unified initialization to prevent race conditions
        window.addEventListener('load', async () => {
            console.log('üîß Page loaded, starting unified initialization...');
            
            try {
                await GameInitializer.initialize();
                console.log('‚úÖ Unified initialization complete');
            } catch (error) {
                console.error('‚ùå Unified initialization failed:', error);
            }
        });

        // =============================================================================
        // IMAGE TEXTURE HELPER FUNCTIONS
        // =============================================================================

        /**
         * Load a texture image for shapes
         * @param {string} imageUrl - URL or path to the image
         * @param {string} shapeName - Name of shape ('square', 'triangle', 'circle', etc.)
         * @param {Object} options - Texture options
         * @returns {Promise<boolean>} Success/failure
         */
        async function loadShapeTexture(imageUrl, shapeName = 'square', options = {}) {
            try {
                debugLog(`üñºÔ∏è Loading texture for ${shapeName}: ${imageUrl}`);
                
                // Default texture options
                const textureConfig = {
                    url: imageUrl,
                    repeat: options.repeat || 'repeat',
                    blendMode: options.blendMode || 'source-over',
                    opacity: options.opacity || 1.0,
                    scale: options.scale || 1.0
                };

                // Add texture to current theme
                if (!window.currentTheme) {
                    window.currentTheme = { shapes: {}, platform: {}, background: {} };
                }
                if (!window.currentTheme.shapes) {
                    window.currentTheme.shapes = {};
                }
                if (!window.currentTheme.shapes.textures) {
                    window.currentTheme.shapes.textures = {};
                }
                window.currentTheme.shapes.textures[shapeName] = textureConfig;
                debugLog(`‚úÖ Set texture config for ${shapeName}:`, textureConfig);
                debugLog(`üîç Current theme textures:`, window.currentTheme.shapes.textures);

                // Also update THEME_DEFINITIONS so the regular theme loading system knows about this texture
                if (window.currentTheme.name && THEME_DEFINITIONS[window.currentTheme.name]) {
                    const themeDef = THEME_DEFINITIONS[window.currentTheme.name];
                    if (themeDef.shapes && themeDef.shapes.textures && themeDef.shapes.textures[shapeName]) {
                        themeDef.shapes.textures[shapeName].url = imageUrl;
                        debugLog(`üîÑ Updated THEME_DEFINITIONS for ${window.currentTheme.name}.${shapeName}`);
                    }
                }

                // Load the image
                const success = await window.assetManager.loadImage(imageUrl);
                if (success) {
                    debugLog(`‚úÖ Texture loaded successfully for ${shapeName}`);
                    return true;
                } else {
                    console.warn(`‚ùå Failed to load texture for ${shapeName}`);
                    return false;
                }
            } catch (error) {
                console.error(`‚ùå Error loading texture for ${shapeName}:`, error);
                return false;
            }
        }

        /**
         * Load a texture image for platforms
         * @param {string} imageUrl - URL or path to the image
         * @param {Object} options - Texture options
         * @returns {Promise<boolean>} Success/failure
         */
        async function loadPlatformTexture(imageUrl, options = {}) {
            try {
                console.log(`üñºÔ∏è Loading platform texture: ${imageUrl}`);
                
                // Default texture options
                const textureConfig = {
                    url: imageUrl,
                    repeat: options.repeat || 'repeat',
                    blendMode: options.blendMode || 'source-over',
                    opacity: options.opacity || 1.0,
                    scale: options.scale || 1.0
                };

                // Add texture to current theme
                window.currentTheme.platform.image = textureConfig;

                // Load the image
                const success = await window.assetManager.loadImage(imageUrl);
                if (success) {
                    console.log(`‚úÖ Platform texture loaded successfully`);
                    return true;
                } else {
                    console.warn(`‚ùå Failed to load platform texture`);
                    return false;
                }
            } catch (error) {
                console.error(`‚ùå Error loading platform texture:`, error);
                return false;
            }
        }

        /**
         * Load a background image
         * @param {string} imageUrl - URL or path to the image
         * @param {Object} options - Background options
         * @returns {Promise<boolean>} Success/failure
         */
        async function loadBackgroundImage(imageUrl, options = {}) {
            try {
                console.log(`üñºÔ∏è Loading background image: ${imageUrl}`);
                
                // Default background options
                const backgroundConfig = {
                    url: imageUrl,
                    mode: options.mode || 'cover', // 'cover', 'contain', 'stretch', 'tile'
                    opacity: options.opacity || 1.0,
                    blur: options.blur || 0,
                    brightness: options.brightness || 1.0
                };

                // Add background to current theme
                window.currentTheme.background.image = backgroundConfig;

                // Load the image
                const success = await window.assetManager.loadImage(imageUrl);
                if (success) {
                    console.log(`‚úÖ Background image loaded successfully`);
                    return true;
                } else {
                    console.warn(`‚ùå Failed to load background image`);
                    return false;
                }
            } catch (error) {
                console.error(`‚ùå Error loading background image:`, error);
                return false;
            }
        }

        /**
         * Clear all textures and return to gradient/solid colors
         */
        function clearAllTextures() {
            console.log('üßπ Clearing all textures...');
            
            // Clear background image
            if (window.currentTheme.background.image) {
                delete window.currentTheme.background.image;
            }
            
            // Clear platform texture
            if (window.currentTheme.platform.image) {
                delete window.currentTheme.platform.image;
            }
            
            // Clear shape textures
            if (window.currentTheme.shapes.textures) {
                delete window.currentTheme.shapes.textures;
            }
            
            console.log('‚úÖ All textures cleared - back to gradients and solid colors');
        }

        // Make functions globally available
        window.loadShapeTexture = loadShapeTexture;
        window.loadPlatformTexture = loadPlatformTexture;
        window.loadBackgroundImage = loadBackgroundImage;
        window.clearAllTextures = clearAllTextures;

// Fix the applyEnhancedTheme function
window.applyEnhancedTheme = function() {
    const enhancedThemeSelect = document.getElementById('enhancedThemeSelect');
    const selectedTheme = enhancedThemeSelect.value;
    
    console.log(`ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ Applying enhanced theme: ${selectedTheme}`);
    
    // Initialize texture manager if needed using AssetManager
    if (!window.textureManager && window.gameManager && window.gameManager.physicsManager) {
        window.textureManager = window.gameManager.physicsManager.assetManager;
    }
    
    // Apply the texture theme
    if (selectedTheme === 'wood') {
        window.textureManager.applyTextureTheme('wood').then(success => {
            if (success) {
                console.log('‚úÖ Wood textures applied successfully!');
                // Rebuild dock to apply textures to shape previews
                rebuildGameDock();
                console.log('üîÑ Dock rebuilt with textures');
            } else {
                console.log('‚ö†Ô∏è Failed to apply wood textures');
            }
        });
    } else {
        // Clear textures for non-wood themes
        if (window.textureManager.loadedTextures.size > 0) {
            window.textureManager.loadedTextures.clear();
            
            // Clear texture references from SHAPE_CONFIG
            Object.keys(SHAPE_CONFIG).forEach(shapeType => {
                delete SHAPE_CONFIG[shapeType].texture;
            });
            
            // Rebuild dock without textures
            rebuildGameDock();
        }
    }
};

// Initialize texture manager on page load using AssetManager
if (!window.textureManager && window.gameManager && window.gameManager.physicsManager) {
    window.textureManager = window.gameManager.physicsManager.assetManager;
    console.log('üñºÔ∏è Global textureManager set to use AssetManager');
}

/*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  ‚ïë BACKGROUND TESTING FUNCTIONS
  ‚ïë Manual testing utilities for background image system
  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/

// Test cycling through all themes to verify background loading
window.testBackgroundSystem = function() {
    console.log('üß™ Testing Background System');
    console.log('============================');
    
    const themes = Object.keys(THEME_DEFINITIONS);
    let currentIndex = 0;
    
    function testNextTheme() {
        if (currentIndex >= themes.length) {
            console.log('‚úÖ All themes tested');
            return;
        }
        
        const themeName = themes[currentIndex];
        console.log(`üé® Testing theme: ${themeName}`);
        
        UnifiedThemeController.changeTheme(themeName, { source: 'test' })
            .then(() => {
                console.log(`‚úÖ Theme ${themeName} applied successfully`);
                currentIndex++;
                
                // Test next theme after 3 seconds
                setTimeout(testNextTheme, 3000);
            })
            .catch(error => {
                console.error(`‚ùå Theme ${themeName} failed:`, error);
                currentIndex++;
                setTimeout(testNextTheme, 1000);
            });
    }
    
    testNextTheme();
};

// Test individual background image loading
window.testBackgroundLoading = function() {
    console.log('üß™ Testing Background Loading');
    console.log('==============================');
    
    // Test individual background loading
    const testUrls = [
        'assets/bkg/bkg1.png',
        'assets/bkg/nonexistent.png', // Should fail gracefully
        'assets/textures/stone/granite.txt',
        'assets/textures/metal/steel.txt'
    ];
    
    testUrls.forEach(async (url, index) => {
        try {
            const img = await window.assetManager.loadBackgroundImage(url);
            console.log(`‚úÖ Background ${index + 1} loaded: ${url}`, img);
        } catch (error) {
            console.log(`‚ùå Background ${index + 1} failed: ${url}`, error.message);
        }
    });
};

// Test pattern backgrounds specifically
window.testPatternBackgrounds = function() {
    console.log('üß™ Testing Pattern Backgrounds');
    console.log('===============================');
    
    const patternThemes = ['stone', 'metal'];
    let currentIndex = 0;
    
    function testNextPattern() {
        if (currentIndex >= patternThemes.length) {
            console.log('‚úÖ All pattern themes tested');
            // Switch back to classic for comparison
            setTimeout(() => testTheme('classic'), 1000);
            return;
        }
        
        const themeName = patternThemes[currentIndex];
        console.log(`üé® Testing ${themeName} pattern background...`);
        
        testTheme(themeName)
            .then(() => {
                const themeConfig = THEME_DEFINITIONS[themeName];
                if (themeConfig.background.type === 'pattern') {
                    console.log(`‚úÖ ${themeName} pattern applied:`, themeConfig.background.pattern.type);
                    console.log(`   Pattern style:`, themeConfig.background.pattern.style.substring(0, 100) + '...');
                }
                currentIndex++;
                setTimeout(testNextPattern, 4000); // Give more time to see the pattern
            })
            .catch(error => {
                console.error(`‚ùå ${themeName} pattern failed:`, error);
                currentIndex++;
                setTimeout(testNextPattern, 1000);
            });
    }
    
    testNextPattern();
};

// Test stone pattern with immediate visual feedback
window.testStonePatternNow = function() {
    console.log('üß™ Testing NEW stone pattern');
    
    const viewport = document.querySelector('.game-viewport');
    
    // Clear all existing classes
    viewport.classList.remove('stone-pattern', 'metal-pattern', 'theme-background');
    
    // Apply stone pattern directly
    viewport.classList.add('stone-pattern');
    
    console.log('‚úÖ Stone pattern class applied');
    console.log('Viewport classes:', viewport.className);
    
    // Force browser to recalculate styles
    viewport.offsetHeight; 
    
    setTimeout(() => {
        const computed = getComputedStyle(viewport, '::before');
        console.log('::before styles:', {
            content: computed.content,
            position: computed.position,
            background: computed.background,
            opacity: computed.opacity,
            zIndex: computed.zIndex
        });
    }, 100);
};

// Emergency fallback - apply pattern with inline styles
window.forceStonePattern = function() {
    console.log('üö® FORCING stone pattern with inline styles');
    
    const viewport = document.querySelector('.game-viewport');
    
    // Create a style element with very specific CSS
    const style = document.createElement('style');
    style.innerHTML = `
        .force-stone::before {
            content: '' !important;
            position: absolute !important;
            top: 0 !important;
            left: 0 !important;
            width: 100% !important;
            height: 100% !important;
            z-index: -1 !important;
            background: linear-gradient(45deg, #8B4513 0%, #A0522D 50%, #696969 100%) !important;
            opacity: 0.7 !important;
        }
    `;
    document.head.appendChild(style);
    
    viewport.classList.remove('stone-pattern', 'metal-pattern', 'theme-background');
    viewport.classList.add('force-stone');
    
    console.log('‚úÖ Emergency stone pattern applied');
};

// Test stone pattern specifically
window.testStonePattern = function() {
    console.log('üß™ Testing stone pattern specifically');
    
    // Apply stone theme
    window.themeController.applyTheme('stone');
    
    // Wait a moment then check what happened
    setTimeout(() => {
        const viewport = document.querySelector('.game-viewport');
        console.log('Viewport classes:', viewport.className);
        console.log('Viewport computed styles:', {
            backgroundImage: getComputedStyle(viewport).backgroundImage,
            backgroundColor: getComputedStyle(viewport).backgroundColor
        });
        
        // Check ::before pseudo-element if possible
        const beforeStyles = getComputedStyle(viewport, '::before');
        console.log('::before pseudo styles:', {
            backgroundImage: beforeStyles.backgroundImage,
            opacity: beforeStyles.opacity,
            content: beforeStyles.content,
            display: beforeStyles.display,
            position: beforeStyles.position
        });
        
    }, 100);
};

// Clear all backgrounds and reset to default
window.clearAllBackgrounds = function() {
    console.log('üßπ Clearing all backgrounds');
    if (window.assetManager) {
        window.assetManager.clearBackgroundCSS();
        window.assetManager.backgroundImageCache.clear();
        console.log('‚úÖ Background system cleared');
    }
};

// Test specific theme
window.testTheme = function(themeName) {
    console.log(`üé® Testing individual theme: ${themeName}`);
    return UnifiedThemeController.changeTheme(themeName, { source: 'manual-test' })
        .then(() => console.log(`‚úÖ ${themeName} theme applied`))
        .catch(error => console.error(`‚ùå ${themeName} theme failed:`, error));
};

// Inspect CSS properties set by background system
window.inspectBackgroundCSS = function() {
    const viewport = document.querySelector('.game-viewport');
    if (!viewport) {
        console.log('‚ùå Game viewport not found');
        return;
    }
    
    console.log('üîç Background CSS Properties:');
    console.log('==============================');
    console.log('Has theme-background class:', viewport.classList.contains('theme-background'));
    console.log('--background-image:', viewport.style.getPropertyValue('--background-image'));
    console.log('--background-opacity:', viewport.style.getPropertyValue('--background-opacity'));
    console.log('background-color:', viewport.style.backgroundColor);
    
    // Check computed styles on ::before pseudo-element
    const beforeStyles = getComputedStyle(viewport, '::before');
    console.log('Computed ::before styles:');
    console.log('  background-image:', beforeStyles.backgroundImage);
    console.log('  opacity:', beforeStyles.opacity);
    console.log('  background-size:', beforeStyles.backgroundSize);
    console.log('  background-position:', beforeStyles.backgroundPosition);
};

/*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  ‚ïë PULSE SYSTEM TESTING FUNCTIONS
  ‚ïë Test and debug the new accelerating pulse effects
  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/

// Test fire shape pulsing by creating two fire shapes and making them collide
window.testFirePulsing = function() {
    console.log('üî• Testing fire shape pulsing effects');
    
    if (!window.physicsManager) {
        console.error('‚ùå PhysicsManager not available');
        return;
    }
    
    // Clear existing shapes
    window.physicsManager.clearAllShapes();
    
    // Create two fire shapes
    const fireConfig = {
        specialType: {
            type: 'FIRE',
            explosionDelaySeconds: 2, // 2 second delay
            explosionRadius: 50
        }
    };
    
    // Create first fire shape
    const fire1 = window.physicsManager.createBodyFromConfig(300, 200, 'triangle', 0, fireConfig);
    const fire2 = window.physicsManager.createBodyFromConfig(500, 200, 'circle', 0, fireConfig);
    
    if (fire1 && fire2) {
        console.log('‚úÖ Created fire shapes:', fire1.id, fire2.id);
        
        // Give them velocity to collide
        window.physicsManager.Body.setVelocity(fire1, { x: 2, y: 0 });
        window.physicsManager.Body.setVelocity(fire2, { x: -2, y: 0 });
        
        console.log('üéØ Fire shapes should collide and start pulsing with accelerating effects');
    } else {
        console.error('‚ùå Failed to create fire shapes');
    }
};

// Test timer shape pulsing  
window.testTimerPulsing = function() {
    console.log('‚è∞ Testing timer shape pulsing effects');
    
    if (!window.physicsManager) {
        console.error('‚ùå PhysicsManager not available');
        return;
    }
    
    // Create timer shape with short countdown
    const timerConfig = {
        specialType: {
            type: 'TIMER',
            countdownDuration: 5000, // 5 seconds
            action: 'explode'
        }
    };
    
    const timer = window.physicsManager.createBodyFromConfig(400, 300, 'hexagon', 0, timerConfig);
    
    if (timer) {
        console.log('‚úÖ Created timer shape:', timer.id);
        console.log('Timer state:', timer.userData.timerState);
        
        // Start the timer pulsing
        window.physicsManager.startPulsing(timer, 'timer');
        
        // Check pulse state after starting
        setTimeout(() => {
            const pulseState = window.physicsManager.pulseManager.activePulses.get(timer.id);
            console.log(`Timer ${timer.id} pulse state after start:`, pulseState);
        }, 100);
        
        console.log('‚è∞ Timer should pulse with accelerating frequency as countdown approaches zero');
    } else {
        console.error('‚ùå Failed to create timer shape');
    }
};

// Quick test timer with weight trigger
window.quickTimerTest = function() {
    console.log('üöÄ Quick Timer Test Starting...');
    
    if (!window.physicsManager) {
        console.error('‚ùå PhysicsManager not available');
        return;
    }
    
    // Find existing timer shapes first
    const existingTimers = Matter.Composite.allBodies(engine.world).filter(body => 
        body.userData?.specialType?.type === 'TIMER'
    );
    
    if (existingTimers.length > 0) {
        const testTimer = existingTimers[0];
        console.log(`‚è∞ Found existing timer ${testTimer.id}, testing pulsing...`);
        console.log('Timer state:', testTimer.userData.timerState);
        
        // Manually start pulsing to test
        window.physicsManager.startPulsing(testTimer, 'timer');
        
        // Check pulse state 
        setTimeout(() => {
            const pulseState = window.physicsManager.pulseManager.activePulses.get(testTimer.id);
            console.log(`‚úÖ Timer pulse state:`, pulseState);
            
            if (pulseState && pulseState.isPulsing) {
                console.log('‚úÖ Timer pulsing is active!');
            } else {
                console.log('‚ùå Timer pulsing not working');
            }
        }, 200);
    } else {
        console.log('‚ùå No existing timer shapes found in level');
    }
};

window.debugPulseStates = function() {
    console.log('üîç Active Pulse States Debug');
    console.log('============================');
    
    if (!window.physicsManager || !window.physicsManager.pulseManager) {
        console.error('‚ùå Pulse manager not available');
        return;
    }
    
    const pulseManager = window.physicsManager.pulseManager;
    console.log(`Active pulses: ${pulseManager.activePulses.size}`);
    
    pulseManager.activePulses.forEach((pulseState, bodyId) => {
        console.log(`Body ${bodyId}:`, {
            type: pulseState.type,
            isPulsing: pulseState.isPulsing,
            pulseIntensity: pulseState.pulseIntensity?.toFixed(3),
            progress: pulseState.progress?.toFixed(3),
            currentInterval: `${pulseState.currentInterval}ms`,
            pulsesPerSecond: pulseState.pulsesPerSecond?.toFixed(2)
        });
    });
};

// Test pulse effects on different texture types
window.testPulseOnTextures = function() {
    console.log('üñºÔ∏è Testing pulse effects on different texture types');
    
    // Test with classic theme (gradient background)
    window.themeController.applyTheme('classic').then(() => {
        console.log('üé® Applied classic theme - testing with gradient background');
        window.testFirePulsing();
    });
    
    setTimeout(() => {
        // Test with wood theme (image texture)
        window.themeController.applyTheme('wood').then(() => {
            console.log('üå≥ Applied wood theme - testing with image texture');
            window.testFirePulsing();
        });
    }, 3000);
};

// Stress test multiple pulsing shapes
window.testMultiplePulses = function() {
    console.log('üöÄ Stress testing multiple pulsing shapes');
    
    if (!window.physicsManager) {
        console.error('‚ùå PhysicsManager not available');
        return;
    }
    
    window.physicsManager.clearAllShapes();
    
    const shapes = ['triangle', 'circle', 'square', 'hexagon', 'pentagon'];
    const positions = [
        [200, 200], [400, 200], [600, 200],
        [300, 350], [500, 350]
    ];
    
    positions.forEach((pos, i) => {
        const config = {
            specialType: {
                type: Math.random() > 0.5 ? 'FIRE' : 'TIMER',
                explosionDelaySeconds: 1 + Math.random() * 2,
                explosionRadius: 30 + Math.random() * 20,
                countdownDuration: 3000 + Math.random() * 4000
            }
        };
        
        const shape = window.physicsManager.createBodyFromConfig(pos[0], pos[1], shapes[i], 0, config);
        if (shape) {
            window.physicsManager.startPulsing(shape, config.specialType.type.toLowerCase());
        }
    });
    
    console.log('‚úÖ Created 5 shapes with different pulse types and timings');
};

debugLog('‚úÖ Texture loading system fixed and initialized');
debugLog('üß™ Background testing functions added: testBackgroundSystem(), testBackgroundLoading(), testPatternBackgrounds(), clearAllBackgrounds(), testTheme(), inspectBackgroundCSS()');
debugLog('üé® Enhanced stone and metal themes with CSS patterns: granite texture and brushed steel effects');
debugLog('üî• Pulse system testing functions added: testFirePulsing(), testTimerPulsing(), debugPulseStates(), testPulseOnTextures(), testMultiplePulses()');

    </script>
</body>
</html>
