<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>BSH Game - Physics Puzzle Game v20 (Canvas2D)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }

        html {
            overflow: hidden; /* Prevent scrolling on the game */
            height: 100%;
        }

        @import url('https://fonts.googleapis.com/css2?family=Fredoka:wght@400;500;600;700&display=swap');
        
        body {
            font-family: 'Fredoka', sans-serif;
            /* background: linear-gradient(135deg, #87CEEB 0%, #98FB98 100%); */
            height: 100vh;
            height: 100dvh; /* Dynamic viewport height for mobile */
            overflow: hidden; /* Prevent scrolling */
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
        }

          /* Dynamic background system - controlled via JavaScript */
          .game-viewport::before {
              content: '';
              position: absolute;
              top: 0;
              left: 0;
              width: 100%;
              height: 100%;
              
              /* Dynamic background will be set via JavaScript */
              background-size: cover;
              background-position: center top;
              background-repeat: no-repeat;
              
              /* Default opacity - will be overridden by theme */
              opacity: 0.5;
              
              z-index: -1;
              transition: opacity 0.3s ease, background-image 0.3s ease;
          }

          /* Theme-based background control */
          .game-viewport.theme-background::before {
              opacity: var(--background-opacity, 0.5);
              background-image: var(--background-image, none);
          }

          /* Stone granite pattern - HIGHLY VISIBLE VERSION */
          .game-viewport.stone-pattern::before {
              content: '';
              position: absolute;
              top: 0;
              left: 0;
              width: 100%;
              height: 100%;
              z-index: -1;
              
              /* Very visible stone pattern with solid colors */
              background: 
                  /* Stone blocks - more opaque */
                  radial-gradient(ellipse at 15% 15%, #8B4513 0%, rgba(139, 69, 19, 0.6) 30%, transparent 50%),
                  radial-gradient(ellipse at 85% 20%, #A0522D 0%, rgba(160, 82, 45, 0.6) 25%, transparent 45%),
                  radial-gradient(ellipse at 25% 75%, #696969 0%, rgba(105, 105, 105, 0.7) 35%, transparent 55%),
                  radial-gradient(ellipse at 75% 80%, #778899 0%, rgba(119, 136, 153, 0.5) 30%, transparent 50%),
                  radial-gradient(ellipse at 50% 40%, #CD853F 0%, rgba(205, 133, 63, 0.6) 28%, transparent 48%),
                  
                  /* Strong base stone color */
                  linear-gradient(135deg, 
                      #8B4513 0%,    /* Saddle Brown */
                      #A0522D 20%,   /* Sienna */
                      #CD853F 40%,   /* Peru */
                      #696969 60%,   /* Dim Gray */
                      #778899 80%,   /* Light Slate Gray */
                      #708090 100%   /* Slate Gray */
                  );
              
              background-size: 
                  120px 90px,   /* Larger, more visible stone blocks */
                  100px 70px, 
                  140px 100px,
                  90px 60px,
                  110px 80px,
                  100% 100%;
                  
              opacity: 0.75;  /* More visible */
          }

          /* Metal brushed steel pattern */
          .game-viewport.metal-pattern::before {
              content: '';
              position: absolute;
              top: 0;
              left: 0;
              width: 100%;
              height: 100%;
              z-index: -1;
              background-image:
                  repeating-linear-gradient(90deg, 
                      transparent, 
                      transparent 1px, 
                      rgba(135, 206, 235, 0.1) 1px, 
                      rgba(135, 206, 235, 0.1) 2px),
                  repeating-linear-gradient(0deg, 
                      transparent, 
                      transparent 2px, 
                      rgba(70, 130, 180, 0.05) 2px, 
                      rgba(70, 130, 180, 0.05) 4px),
                  linear-gradient(45deg, #1e3a4f 0%, #4682B4 25%, #2d5a7b 50%, #5a7aa6 75%, #4682B4 100%);
              background-size: 4px 4px, 8px 8px, 100% 100%;
              opacity: 0.7;
          }

        /* New Responsive Game Viewport */
        .game-viewport {
            width: 100vw;
            height: 100vh;
            height: 100dvh;
            display: flex;
            flex-direction: column;
            /* Remove size constraints for mobile/tablet - let it use full screen */
            margin: 0 auto;
            /* background: linear-gradient(135deg, #FF6B6B 0%, #4ECDC4 100%); */
            /* REMOVE the background-image properties from here */
                
            /* ADD a solid background color to sit behind the faded image */
            background-color: #2c3e50; /* A dark blue-gray is a good starting point */
        
            position: relative; /* This is required for the pseudo-element to work */
            isolation: isolate; /* Ensures content stays on top of the new background layer */


            aspect-ratio: 9/16;
            overflow: visible; /* Allow dragged elements to extend beyond viewport */
            box-shadow: 0 0 50px rgba(0,0,0,0.3);
        }

        /* Desktop screens - size constraints and styling */
        @media (min-width: 1025px) {
            body {
                background: linear-gradient(135deg, #87CEEB 0%, #98FB98 100%);
                padding: 20px;
            }
            
            .game-viewport {
                max-width: 500px;
                max-height: 889px; /* 500 * 16/9 for aspect ratio */
                border-radius: 20px;
                box-shadow: 0 10px 50px rgba(0,0,0,0.4);
            }
        }

        /* Game HUD - Top Section */
        .game-hud {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: clamp(70px, 12vh, 90px); /* Responsive height */
            background: linear-gradient(135deg, #FF6B6B 0%, #4ECDC4 100%);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: clamp(6px, 2vw, 15px); /* Responsive padding */
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 100;
        }

        /* Left Section - Score and Star Meter */
        .left-section {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            color: white;
            font-weight: bold;
            justify-content: space-between;
            height: 100%;
            min-width: 0; /* Prevent flex overflow */
        }

        .score-display {
            display: flex;
            align-items: center;
            gap: clamp(4px, 1.5vw, 8px); /* Responsive gap */
            margin-bottom: 3px;
        }

        .trophy-icon {
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
            width: clamp(18px, 4vw, 24px); /* Responsive icon size */
            height: clamp(18px, 4vw, 24px);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(8px, 2vw, 12px); /* Responsive font */
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            border: 2px solid #B8860B;
            flex-shrink: 0; /* Prevent shrinking */
        }

        .score-text {
            font-size: clamp(14px, 4vw, 18px); /* Responsive font size */
            font-weight: 700;
            color: #FFE4B5;
            text-shadow: 0 2px 4px rgba(0,0,0,0.4);
            white-space: nowrap; /* Prevent text wrapping */
        }

        .star-progress-container {
            position: relative;
            width: clamp(100px, 25vw, 140px); /* Responsive width */
            height: clamp(14px, 3vw, 18px); /* Responsive height */
            background: rgba(255,255,255,0.25);
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.3);
            overflow: hidden;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.3);
            cursor: pointer; /* Indicate interactivity */
        }

        .progress-area {
            position: relative;
            width: clamp(100px, 25vw, 140px); /* Match container width */
            height: clamp(28px, 6vw, 36px); /* Responsive height for better touch */
        }

        .star-progress-container {
            margin-top: clamp(12px, 3vw, 18px); /* Responsive margin */
        }

        .star-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #8B5CF6 0%, #A855F7 50%, #C084FC 100%);
            border-radius: 7px;
            transition: width 0.8s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            box-shadow: 0 0 6px rgba(139, 92, 246, 0.6);
        }

        /* White progress markers inside the bar */
        .progress-markers {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 100%;
            pointer-events: none;
            z-index: 2;
        }

        .progress-marker {
            position: absolute;
            top: 0;
            width: 2px;
            height: 100%;
            background: rgba(255,255,255,0.8);
            border-radius: 1px;
        }

        .progress-marker:nth-child(1) {
            left: 33.33%;
            transform: translateX(-50%);
        }

        .progress-marker:nth-child(2) {
            left: 66.66%;
            transform: translateX(-50%);
        }

        .progress-marker:nth-child(3) {
            left: 90%;
            transform: translateX(-50%);
        }

        .star-markers {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 16px;
            width: 120px;
            pointer-events: none;
            z-index: 10;
        }

        .star {
            width: 14px;
            height: 14px;
            background: rgba(255,255,255,0.3);
            clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%);
            box-shadow: 0 2px 6px rgba(0,0,0,0.5);
            border: 1px solid rgba(255,255,255,0.6);
            transition: all 0.5s ease;
            position: absolute;
        }

        /* Position stars directly above the white markers */
        .star:nth-child(1) {
            left: 33.33%;
            transform: translateX(-50%);
        }

        .star:nth-child(2) {
            left: 66.66%;
            transform: translateX(-50%);
        }

        .star:nth-child(3) {
            left: 90%;
            transform: translateX(-50%);
        }

        .star.filled {
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
            border: 2px solid #B8860B;
            transform: translateX(-50%) scale(1.3);
            box-shadow: 0 0 20px rgba(255, 215, 0, 1), 0 2px 6px rgba(0,0,0,0.6);
            animation: starPulse 0.5s ease-out;
            z-index: 15;
        }

        /* Middle Section - Timer */
        .middle-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            gap: clamp(3px, 1vw, 6px); /* Responsive gap */
            min-width: 0; /* Prevent overflow */
        }

        /* Level Display */
        .level-display {
            font-size: clamp(11px, 3vw, 14px); /* Responsive font size */
            font-weight: 600;
            color: #FFE4B5;
            text-shadow: 0 1px 2px rgba(0,0,0,0.4);
            background: rgba(0,0,0,0.15);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            padding: clamp(3px, 1vw, 6px) clamp(6px, 2vw, 10px); /* Responsive padding */
            min-width: clamp(50px, 12vw, 70px); /* Responsive min-width */
            text-align: center;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
            white-space: nowrap;
        }

        .timer-container {
            background: rgba(0,0,0,0.2);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 12px;
            padding: clamp(6px, 2vw, 10px) clamp(8px, 3vw, 14px); /* Responsive padding */
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: clamp(60px, 15vw, 80px); /* Responsive min-width */
            min-height: 44px; /* Minimum touch target */
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }

        .timer-container:hover {
            background: rgba(0,0,0,0.3);
            transform: translateY(-1px);
        }

        .timer-text {
            font-size: clamp(12px, 3.5vw, 16px); /* Responsive font size */
            font-weight: 600;
            color: #FFE4B5;
            text-shadow: 0 1px 2px rgba(0,0,0,0.4);
            font-variant-numeric: tabular-nums;
            transition: all 0.3s ease;
            white-space: nowrap;
        }

        .timer-text.timer-warning {
            color: #FFA500;
            text-shadow: 0 0 10px rgba(255, 165, 0, 0.6);
        }

        .timer-text.timer-critical {
            color: #FF4444;
            text-shadow: 0 0 15px rgba(255, 68, 68, 0.8);
            animation: timerPulse 1s infinite;
        }

        @keyframes timerPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        /* Right Section - Settings, Reset, and Coins */
        .right-section {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            justify-content: space-between;
            height: 100%;
            min-width: 0; /* Prevent overflow */
        }

        .top-buttons {
            display: flex;
            gap: clamp(6px, 2vw, 10px); /* Responsive gap */
            align-items: center;
            flex-wrap: wrap; /* Allow wrapping on very small screens */
        }

        /* All Buttons - Consolidated Base Properties */
        .settings-button, .reset-button, .theme-button, .level-cleared-button, .game-over-button {
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            font-weight: 500;
        }

        .settings-button:hover, .reset-button:hover, .theme-button:hover, .level-cleared-button:hover, .game-over-button:hover {
            transform: translateY(-2px);
        }

        .settings-button:active, .reset-button:active, .theme-button:active, .level-cleared-button:active, .game-over-button:active {
            transform: translateY(0);
        }

        /* Top Navigation Buttons */
        .settings-button, .reset-button {
            width: clamp(32px, 8vw, 44px);
            height: clamp(32px, 8vw, 44px);
            min-width: 44px;
            min-height: 44px;
            background: rgba(0,0,0,0.2);
            border: 1px solid rgba(255,255,255,0.2);
            color: #FFE4B5;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }

        .settings-button:hover, .reset-button:hover {
            background: rgba(0,0,0,0.3);
            box-shadow: 0 6px 15px rgba(0,0,0,0.4);
        }

        .settings-button:active, .reset-button:active {
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }

        /* Theme Button */
        .theme-button {
            width: clamp(32px, 8vw, 44px);
            height: clamp(32px, 8vw, 44px);
            min-width: 44px;
            min-height: 44px;
            background: linear-gradient(135deg, #4ECDC4 0%, #44A08D 100%);
            border: 1px solid rgba(255,255,255,0.2);
            color: white;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            font-size: clamp(16px, 4vw, 20px);
        }

        .theme-button:hover {
            background: linear-gradient(135deg, #44A08D 0%, #4ECDC4 100%);
            box-shadow: 0 6px 15px rgba(0,0,0,0.4);
        }

        .theme-button:active {
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }

        .reset-icon {
            width: clamp(12px, 3vw, 16px); /* Responsive icon size */
            height: clamp(12px, 3vw, 16px);
            color: #FFE4B5;
            font-size: clamp(10px, 3vw, 14px); /* Responsive font */
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .pause-icon {
            width: clamp(12px, 3vw, 16px);
            height: clamp(12px, 3vw, 16px);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 2px;
        }

        .pause-bar {
            width: 3px;
            height: clamp(10px, 3vw, 14px); /* Responsive height */
            background: #FFE4B5;
            border-radius: 1px;
        }

        .coin-counter {
            display: flex;
            align-items: center;
            gap: clamp(4px, 1.5vw, 7px); /* Responsive gap */
            background: rgba(0,0,0,0.2);
            padding: clamp(4px, 1.5vw, 7px) clamp(8px, 2.5vw, 12px); /* Responsive padding */
            border-radius: 10px;
            border: 1px solid rgba(255,255,255,0.2);
            cursor: pointer;
            transition: all 0.3s ease;
            min-height: 44px; /* Minimum touch target */
            min-width: 60px; /* Minimum width for readability */
        }

        .coin-counter:hover {
            background: rgba(0,0,0,0.3);
            transform: translateY(-1px);
        }

        .coin-icon {
            width: clamp(14px, 4vw, 18px); /* Responsive icon size */
            height: clamp(14px, 4vw, 18px);
            font-size: clamp(10px, 3vw, 14px); /* Responsive font */
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .coin-amount {
            font-size: clamp(12px, 3.5vw, 16px); /* Responsive font size */
            font-weight: 600;
            color: #FFE4B5;
            text-shadow: 0 1px 2px rgba(0,0,0,0.4);
            white-space: nowrap; /* Prevent text wrapping */
        }

        /* Timer Mode Indicator */
        .timer-mode-indicator {
            position: absolute;
            top: -5px;
            right: -5px;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            font-size: 8px;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            border: 1px solid rgba(255,255,255,0.3);
        }

        .timer-mode-elapsed {
            background: linear-gradient(135deg, #8B5CF6 0%, #7C3AED 100%);
        }

        .timer-mode-countdown {
            background: linear-gradient(135deg, #EF4444 0%, #DC2626 100%);
        }

        .timer-mode-endlevel {
            background: linear-gradient(135deg, #10B981 0%, #059669 100%);
        }

        /* Docking Area - Shape Selection */
        .docking-area {
            position: absolute;
            top: clamp(70px, 12vh, 90px); /* Match HUD height */
            left: 0;
            right: 0;
            height: clamp(120px, 20vh, 160px); /* Responsive height */
            background: transparent; /* Changed from #34495e to transparent */
            display: grid;
            grid-template-columns: repeat(5, 1fr); /* Equal column distribution */
            grid-template-rows: repeat(2, 1fr); /* Equal row distribution */
            gap: clamp(4px, 1.5vw, 10px); /* Responsive gap */
            padding: clamp(4px, 2vw, 8px); /* Responsive padding */
            /* box-shadow: 0 2px 10px rgba(0,0,0,0.3); */
            z-index: 50;
            align-items: center;
            justify-items: center;
            overflow: visible; /* Allow shapes to extend beyond docking area */
        }

        .docking-area.loading .game-shape {
            opacity: 0;
        }
        
        /* Enhanced loading states for dock */
        .docking-area.loading::before {
            content: "Loading shapes...";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 10;
            animation: pulse 1.5s ease-in-out infinite alternate;
        }
        
        .docking-area.error::before {
            content: "⚠️ Failed to load shapes";
            background: rgba(220, 53, 69, 0.9);
            animation: none;
        }
        
        .docking-area.retrying::before {
            content: "🔄 Retrying...";
            background: rgba(255, 193, 7, 0.9);
            color: black;
        }
        
        @keyframes pulse {
            from { opacity: 0.6; }
            to { opacity: 1; }
        }

        .shape-slot {
            width: 100%;
            height: 100%;
            min-width: clamp(50px, 12vw, 70px); /* Responsive minimum size */
            min-height: clamp(50px, 12vw, 70px);
            max-width: 80px; /* Prevent too large on desktop */
            max-height: 80px;
            background: rgba(255,255,255,0.1);
            border: 2px dashed rgba(255,255,255,0.3);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            transition: all 0.3s ease;
            padding: 0;
            margin: 0;
            overflow: visible;
            box-sizing: border-box;
            cursor: pointer; /* Indicate interactivity */
        }

        .special-effect-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 65;
        }

        .shape-slot:hover {
            background: rgba(255,255,255,0.15);
            border-color: rgba(255,255,255,0.5);
            transform: scale(1.05);
        }

        .shape-slot.empty {
            border-color: rgba(255,255,255,0.1);
            background: rgba(255,255,255,0.05);
        }

        .shape-slot.empty:hover {
            border-color: rgba(255,255,255,0.2);
            background: rgba(255,255,255,0.1);
        }

        .game-shape {
            cursor: grab;
            transition: all 0.3s ease;
            position: relative;
            z-index: 60;
            width: 100%; /* Fill slot */
            height: 100%;
            min-width: 44px; /* Minimum touch target */
            min-height: 44px;
        }

        .game-shape:active {
            cursor: grabbing;
            transform: scale(1.15); /* Slightly larger feedback on touch */
            filter: drop-shadow(0 5px 15px rgba(0,0,0,0.4));
            transition: all 0.1s ease; /* Quick response for touch */
        }

        .shape-entrance-animation {
            transition-property: transform, opacity;
        }

        .game-shape:hover {
            transform: scale(1.1);
            filter: drop-shadow(0 3px 10px rgba(0,0,0,0.3));
        }

        /* Locked Shape Styles */
        .shape-slot .locked { filter: saturate(0.1) brightness(0.5); cursor: not-allowed; }
        .shape-slot .lock-icon { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 1.75em; height: 1.75em; pointer-events: none; z-index: 70; }

        .game-shape.dragging {
            z-index: 1000;
            transform: scale(1.2); /* Slightly larger when dragging */
            filter: drop-shadow(0 8px 20px rgba(0,0,0,0.4));
        }

        /* Enhanced touch feedback for mobile */
        @media (pointer: coarse) {
            .game-shape {
                transition: all 0.2s ease; /* Longer transitions on touch devices */
            }
            
            .game-shape:active {
                transform: scale(1.2); /* Larger feedback on touch devices */
                transition: all 0.05s ease; /* Very quick response */
            }
            
            .shape-slot:active {
                background: rgba(255,255,255,0.2);
                border-color: rgba(255,255,255,0.7);
                transform: scale(1.02);
                transition: all 0.05s ease;
            }
        }
        
        /* End Level Countdown - 3 Dot Display */
        .countdown-dots {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            padding: 8px 12px;
        }

        .countdown-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: rgba(255,255,255,0.3);
            transition: all 0.3s ease;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }

        .countdown-dot.active {
            background: linear-gradient(135deg, #10B981 0%, #059669 100%);
            transform: scale(1.7);
            box-shadow: 0 0 12px rgba(16, 185, 129, 0.8);
            animation: dotPulse 0.6s ease-in-out;
        }

        .countdown-dot.completed {
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
            transform: scale(1.8);
            box-shadow: 0 0 8px rgba(255, 215, 0, 0.6);
        }

        @keyframes dotPulse {
            0%, 100% { transform: scale(1.3); }
            50% { transform: scale(1.6); }
        }

        /* Particle Effects */
        .particle {
            position: fixed;
            pointer-events: none;
            z-index: 9999;
            font-size: 14px;
            font-weight: bold;
            opacity: 1;
            animation: particleFloat 2s ease-out forwards;
        }

        @keyframes particleFloat {
            0% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
            100% {
                opacity: 0;
                transform: translateY(-40px) scale(0);
            }
        }

        @keyframes starBurst {
            0% {
                opacity: 1;
                transform: scale(0) rotate(0deg);
            }
            50% {
                opacity: 0.8;
                transform: scale(1.5) rotate(180deg);
            }
            100% {
                opacity: 0;
                transform: scale(2) rotate(360deg);
            }
        }

        .progress-animate {
            animation: progressPulse 0.8s ease-out;
        }

        @keyframes progressPulse {
            0% { transform: scaleY(1); }
            50% { transform: scaleY(1.1); box-shadow: 0 0 15px rgba(255, 215, 0, 0.6); }
            100% { transform: scaleY(1); }
        }

        /* Enhanced Star Animations */
        .star.filled {
            animation: starFill 0.5s ease-out;
        }

        @keyframes starFill {
            0% { transform: scale(0) rotate(0deg); opacity: 0; }
            50% { transform: scale(1.3) rotate(180deg); opacity: 1; }
            100% { transform: scale(1) rotate(360deg); opacity: 1; }
        }

        /* Score Text Animation */
        .score-text {
            transition: all 0.3s ease;
        }

        .score-text.score-increase {
            animation: scoreBoost 0.6s ease-out;
        }

        @keyframes scoreBoost {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); color: #FFD700; }
            100% { transform: scale(1); }
        }

        /* Coin Animation */
        .coin-amount {
            transition: all 0.3s ease;
        }

        .coin-amount.coin-increase {
            animation: coinBoost 0.6s ease-out;
        }

        @keyframes coinBoost {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); color: #FFD700; text-shadow: 0 0 10px #FFD700; }
            100% { transform: scale(1); }
        }

        /* Enhanced Coin Animations */
        @keyframes coinShower {
            0% { 
                transform: translateY(0) rotate(0deg); 
                opacity: 1; 
            }
            50% { 
                transform: translateY(-50px) rotate(180deg); 
                opacity: 0.8; 
            }
            100% { 
                transform: translateY(100px) rotate(360deg); 
                opacity: 0; 
            }
        }

        @keyframes coinPulse {
            0%, 100% { 
                transform: scale(1); 
                box-shadow: 0 0 5px rgba(255, 215, 0, 0.3); 
            }
            50% { 
                transform: scale(1.3); 
                box-shadow: 0 0 25px rgba(255, 215, 0, 0.8); 
            }
        }

        @keyframes coinShake {
            0%, 100% { transform: translateX(0); }
            10% { transform: translateX(-2px) rotate(-1deg); }
            20% { transform: translateX(2px) rotate(1deg); }
            30% { transform: translateX(-3px) rotate(-1deg); }
            40% { transform: translateX(3px) rotate(1deg); }
            50% { transform: translateX(-2px) rotate(-1deg); }
            60% { transform: translateX(2px) rotate(1deg); }
            70% { transform: translateX(-1px) rotate(-1deg); }
            80% { transform: translateX(1px) rotate(1deg); }
            90% { transform: translateX(-1px) rotate(-1deg); }
        }

        /* Particle Effects */
        .particle {
            position: fixed;
            pointer-events: none;
            font-size: 18px;
            font-weight: bold;
            z-index: 9999;
            animation: particleFloat 2s ease-out forwards;
        }

        /* Level Complete Effects */
        @keyframes levelCompleteFlash {
            0%, 100% { filter: brightness(1); }
            25% { filter: brightness(1.3) saturate(1.2); }
            50% { filter: brightness(1.1) saturate(1.1); }
            75% { filter: brightness(1.2) saturate(1.15); }
        }

        /* Level Cleared Popup Modal */
        .level-cleared-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            opacity: 0;
            animation: modalFadeIn 0.5s ease-out forwards;
        }

        .level-cleared-content {
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
            transform: scale(0.5);
            animation: modalPopIn 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55) forwards;
        }

        .level-cleared-title {
            font-size: 48px;
            font-weight: bold;
            color: #8B4513;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            animation: titlePulse 1s ease-in-out infinite alternate;
        }

        .level-cleared-subtitle {
            font-size: 24px;
            color: #654321;
            margin-bottom: 30px;
            font-weight: 600;
        }

        .level-cleared-stars {
            font-size: 60px;
            margin: 20px 0;
            animation: starsSparkle 2s ease-in-out infinite;
        }

        /* Level Cleared Button */
        .level-cleared-button {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
            padding: clamp(12px, 3vw, 18px) clamp(24px, 6vw, 36px);
            font-size: clamp(16px, 4vw, 20px);
            border-radius: 12px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            margin: clamp(8px, 2vw, 12px);
            min-height: 44px; /* Minimum touch target */
            min-width: 120px;
            transition: all 0.3s ease;
            font-weight: 600;
            cursor: pointer;
            border: none;
            touch-action: manipulation; /* Prevent zoom on double-tap */
            -webkit-tap-highlight-color: transparent; /* Remove blue highlight on mobile */
        }

        .level-cleared-button:hover {
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
            transform: translateY(-2px);
        }

        .level-cleared-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        /* Game Over Popup Modal */
        .game-over-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10001;
            opacity: 0;
            animation: modalFadeIn 0.45s ease-out forwards;
        }

        .game-over-content {
            background: linear-gradient(135deg, #2c3e50 0%, #8e0e00 100%);
            border-radius: 24px;
            padding: clamp(28px, 6vw, 48px);
            text-align: center;
            box-shadow: 0 24px 48px rgba(0, 0, 0, 0.55);
            transform: scale(0.6);
            animation: modalPopIn 0.55s cubic-bezier(0.68, -0.55, 0.265, 1.55) forwards;
            max-width: min(420px, 90vw);
        }

        .game-over-title {
            font-size: clamp(36px, 9vw, 48px);
            font-weight: 800;
            color: #FFECEC;
            text-transform: uppercase;
            letter-spacing: 4px;
            text-shadow: 0 4px 12px rgba(0, 0, 0, 0.45);
            margin-bottom: clamp(12px, 3vw, 20px);
            animation: titlePulse 1s ease-in-out infinite alternate;
        }

        .game-over-message {
            font-size: clamp(18px, 4.2vw, 22px);
            color: #FFD7D7;
            margin-bottom: clamp(18px, 4vw, 26px);
            font-weight: 600;
        }

        .game-over-stats {
            display: grid;
            gap: 10px;
            color: #FFFFFF;
            font-size: clamp(16px, 4vw, 20px);
            margin-bottom: clamp(22px, 5vw, 32px);
        }

        .game-over-stats strong {
            color: #FFE082;
        }

        .game-over-buttons {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: clamp(12px, 3vw, 18px);
            flex-wrap: wrap;
        }

        /* Game Over Buttons */
        .game-over-button {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            color: #FFFFFF;
            padding: clamp(14px, 3.5vw, 18px) clamp(24px, 6vw, 32px);
            font-size: clamp(16px, 4vw, 18px);
            border-radius: 12px;
            box-shadow: 0 6px 16px rgba(231, 76, 60, 0.45);
            min-width: 150px;
            min-height: 44px; /* Minimum touch target */
            transition: all 0.3s ease;
            font-weight: 600;
            cursor: pointer;
            border: none;
            touch-action: manipulation; /* Prevent zoom on double-tap */
            -webkit-tap-highlight-color: transparent; /* Remove blue highlight on mobile */
        }

        .game-over-button.secondary {
            background: rgba(255, 255, 255, 0.12);
            border: 1px solid rgba(255, 255, 255, 0.4);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.35);
        }

        .game-over-button:hover {
            transform: translateY(-3px); /* Custom hover transform */
            box-shadow: 0 10px 22px rgba(231, 76, 60, 0.55);
        }

        .game-over-button.secondary:hover {
            transform: translateY(-3px); /* Custom hover transform */
            box-shadow: 0 10px 22px rgba(0, 0, 0, 0.4);
        }

        .game-over-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 8px rgba(231, 76, 60, 0.45);
        }

        .game-over-button.secondary:active {
            transform: translateY(0);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.35);
        }

        /* Enhanced touch feedback for popup buttons on mobile */
        @media (pointer: coarse) {
            .game-over-button, .level-cleared-button {
                min-height: 48px; /* Larger touch targets on mobile */
                min-width: 160px;
                padding: clamp(16px, 4vw, 20px) clamp(28px, 7vw, 36px);
                font-size: clamp(18px, 4.5vw, 20px);
                transition: all 0.2s ease; /* Faster response on touch */
            }
            
            .game-over-button:active, .level-cleared-button:active {
                transform: scale(0.95); /* Scale down for immediate feedback */
                transition: all 0.1s ease;
            }
            
            .game-over-buttons {
                gap: clamp(16px, 4vw, 24px); /* More space between buttons on mobile */
                margin-top: clamp(16px, 4vw, 24px);
            }
        }

        /* Additional mobile optimizations for popup modals */
        @media (max-width: 480px) {
            .game-over-content, .level-cleared-content {
                padding: clamp(20px, 5vw, 32px);
                margin: 20px;
                max-width: calc(100vw - 40px);
            }
            
            .game-over-buttons {
                flex-direction: column; /* Stack buttons vertically on small screens */
                width: 100%;
            }
            
            .game-over-button, .level-cleared-button {
                width: 100%; /* Full width buttons on small screens */
                margin: clamp(6px, 1.5vw, 8px) 0;
            }
        }

        /* Prevent mobile scroll issues during popup */
        .modal-open {
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
        }

        /* Ensure popup modals work with mobile keyboards */
        @media (max-height: 500px) {
            .game-over-modal, .level-cleared-modal {
                align-items: flex-start;
                padding-top: 20px;
            }
            
            .game-over-content, .level-cleared-content {
                max-height: calc(100vh - 40px);
                overflow-y: auto;
            }
        }

        @keyframes modalFadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes modalPopIn {
            from { 
                transform: scale(0.5) rotate(-10deg);
                opacity: 0;
            }
            to { 
                transform: scale(1) rotate(0deg);
                opacity: 1;
            }
        }

        @keyframes titlePulse {
            from { transform: scale(1); }
            to { transform: scale(1.05); }
        }

        @keyframes starsSparkle {
            0%, 100% { 
                transform: scale(1) rotate(0deg);
                filter: brightness(1);
            }
            50% { 
                transform: scale(1.1) rotate(5deg);
                filter: brightness(1.3);
            }
        }

        /* Global Drag Overlay - Ensure dragging works across entire viewport */
        #dragOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 9998;
            overflow: visible;
        }

        .ghost-shape {
            position: fixed !important;
            pointer-events: none !important;
            z-index: 10000 !important; /* Increased z-index */
            visibility: visible !important;
            opacity: 0.9 !important;
            display: block !important;
            transition: transform 0.2s ease-out !important;
        }

        .game-shape.ghost-active {
            opacity: 0;
            transform: scale(0.9);
            transition: all 0.3s ease;
        }

        /* Touch Feedback */
        .touch-ripple {
            position: fixed;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.6);
            pointer-events: none;
            z-index: 9998;
            animation: rippleEffect 0.6s ease-out forwards;
        }

        @keyframes rippleEffect {
            0% { transform: scale(0); opacity: 1; }
            100% { transform: scale(4); opacity: 0; }
        }

        .rotation-indicator {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: bold;
            z-index: 10000;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .rotation-indicator.show {
            opacity: 1;
        }

        /* Enhanced Drag Feedback */
        .game-shape.ghost-active {
            opacity: 0;
            transform: scale(0.9);
            transition: all 0.3s ease;
        }

        /* Shape Visual Designs - REMOVED: Now using unified canvas-based system */
        /* All shape appearances now handled by PhysicsShapeRenderer and SHAPE_CONFIG */

        /* Canvas preview styling for dock */
        .shape-preview {
            width: 46px;
            height: 46px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .shape-preview:hover {
            filter: brightness(1.1);
            transform: scale(1.05);
        }

        /* Ghost effect for dragged shapes */
        .shape-preview.ghost-active {
            opacity: 0.3;
            transform: scale(0.9);
            transition: all 0.3s ease;
        }

        /* Mode Toggle Inside HUD */
        .mode-toggle-switch {
            position: relative;
            width: 60px;
            height: 28px;
            background: rgba(52, 73, 94, 0.8);
            border-radius: 14px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .mode-toggle-switch.design-active {
            background: rgba(52, 152, 219, 0.8);
            border-color: #3498db;
        }

        .mode-toggle-slider {
            position: absolute;
            top: 2px;
            left: 2px;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
        }

        .mode-toggle-switch.design-active .mode-toggle-slider {
            transform: translateX(28px);
        }

        .mode-toggle-labels {
            position: absolute;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            white-space: nowrap;
            color: rgba(255, 255, 255, 0.8);
        }

        /* Design Mode Sidebar */
        .design-sidebar {
            position: fixed;
            top: 0;
            left: -350px;
            width: 350px;
            height: 100vh;
            background: linear-gradient(180deg, #2c3e50 0%, #34495e 100%);
            box-shadow: 5px 0 20px rgba(0,0,0,0.3);
            transition: left 0.4s ease;
            z-index: 999;
            overflow-y: auto;
            color: white;
        }

        .design-sidebar.active {
            left: 0;
        }

        .design-mode .game-viewport {
            margin-left: 350px;
            transition: margin-left 0.4s ease;
        }

        .sidebar-header {
            padding: 20px;
            background: rgba(0,0,0,0.2);
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .sidebar-title {
            font-size: 16px;
            font-weight: bold;
            color: #3498db;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .sidebar-section {
            padding: 15px 20px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .config-group {
            margin-bottom: 12px;
        }

        .config-label {
            display: block;
            font-size: 13px;
            font-weight: 500;
            margin-bottom: 5px;
            color: #bdc3c7;
        }

        .config-input, .config-select {
            width: 100%;
            padding: 8px 12px;
            background: rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 6px;
            color: white;
            font-size: 14px;
        }

        .config-input:focus, .config-select:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 5px rgba(52, 152, 219, 0.3);
        }

        .config-sub-group {
            margin-left: 20px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .config-sub-group .config-label {
            min-width: 100px;
            margin-bottom: 0;
            font-size: 12px;
        }

        .config-sub-group input[type="range"] {
            flex: 1;
            margin: 0;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
        }

        .range-value {
            min-width: 50px;
            text-align: right;
            font-size: 12px;
            color: #FFE4B5;
            font-weight: 600;
            background: rgba(0,0,0,0.2);
            padding: 2px 6px;
            border-radius: 4px;
        }

        .config-btn {
            width: 100%;
            padding: 10px;
            background: linear-gradient(135deg, #27ae60 0%, #229954 100%);
            color: white;
            border: none;
            border-radius: 6px;
            font-weight: bold;
            cursor: pointer;
            margin-top: 8px;
            transition: all 0.3s ease;
        }

        .config-btn:hover {
            background: linear-gradient(135deg, #229954 0%, #1e8449 100%);
            transform: translateY(-1px);
        }

        /* Theme Selector Styles */
        .checkbox-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 8px;
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            color: #ecf0f1;
            cursor: pointer;
        }

        .checkbox-label input[type="checkbox"] {
            width: 16px;
            height: 16px;
            accent-color: #27ae60;
        }

        .theme-preview {
            width: 100%;
            height: 40px;
            border-radius: 4px;
            margin: 4px 0 8px 0;
            background: linear-gradient(135deg, #87CEEB 0%, #4ECDC4 50%, #90EE90 100%);
            border: 2px solid transparent;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .theme-preview:hover {
            border-color: #27ae60;
            transform: scale(1.02);
        }

        .theme-preview.active {
            border-color: #27ae60;
            box-shadow: 0 0 10px rgba(39, 174, 96, 0.5);
        }

        .dock-slot-config {
            background: rgba(0,0,0,0.2);
            padding: 8px;
            border-radius: 6px;
            margin-bottom: 8px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .game-canvas-container {
            position: absolute;
            top: calc(clamp(70px, 12vh, 90px) + clamp(120px, 20vh, 160px)); /* HUD + Docking height */ 
            left: 0;
            right: 0;
            bottom: 0; /* Use full available space */
            /* background: linear-gradient(135deg, #87CEEB 0%, #98FB98 100%); */
            background: transparent; /* Changed from gradient to transparent */
            border-radius: 0;
            overflow: visible; /* Allow dragged shapes to extend beyond canvas boundaries */
        }

        #gameCanvas {
            width: 100%;
            height: 100%;
            display: block;
            background: transparent;
            cursor: crosshair;
        }

        /* Debug Info */
        .debug-info {
            position: absolute;
            bottom: clamp(5px, 2vh, 15px); /* Responsive bottom position */
            left: clamp(5px, 2vw, 15px); /* Responsive left position */
            color: white;
            font-size: clamp(10px, 2.5vw, 12px); /* Responsive font size */
            opacity: 0.7;
            font-family: monospace;
            background: rgba(0,0,0,0.7);
            padding: clamp(4px, 1.5vw, 8px); /* Responsive padding */
            border-radius: 6px;
            z-index: 100;
            max-width: 70vw; /* Prevent overflow */
            word-break: break-word;
        }

        /* Event Notifications */
        .event-notification {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: clamp(12px, 3vw, 20px) clamp(16px, 4vw, 24px); /* Responsive padding */
            border-radius: 12px;
            font-size: clamp(14px, 4vw, 18px); /* Responsive font size */
            font-weight: bold;
            z-index: 1000;
            opacity: 0;
            transition: all 0.3s ease;
            pointer-events: none;
            max-width: 80vw; /* Prevent overflow on small screens */
            min-width: 200px; /* Minimum readable width */
            text-align: center;
        }

        .event-notification.show {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1.1);
        }

        .event-notification.fall {
            background: rgba(231, 76, 60, 0.9);
            border: 2px solid #e74c3c;
        }

        .event-notification.collision {
            background: rgba(46, 204, 113, 0.9);
            border: 2px solid #2ecc71;
        }

        .event-notification.balance {
            background: rgba(52, 152, 219, 0.9);
            border: 2px solid #3498db;
        }

        /* Animations */
        @keyframes starPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.3); }
            100% { transform: scale(1.2); }
        }

        /* Test Controls (REMOVED - Debug squares eliminated) */

        /* Responsive Design - Mobile and Tablet First */
        @media (max-width: 1023px) {
            body {
                padding: 0;
            }
            
            .game-viewport {
                width: 100vw;
                height: 100vh;
                height: 100dvh;
                border-radius: 0;
                box-shadow: none;
                max-width: none;
                max-height: none;
                aspect-ratio: unset; /* Allow full screen on mobile/tablet */
                padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
            }
            
            .game-hud {
                height: clamp(60px, 10vh, 70px); /* Slightly smaller on mobile */
                padding: clamp(4px, 1.5vw, 8px);
            }
            
            .docking-area {
                height: clamp(100px, 18vh, 140px); /* Adjust for mobile */
                gap: clamp(3px, 1vw, 6px);
                padding: clamp(3px, 1vw, 6px);
            }
            
            .shape-slot {
                min-width: clamp(45px, 15vw, 60px); /* Optimize for mobile touch */
                min-height: clamp(45px, 15vw, 60px);
            }
            
            .game-canvas-container {
                border-radius: 0;
                top: calc(clamp(60px, 10vh, 70px) + clamp(100px, 18vh, 140px)); /* Updated for mobile HUD + docking */
            }
            
            /* Enhanced touch targets on mobile */
            .settings-button, .reset-button, .theme-button {
                min-width: 48px; /* Larger touch targets */
                min-height: 48px;
            }
            
            .timer-container {
                min-height: 48px; /* Better touch target */
            }
            
            .coin-counter {
                min-height: 48px; /* Better touch target */
                padding: 6px 10px;
            }
            
            /* Hide design mode on mobile */
            .design-sidebar {
                display: none;
            }
        }

        /* Rotation Zones - Mobile Enhancement */
        .rotation-zone {
            position: absolute;
            width: 80px;
            height: 100%;
            top: 0;
            border: 2px dashed rgba(74, 144, 226, 0.4);
            border-radius: 10px;
            transition: all 0.3s ease;
            pointer-events: none;
            opacity: 0.3; /* Make visible for testing */
            z-index: 1000;
            display: block; /* Always visible for testing */
        }

        .rotation-zone.left {
            left: 0;
            background: linear-gradient(to right, rgba(229, 115, 115, 0.2), transparent);
            border-color: rgba(229, 115, 115, 0.4);
        }

        .rotation-zone.right {
            right: 0;
            background: linear-gradient(to left, rgba(129, 199, 132, 0.2), transparent);
            border-color: rgba(129, 199, 132, 0.4);
        }

        .rotation-zone.visible {
            display: block;
            opacity: 1;
        }

        .rotation-zone.active {
            border-color: rgba(74, 144, 226, 1);
            box-shadow: 0 0 20px rgba(74, 144, 226, 0.4);
        }

        .rotation-zone.left.active {
            background: linear-gradient(to right, rgba(229, 115, 115, 0.4), transparent);
            border-color: rgba(229, 115, 115, 1);
            box-shadow: 0 0 20px rgba(229, 115, 115, 0.4);
        }

        .rotation-zone.right.active {
            background: linear-gradient(to left, rgba(129, 199, 132, 0.4), transparent);
            border-color: rgba(129, 199, 132, 1);
            box-shadow: 0 0 20px rgba(129, 199, 132, 0.4);
        }

        .rotation-zone::before {
            content: "↺";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2rem;
            color: rgba(255, 255, 255, 0.8);
            animation: zonePulse 2s infinite;
        }

        .rotation-zone.right::before {
            content: "↻";
        }

        .rotation-zone.active::before {
            animation: zoneRotate 1s linear infinite;
            color: rgba(255, 255, 255, 1);
        }

        @keyframes zonePulse {
            0%, 100% { opacity: 0.6; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
        }

        @keyframes zoneRotate {
            from { transform: translate(-50%, -50%) rotate(0deg); }
            to { transform: translate(-50%, -50%) rotate(360deg); }
        }

        /* Mobile-specific HUD adjustments */
        @media (max-width: 600px), (pointer: coarse) {
            /* Hide the play/edit toggle and the purple mobile debug button on mobile devices */
            #modeToggleSwitch,
            #mobileDebugButton {
                display: none !important;
            }
            /* Reflow the right section horizontally and allow the coin counter
               to occupy the space left by the hidden controls. Using flex-start
               ensures the group of remaining buttons and the coin counter starts
               from the left of the right section rather than hugging the far edge. */
            .right-section {
                flex-direction: row;
                align-items: center;
                justify-content: flex-start;
                gap: clamp(6px, 2vw, 12px);
            }
            /* Remove the left margin so the coin counter sits directly next to
               the remaining HUD buttons. The gap on the parent will handle spacing. */
            .coin-counter {
                margin-left: 0;
            }
        }
        
    </style>
</head>
<body>
    <!-- Global drag overlay to prevent clipping -->
    <div id="dragOverlay"></div>
    
    <div class="game-viewport" id="gameContainer">
        <!-- Mobile Rotation Zones -->
        <div id="leftRotationZone" class="rotation-zone left"></div>
        <div id="rightRotationZone" class="rotation-zone right"></div>
            
            <!-- Game HUD -->
            <div class="game-hud">
                <div class="left-section">
                    <div class="score-display">
                        <div class="trophy-icon">🏆</div>
                        <span class="score-text" id="scoreText">0</span>
                    </div>
                    <div class="progress-area">
                        <div class="star-progress-container" onclick="initializeProgressBarInteraction()">
                            <div class="star-progress-bar" id="starProgressBar" style="width: 0%;"></div>
                            <div class="progress-markers">
                                <div class="progress-marker"></div>
                                <div class="progress-marker"></div>
                                <div class="progress-marker"></div>
                            </div>
                        </div>
                        <div class="star-markers">
                            <div class="star"></div>
                            <div class="star"></div>
                            <div class="star"></div>
                        </div>
                    </div>
                </div>

                <div class="middle-section">
                    <div class="level-display" id="levelDisplay">World 1-1</div>
                    <div class="timer-container" id="timerContainer" onclick="switchTimerMode()">
                        <span class="timer-text" id="gameTimer">0:00</span>
                        <div class="timer-mode-indicator timer-mode-elapsed" id="timerModeIndicator">⏱</div>
                    </div>
                </div>

                <div class="right-section">
                    <div class="top-buttons">

                        
                        <!-- Theme cycling button -->
                        <div class="theme-button" id="themeButton" onclick="cycleThemes()" title="Cycle Theme">
                            <div class="theme-icon">🎨</div>
                        </div>
                        
                        <!-- Phase 2: Mode Toggle Switch -->
                        <div class="mode-toggle-switch" id="modeToggleSwitch" onclick="toggleModeSwitch()">
                            <div class="mode-toggle-slider">🎮</div>
                            <div class="mode-toggle-labels">Play/Design</div>
                        </div>
                        
                        <div class="reset-button" id="resetButton" onclick="resetLevel()">
                            <div class="reset-icon">⟲</div>
                        </div>
                        
                        <div class="reset-button" id="mobileDebugButton" onclick="toggleMobileDebug()" style="background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%);">
                            <div class="reset-icon">📱</div>
                        </div>
                    </div>
                    <div class="coin-counter" id="coinCounter" onclick="animateCoin()">
                        <div class="coin-icon">💰</div>
                        <span class="coin-amount" id="coinAmount">0</span>
                    </div>
                </div>
            </div>

            <!-- Docking Area -->
            <div class="docking-area loading" id="dockingArea">
                <div class="shape-slot" id="slot-square">
                    <div class="game-shape shape-square" data-shape="square" id="shape-square"></div>
                </div>
                <div class="shape-slot" id="slot-triangle">
                    <div class="game-shape shape-triangle" data-shape="triangle" id="shape-triangle"></div>
                </div>
                <div class="shape-slot" id="slot-circle">
                    <div class="game-shape shape-circle" data-shape="circle" id="shape-circle"></div>
                </div>
                <div class="shape-slot" id="slot-cross2">
                    <div class="game-shape shape-cross2" data-shape="cross2" id="shape-cross2"></div>
                </div>
                <div class="shape-slot" id="slot-l">
                    <div class="game-shape shape-l" data-shape="l" id="shape-l"></div>
                </div>
                <div class="shape-slot" id="slot-cross">
                    <div class="game-shape shape-cross" data-shape="cross" id="shape-cross"></div>
                </div>
                <div class="shape-slot" id="slot-barbell-one">
                    <div class="game-shape shape-barbell-one" data-shape="barbell-one" id="shape-barbell-one"></div>
                </div>
                <div class="shape-slot" id="slot-barbell-two">
                    <div class="game-shape shape-barbell-two" data-shape="barbell-two" id="shape-barbell-two"></div>
                </div>
                <div class="shape-slot" id="slot-diamond-barbell">
                    <div class="game-shape shape-diamond-barbell" data-shape="diamond-barbell" id="shape-diamond-barbell"></div>
                </div>
            </div>

            <!-- Game Canvas Area -->
            <div class="game-canvas-container">
                <canvas id="gameCanvas"></canvas>
            </div>

            <!-- Event Notification System -->
            <div class="event-notification" id="eventNotification"></div>

            <!-- Debug Info -->
            <div class="debug-info" id="debugInfo">
                Shapes: 0/9 | Events: 0 | Collisions: 0 | FPS: 60
            </div>

            <!-- Rotation Indicator -->
            <div class="rotation-indicator" id="rotationIndicator">
                🔄 R/E or ←/→ to rotate
            </div>
    </div>

    <!-- Phase 2: Design Mode Sidebar -->
    <div class="design-sidebar" id="designSidebar">
        <div class="sidebar-header">
            <h2>🔧 Level Editor</h2>
            <p>Configure level settings and dock layout</p>
        </div>

        <!-- Level Configuration -->
        <div class="sidebar-section">
            <div class="sidebar-title">📋 Level Configuration</div>
            
            <div class="config-group">
                <label class="config-label">World-Level</label>
                <input type="text" class="config-input" id="levelNumber" value="1-1" placeholder="1-1">
            </div>

            <div class="config-group">
                <label class="config-label">Timer Mode</label>
                <select class="config-select" id="timerMode" onchange="updateTimerModeConfig()">
                    <option value="none">No Timer</option>
                    <option value="elapsed" selected>Count-Up Timer</option>
                    <option value="countdown">Count-Down Timer</option>
                </select>
            </div>
            
            <div class="config-group">
                <label class="config-label">Starting Timer Value</label>
                <input type="number" class="config-input" id="timerStart" value="60" min="0" max="3600" placeholder="Seconds">
            </div>
            
            <div class="config-group">
                <label class="config-label">End-Level Countdown</label>
                <input type="number" class="config-input" id="endLevelDuration" value="5" min="3" max="15" placeholder="Seconds">
            </div>
        </div>

        <!-- Theme Selection -->
        <div class="sidebar-section">
            <div class="sidebar-title">🎨 Theme Selection</div>
            
            <div class="config-group">
                <label class="config-label">Visual Theme</label>
                <select class="config-select" id="themeSelector" onchange="applyTheme(this.value)">
                    <option value="classic" selected>Classic Puzzle</option>
                    <option value="wood">Wood</option>
                    <option value="stone">Stone</option>
                    <option value="metal">Metal</option>
                </select>
            </div>

            <div class="config-group">
                <label class="config-label">Canvas Enhancements</label>
                <div class="checkbox-group">
                    <label class="checkbox-label">
                        <input type="checkbox" id="enableCanvas" checked onchange="toggleCanvasEnhancements()">
                        Enable Advanced Graphics
                    </label>
                    <label class="checkbox-label">
                        <input type="checkbox" id="enableParticles" checked onchange="toggleParticleEffects()">
                        Particle Effects
                    </label>
                    <label class="checkbox-label">
                        <input type="checkbox" id="enableAnimations" checked onchange="toggleAnimations()">
                        Shape Animations
                    </label>
                </div>
            </div>

            <div class="config-group">
                <label class="config-label">Mobile Touch Offset</label>
                <div class="checkbox-group">
                    <label class="checkbox-label">
                        <input type="checkbox" id="enableTouchOffset" checked onchange="toggleTouchOffset()">
                        Enable Touch Offset
                    </label>
                </div>
                <div class="config-sub-group">
                    <label class="config-label">X Offset (Horizontal)</label>
                    <input type="range" id="touchOffsetX" min="-100" max="100" value="0" 
                           onchange="updateTouchOffset()" oninput="updateTouchOffsetDisplay()">
                    <span class="range-value" id="touchOffsetXValue">0px</span>
                </div>
                <div class="config-sub-group">
                    <label class="config-label">Y Offset (Vertical)</label>
                    <input type="range" id="touchOffsetY" min="-150" max="50" value="-80" 
                           onchange="updateTouchOffset()" oninput="updateTouchOffsetDisplay()">
                    <span class="range-value" id="touchOffsetYValue">-80px</span>
                </div>
            </div>
        </div>

        <!-- Dock Configuration -->
        <div class="sidebar-section">
            <div class="sidebar-title">🔧 Dock Configuration</div>
            
            <div class="config-group">
                <label class="config-label">Number of Dock Slots</label>
                <input type="number" class="config-input" id="dockSlotCount" value="9" min="3" max="12" onchange="generateDockSlots()">
            </div>
            
            <div class="config-group">
                <label class="config-label">Barbell Orientation in Dock</label>
                <select class="config-select" id="barbellOrientation" onchange="updateBarbellOrientation()">
                    <option value="vertical" selected>Vertical (90°)</option>
                    <option value="horizontal">Horizontal (0°)</option>
                </select>
            </div>
            
            <div class="config-group">
                <label class="config-label">Shape Assignment</label>
                <div id="dockSlotsContainer">
                    <!-- Dynamic dock slots will be generated here -->
                </div>
            </div>
        </div>

        <!-- Actions -->
        <div class="sidebar-section">
            <div class="sidebar-title">⚡ Actions</div>
            
            <button class="config-btn" id="applyChangesBtn" onclick="applyLevelChanges()">
                Apply Level Changes
            </button>
            
            <button class="config-btn" onclick="resetLevel()" style="background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);">
                Reset Level
            </button>
            
            <button class="config-btn" onclick="syncDockToDesign()" style="background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);">
                Sync Current Dock
            </button>
        </div>
    </div>



    <!-- Matter.js Physics Engine -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    
    <script>
        // Debug configuration
        const DEBUG_MODE = false; // Set to true for verbose logging (change to true for debugging)
        const debugLog = (...args) => DEBUG_MODE && console.log(...args);
        
        // Logging helpers for different types of messages
        const infoLog = (...args) => DEBUG_MODE && console.log(...args);
        const systemLog = (...args) => DEBUG_MODE && console.log(...args);
        const assetLog = (...args) => DEBUG_MODE && console.log(...args);
        
        // Enhanced debugging for race condition validation
        const raceConditionDebugger = {
            operationTimes: new Map(),
            duplicateCallCount: new Map(),
            
            trackOperation(operationName, source = 'unknown') {
                const timestamp = Date.now();
                const key = `${operationName}-${source}`;
                
                if (this.operationTimes.has(key)) {
                    const count = this.duplicateCallCount.get(key) || 0;
                    this.duplicateCallCount.set(key, count + 1);
                    console.warn(`⚠️ DUPLICATE OPERATION: ${operationName} from ${source} (count: ${count + 1})`);
                } else {
                    this.operationTimes.set(key, timestamp);
                }
                
                console.log(`⏱️ [${new Date(timestamp).toISOString()}] ${operationName} started from ${source}`);
            },
            
            getSummary() {
                return {
                    totalOperations: this.operationTimes.size,
                    duplicates: Array.from(this.duplicateCallCount.entries()),
                    operationHistory: Array.from(this.operationTimes.entries())
                };
            },
            
            clear() {
                this.operationTimes.clear();
                this.duplicateCallCount.clear();
            }
        };
        
        // Make globally available for testing
        window.raceConditionDebugger = raceConditionDebugger;
        
        // Race condition validation function
        window.validateRaceConditionFixes = function() {
            console.log('🔍 Race Condition Fix Validation Report:');
            console.log('======================================');
            
            const summary = raceConditionDebugger.getSummary();
            console.log(`📊 Total Operations Tracked: ${summary.totalOperations}`);
            
            if (summary.duplicates.length === 0) {
                console.log('✅ NO DUPLICATE OPERATIONS DETECTED - All fixes working correctly!');
            } else {
                console.log('⚠️ DUPLICATE OPERATIONS DETECTED:');
                summary.duplicates.forEach(([operation, count]) => {
                    console.log(`  - ${operation}: ${count} duplicates`);
                });
            }
            
            console.log('\n📋 Operation History:');
            summary.operationHistory.forEach(([operation, timestamp]) => {
                console.log(`  - ${operation}: ${new Date(timestamp).toISOString()}`);
            });
            
            // Check race condition monitor status
            if (typeof raceConditionMonitor !== 'undefined' && raceConditionMonitor.getStats) {
                const stats = raceConditionMonitor.getStats();
                console.log('\n🔧 Race Condition Monitor Stats:');
                console.log(`  - Total tracked accesses: ${stats.totalAccesses || 0}`);
                console.log(`  - Potential race conditions: ${stats.potentialRaceConditions || 0}`);
            }
            
            return summary;
        };
        
        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ UNIFIED GAME INITIALIZER - RACE CONDITION FIX
          ║ Single entry point for coordinated startup sequence
          ╚═══════════════════════════════════════════════════════════════════════════*/
        class GameInitializer {
            static isInitialized = false;
            static isInitializing = false;
            static initPromise = null;
            
            static async initialize() {
                raceConditionDebugger.trackOperation('GameInitializer.initialize', 'main');
                
                if (this.isInitialized) {
                    debugLog('⚠️ GameInitializer already initialized, skipping');
                    return this.initPromise;
                }
                
                if (this.isInitializing) {
                    debugLog('⚠️ GameInitializer already initializing, returning existing promise');
                    return this.initPromise;
                }
                
                this.isInitializing = true;
                
                // Wait for mutexes to be available (they're declared later in the file)
                const waitForMutexes = () => {
                    return new Promise((resolve) => {
                        const checkMutexes = () => {
                            if (typeof assetMutex !== 'undefined' && typeof dockMutex !== 'undefined') {
                                resolve();
                            } else {
                                setTimeout(checkMutexes, 10);
                            }
                        };
                        checkMutexes();
                    });
                };
                
                this.initPromise = (async () => {
                    await waitForMutexes();
                    
                    systemLog('🚀 Starting unified game initialization...');
                    
                    try {
                        // Phase 1: Create AssetManager
                        await this._createAssetManager();
                        
                        // Phase 2: Load default theme
                        await this._loadDefaultTheme();
                        
                        // Phase 3: Load level data
                        const levelData = await this._loadLevelData();
                        
                        // Phase 4: Initialize game systems
                        await this._initializeGameSystems(levelData);
                        
                        // Phase 5: Apply level theme if specified
                        await this._applyLevelTheme();
                        
                        // Phase 6: Build UI
                        await this._buildUI();
                        
                        this.isInitialized = true;
                        this.isInitializing = false;
                        systemLog('✅ Unified game initialization complete');
                        
                    } catch (error) {
                        this.isInitializing = false;
                        this.initPromise = null;
                        console.error('❌ Game initialization failed:', error);
                        throw error;
                    }
                })();
                
                return this.initPromise;
            }
            
            static async _createAssetManager() {
                if (!window.assetManager) {
                    window.assetManager = new AssetManager();
                    debugLog('✅ AssetManager created');
                }
                // Ensure backward compatibility
                window.textureManager = window.assetManager;
            }
            
            static async _loadDefaultTheme() {
                const defaultTheme = CANVAS_CONFIG.defaultTheme || 'classic';
                try {
                    // Check if theme is already loaded
                    if (!window.assetManager.themes[defaultTheme]?.loaded) {
                        await window.assetManager.loadTheme(defaultTheme);
                    }
                    debugLog(`✅ Default theme '${defaultTheme}' loaded`);
                } catch (error) {
                    console.error('❌ Failed to load default theme:', error);
                    throw error;
                }
            }
            
            static async _loadLevelData() {
                let levelFile = 'levelData.json';
                try {
                    levelFile = new URL(levelFile, window.location.href).href;
                } catch (e) {
                    console.warn('🔧 Using relative path for level data');
                }
                
                const loader = new LevelLoader();
                const ok = await loader.loadFromFile(levelFile);
                if (!ok) {
                    throw new Error('Failed to load level data');
                }
                
                const data = loader.getData();
                window.currentLevelData = data;
                debugLog('✅ Level data loaded');
                return data;
            }
            
            static async _initializeGameSystems(levelData) {
                if (levelData.mode === 'PLAYABLE_AD') {
                    debugLog('🚀 PLAYABLE_AD mode detected.');
                    window.adSequencer = new AdSequencer(levelData.adConfig);
                    alert('Playable Ad Mode Initialized! (stub).');
                } else if (levelData.mode === 'LEVEL') {
                    debugLog('🎮 LEVEL mode detected.');
                    
                    const gameManager = new GameManager(levelData);
                    window.gameManager = gameManager;
                    
                    // Wait for GameManager async initialization to complete
                    await gameManager.initPromise;
                    debugLog('✅ GameManager initialized');
                } else {
                    throw new Error(`Unknown mode in level data: ${levelData.mode}`);
                }
            }
            
            static async _applyLevelTheme() {
                if (window.gameManager && typeof window.gameManager.applyLevelTheme === 'function') {
                    await window.gameManager.applyLevelTheme();
                    debugLog('✅ Level theme applied');
                }
            }
            
            static async _buildUI() {
                if (window.gameManager) {
                    // Use dockMutex for coordinated dock building
                    await dockMutex.execute(async () => {
                        await window.gameManager.rebuildDockFromData(true);
                        
                        if (typeof window.gameManager.createPlatformsFromData === 'function') {
                            window.gameManager.createPlatformsFromData();
                        }
                        
                        if (window.gameManager.updateDebugInfo) {
                            window.gameManager.updateDebugInfo();
                        }
                        
                        console.log('✅ Game UI built');
                    }, 'initial-ui-build');
                }
                
                // Initialize UI components
                if (typeof initializeThemeUI === 'function') initializeThemeUI();
                if (typeof updateTouchOffsetDisplay === 'function') updateTouchOffsetDisplay();
                if (typeof startCoinBonusSystem === 'function') startCoinBonusSystem();
                
                debugLog('✅ UI components initialized');
            }
        }
        
        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ BSH GAME - CANVAS2D ARCHITECTURE
          ║ Complete PixiJS Removal & Canvas2D Optimization
          ╚═══════════════════════════════════════════════════════════════════════════*/
        /*
         * ARCHITECTURAL OVERVIEW:
         * 
         * This version represents the complete removal of PixiJS dependencies,
         * transitioning to a pure Canvas2D rendering architecture for optimal
         * performance, compatibility, and maintainability.
         * 
         * KEY CHANGES FROM PREVIOUS VERSION:
         * • Complete PixiJS removal (PixiJS CDN, classes, references)
         * • Canvas2D-only rendering system
         * • Simplified renderer architecture
         * • Reduced bundle size (~200KB smaller)
         * • Enhanced browser compatibility
         * • Improved performance on older devices
         * 
         * CORE SYSTEMS:
         * • RendererManager: Canvas2D-only rendering
         * • PhysicsManager: Matter.js with Canvas2D visualization
         * • ThemeManager: Canvas-optimized theme system
         * • DragDropManager: Canvas-based interaction
         * 
         * PRESERVED FUNCTIONALITY:
         * • All physics mechanics (Matter.js)
         * • Complete shape library with textures
         * • Full theme system (10+ themes)
         * • Responsive design and mobile support
         * • Settings and customization options
         * • Performance monitoring and debug tools
         */

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ LEVEL LOADER & DATA MANAGER
          ║ Fetches and stores level JSON data.
          ╚═══════════════════════════════════════════════════════════════════════════*/
        class LevelLoader {
            constructor() {
                this.levelData = null;
            }
            async loadFromFile(filePath) {
                try {
                    let response;
                    try {
                        response = await fetch(filePath);
                    } catch (err) {
                        return new Promise((resolve) => {
                            const xhr = new XMLHttpRequest();
                            xhr.overrideMimeType('application/json');
                            xhr.onreadystatechange = () => {
                                if (xhr.readyState === 4) {
                                    if (xhr.status === 200 || xhr.status === 0) {
                                        try {
                                            this.levelData = JSON.parse(xhr.responseText);
                                            console.log(`✅ Level data loaded via XHR from ${filePath}`, this.levelData);
                                            resolve(true);
                                        } catch (parseErr) {
                                            console.error('❌ Failed to parse level data via XHR:', parseErr);
                                            this.levelData = null;
                                            resolve(false);
                                        }
                                    } else {
                                        console.error(`❌ Failed to load level data via XHR. Status: ${xhr.status}`);
                                        resolve(false);
                                    }
                                }
                            };
                            xhr.open('GET', filePath, true);
                            xhr.send(null);
                        });
                    }
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    this.levelData = await response.json();
                    console.log(`✅ Level data loaded successfully from ${filePath}`, this.levelData);
                    return true;
                } catch (error) {
                    console.error('❌ Failed to load or parse level data:', error);
                    this.levelData = null;
                    return false;
                }
            }
            getData() {
                return this.levelData;
            }
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ STUB MANAGERS FOR ADVANCED FEATURES
          ║ Placeholder classes to store additional level data for future implementation.
          ╚═══════════════════════════════════════════════════════════════════════════*/
        class ObjectiveManager {
            constructor(victoryData, failureData) {
                this.victoryData = victoryData || null;
                this.failureData = failureData || null;
                debugLog('🗺️ ObjectiveManager initialized with data:', this.victoryData, this.failureData);
            }
        }
        class StarManager {
            constructor(starData) {
                this.starData = starData || [];
                debugLog(`⭐ StarManager initialized with ${this.starData.length} stars.`);
            }
        }
        class OnboardingManager {
            constructor(onboardingData) {
                this.onboardingData = onboardingData || null;
                console.log('🎓 OnboardingManager initialized with data:', this.onboardingData);
            }
        }
        /**
         * Helper function to deeply merge two objects. The source object's properties overwrite the target's.
         * @param {object} target - The target object to merge into.
         * @param {object} source - The source object with new properties.
         * @returns {object} The merged object.
         */
        function deepMerge(target, source) {
            const output = { ...target };
            if (isObject(target) && isObject(source)) {
                Object.keys(source).forEach(key => {
                    if (isObject(source[key])) {
                        if (!(key in target)) {
                            Object.assign(output, { [key]: source[key] });
                        } else {
                            output[key] = deepMerge(target[key], source[key]);
                        }
                    } else {
                        Object.assign(output, { [key]: source[key] });
                    }
                });
            }
            return output;
        }

        function isObject(item) {
            return (item && typeof item === 'object' && !Array.isArray(item));
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ AD SEQUENCER (this is for context to find the right location)
          ╚═══════════════════════════════════════════════════════════════════════════*/
        class AdSequencer {
            constructor(adConfig) {
                this.adConfig = adConfig || null;
                console.log('📺 AdSequencer initialized with config:', this.adConfig);
            }
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ CANVAS ENHANCEMENT CONFIGURATION
          ║ Feature flags and settings for texture, theme, and visual enhancement system
          ╚═══════════════════════════════════════════════════════════════════════════*/
        const CANVAS_CONFIG = {
            // Basic canvas rendering settings
            width: 800,
            height: 500,
            resolution: Math.min(window.devicePixelRatio || 1, 2),
            antialias: true,
            transparent: false,
            powerPreference: 'high-performance',
            backgroundColor: 0x87CEEB,  // Sky blue
            
            // Feature flags
            enabled: true,                    // Master switch for canvas enhancements
            useTextures: true,               // Enable texture system for shapes
            useThemes: true,                 // Enable theme switching
            useParticles: true,              // Enable particle effects
            useAnimations: true,             // Enable shape animations
            useBackgroundTextures: true,     // Enable background textures
            usePlatformTextures: true,       // Enable platform textures
            
            // Performance settings
            maxParticles: 50,                // Maximum particles on screen
            textureQuality: 'high',          // 'low', 'medium', 'high'
            enableLOD: true,                 // Level of detail for small shapes
            cacheTextures: true,             // Cache rendered textures
            
            // Default theme and fallback behavior
            defaultTheme: 'classic',
            fallbackToSolid: true,           // Use solid colors if textures fail
            showLoadingProgress: true,       // Show loading indicators
            
            // Debug options
            debugMode: false,                // Show texture loading info
            showBounds: false,               // Show texture boundaries
            logAssetLoading: true            // Console logging for asset loading
        };

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ UNIFIED CONFIGURATION SYSTEM
          ║ Centralized configuration management for improved code quality
          ║ Single source of truth for all magic numbers and settings
          ║
          ║ ARCHITECTURE:
          ║ • CANVAS_CONFIG: Canvas enhancement features and rendering settings
          ║ • UNIFIED_GAME_CONFIG: Core game configuration (shapes, timers, performance)
          ║
          ║ BENEFITS:
          ║ • Eliminates hard-coded magic numbers throughout the codebase
          ║ • Provides single source of truth for configuration values
          ║ • Maintains backwards compatibility with existing code
          ║ • Enables easy configuration management and testing
          ╚═══════════════════════════════════════════════════════════════════════════*/
        
        // Unified game configuration - single source of truth
        const UNIFIED_GAME_CONFIG = {
            // Core renderer settings
            renderer: {
                engine: 'canvas',
                fallbackEnabled: false, // No fallback needed - Canvas only
                ...CANVAS_CONFIG
            },
            
            // Performance settings
            performance: {
                targetFPS: 60,
                scaleMultiplier: 1.9,
                enableAntialiasing: true,
                enableTransparency: true,
                backgroundAlpha: 0
            },
            
            // Shape and dock configuration
            shapes: {
                dockPreviewSize: 90,
                defaultStrokeWidth: 2,
                defaultFillAlpha: 0.8,
                minShapeSize: 20,
                maxShapeSize: 200
            },
            
            // Timer and level configuration
            timer: {
                defaultStartValue: 60,
                endLevelCountdown: 5,
                min: 0,
                max: 3600
            },
            
            // Theme and visual settings
            theme: {
                enabled: true,
                defaultTheme: 'classic',
                transitions: true,
                colors: {
                    primary: 0xFF6B6B,
                    secondary: 0x4ECDC4,
                    background: 0x87CEEB
                }
            },
            
            // Animation settings
            animations: {
                enabled: true,
                quality: 'high',
                easing: 'default',
                reduceMotion: false
            },
            
            // Debug options
            debug: {
                enabled: false,
                showFPS: false,
                logPerformance: false,
                wireframe: false
            }
        };

        /*╔═══════════════════════════════════════════════════════════════════════════
         ║ UNIFIED TEXTURE AND THEME SYSTEM
         ║ Single source of truth for all texture operations
         ║ Consolidates 4 different texture checking implementations:
         ║ • isTextureAvailable() [legacy function]
         ║ • AssetManager.isTextureLoaded() 
         ║ • PhysicsShapeRenderer.hasTexture()
         ║ • window.assetManager.isTextureLoaded()
         ╚═══════════════════════════════════════════════════════════════════════════*/
        class UnifiedTextureSystem {
            /**
             * Master texture availability checker
             * Replaces all scattered texture checking implementations
             */
            static isTextureAvailable(shapeType) {
                if (!window.assetManager) {
                    console.warn('UnifiedTextureSystem: AssetManager not available');
                    return false;
                }
                
                try {
                    const currentTheme = window.assetManager.currentTheme || 'classic';
                    
                    // Get the theme configuration to check if it uses textures
                    const themeConfig = THEME_DEFINITIONS[currentTheme];
                    if (!themeConfig || !themeConfig.shapes || !themeConfig.shapes.useTextures) {
                        return false; // Theme doesn't use textures, use colors instead
                    }
                    
                    // For textured themes, check if texture exists and is loaded
                    const texture = window.assetManager.getShapeTexture(shapeType);
                    return texture !== null && texture !== undefined;
                } catch (error) {
                    console.warn(`UnifiedTextureSystem: Texture check failed for ${shapeType}:`, error);
                    return false;
                }
            }
            
            /**
             * Master texture retrieval method
             * Returns texture if available, null otherwise
             */
            static getShapeTexture(shapeType) {
                if (!this.isTextureAvailable(shapeType)) {
                    return null;
                }
                
                try {
                    return window.assetManager.getShapeTexture(shapeType);
                } catch (error) {
                    console.warn(`UnifiedTextureSystem: Texture retrieval failed for ${shapeType}:`, error);
                    return null;
                }
            }
            
            /**
             * Check if a theme uses textures for shapes
             */
            static themeUsesTextures(themeName = null) {
                const currentTheme = themeName || window.assetManager?.currentTheme || 'classic';
                const themeConfig = THEME_DEFINITIONS[currentTheme];
                return !!(themeConfig?.shapes?.useTextures);
            }
            
            /**
             * Get texture configuration for a shape in current theme
             */
            static getTextureConfig(shapeType) {
                if (!this.isTextureAvailable(shapeType)) {
                    return null;
                }
                
                const currentTheme = window.assetManager.currentTheme || 'classic';
                const themeConfig = THEME_DEFINITIONS[currentTheme];
                
                return {
                    repeat: themeConfig.shapes?.textureRepeat || 'repeat',
                    blend: themeConfig.shapes?.textureBlend || 'multiply', 
                    opacity: themeConfig.shapes?.textureOpacity || 0.7
                };
            }
            
            /**
             * Unified theme application method
             * Consolidates theme switching logic
             */
            static applyTheme(themeName, source = 'unified') {
                return UnifiedThemeController.changeTheme(themeName, { source });
            }
        }

        // Legacy compatibility - gradually replace these calls with UnifiedTextureSystem
        function isTextureAvailable(shapeType) {
            return UnifiedTextureSystem.isTextureAvailable(shapeType);
        }

        // Global access for backward compatibility
        window.UnifiedTextureSystem = UnifiedTextureSystem;

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ THEME DEFINITIONS - VISUAL THEMES FOR THE GAME
          ║ Each theme defines complete visual styling for all game elements
          ╚═══════════════════════════════════════════════════════════════════════════*/
        
        // Base configurations for inheritance and composition
        const BASE_TEXTURE_CONFIG = {
            repeat: "repeat",
            blend: "multiply",
            opacity: 0.7
        };

        const BASE_IMAGE_CONFIG = {
            repeat: "no-repeat",
            position: "center",
            size: "cover"
        };

        // Factory function to create texture configuration
        function createTextureConfig(overrides = {}) {
            return {
                ...BASE_TEXTURE_CONFIG,
                ...overrides
            };
        }

        // Factory function to create image configuration
        function createImageConfig(overrides = {}) {
            return {
                ...BASE_IMAGE_CONFIG,
                ...overrides
            };
        }

        // Base theme configurations for inheritance and composition
        const BASE_THEME_STRUCTURE = {
            background: {
                type: "gradient",
                texture: null,
                image: createImageConfig()
            },
            platform: {
                texture: null,
                pattern: "solid",
                image: createImageConfig({
                    repeat: "repeat",
                    blend: "multiply",
                    opacity: 0.8
                })
            },
            shapes: {
                useTextures: false,
                baseTexturePath: null,
                specialEffects: ["shadow"],
                animations: ["bounce"]
            },
            particles: {
                style: "geometric"
            }
        };

        // Factory function to create theme configuration
        function createThemeConfig(name, description, customConfig = {}) {
            const theme = {
                name,
                description,
                ...BASE_THEME_STRUCTURE,
                ...customConfig
            };

            // Generate consistent shape texture mappings if not provided
            if (!theme.shapes.textures) {
                const shapeNames = ['square', 'circle', 'triangle', 'cross', 'cross2', 'l', 'barbell-one', 'barbell-two', 'diamond-barbell'];
                theme.shapes.textures = {};
                
                shapeNames.forEach(shapeName => {
                    theme.shapes.textures[shapeName] = createTextureConfig({
                        url: customConfig.shapes?.textureUrl || null,
                        opacity: customConfig.shapes?.textureOpacity || 0.7
                    });
                });
            }

            return theme;
        }

        const THEME_DEFINITIONS = {
            classic: createThemeConfig(
                "Classic Puzzle",
                "Clean, geometric shapes with simple colors",
                {
                    background: {
                        type: "gradient",
                        colors: ["#87CEEB", "#4ECDC4", "#90EE90"],
                        texture: null,
                        gradient: {
                            colors: ['#87CEEB', '#98FB98'],
                            direction: '135deg'
                        },
                        opacity: 1.0,
                        image: createImageConfig()
                    },
                    platform: {
                        texture: null,
                        color: "#8B4513",
                        material: "wood",
                        pattern: "solid",
                        image: createImageConfig({
                            repeat: "repeat",
                            blend: "multiply",
                            opacity: 0.8
                        })
                    },
                    particles: {
                        style: "geometric",
                        colors: ["#FFD700", "#FF6B6B", "#4ECDC4"]
                    }
                }
            ),
            
            wood: createThemeConfig(
                "Wood",
                "Natural wood textures and warm earth tones",
                {
                    background: {
                        type: "image",
                        colors: ["#8B4513", "#A0522D", "#CD853F"],
                        texture: "wood_grain",
                        image: {
                            url: "assets/bkg/bkg1.png",
                            size: "cover",
                            position: "center top",
                            repeat: "no-repeat"
                        },
                        opacity: 0.5,
                        fallbackColor: "#8B4513"
                    },
                    platform: {
                        texture: "wood_grain",
                        color: "#8B4513",
                        material: "wood",
                        pattern: "grain",
                        image: createImageConfig({
                            // repeat: "repeat-x",
                            // blend: "multiply",
                            // opacity: 0.8
            		    url: "assets/textures/stone/stone1.png",  // Add this
                            opacity: 0.9,
                            repeat: "repeat"
                        })
                    },
                    shapes: {
                        useTextures: true,
                        baseTexturePath: "textures/wood/",
                        specialEffects: ["grain", "knot"],
                        animations: ["creak", "sway"],
                        textureUrl: "assets/textures/wood/oak.png"
                    },
                    particles: {
                        style: "sawdust",
                        colors: ["#D2B48C", "#DEB887", "#F4A460"]
                    }
                }
            ),
            
            stone: createThemeConfig(
                "Stone",
                "Ancient stone structures with granite and marble textures",
                {
                    background: {
                        type: "pattern",
                        colors: ["#2F4F4F", "#708090", "#778899"],
                        texture: "granite",
                        pattern: {
                            type: "granite",
                            baseColor: "#696969",
                            accentColors: ["#778899", "#708090", "#2F4F4F", "#A9A9A9"],
                            style: "radial-gradient(circle at 20% 30%, rgba(119, 136, 153, 0.8) 0px, rgba(119, 136, 153, 0.6) 3px, transparent 6px), radial-gradient(circle at 60% 70%, rgba(112, 128, 144, 0.7) 0px, rgba(112, 128, 144, 0.4) 2px, transparent 5px), radial-gradient(circle at 40% 20%, rgba(47, 79, 79, 0.9) 0px, rgba(47, 79, 79, 0.5) 2px, transparent 4px), radial-gradient(circle at 80% 40%, rgba(169, 169, 169, 0.6) 0px, rgba(169, 169, 169, 0.3) 1px, transparent 3px), radial-gradient(circle at 10% 80%, rgba(119, 136, 153, 0.5) 0px, transparent 2px), radial-gradient(circle at 90% 10%, rgba(112, 128, 144, 0.4) 0px, transparent 3px), linear-gradient(135deg, #696969 0%, #708090 50%, #778899 100%)"
                        },
                        image: {
                            url: "assets/textures/stone/granite.txt",
                            size: "cover",
                            position: "center",
                            repeat: "no-repeat"
                        },
                        opacity: 0.7,
                        fallbackColor: "#696969"
                    },
                    platform: {
                        texture: null,
                        color: "#696969",
                        material: "granite",
                        pattern: "rough",
                        image: createImageConfig({
                            repeat: "repeat",
                            blend: "hard-light",
                            opacity: 0.9
                        })
                    },
                    shapes: {
                        useTextures: true,
                        baseTexturePath: "textures/stone/",
                        specialEffects: ["dust", "crack"],
                        animations: ["settle", "crumble"],
                        textureOpacity: 0.8,
                        colors: {
                            square: { color: '#696969', stroke: '#555555', strokeWidth: 2 },      // Dark gray granite
                            triangle: { color: '#778899', stroke: '#556B83', strokeWidth: 2 },   // Light slate gray  
                            circle: { color: '#708090', stroke: '#5F6F7F', strokeWidth: 2 },     // Slate gray
                            cross: { color: '#2F4F4F', stroke: '#1F3F3F', strokeWidth: 2 },      // Dark slate gray
                            'cross2': { color: '#696969', stroke: '#555555', strokeWidth: 2 },   // Granite gray
                            'l': { color: '#A9A9A9', stroke: '#8A8A8A', strokeWidth: 2 },        // Light gray stone
                            'barbell-one': { color: '#778899', stroke: '#556B83', strokeWidth: 2 }, // Slate
                            'barbell-two': { color: '#708090', stroke: '#5F6F7F', strokeWidth: 2 }, // Blue-gray stone
                            'diamond-barbell': { color: '#2F4F4F', stroke: '#1F3F3F', strokeWidth: 2 } // Dark slate
                        }
                    },
                    particles: {
                        style: "dust",
                        colors: ["#A9A9A9", "#D3D3D3", "#C0C0C0"]
                    }
                }
            ),
            
            metal: createThemeConfig(
                "Metal",
                "Industrial metal structures with steel and iron textures",
                {
                    background: {
                        type: "pattern",
                        colors: ["#1e3a4f", "#2d5a7b", "#4682b4", "#5a7aa6"],  // Deep blue steel gradient
                        texture: "brushed-steel",
                        pattern: {
                            type: "brushed-metal",
                            baseColor: "#4A4A4A",
                            accentColors: ["#4682B4", "#1e3a4f", "#2d5a7b", "#87CEEB"],
                            style: "repeating-linear-gradient(90deg, transparent, transparent 1px, rgba(135, 206, 235, 0.1) 1px, rgba(135, 206, 235, 0.1) 2px), repeating-linear-gradient(0deg, transparent, transparent 1px, rgba(70, 130, 180, 0.05) 1px, rgba(70, 130, 180, 0.05) 3px), linear-gradient(45deg, #1e3a4f 0%, #4682B4 25%, #2d5a7b 50%, #5a7aa6 75%, #4682B4 100%)"
                        },
                        image: {
                            url: "assets/textures/metal/steel.txt",
                            size: "cover",
                            position: "center",
                            repeat: "no-repeat"
                        },
                        opacity: 0.4,
                        fallbackColor: "#4A4A4A"
                    },
                    platform: {
                        texture: null,
                        color: "#4682B4",  // Steel blue instead of gray
                        material: "steel",
                        pattern: "brushed",
                        image: createImageConfig({
                            repeat: "repeat",
                            blend: "hard-light",
                            opacity: 0.9
                        })
                    },
                    shapes: {
                        useTextures: true,
                        baseTexturePath: "textures/metal/",
                        specialEffects: ["spark", "gleam"],
                        animations: ["clang", "shine"],
                        textureOpacity: 0.9,
                        colors: {
                            square: { color: '#4169E1', stroke: '#1E3A8A', strokeWidth: 2 },      // Royal blue steel
                            triangle: { color: '#4682B4', stroke: '#2F4F7F', strokeWidth: 2 },   // Steel blue
                            circle: { color: '#6495ED', stroke: '#4169E1', strokeWidth: 2 },     // Cornflower blue
                            cross: { color: '#1E3A8A', stroke: '#1B1F3A', strokeWidth: 2 },      // Dark blue steel
                            'cross2': { color: '#5F8DCE', stroke: '#3A5B94', strokeWidth: 2 },   // Medium blue steel
                            'l': { color: '#87CEEB', stroke: '#5F8DCE', strokeWidth: 2 },        // Sky blue steel
                            'barbell-one': { color: '#4169E1', stroke: '#1E3A8A', strokeWidth: 2 }, // Royal blue
                            'barbell-two': { color: '#4682B4', stroke: '#2F4F7F', strokeWidth: 2 }, // Steel blue
                            'diamond-barbell': { color: '#1E3A8A', stroke: '#0F1F45', strokeWidth: 2 } // Deep blue steel
                        }
                    },
                    particles: {
                        style: "sparks",
                        colors: ["#87CEEB", "#4682B4", "#1E90FF", "#4169E1"]  // Blue spark colors
                    }
                }
            )
        };

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ MASTER SHAPE REGISTRY - UNIFIED SHAPE ATTRIBUTE SYSTEM
          ║ Single source of truth for ALL shape properties across all rendering contexts
          ║ Eliminates inconsistencies between dock, canvas, and physics representations
          ╚═══════════════════════════════════════════════════════════════════════════*/

        // Master shape registry with complete attribute definitions
        const MASTER_SHAPE_REGISTRY = {
            square: {
                geometry: {
                    type: 'rectangle',
                    width: 35,
                    height: 35,
                    borderRadius: 3
                },
                physics: {
                    density: 0.5,
                    friction: 0.7,
                    restitution: 0.2
                },
                visual: {
                    color: '#F39C12',
                    stroke: '#E67E22',
                    strokeWidth: 2
                }
            },

            triangle: {
                geometry: {
                    type: 'polygon',
                    vertices: [
                        { x: 0, y: -15 },
                        { x: -17.5, y: 15 },
                        { x: 17.5, y: 15 }
                    ]
                },
                physics: {
                    density: 0.5,
                    friction: 0.7,
                    restitution: 0.2
                },
                visual: {
                    color: '#9B59B6',
                    stroke: '#8E44AD',
                    strokeWidth: 2
                }
            },

            circle: {
                geometry: {
                    type: 'circle',
                    radius: 17.5
                },
                physics: {
                    density: 0.5,
                    friction: 0.7,
                    restitution: 0.2
                },
                visual: {
                    color: '#1ABC9C',
                    stroke: '#16A085',
                    strokeWidth: 2
                }
            },

            cross: {
                geometry: {
                    type: 'compound',
                    parts: [
                        {
                            type: 'rectangle',
                            width: 15,
                            height: 35,
                            offsetX: 0,
                            offsetY: 0
                        },
                        {
                            type: 'rectangle',
                            width: 35,
                            height: 15,
                            offsetX: 0,
                            offsetY: 0
                        }
                    ]
                },
                physics: {
                    density: 0.5,
                    friction: 0.7,
                    restitution: 0.2
                },
                visual: {
                    color: '#E74C3C',
                    stroke: '#C0392B',
                    strokeWidth: 2
                }
            },

            cross2: {
                geometry: {
                    type: 'compound',
                    parts: [
                        {
                            type: 'rectangle',
                            width: 15,
                            height: 35,
                            offsetX: 0,
                            offsetY: 0
                        },
                        {
                            type: 'rectangle',
                            width: 35,
                            height: 15,
                            offsetX: 0,
                            offsetY: 0
                        }
                    ]
                },
                physics: {
                    density: 0.5,
                    friction: 0.7,
                    restitution: 0.2
                },
                visual: {
                    color: '#3498DB',
                    stroke: '#2980B9',
                    strokeWidth: 2
                }
            },

            l: {
                geometry: {
                    type: 'compound',
                    parts: [
                        {
                            type: 'rectangle',
                            width: 15,
                            height: 35,
                            offsetX: -7.5,
                            offsetY: 0
                        },
                        {
                            type: 'rectangle',
                            width: 15,
                            height: 15,
                            offsetX: 7.5,
                            offsetY: 10
                        }
                    ]
                },
                physics: {
                    density: 0.5,
                    friction: 0.7,
                    restitution: 0.2
                },
                visual: {
                    color: '#8E44AD',
                    stroke: '#732D91',
                    strokeWidth: 2
                }
            },

            'barbell-one': {
                geometry: {
                    type: 'compound',
                    parts: [
                        {
                            type: 'rectangle',
                            width: 31,
                            height: 5,
                            offsetX: -12,
                            offsetY: 0
                        },
                        {
                            type: 'circle',
                            radius: 8,
                            offsetX: 12,
                            offsetY: 0
                        }
                    ]
                },
                physics: {
                    density: 0.5,
                    friction: 0.7,
                    restitution: 0.2
                },
                visual: {
                    color: '#16A085',
                    stroke: '#138D75',
                    strokeWidth: 2
                }
            },

            'barbell-two': {
                geometry: {
                    type: 'compound',
                    parts: [
                        {
                            type: 'rectangle',
                            width: 26,
                            height: 5,
                            offsetX: 0,
                            offsetY: 0
                        },
                        {
                            type: 'circle',
                            radius: 9,
                            offsetX: -17,
                            offsetY: 0
                        },
                        {
                            type: 'circle',
                            radius: 9,
                            offsetX: 17,
                            offsetY: 0
                        }
                    ]
                },
                physics: {
                    density: 0.5,
                    friction: 0.7,
                    restitution: 0.2
                },
                visual: {
                    color: '#D35400',
                    stroke: '#BA4A00',
                    strokeWidth: 2
                }
            },

            'diamond-barbell': {
                geometry: {
                    type: 'compound',
                    parts: [
                        {
                            type: 'rectangle',
                            width: 26,
                            height: 5,
                            offsetX: -10,
                            offsetY: 0
                        },
                        {
                            type: 'diamond',
                            width: 20,
                            height: 20,
                            offsetX: 10,
                            offsetY: 0
                        }
                    ]
                },
                physics: {
                    density: 0.5,
                    friction: 0.7,
                    restitution: 0.2
                },
                visual: {
                    color: '#C0392B',
                    stroke: '#A93226',
                    strokeWidth: 2
                }
            }
        };

        // Simple system test - verify MASTER_SHAPE_REGISTRY is accessible
        debugLog('🔍 MASTER_SHAPE_REGISTRY loaded with shapes:', Object.keys(MASTER_SHAPE_REGISTRY));

        // Shape Attribute Propagator - converts master registry to format-specific configs
        class ShapeAttributePropagator {
            // Generate legacy SHAPE_CONFIG format for backward compatibility
            static generateLegacyConfig() {
                const legacyConfig = {};
                
                for (const [shapeType, masterConfig] of Object.entries(MASTER_SHAPE_REGISTRY)) {
                    legacyConfig[shapeType] = {
                        // Merge all properties for backward compatibility
                        ...masterConfig.geometry,
                        ...masterConfig.physics,
                        ...masterConfig.visual,
                        type: masterConfig.geometry.type
                    };

                    // Handle compound shapes
                    if (masterConfig.geometry.type === 'compound' && masterConfig.geometry.parts) {
                        legacyConfig[shapeType].parts = masterConfig.geometry.parts;
                    }
                }
                
                return legacyConfig;
            }

            // Get unified shape attributes for any context
            static getShapeAttributes(shapeType) {
                const master = MASTER_SHAPE_REGISTRY[shapeType];
                if (!master) {
                    console.warn(`⚠️ Shape type '${shapeType}' not found in master registry`);
                    return null;
                }
                return master;
            }

            // Get geometry-specific attributes
            static getGeometry(shapeType) {
                const attributes = this.getShapeAttributes(shapeType);
                return attributes ? attributes.geometry : null;
            }

            // Get physics-specific attributes
            static getPhysics(shapeType) {
                const attributes = this.getShapeAttributes(shapeType);
                return attributes ? attributes.physics : null;
            }

            // Get visual-specific attributes
            static getVisual(shapeType) {
                const attributes = this.getShapeAttributes(shapeType);
                return attributes ? attributes.visual : null;
            }

            // Validate shape registry integrity
            static validateRegistry() {
                const errors = [];
                
                for (const [shapeType, config] of Object.entries(MASTER_SHAPE_REGISTRY)) {
                    if (!config.geometry || !config.physics || !config.visual) {
                        errors.push(`${shapeType}: Missing required sections (geometry/physics/visual)`);
                    }
                    
                    if (!config.geometry.type) {
                        errors.push(`${shapeType}: Missing geometry.type`);
                    }
                    
                    if (config.geometry.type === 'compound' && !config.geometry.parts) {
                        errors.push(`${shapeType}: Compound shape missing parts array`);
                    }
                }
                
                if (errors.length > 0) {
                    console.error('🚨 Shape registry validation errors:', errors);
                } else {
                    debugLog('✅ Shape registry validation passed');
                }
                
                return errors.length === 0;
            }
        }

        // Generate backward-compatible SHAPE_CONFIG from master registry
        const SHAPE_CONFIG = ShapeAttributePropagator.generateLegacyConfig();

        // Validate the registry on initialization
        ShapeAttributePropagator.validateRegistry();

        // Utility functions for shape configuration
        function getShapeConfig(shapeType) {
            // Start with MASTER_SHAPE_REGISTRY as base - use visual properties flattened
            const masterConfig = MASTER_SHAPE_REGISTRY[shapeType];
            const baseConfig = masterConfig ? {
                ...masterConfig.geometry,
                ...masterConfig.physics,
                ...masterConfig.visual  // Flatten visual properties to root level for compatibility
            } : {};
            
            // Add legacy SHAPE_CONFIG overrides if they exist
            if (SHAPE_CONFIG[shapeType]) {
                Object.assign(baseConfig, SHAPE_CONFIG[shapeType]);
            }
            
            // Use AssetManager for theme-specific overrides if available
            if (window.assetManager) {
                const currentTheme = window.assetManager.getCurrentTheme();
                
                // Check for theme color overrides in the new structure
                if (currentTheme?.config?.shapes?.colors?.[shapeType]) {
                    const themeColors = currentTheme.config.shapes.colors[shapeType];
                    Object.assign(baseConfig, {
                        color: themeColors.color || baseConfig.color,
                        stroke: themeColors.stroke || baseConfig.stroke,
                        strokeWidth: themeColors.strokeWidth || baseConfig.strokeWidth
                    });
                }
                
                // Legacy theme overrides support
                if (currentTheme?.config?.shapes?.overrides?.[shapeType]) {
                    const themeOverride = currentTheme.config.shapes.overrides[shapeType];
                    Object.assign(baseConfig, {
                        color: themeOverride.color || baseConfig.color,
                        stroke: themeOverride.stroke || baseConfig.stroke
                    });
                }
                
                // Check for texture through AssetManager
                const texture = UnifiedTextureSystem.getShapeTexture(shapeType);
                if (texture) {
                    baseConfig.texture = texture;
                }
            }
            
            return baseConfig;
        }

        function getAllShapeTypes() {
            return Object.keys(MASTER_SHAPE_REGISTRY);
        }

        function validateShapeConfig() {
            // Validation logic can be added here
            return true;
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ ASSET MANAGER - HANDLES TEXTURE LOADING AND THEME ASSETS
          ║ Provides centralized asset management with fallbacks and caching
          ╚═══════════════════════════════════════════════════════════════════════════*/
        class AssetManager {
            constructor() {
                this.themes = {};
                this.currentTheme = CANVAS_CONFIG.defaultTheme;
                this.loadingProgress = 0;
                this.isLoaded = false;
                this.loadingCallbacks = [];
                this.imageCache = new Map(); // Cache for loaded images
                this.loadingPromises = new Map(); // Track loading promises
                this.backgroundImageCache = new Map(); // New cache for background images
            }

            async loadTheme(themeName) {
                raceConditionDebugger.trackOperation('AssetManager.loadTheme', `theme-${themeName}`);
                
                // Check if theme is already fully loaded
                if (this.themes[themeName]?.loaded && this.currentTheme === themeName) {
                    debugLog(`✅ Theme ${themeName} already loaded and active, skipping`);
                    return;
                }
                
                // Add deduplication check
                const loadingKey = `theme-${themeName}`;
                
                // Check if this theme is already being loaded
                if (this.loadingPromises.has(loadingKey)) {
                    debugLog(`⚠️ Theme ${themeName} already loading, returning existing promise`);
                    return this.loadingPromises.get(loadingKey);
                }
                
                // Track asset loading for race condition monitoring
                raceConditionMonitor.trackAccess('asset-system', 'loadTheme', 'write', {
                    themeName,
                    currentTheme: this.currentTheme
                });
                
                // Create and store the loading promise
                const loadPromise = assetMutex.execute(async () => {
                    if (!CANVAS_CONFIG.enabled || !CANVAS_CONFIG.useThemes) {
                        assetLog('📦 Asset Manager: Canvas enhancements disabled');
                        return;
                    }

                    assetLog(`📦 Loading theme: ${themeName}`);
                    
                    try {
                        const themeConfig = THEME_DEFINITIONS[themeName];
                        if (!themeConfig) {
                            console.error(`❌ Theme not found: ${themeName}`);
                            return;
                        }

                        // Initialize theme structure
                        this.themes[themeName] = {
                            config: themeConfig,
                            assets: {
                                backgroundImage: null,
                                platformImage: null,
                                shapeTextures: {}
                            },
                            loaded: false
                        };

                        // Load all images for this theme
                        await this.loadThemeImages(themeName, themeConfig);
                        
                        // Load background image if specified
                        if (themeConfig.background?.type === 'image' && themeConfig.background.image?.url) {
                            try {
                                const bgImage = await this.loadBackgroundImage(themeConfig.background.image.url);
                                this.themes[themeName].assets.backgroundImage = bgImage;
                                console.log(`✅ Background image loaded for theme: ${themeName}`);
                            } catch (error) {
                                console.warn(`⚠️ Failed to load background image for ${themeName}:`, error);
                                // Mark background as failed but continue with theme loading
                                if (!themeConfig.background) themeConfig.background = {};
                                themeConfig.background.loadFailed = true;
                            }
                        }
                        
                        this.themes[themeName].loaded = true;
                        this.currentTheme = themeName;  // Set this theme as current
                        this.loadingProgress = 100;
                        this.isLoaded = true;
                        
                        // Apply the background to CSS immediately
                        this.applyBackgroundToCSS({ name: themeName, ...themeConfig });
                        
                        assetLog(`✅ Theme loaded: ${themeName}`);
                        debugLog(`🎯 AssetManager current theme set to: ${this.currentTheme}`);
                        this.notifyLoadingComplete(themeName);
                        
                    } catch (error) {
                        console.error(`❌ Failed to load theme ${themeName}:`, error);
                        this.loadingProgress = 0;
                    }
                    
                }, `asset-load-theme-${themeName}`);
                
                this.loadingPromises.set(loadingKey, loadPromise);
                
                try {
                    const result = await loadPromise;
                    return result;
                } finally {
                    // Clean up after loading completes
                    this.loadingPromises.delete(loadingKey);
                }
            }

            async loadThemeImages(themeName, themeConfig) {
                const loadPromises = [];
                const theme = this.themes[themeName];

                // Load background image
                if (themeConfig.background.image && themeConfig.background.image.url) {
                    const bgPromise = this.loadImage(themeConfig.background.image.url)
                        .then(img => {
                            theme.assets.backgroundImage = img;
                            debugLog(`🖼️ Background image loaded for ${themeName}`);
                        })
                        .catch(err => {
                            console.warn(`⚠️ Background image failed for ${themeName}:`, err.message);
                        });
                    loadPromises.push(bgPromise);
                }

                // Load platform image
                if (themeConfig.platform.image && themeConfig.platform.image.url) {
                    const platformPromise = this.loadImage(themeConfig.platform.image.url)
                        .then(img => {
                            theme.assets.platformImage = img;
                            debugLog(`🏗️ Platform image loaded for ${themeName}`);
                        })
                        .catch(err => {
                            console.warn(`⚠️ Platform image failed for ${themeName}:`, err.message);
                        });
                    loadPromises.push(platformPromise);
                }

                // Load shape textures
                if (themeConfig.shapes.textures) {
                    Object.keys(themeConfig.shapes.textures).forEach(shapeType => {
                        const textureConfig = themeConfig.shapes.textures[shapeType];
                        if (textureConfig.url) {
                            const shapePromise = this.loadImage(textureConfig.url)
                                .then(img => {
                                    theme.assets.shapeTextures[shapeType] = img;
                                    debugLog(`🔶 Shape texture loaded for ${shapeType} in ${themeName}`);
                                })
                                .catch(err => {
                                    console.warn(`⚠️ Shape texture failed for ${shapeType} in ${themeName}:`, err.message);
                                });
                            loadPromises.push(shapePromise);
                        }
                    });
                } else if (themeConfig.shapes.useTextures && themeConfig.shapes.textureUrl) {
                    // Handle themes that use a single shared texture for all shapes
                    const sharedTextureUrl = themeConfig.shapes.textureUrl;
                    const shapeNames = ['square', 'circle', 'triangle', 'cross', 'cross2', 'l', 'barbell-one', 'barbell-two', 'diamond-barbell'];
                    
                    const sharedPromise = this.loadImage(sharedTextureUrl)
                        .then(img => {
                            // Apply the same texture to all shapes
                            shapeNames.forEach(shapeType => {
                                theme.assets.shapeTextures[shapeType] = img;
                            });
                            debugLog(`🔶 Shared texture loaded for all shapes in ${themeName} from ${sharedTextureUrl}`);
                        })
                        .catch(err => {
                            console.warn(`⚠️ Shared texture failed for ${themeName}:`, err.message);
                        });
                    loadPromises.push(sharedPromise);
                }

                // Wait for all images to load (or fail)
                await Promise.allSettled(loadPromises);
                
                const successCount = loadPromises.length;
                assetLog(`📦 Theme ${themeName}: Attempted to load ${successCount} images`);
            }

            async loadImage(url) {
                // Check cache first
                if (this.imageCache.has(url)) {
                    return this.imageCache.get(url);
                }

                // Check if already loading
                if (this.loadingPromises.has(url)) {
                    return this.loadingPromises.get(url);
                }

                // Create loading promise
                const loadPromise = new Promise((resolve, reject) => {
                    const img = new Image();
                    img.crossOrigin = 'anonymous'; // Enable CORS for external images
                    
                    img.onload = () => {
                        this.imageCache.set(url, img);
                        this.loadingPromises.delete(url);
                        resolve(img);
                    };
                    
                    img.onerror = () => {
                        this.loadingPromises.delete(url);
                        reject(new Error(`Failed to load image: ${url}`));
                    };
                    
                    img.src = url;
                    
                    // Set timeout for image loading
                    setTimeout(() => {
                        if (!img.complete) {
                            this.loadingPromises.delete(url);
                            reject(new Error(`Image load timeout: ${url}`));
                        }
                    }, 10000); // 10 second timeout
                });

                this.loadingPromises.set(url, loadPromise);
                return loadPromise;
            }

            // Get loaded image assets
            getBackgroundImage(themeName = null) {
                const theme = themeName ? this.getTheme(themeName) : this.getCurrentTheme();
                return theme?.assets?.backgroundImage || null;
            }

            getPlatformImage(themeName = null) {
                const theme = themeName ? this.getTheme(themeName) : this.getCurrentTheme();
                return theme?.assets?.platformImage || null;
            }

            getShapeTexture(shapeType, themeName = null) {
                const currentTheme = themeName || this.currentTheme || 'classic';
                const themeData = this.themes[currentTheme];
                
                // Check if theme exists and has assets
                if (!themeData || !themeData.assets) {
                    return null;
                }
                
                // Check for loaded texture assets first (preferred)
                if (themeData.assets.shapeTextures && themeData.assets.shapeTextures.hasOwnProperty(shapeType)) {
                    return themeData.assets.shapeTextures[shapeType];
                }
                
                // Fallback to legacy textures structure if it exists
                if (themeData.textures && themeData.textures.hasOwnProperty(shapeType)) {
                    return themeData.textures[shapeType];
                }
                
                return null;
            }

            // Clear cache (useful for development)
            clearImageCache() {
                this.imageCache.clear();
                this.loadingPromises.clear();
                console.log('🧹 Image cache cleared');
            }
            
            clearThemeImages(themeName) {
                console.log(`🧹 ImageAssetManager: Clearing images for theme: ${themeName}`);
                
                // Get theme configuration
                const themeConfig = THEME_DEFINITIONS[themeName];
                if (!themeConfig) return;
                
                const themeUrls = new Set();
                
                // Add background image URL
                if (themeConfig.background?.image?.url) {
                    themeUrls.add(themeConfig.background.image.url);
                }
                
                // Add platform image URL
                if (themeConfig.platform?.image?.url) {
                    themeUrls.add(themeConfig.platform.image.url);
                }
                
                // Add shape texture URLs
                if (themeConfig.shapes?.textures) {
                    Object.values(themeConfig.shapes.textures).forEach(textureData => {
                        if (textureData?.url) {
                            themeUrls.add(textureData.url);
                        }
                    });
                }
                
                // Remove theme images from cache
                let removedCount = 0;
                for (const url of themeUrls) {
                    if (this.imageCache.has(url)) {
                        this.imageCache.delete(url);
                        removedCount++;
                    }
                    if (this.loadingPromises.has(url)) {
                        this.loadingPromises.delete(url);
                    }
                }
                
                // Clear the theme data as well
                if (this.themes[themeName]) {
                    delete this.themes[themeName];
                }
                
                console.log(`🧹 ImageAssetManager: Removed ${removedCount} images for theme: ${themeName}`);
            }

            getTheme(themeName) {
                return this.themes[themeName] || null;
            }

            getCurrentTheme() {
                // Only log when theme actually changes to avoid spam
                if (!this._lastLoggedCurrentTheme || this._lastLoggedCurrentTheme !== this.currentTheme) {
                    debugLog(`🔍 AssetManager.getCurrentTheme() - this.currentTheme: '${this.currentTheme}'`);
                    const theme = this.getTheme(this.currentTheme);
                    debugLog(`🔍 AssetManager.getCurrentTheme() - found theme:`, theme?.config?.name || 'null');
                    debugLog(`🔍 Available themes:`, Object.keys(this.themes));
                    this._lastLoggedCurrentTheme = this.currentTheme;
                    return theme;
                }
                return this.getTheme(this.currentTheme);
            }

            getBackgroundStyle(themeName = null) {
                const theme = themeName ? this.getTheme(themeName) : this.getCurrentTheme();
                if (!theme) return null;
                
                const bgConfig = theme.config.background;
                const bgImage = this.getBackgroundImage(themeName);
                
                return {
                    type: bgConfig.type,
                    colors: bgConfig.colors,
                    image: bgImage,
                    imageConfig: bgConfig.image || null
                };
            }

            getPlatformStyle(themeName = null) {
                const theme = themeName ? this.getTheme(themeName) : this.getCurrentTheme();
                if (!theme) return null;
                
                const platformConfig = theme.config.platform;
                const platformImage = this.getPlatformImage(themeName);
                
                return {
                    ...platformConfig,
                    image: platformImage,
                    imageConfig: platformConfig.image || null
                };
            }

            getShapeStyle(shapeType, themeName = null) {
                const theme = themeName ? this.getTheme(themeName) : this.getCurrentTheme();
                if (!theme) return null;
                
                const shapeConfig = theme.config.shapes;
                const shapeTexture = this.getShapeTexture(shapeType, themeName);
                
                if (shapeConfig.textures && shapeConfig.textures[shapeType]) {
                    return {
                        useTextures: shapeConfig.useTextures,
                        texture: shapeTexture,
                        textureConfig: shapeConfig.textures[shapeType]
                    };
                }
                
                return {
                    useTextures: false,
                    texture: null,
                    textureConfig: null
                };
            }

            getParticleStyle(themeName = null) {
                const theme = themeName ? this.getTheme(themeName) : this.getCurrentTheme();
                if (!theme) return null;
                
                return theme.config.particles;
            }

            notifyLoadingComplete(themeName) {
                this.loadingCallbacks.forEach(callback => {
                    try {
                        callback(themeName);
                    } catch (error) {
                        console.error('❌ Error in loading callback:', error);
                    }
                });
            }

            onThemeLoaded(callback) {
                this.loadingCallbacks.push(callback);
            }

            getTextureUrl(shapeType) {
                const theme = this.getCurrentTheme();
                if (!theme) return null;
                
                const themeConfig = theme.config;
                if (themeConfig && themeConfig.shapes && themeConfig.shapes.textures) {
                    const textureConfig = themeConfig.shapes.textures[shapeType];
                    if (textureConfig && textureConfig.url) {
                        return textureConfig.url;
                    }
                }
                return null;
            }

            // Texture cache getter for compatibility
            get textureCache() {
                return this.imageCache;
            }

            // Method to apply texture themes (compatibility)
            async applyTextureTheme(themeName) {
                debugLog(`🎨 Applying texture theme: ${themeName}`);
                // Check if theme is already loaded before loading
                if (!this.themes[themeName]?.loaded) {
                    await this.loadTheme(themeName);
                }
                return true;
            }

            // Property for loaded textures compatibility
            get loadedTextures() {
                return this.imageCache;
            }

            /*╔═══════════════════════════════════════════════════════════════════════════
              ║ BACKGROUND IMAGE MANAGEMENT METHODS
              ║ Handles CSS background image loading and application
              ╚═══════════════════════════════════════════════════════════════════════════*/
            
            async loadBackgroundImage(url) {
                if (this.backgroundImageCache.has(url)) {
                    return this.backgroundImageCache.get(url);
                }

                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.onload = () => {
                        this.backgroundImageCache.set(url, img);
                        console.log(`🖼️ Background image loaded: ${url}`);
                        resolve(img);
                    };
                    img.onerror = () => {
                        console.error(`❌ Failed to load background image: ${url}`);
                        reject(new Error(`Failed to load background image: ${url}`));
                    };
                    img.src = url;
                });
            }

            applyBackgroundToCSS(theme) {
                const viewport = document.querySelector('.game-viewport');
                if (!viewport) return;

                const backgroundConfig = theme.background;
                
                // Clear previous pattern classes
                viewport.classList.remove('stone-pattern', 'metal-pattern', 'theme-background');
                
                if (backgroundConfig?.type === 'image' && backgroundConfig.image?.url) {
                    // Apply image background
                    const imageConfig = backgroundConfig.image;
                    
                    // Set CSS custom properties
                    viewport.style.setProperty('--background-image', `url(${imageConfig.url})`);
                    viewport.style.setProperty('--background-opacity', backgroundConfig.opacity || 0.5);
                    
                    // Add theme background class
                    viewport.classList.add('theme-background');
                    
                    console.log(`🎨 Applied background image for theme: ${theme.name}`);
                } else if (backgroundConfig?.type === 'pattern' && backgroundConfig.pattern?.type) {
                    // Apply pattern background using CSS classes
                    const patternType = backgroundConfig.pattern.type;
                    
                    console.log(`🔍 Pattern debug - Type: ${patternType}, Theme: ${theme.name}`);
                    console.log(`🔍 Pattern config:`, backgroundConfig.pattern);
                    
                    if (patternType === 'granite') {
                        viewport.classList.add('stone-pattern');
                        console.log(`🎨 Applied granite pattern for theme: ${theme.name} - Class added: stone-pattern`);
                        console.log(`🔍 Viewport classes:`, viewport.className);
                    } else if (patternType === 'brushed-metal') {
                        viewport.classList.add('metal-pattern');
                        console.log(`🎨 Applied brushed metal pattern for theme: ${theme.name}`);
                    } else {
                        // Fallback to custom pattern style
                        viewport.style.setProperty('--background-image', backgroundConfig.pattern.style);
                        viewport.classList.add('theme-background');
                        console.log(`🎨 Applied custom ${patternType} pattern for theme: ${theme.name}`);
                    }
                    
                    // Set opacity
                    viewport.style.setProperty('--background-opacity', backgroundConfig.opacity || 0.6);
                    console.log(`🔍 Background opacity set to:`, backgroundConfig.opacity || 0.6);
                } else if (backgroundConfig?.type === 'gradient') {
                    // Apply gradient background
                    const gradientConfig = backgroundConfig.gradient;
                    if (gradientConfig) {
                        const gradientCSS = `linear-gradient(${gradientConfig.direction}, ${gradientConfig.colors.join(', ')})`;
                        
                        viewport.style.setProperty('--background-image', gradientCSS);
                        viewport.style.setProperty('--background-opacity', backgroundConfig.opacity || 1.0);
                        viewport.classList.add('theme-background');
                        
                        console.log(`🎨 Applied gradient background for theme: ${theme.name}`);
                    }
                } else {
                    // Fallback or clear background
                    this.clearBackgroundCSS();
                    
                    // Apply fallback color if specified
                    if (backgroundConfig?.fallbackColor) {
                        viewport.style.backgroundColor = backgroundConfig.fallbackColor;
                    }
                }
            }

            clearBackgroundCSS() {
                const viewport = document.querySelector('.game-viewport');
                if (!viewport) return;

                viewport.style.removeProperty('--background-image');
                viewport.style.removeProperty('--background-opacity');
                viewport.classList.remove('theme-background', 'stone-pattern', 'metal-pattern');
                viewport.style.removeProperty('background-color');
                
                console.log('🧹 Cleared CSS background');
            }
        }

        /*
         * RendererManager - Canvas2D-Only Rendering System
         * 
         * Simplified from dual-renderer architecture to Canvas2D-only implementation.
         * Provides high-performance 2D rendering with full feature support including
         * textures, themes, animations, and responsive design.
         * 
         * Key Features:
         * • Canvas2D rendering optimization
         * • Texture and theme system integration
         * • Performance monitoring and metrics
         * • Mobile and responsive design support
         */
        class RendererManager {
            constructor(canvas) {
                this.canvas = canvas;
                this.currentRenderer = 'canvas'; // Start with canvas
                this.canvasContext = canvas.getContext('2d');
                
                // Performance tracking
                this.performanceMetrics = {
                    fps: UNIFIED_GAME_CONFIG.performance.targetFPS,
                    drawCalls: 0,
                    lastFrameTime: performance.now()
                };
                
            }

            async initialize() {
                // Always initialize Canvas (it's our fallback)
                this.initializeCanvas();
                
                return true;
            }

            initializeCanvas() {
                if (!this.canvasContext) {
                    this.canvasContext = this.canvas.getContext('2d');
                }
            }


            updatePerformanceMetrics() {
                const now = performance.now();
                const deltaTime = now - this.performanceMetrics.lastFrameTime;
                this.performanceMetrics.fps = 1000 / deltaTime;
                this.performanceMetrics.lastFrameTime = now;
            }

            destroy() {
                // No cleanup needed for Canvas
            }
        }

        // Theme Manager - Canvas-only theme system
        class ThemeManager {
            constructor(assetManager, gameManager) {
                this.assetManager = assetManager;
                this.gameManager = gameManager;
                
                // Support both unified and legacy configuration
                this.currentTheme = this.getDefaultTheme();
                this.isTransitioning = false;
                this.transitionCallbacks = [];
                
                // Track configuration source
                this.useUnifiedConfig = typeof UNIFIED_GAME_CONFIG !== 'undefined';

                // Read base theme id and overrides from level data for future use
                this.baseThemeId = this.gameManager?.levelData?.theme?.baseThemeId || null;
                this.themeOverrides = this.gameManager?.levelData?.theme?.overrides || null;
                

            }
            
            // Smart default theme resolution
            getDefaultTheme() {
                if (typeof UNIFIED_GAME_CONFIG !== 'undefined' && UNIFIED_GAME_CONFIG.theme) {
                    return UNIFIED_GAME_CONFIG.theme.defaultTheme;
                }
                return CANVAS_CONFIG.defaultTheme;
            }
            
            // Smart theme enabled check
            isThemeSystemEnabled() {
                if (this.useUnifiedConfig && UNIFIED_GAME_CONFIG.theme) {
                    return UNIFIED_GAME_CONFIG.theme.enabled;
                }
                return CANVAS_CONFIG.enabled && CANVAS_CONFIG.useThemes;
            }

            async switchTheme(themeName, animated = true) {
                if (!this.isThemeSystemEnabled()) {
                    return;
                }

                if (this.isTransitioning || !THEME_DEFINITIONS[themeName]) {
                    return;
                }

                this.isTransitioning = true;

                if (this.gameManager) {
                    this.gameManager.dockAnimationPlayed = false;
                }

                try {
                    // --- NEW OVERRIDE LOGIC ---
                    // 1. Create a deep copy of the base theme to avoid modifying the original constant.
                    let finalThemeConfig = JSON.parse(JSON.stringify(THEME_DEFINITIONS[themeName]));

                    // 2. Check for level-specific overrides and merge them.
                    if (this.gameManager && this.gameManager.themeOverrides) {
                        finalThemeConfig = deepMerge(finalThemeConfig, this.gameManager.themeOverrides);
                    }
                    // --- END NEW LOGIC ---

                    // The asset manager now uses the final, potentially merged, theme configuration.
                    this.assetManager.themes[themeName] = {
                        config: finalThemeConfig,
                        assets: { backgroundImage: null, platformImage: null, shapeTextures: {} },
                        loaded: false
                    };

                    await this.assetManager.loadThemeImages(themeName, finalThemeConfig);
                    this.assetManager.themes[themeName].loaded = true;

                    this.updateBackgroundStyle(themeName);
                    this.updatePlatformStyle(themeName);
                    
                    if (typeof this.gameManager.rebuildDockFromData === 'function') {
                        // This rebuild is premature. The final rebuild should happen after textures are loaded.
                        // console.log('🎨 Refreshing dock with new theme colors...');
                        // this.gameManager.rebuildDockFromData();
                    }

                    this.currentTheme = themeName;
                    this.assetManager.currentTheme = themeName;
                    console.log(`🔄 ThemeManager: Set currentTheme to '${themeName}' on both ThemeManager and AssetManager`);

                    this.notifyThemeChanged(themeName);

                } catch (error) {
                    console.error(`Failed to switch theme to ${themeName}:`, error);
                } finally {
                    this.isTransitioning = false;
                }
            }

            updateBackgroundStyle(themeName) {
                const bgStyle = this.assetManager.getBackgroundStyle(themeName);
                if (!bgStyle || !this.gameManager?.physicsManager) return;

                if (bgStyle.type === 'gradient') {
                    this.gameManager.physicsManager.backgroundGradient = bgStyle.colors;
                }
            }

            updatePlatformStyle(themeName) {
                const platformStyle = this.assetManager.getPlatformStyle(themeName);
                if (!platformStyle || !this.gameManager?.physicsManager) return;

                this.gameManager.physicsManager.platformColor = platformStyle.color;
            }

            getAvailableThemes() {
                return Object.keys(THEME_DEFINITIONS);
            }

            getCurrentTheme() {
                return this.currentTheme;
            }

            onThemeChanged(callback) {
                this.transitionCallbacks.push(callback);
            }

            notifyThemeChanged(themeName) {
                this.transitionCallbacks.forEach(callback => {
                    try {
                        callback(themeName);
                    } catch (error) {
                        console.error('❌ Error in theme change callback:', error);
                    }
                });
            }
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ PARTICLE SYSTEM - THEME-BASED VISUAL EFFECTS
          ║ Creates and manages particle effects based on current theme
          ╚═══════════════════════════════════════════════════════════════════════════*/
        class ParticleSystem {
            constructor(canvas, assetManager) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.assetManager = assetManager;
                this.particles = [];
                this.maxParticles = CANVAS_CONFIG.maxParticles;
                this.ambientParticleTimer = 0;
                this.ambientParticleInterval = 1000; // Spawn ambient particle every 1 second
            }

            createThemeParticles(type, x, y, count = 5) {
                if (!CANVAS_CONFIG.enabled || !CANVAS_CONFIG.useParticles) return;

                const particleStyle = this.assetManager.getParticleStyle();
                if (!particleStyle) return;

                for (let i = 0; i < Math.min(count, this.maxParticles - this.particles.length); i++) {
                    this.particles.push(this.createParticle(particleStyle, x, y, type));
                }
            }

            createParticle(style, x, y, type) {
                // New particle effect for weighted shape explosions
                if (type === 'explosion') {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * 6 + 2; // Explosion speed from 2 to 8
                    return {
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: Math.random() * 0.5 + 0.5, // Lifetime 0.5s to 1.0s
                        decay: 0.015 + Math.random() * 0.01, // Slower decay for a bigger effect
                        size: 3 + Math.random() * 4, // Larger particles
                        color: ['#ff471a', '#ff7a33', '#ffc300', '#ffffff'][Math.floor(Math.random() * 4)],
                        style: 'explosion'
                    };
                }

                if (style.style === 'flame') {
                    return {
                        x: x,
                        y: y,
                        vx: (Math.random() - 0.5) * 1.5, // Less horizontal spread
                        vy: -Math.random() * 2 - 1,   // Move upwards
                        life: Math.random() * 0.4 + 0.2, // Very short life (0.2s to 0.6s)
                        decay: 0.05, // Faster decay
                        size: 2 + Math.random() * 4,
                        color: ['#FF4500', '#FFA500', '#FFD700'][Math.floor(Math.random() * 3)],
                        style: 'flame'
                    };
                }

                const colors = style.colors;
                const color = colors[Math.floor(Math.random() * colors.length)];

                return {
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4 - 2,
                    life: 1.0,
                    decay: 0.02 + Math.random() * 0.02,
                    size: 2 + Math.random() * 3,
                    color: color,
                    style: style.style
                };
            }

            createAmbientParticle() {
                if (!CANVAS_CONFIG.enabled || !CANVAS_CONFIG.useParticles) return;
                if (this.particles.length >= this.maxParticles) return;

                const particleStyle = this.assetManager.getParticleStyle();
                if (!particleStyle) return;

                // Create particles from random positions around the canvas edges
                const side = Math.floor(Math.random() * 4); // 0=top, 1=right, 2=bottom, 3=left
                let x, y, vx, vy;

                switch(side) {
                    case 0: // Top
                        x = Math.random() * this.canvas.width;
                        y = -10;
                        vx = (Math.random() - 0.5) * 2;
                        vy = Math.random() * 2 + 1;
                        break;
                    case 1: // Right  
                        x = this.canvas.width + 10;
                        y = Math.random() * this.canvas.height;
                        vx = -Math.random() * 2 - 1;
                        vy = (Math.random() - 0.5) * 2;
                        break;
                    case 2: // Bottom
                        x = Math.random() * this.canvas.width;
                        y = this.canvas.height + 10;
                        vx = (Math.random() - 0.5) * 2;
                        vy = -Math.random() * 2 - 1;
                        break;
                    case 3: // Left
                        x = -10;
                        y = Math.random() * this.canvas.height;
                        vx = Math.random() * 2 + 1;
                        vy = (Math.random() - 0.5) * 2;
                        break;
                }

                const colors = particleStyle.colors;
                const color = colors[Math.floor(Math.random() * colors.length)];
                
                this.particles.push({
                    x: x,
                    y: y,
                    vx: vx,
                    vy: vy,
                    life: 1.0,
                    decay: 0.01 + Math.random() * 0.01, // Slower decay for ambient particles
                    size: 1 + Math.random() * 2, // Smaller ambient particles
                    color: color,
                    style: particleStyle.style,
                    isAmbient: true
                });
            }

            update(deltaTime) {
                if (!CANVAS_CONFIG.useParticles) return;

                // Spawn ambient background particles periodically
                this.ambientParticleTimer += deltaTime;
                if (this.ambientParticleTimer >= this.ambientParticleInterval) {
                    this.createAmbientParticle();
                    this.ambientParticleTimer = 0;
                }

                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const particle = this.particles[i];
                    
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.vy += 0.1; // Gravity
                    particle.life -= particle.decay;
                    
                    if (particle.life <= 0) {
                        this.particles.splice(i, 1);
                    }
                }
            }

            render() {
                if (!CANVAS_CONFIG.useParticles) return;

                this.particles.forEach(particle => {
                    this.ctx.save();
                    this.ctx.globalAlpha = particle.life;
                    this.ctx.fillStyle = particle.color;
                    
                    if (particle.style === 'bubbles') {
                        this.ctx.strokeStyle = particle.color;
                        this.ctx.lineWidth = 1;
                        this.ctx.beginPath();
                        this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        this.ctx.stroke();
                    } else {
                        this.ctx.beginPath();
                        this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                    
                    this.ctx.restore();
                });
            }
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ PHYSICS-BASED SHAPE RENDERER
          ║ Renders shapes consistently using physics configuration
          ║ Used for both dock previews and physics simulation
          ╚═══════════════════════════════════════════════════════════════════════════*/
        class PhysicsShapeRenderer {
            constructor() {
                // Initialize caches for performance optimization
                this.pathCache = new Map(); // Cache Path2D objects by shape type
                this.matrixPool = []; // Pool of transformation matrices
                this.canvasPool = []; // Pool of canvas elements for dock previews
                this.lastCacheCleanup = 0;
            }
            
            // Get or create cached Path2D for a shape
            getCachedPath(shapeType) {
                if (!this.pathCache.has(shapeType)) {
                    const config = getShapeConfig(shapeType);
                    if (config) {
                        const path = new Path2D();
                        this.createShapePath(path, config);
                        this.pathCache.set(shapeType, path);
                    }
                }
                return this.pathCache.get(shapeType);
            }
            
            // Get transformation matrix from pool or create new one
            getMatrixFromPool() {
                return this.matrixPool.pop() || new DOMMatrix();
            }
            
            // Return matrix to pool for reuse
            returnMatrixToPool(matrix) {
                matrix.setMatrixValue('matrix(1, 0, 0, 1, 0, 0)'); // Reset to identity
                if (this.matrixPool.length < 20) { // Limit pool size
                    this.matrixPool.push(matrix);
                }
            }
            
            // Get canvas from pool or create new one
            getCanvasFromPool(width, height) {
                const canvas = this.canvasPool.pop() || document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                return canvas;
            }
            
            // Return canvas to pool for reuse
            returnCanvasToPool(canvas) {
                if (this.canvasPool.length < 10) { // Limit pool size
                    // Clear the canvas
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    this.canvasPool.push(canvas);
                }
            }
            
            // Ensure AssetManager and theme are ready for rendering
            async ensureReady() {
                // Wait for AssetManager to be available
                if (!window.assetManager) {
                    console.log('⏳ PhysicsShapeRenderer waiting for AssetManager...');
                    await new Promise(resolve => {
                        const checkAssetManager = () => {
                            if (window.assetManager) {
                                resolve();
                            } else {
                                setTimeout(checkAssetManager, 50);
                            }
                        };
                        checkAssetManager();
                    });
                }
                
                // Ensure a theme is loaded
                let currentTheme = window.assetManager.getCurrentTheme();
                if (!currentTheme || !currentTheme.name) {
                    const themeSelector = document.getElementById('themeSelector');
                    const themeName = themeSelector?.value || CANVAS_CONFIG.defaultTheme;
                    
                    // Check if theme is already loaded to prevent duplicates
                    if (!window.assetManager.themes[themeName]?.loaded) {
                        console.log(`⏳ PhysicsShapeRenderer loading theme: ${themeName}`);
                        await window.assetManager.loadTheme(themeName);
                    }
                }
                
                return true;
            }
            
            // Clean caches periodically
            cleanCaches() {
                const now = performance.now();
                if (now - this.lastCacheCleanup > 10000) { // Every 10 seconds
                    // Clear path cache if it gets too large
                    if (this.pathCache.size > 50) {
                        this.pathCache.clear();
                    }
                    this.lastCacheCleanup = now;
                    debugLog('🧹 PhysicsShapeRenderer caches cleaned');
                }
            }
            
            renderShapeOnCanvas(ctx, shapeType, x, y, rotation = 0, scale = 1, forcedTexture = null, unifiedConfig = null) {
                // Use unified config if provided, otherwise fallback to legacy system
                const config = unifiedConfig || getShapeConfig(shapeType);
                if (!config) {
                    console.error(`❌ No config found for renderShapeOnCanvas: ${shapeType}`);
                    return;
                }

                // Clean caches periodically
                this.cleanCaches();

                // --- NEW: Get renderStyle from the current theme ---
                let renderStyle = { type: 'FLAT' }; // Default fallback
                if (window.gameManager && window.gameManager.themeManager) {
                    const currentThemeName = window.gameManager.themeManager.getCurrentTheme();
                    const currentTheme = window.gameManager.themeManager.assetManager.getTheme(currentThemeName);
                    if (currentTheme?.config?.shapes?.renderStyle) {
                        renderStyle = currentTheme.config.shapes.renderStyle;
                    }
                }
                // --- END NEW ---

                // Check for renderStyle overrides specified directly in level data theme overrides
                if (window.gameManager && window.gameManager.levelData && window.gameManager.levelData.theme && window.gameManager.levelData.theme.overrides && window.gameManager.levelData.theme.overrides.shapes && window.gameManager.levelData.theme.overrides.shapes.renderStyle) {
                    renderStyle = window.gameManager.levelData.theme.overrides.shapes.renderStyle;
                }

                // --- UNIFIED: Retrieve texture image and config if not provided ---
                let textureConfig = null;
                if (!forcedTexture) {
                    const textureImage = UnifiedTextureSystem.getShapeTexture(shapeType);
                    if (textureImage) {
                        forcedTexture = textureImage;
                        textureConfig = UnifiedTextureSystem.getTextureConfig(shapeType);
                    }
                }
                // --- END UNIFIED ---

                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.scale(scale, scale);

                // Use cached Path2D object instead of creating new one
                const path = this.getCachedPath(shapeType);
                if (!path) {
                    console.error(`❌ Failed to create path for shape: ${shapeType}`);
                    ctx.restore();
                    return;
                }

                // The unified rendering method with texture configuration
                this.renderPathWithStyle(ctx, path, config, renderStyle, forcedTexture, textureConfig);

                ctx.restore();
            }

            createDockPreview(shapeType, size = UNIFIED_GAME_CONFIG.shapes.dockPreviewSize) {
                // Commented out verbose dock preview logging
                // console.log(`🎨 createDockPreview called for: ${shapeType}, size: ${size}`);
                const config = getShapeConfig(shapeType);
                if (!config) {
                    console.error(`❌ No config found for shape: ${shapeType}`);
                    return null;
                }
                
                debugLog(`🔍 Shape config for ${shapeType}:`, config);
                
                // Use unified texture checking
                const hasTexture = UnifiedTextureSystem.isTextureAvailable(shapeType);
                
                debugLog(`🔍 Texture availability for ${shapeType}:`, {
                    hasTexture,
                    textureManagerReady: !!window.textureManager,
                    assetManagerReady: !!window.assetManager
                });
                
                // Always use Canvas preview
                if (hasTexture) {
                    debugLog(`🎨 Creating Canvas preview for ${shapeType} with texture`);
                } else {
                    debugLog(`🎨 Creating Canvas preview for ${shapeType} (no texture available)`);
                }
                return this.createCanvasDockPreview(shapeType, config, size);
            }

            createCanvasDockPreview(shapeType, config, size = 90) {
                // Use SHAPE_CONFIG for theme-aware colors instead of master registry
                const legacyConfig = SHAPE_CONFIG[shapeType];
                const unifiedConfig = MASTER_SHAPE_REGISTRY[shapeType];
                
                if (!unifiedConfig || !legacyConfig) {
                    console.error(`❌ Shape ${shapeType} not found in registries for dock preview`);
                    // Return a fallback canvas so dock doesn't break
                    const canvas = this.getCanvasFromPool(size, size);
                    canvas.className = `shape-preview`;
                    canvas.dataset.shape = shapeType;
                    return canvas;
                }
                
                // Merge unified config with theme-aware colors from SHAPE_CONFIG
                const mergedConfig = {
                    ...unifiedConfig,
                    visual: {
                        ...unifiedConfig.visual,
                        color: legacyConfig.color || unifiedConfig.visual.color,
                        stroke: legacyConfig.stroke || unifiedConfig.visual.stroke,
                        strokeWidth: legacyConfig.strokeWidth || unifiedConfig.visual.strokeWidth
                    }
                };
                
                debugLog(`🎨 Merged config for ${shapeType}:`, {
                    originalColor: unifiedConfig.visual.color,
                    themeColor: legacyConfig.color,
                    finalColor: mergedConfig.visual.color
                });
                
                // Use canvas pool for better performance
                const canvas = this.getCanvasFromPool(size, size);
                canvas.className = `shape-preview`;
                canvas.dataset.shape = shapeType;

                const ctx = canvas.getContext('2d');
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';

                // Use unified texture checking
                const hasTexture = UnifiedTextureSystem.isTextureAvailable(shapeType);
                
                if (hasTexture) {
                    debugLog(`🎨 Canvas preview for ${shapeType} - texture available`);
                    // Add a subtle texture indicator border
                    // RdW TODO: leave the following statements commented out in the new version
                    // canvas.style.border = '2px solid #DAA520';
                    // canvas.style.boxShadow = '0 0 8px rgba(218, 165, 32, 0.5)';
                    canvas.title = `${shapeType} - Textured`;
                } else {
                    debugLog(`🎨 Canvas preview for ${shapeType} - using themed colors only`);
                    canvas.style.border = '1px solid #ccc';
                    canvas.title = `${shapeType} - Themed colors`;
                }

                // Use 2x scale for full-size display, matching 2x physics scale (30→60)
                const scale = UNIFIED_GAME_CONFIG.performance.scaleMultiplier;
                debugLog(`📐 Shape ${shapeType}: using enlarged scale=${scale} for full-size display`);
                
                // Check barbell orientation setting for dock preview rotation
                let rotation = 0;
                if (shapeType && shapeType.includes('barbell')) {
                    const barbellOrientationSelect = document.getElementById('barbellOrientation');
                    if (barbellOrientationSelect && barbellOrientationSelect.value === 'vertical') {
                        rotation = Math.PI / 2; // 90 degrees for vertical orientation
                        debugLog(`🔄 Applying vertical rotation (90°) to ${shapeType}`);
                    }
                }
                
                // Get texture for rendering if available
                const textureImage = UnifiedTextureSystem.getShapeTexture(shapeType);
                
                // Render the shape in the center of the preview canvas with theme-aware colors
                this.renderShapeOnCanvas(ctx, shapeType, size / 2, size / 2, rotation, scale, textureImage, mergedConfig);
                
                debugLog(`✅ Canvas preview created for: ${shapeType} with scale ${scale}, rotation ${(rotation * 180 / Math.PI).toFixed(0)}°, textured: ${!!textureImage}`);
                return canvas;
            }

            /* --- Begin new bevel-capable rendering engine --- */
            createShapePath(path, config) {
                switch (config.type) {
                    case 'rectangle':
                        path.rect(-config.width / 2, -config.height / 2, config.width, config.height);
                        break;
                    case 'circle':
                        path.arc(0, 0, config.radius, 0, Math.PI * 2);
                        break;
                    case 'polygon':
                        if (config.vertices) {
                            path.moveTo(config.vertices[0].x, config.vertices[0].y);
                            for (let i = 1; i < config.vertices.length; i++) {
                                path.lineTo(config.vertices[i].x, config.vertices[i].y);
                            }
                            path.closePath();
                        }
                        break;
                    case 'diamond':
                        // Render a diamond using width and height (rotated square)
                        {
                            const halfW = (config.width ?? config.height ?? 0) / 2;
                            const halfH = (config.height ?? config.width ?? 0) / 2;
                            path.moveTo(0, -halfH);
                            path.lineTo(halfW, 0);
                            path.lineTo(0, halfH);
                            path.lineTo(-halfW, 0);
                            path.closePath();
                        }
                        break;
                    case 'compound':
                        if (config.parts) {
                            config.parts.forEach(part => {
                                // Create a Path2D for the sub-part
                                const partPath = new Path2D();
                                const partConfigWithOffset = { ...config, ...part };
                                this.createShapePath(partPath, partConfigWithOffset);
                                
                                // Add the sub-path to the main path, applying its offset
                                path.addPath(partPath, new DOMMatrix().translate(part.offsetX || 0, part.offsetY || 0));
                            });
                        }
                        break;
                }
            }

            renderPathWithStyle(ctx, path, shapeConfig, renderStyle, forcedTexture = null, textureConfig = null) {
                // If a forced texture is provided, render with texture
                if (forcedTexture) {
                    this.renderWithTexture(ctx, path, shapeConfig, forcedTexture, textureConfig);
                } else {
                    switch (renderStyle.type) {
                        case 'BEVEL_STANDARD':
                        case 'BEVEL_ROUNDED':
                            this.renderBevel(ctx, path, shapeConfig, renderStyle);
                            break;
                        case 'FLAT':
                        default:
                            this.renderFlat(ctx, path, shapeConfig);
                            break;
                    }
                }
            }

            renderWithTexture(ctx, path, config, textureImage, textureConfig = null) {
                if (!textureImage) {
                    this.renderFlat(ctx, path, config);
                    return;
                }

                // Save the context state before applying texture
                ctx.save();
                
                // Apply texture configuration if provided
                if (textureConfig) {
                    if (textureConfig.opacity && textureConfig.opacity < 1) {
                        ctx.globalAlpha = textureConfig.opacity;
                    }
                    if (textureConfig.blend && textureConfig.blend !== 'source-over') {
                        ctx.globalCompositeOperation = textureConfig.blend;
                    }
                }
                
                // Create and apply the texture pattern
                const repeatPattern = textureConfig?.repeat || 'repeat';
                const pattern = ctx.createPattern(textureImage, repeatPattern);
                if (pattern) {
                    ctx.fillStyle = pattern;
                    // Fill the path with the texture pattern
                    ctx.fill(path);
                }
                
                ctx.restore();
                
                // Add stroke if configured - handle both old and new structure
                const strokeWidth = config.visual?.strokeWidth || config.strokeWidth || 0;
                const stroke = config.visual?.stroke || config.stroke || '#666666';
                if (strokeWidth > 0) {
                    ctx.strokeStyle = stroke;
                    ctx.lineWidth = strokeWidth;
                    ctx.stroke(path);
                }
            }

            renderFlat(ctx, path, config) {
                // Handle both old flat structure and new nested structure
                const color = config.visual?.color || config.color || '#808080';
                const stroke = config.visual?.stroke || config.stroke || '#666666';
                const strokeWidth = config.visual?.strokeWidth || config.strokeWidth || 0;
                
                ctx.fillStyle = color;
                ctx.fill(path);
                if (strokeWidth > 0) {
                    ctx.strokeStyle = stroke;
                    ctx.lineWidth = strokeWidth;
                    ctx.stroke(path);
                }
            }

            renderBevel(ctx, path, config, style) {
                // Read parameters with sensible defaults
                const depth = style.depth || 4;
                const lightAngleRad = (style.lightAngle || 135) * (Math.PI / 180); // Convert angle to radians
                const highlightOpacity = style.highlightOpacity || 0.8;
                const shadowOpacity = style.shadowOpacity || 0.6;
                const softness = style.softness || 0;

                // Calculate offsets for highlight and shadow based on light angle
                const offsetX = Math.cos(lightAngleRad) * depth / 2;
                const offsetY = Math.sin(lightAngleRad) * depth / 2;

                // 1. Render Shadow Layer
                ctx.save();
                ctx.translate(-offsetX, -offsetY); // Offset opposite to the light source
                ctx.fillStyle = 'black';
                ctx.globalAlpha = shadowOpacity;
                if (softness > 0) {
                    ctx.filter = `blur(${softness}px)`;
                }
                ctx.fill(path);
                ctx.restore();

                // 2. Render Highlight Layer
                ctx.save();
                ctx.translate(offsetX, offsetY); // Offset towards the light source
                ctx.fillStyle = 'white';
                ctx.globalAlpha = highlightOpacity;
                if (softness > 0) {
                    ctx.filter = `blur(${softness}px)`;
                }
                ctx.fill(path);
                ctx.restore();

                // 3. Render Main Body Color - handle both old and new structure
                const color = config.visual?.color || config.color || '#808080';
                const stroke = config.visual?.stroke || config.stroke || '#666666';
                const strokeWidth = config.visual?.strokeWidth || config.strokeWidth || 0;
                
                ctx.fillStyle = color;
                ctx.fill(path);
                
                // 4. Render Stroke on top for crisp edges
                if (strokeWidth > 0) {
                    ctx.strokeStyle = stroke;
                    ctx.lineWidth = strokeWidth;
                    ctx.stroke(path);
                }
            }
            /* --- End new bevel-capable rendering engine --- */
        }

        // Global shape renderer instance
        const shapeRenderer = new PhysicsShapeRenderer();

        const WEIGHTED_DEFAULTS = {
            maxWeight: 3,
            overloadDelayMs: 1000,
            indicatorColors: {
                safe: '#2ecc71',
                warning: '#f1c40f',
                danger: '#e74c3c'
            }
        };

        class DockingSpecialEffectsManager {
            constructor() {
                this.entries = [];
                this.animationFrameId = null;
                this.lastTimestamp = 0;
                this.renderFrame = this.renderFrame.bind(this);
            }

            reset() {
                this.entries.forEach(entry => {
                    if (entry.overlay && entry.overlay.parentElement) {
                        entry.overlay.parentElement.removeChild(entry.overlay);
                    }
                    if (entry.sourceElement && entry.sourceElement.dataset) {
                        delete entry.sourceElement.dataset.specialEffectId;
                    }
                });
                this.entries = [];
                if (this.animationFrameId !== null) {
                    cancelAnimationFrame(this.animationFrameId);
                    this.animationFrameId = null;
                }
                this.lastTimestamp = 0;
            }

            sanitizeSpecialConfig(specialConfig) {
                const sanitized = { ...specialConfig };

                if (sanitized.type === 'WEIGHTED') {
                    sanitized.maxWeight = (typeof sanitized.maxWeight === 'number' && sanitized.maxWeight > 0)
                        ? sanitized.maxWeight
                        : WEIGHTED_DEFAULTS.maxWeight;
                    sanitized.overloadDelayMs = (typeof sanitized.overloadDelayMs === 'number' && sanitized.overloadDelayMs >= 0)
                        ? sanitized.overloadDelayMs
                        : WEIGHTED_DEFAULTS.overloadDelayMs;
                    sanitized.indicatorColors = {
                        ...WEIGHTED_DEFAULTS.indicatorColors,
                        ...(sanitized.indicatorColors || {})
                    };
                }

                if (sanitized.type === 'TIMER') {
                    const duration = typeof sanitized.countdownSeconds === 'number'
                        ? sanitized.countdownSeconds
                        : sanitized.duration;
                    sanitized.countdownSeconds = Math.max(duration || 3, 0.1);
                }

                return sanitized;
            }

            getEntryByElement(element) {
                if (!element) return null;
                const effectId = element.dataset?.specialEffectId;
                for (let i = 0; i < this.entries.length; i++) {
                    const entry = this.entries[i];
                    if (entry.sourceElement === element) {
                        return entry;
                    }
                    if (effectId && entry.id === effectId) {
                        return entry;
                    }
                }
                return null;
            }

            setEffectVisibility(element, visible) {
                const entry = this.getEntryByElement(element);
                if (entry && entry.overlay) {
                    entry.overlay.style.display = visible ? 'block' : 'none';
                }
            }

            unregisterByElement(element) {
                if (!element) return;
                const effectId = element.dataset?.specialEffectId;
                for (let i = this.entries.length - 1; i >= 0; i--) {
                    const entry = this.entries[i];
                    if (entry.sourceElement === element || (effectId && entry.id === effectId)) {
                        if (entry.overlay && entry.overlay.parentElement) {
                            entry.overlay.parentElement.removeChild(entry.overlay);
                        }
                        this.entries.splice(i, 1);
                    }
                }
                if (effectId) {
                    delete element.dataset.specialEffectId;
                }
            }

            register(canvas, specialConfig) {
                console.log(`🎨 DockingSpecialEffectsManager.register called:`, { canvas, specialConfig });
                if (!canvas || !specialConfig || !specialConfig.type) {
                    console.log(`❌ Registration failed - missing data:`, { hasCanvas: !!canvas, hasSpecialConfig: !!specialConfig, hasType: !!specialConfig?.type });
                    return;
                }

                const parent = canvas.parentElement;
                if (!parent) {
                    console.log(`❌ Registration failed - no parent element for canvas`);
                    return;
                }

                this.unregisterByElement(canvas);

                const overlay = document.createElement('canvas');
                overlay.width = canvas.width;
                overlay.height = canvas.height;
                
                // Copy all styles from the original canvas
                const computedStyle = window.getComputedStyle(canvas);
                overlay.style.cssText = canvas.style.cssText;
                
                // Override with overlay-specific styles
                overlay.className = 'special-effect-overlay';
                overlay.style.position = 'absolute';
                overlay.style.top = '0';
                overlay.style.left = '0';
                overlay.style.zIndex = '65';
                overlay.style.pointerEvents = 'none';
                overlay.style.display = 'block';
                parent.appendChild(overlay);

                const sanitizedConfig = this.sanitizeSpecialConfig(specialConfig);
                const entryId = `effect-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;

                if (!sanitizedConfig.currentStatus) {
                    sanitizedConfig.currentStatus = 'safe';
                }
                if (typeof sanitizedConfig.currentWeight !== 'number') {
                    sanitizedConfig.currentWeight = 0;
                }

                const entry = {
                    id: entryId,
                    type: sanitizedConfig.type,
                    overlay,
                    ctx: overlay.getContext('2d'),
                    specialParams: sanitizedConfig,
                    particles: [],
                    timerElapsed: 0,
                    timerDuration: Math.max(sanitizedConfig.countdownSeconds || sanitizedConfig.duration || 3, 0.1),
                    indicatorColors: sanitizedConfig.indicatorColors || {
                        safe: '#2ecc71',
                        warning: '#f1c40f',
                        danger: '#e74c3c'
                    },
                    sourceElement: canvas
                };

                overlay.dataset.specialEffectId = entryId;
                canvas.dataset.specialEffectId = entryId;

                this.entries.push(entry);
                console.log(`✅ Special effect registered successfully:`, { 
                    id: entryId, 
                    type: sanitizedConfig.type,
                    canvas: canvas.id || 'unnamed',
                    overlaySize: { width: overlay.width, height: overlay.height }
                });

                if (!this.animationFrameId) {
                    this.lastTimestamp = performance.now();
                    this.animationFrameId = requestAnimationFrame(this.renderFrame);
                    console.log(`🎬 Started special effects animation loop`);
                }
            }

            renderFrame(timestamp) {
                if (this.entries.length === 0) {
                    this.animationFrameId = null;
                    this.lastTimestamp = 0;
                    return;
                }

                const delta = this.lastTimestamp ? (timestamp - this.lastTimestamp) : 16.67;
                this.lastTimestamp = timestamp;
                const deltaMultiplier = delta / 16.67;

                for (let i = this.entries.length - 1; i >= 0; i--) {
                    const entry = this.entries[i];
                    if (!entry.overlay || !entry.overlay.isConnected) {
                        this.entries.splice(i, 1);
                        continue;
                    }

                    const ctx = entry.ctx;
                    if (!ctx) {
                        this.entries.splice(i, 1);
                        continue;
                    }

                    ctx.clearRect(0, 0, entry.overlay.width, entry.overlay.height);

                    // console.log(`🎬 Rendering special effect:`, { id: entry.id, type: entry.type, canvasSize: { width: entry.overlay.width, height: entry.overlay.height } });

                    switch (entry.type) {
                        case 'FIRE':
                            this.renderFire(entry, deltaMultiplier);
                            break;
                        case 'TIMER':
                            this.renderTimer(entry, delta);
                            break;
                        case 'WEIGHTED':
                            this.renderWeighted(entry);
                            break;
                        default:
                            console.log(`⚠️ Unknown special effect type: ${entry.type}`);
                            break;
                    }
                }

                if (this.entries.length > 0) {
                    this.animationFrameId = requestAnimationFrame(this.renderFrame);
                } else {
                    this.animationFrameId = null;
                    this.lastTimestamp = 0;
                }
            }

            renderFire(entry, deltaMultiplier) {
                // console.log(`🔥 renderFire called for entry:`, { id: entry.id, particles: entry.particles.length });
                const { overlay, ctx, particles } = entry;
                const centerX = overlay.width / 2;
                const centerY = overlay.height / 2;
                const maxParticles = 40;

                if (Math.random() > 0.4 && particles.length < maxParticles) {
                    const spawnCount = Math.random() > 0.7 ? 2 : 1;
                    for (let i = 0; i < spawnCount && particles.length < maxParticles; i++) {
                        particles.push({
                            x: centerX + (Math.random() - 0.5) * 6,
                            y: centerY + 10 + Math.random() * 4,
                            vx: (Math.random() - 0.5) * 1.2,
                            vy: -Math.random() * 1.8 - 0.4,
                            life: Math.random() * 0.4 + 0.2,
                            decay: 0.05,
                            size: 2 + Math.random() * 3,
                            color: ['#FF4500', '#FFA500', '#FFD700'][Math.floor(Math.random() * 3)]
                        });
                    }
                }

                for (let i = particles.length - 1; i >= 0; i--) {
                    const particle = particles[i];
                    particle.x += particle.vx * deltaMultiplier;
                    particle.y += particle.vy * deltaMultiplier;
                    particle.life -= particle.decay * deltaMultiplier;

                    if (particle.life <= 0) {
                        particles.splice(i, 1);
                        continue;
                    }

                    ctx.save();
                    ctx.globalAlpha = Math.max(particle.life, 0);
                    ctx.fillStyle = particle.color;
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
            }

            renderWeighted(entry) {
                // console.log(`⚖️ renderWeighted called for entry:`, { id: entry.id, status: entry.specialParams?.currentStatus });
                const { overlay, ctx, indicatorColors, specialParams } = entry;
                const centerX = overlay.width / 2;
                const centerY = overlay.height / 2;

                ctx.save();
                ctx.translate(centerX, centerY);
                ctx.fillStyle = '#333';
                ctx.fillRect(-8, -4, 16, 8);

                ctx.beginPath();
                ctx.arc(0, 0, 5, 0, Math.PI * 2);
                const status = specialParams?.currentStatus || 'safe';
                const lightColor = indicatorColors[status] || indicatorColors.safe;
                ctx.fillStyle = lightColor;
                ctx.fill();
                ctx.strokeStyle = '#555';
                ctx.lineWidth = 1;
                ctx.stroke();
                ctx.restore();
            }

            renderTimer(entry, delta) {
                // console.log(`⏱️ renderTimer called for entry:`, { id: entry.id, elapsed: entry.timerElapsed });
                const { overlay, ctx, timerDuration } = entry;
                const centerX = overlay.width / 2;
                const centerY = overlay.height / 2;

                entry.timerElapsed += delta / 1000;
                const progress = timerDuration > 0 ? (entry.timerElapsed % timerDuration) / timerDuration : 0;
                const angle = progress * Math.PI * 2;

                ctx.save();
                ctx.translate(centerX, centerY);

                ctx.beginPath();
                ctx.arc(0, 0, 8, 0, Math.PI * 2);
                ctx.fillStyle = '#E0E0E0';
                ctx.fill();
                ctx.strokeStyle = '#757575';
                ctx.lineWidth = 1.5;
                ctx.stroke();

                ctx.fillRect(-1.5, -11, 3, 3);

                ctx.save();
                ctx.rotate(angle);
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(0, -6);
                ctx.lineWidth = 1;
                ctx.strokeStyle = '#d32f2f';
                ctx.stroke();
                ctx.restore();

                ctx.restore();
            }
        }

        const dockingSpecialEffectsManager = new DockingSpecialEffectsManager();

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ ASYNC MUTEX - STATE MANAGEMENT SYNCHRONIZATION
          ║ Prevents concurrent state mutations that could cause race conditions.
          ║ Provides exclusive access to critical game state updates.
          ╚═══════════════════════════════════════════════════════════════════════════*/
        class AsyncMutex {
            constructor(name = 'unnamed') {
                this.name = name;
                this.locked = false;
                this.queue = [];
                this.lockCount = 0;
                this.maxWaitTime = 5000; // 5 seconds
            }
            
            // Acquire lock with timeout
            async acquire(operation = 'unknown') {
                return new Promise((resolve, reject) => {
                    const lockRequest = {
                        operation,
                        resolve,
                        reject,
                        timestamp: Date.now()
                    };
                    
                    if (!this.locked) {
                        this.locked = true;
                        this.lockCount++;
                        debugLog(`🔒 AsyncMutex '${this.name}' acquired for: ${operation}`);
                        resolve();
                    } else {
                        debugLog(`⏳ AsyncMutex '${this.name}' queued: ${operation} (queue: ${this.queue.length + 1})`);
                        this.queue.push(lockRequest);
                        
                        // Set timeout for waiting
                        setTimeout(() => {
                            const index = this.queue.indexOf(lockRequest);
                            if (index !== -1) {
                                this.queue.splice(index, 1);
                                reject(new Error(`AsyncMutex '${this.name}' timeout for operation: ${operation}`));
                            }
                        }, this.maxWaitTime);
                    }
                });
            }
            
            // Release lock and process queue
            release(operation = 'unknown') {
                if (!this.locked) {
                    console.warn(`⚠️ AsyncMutex '${this.name}' release called but not locked`);
                    return;
                }
                
                debugLog(`🔓 AsyncMutex '${this.name}' released by: ${operation}`);
                this.locked = false;
                
                if (this.queue.length > 0) {
                    const next = this.queue.shift();
                    this.locked = true;
                    this.lockCount++;
                    debugLog(`🔒 AsyncMutex '${this.name}' acquired for: ${next.operation} (from queue)`);
                    next.resolve();
                }
            }
            
            // Execute operation with automatic lock management
            async execute(operation, operationName = 'anonymous') {
                try {
                    await this.acquire(operationName);
                    const result = await operation();
                    return result;
                } finally {
                    this.release(operationName);
                }
            }
            
            // Check if currently locked
            isLocked() {
                return this.locked;
            }
            
            // Get queue status
            getStatus() {
                return {
                    name: this.name,
                    locked: this.locked,
                    queueLength: this.queue.length,
                    lockCount: this.lockCount
                };
            }
            
            // Force unlock (emergency use only)
            forceUnlock(reason = 'forced') {
                console.warn(`⚠️ AsyncMutex '${this.name}' force unlocked: ${reason}`);
                this.locked = false;
                
                // Reject all queued operations
                while (this.queue.length > 0) {
                    const request = this.queue.shift();
                    request.reject(new Error(`Mutex force unlocked: ${reason}`));
                }
            }
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ DOCK LOADING MANAGER - ERROR HANDLING & LOADING STATES
          ║ Manages loading states, error boundaries, and graceful fallbacks for dock
          ║ initialization. Provides visual feedback during asset loading.
          ╚═══════════════════════════════════════════════════════════════════════════*/
        class DockLoadingManager {
            constructor() {
                this.maxRetries = 3;
                this.retryDelay = 1000; // 1 second
                this.currentRetries = 0;
                this.isLoading = false;
                this.loadingTimeout = null;
            }
            
            // Show loading state
            showLoading(message = 'Loading shapes...') {
                const dockingArea = document.getElementById('dockingArea');
                if (dockingArea) {
                    dockingArea.classList.add('loading');
                    dockingArea.classList.remove('error', 'retrying');
                    this.isLoading = true;
                    
                    // Set timeout for loading state
                    this.clearLoadingTimeout();
                    this.loadingTimeout = setTimeout(() => {
                        console.warn('⚠️ Dock loading taking longer than expected');
                        this.showError('Loading timeout - check network connection');
                    }, 10000); // 10 second timeout
                    
                    console.log(`🔄 Dock loading: ${message}`);
                }
            }
            
            // Show error state
            showError(errorMessage = 'Failed to load shapes') {
                const dockingArea = document.getElementById('dockingArea');
                if (dockingArea) {
                    dockingArea.classList.add('error');
                    dockingArea.classList.remove('loading', 'retrying');
                    this.isLoading = false;
                    this.clearLoadingTimeout();
                    console.error(`❌ Dock error: ${errorMessage}`);
                }
            }
            
            // Show retry state
            showRetrying(attempt) {
                const dockingArea = document.getElementById('dockingArea');
                if (dockingArea) {
                    dockingArea.classList.add('retrying');
                    dockingArea.classList.remove('loading', 'error');
                    console.log(`🔄 Dock retry attempt ${attempt}/${this.maxRetries}`);
                }
            }
            
            // Hide all loading states
            hideLoading() {
                const dockingArea = document.getElementById('dockingArea');
                if (dockingArea) {
                    dockingArea.classList.remove('loading', 'error', 'retrying');
                    this.isLoading = false;
                    this.clearLoadingTimeout();
                    debugLog('✅ Dock loading complete');
                }
            }
            
            // Clear loading timeout
            clearLoadingTimeout() {
                if (this.loadingTimeout) {
                    clearTimeout(this.loadingTimeout);
                    this.loadingTimeout = null;
                }
            }
            
            // Retry mechanism with exponential backoff
            async retryOperation(operation, context = 'dock operation') {
                this.currentRetries = 0;
                
                while (this.currentRetries < this.maxRetries) {
                    try {
                        if (this.currentRetries > 0) {
                            this.showRetrying(this.currentRetries + 1);
                            const delay = this.retryDelay * Math.pow(2, this.currentRetries); // Exponential backoff
                            await new Promise(resolve => setTimeout(resolve, delay));
                        }
                        
                        const result = await operation();
                        this.currentRetries = 0; // Reset on success
                        return result;
                        
                    } catch (error) {
                        this.currentRetries++;
                        console.warn(`⚠️ ${context} failed (attempt ${this.currentRetries}/${this.maxRetries}):`, error.message);
                        
                        if (this.currentRetries >= this.maxRetries) {
                            this.showError(`${context} failed after ${this.maxRetries} attempts`);
                            throw new Error(`${context} failed after ${this.maxRetries} attempts: ${error.message}`);
                        }
                    }
                }
            }
            
            // Create fallback shape if asset loading fails
            createFallbackShape(shapeType, size = 90) {
                const canvas = document.createElement('canvas');
                canvas.width = size;
                canvas.height = size;
                canvas.className = 'shape-preview fallback';
                canvas.dataset.shape = shapeType;
                canvas.title = `${shapeType} (fallback)`;
                
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#f0f0f0';
                ctx.strokeStyle = '#999';
                ctx.lineWidth = 2;
                
                // Draw simple geometric fallback based on shape type
                const center = size / 2;
                const radius = size * 0.3;
                
                ctx.beginPath();
                if (shapeType.includes('circle')) {
                    ctx.arc(center, center, radius, 0, Math.PI * 2);
                } else if (shapeType.includes('triangle')) {
                    ctx.moveTo(center, center - radius);
                    ctx.lineTo(center - radius, center + radius);
                    ctx.lineTo(center + radius, center + radius);
                    ctx.closePath();
                } else {
                    // Default to square
                    ctx.rect(center - radius, center - radius, radius * 2, radius * 2);
                }
                
                ctx.fill();
                ctx.stroke();
                
                // Add shape type label
                ctx.fillStyle = '#666';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(shapeType, center, size - 5);
                
                console.log(`🔧 Created fallback shape for: ${shapeType}`);
                return canvas;
            }
        }
        
        // Create global dock loading manager instance
        const dockLoadingManager = new DockLoadingManager();

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ GLOBAL MUTEX INSTANCES - CRITICAL OPERATION SYNCHRONIZATION
          ║ Create mutex instances for different types of critical operations to
          ║ prevent race conditions and ensure proper synchronization.
          ╚═══════════════════════════════════════════════════════════════════════════*/
        
        // Dock operations (rebuild, initialization, shape loading)
        const dockMutex = new AsyncMutex('dock-operations');
        
        // Theme operations (theme switching, asset loading, texture management)
        const themeMutex = new AsyncMutex('theme-operations');
        
        // Game state operations (level changes, resets, score updates)
        const gameStateMutex = new AsyncMutex('game-state');
        
        // Asset loading operations (texture loading, level data)
        const assetMutex = new AsyncMutex('asset-loading');
        
        // Global mutex manager for monitoring and debugging
        const mutexManager = {
            mutexes: { dockMutex, themeMutex, gameStateMutex, assetMutex },
            
            getStatus() {
                const status = {};
                for (const [name, mutex] of Object.entries(this.mutexes)) {
                    status[name] = mutex.getStatus();
                }
                return status;
            },
            
            logStatus() {
                console.log('🔒 Mutex Status:', this.getStatus());
            },
            
            forceUnlockAll(reason = 'emergency') {
                console.warn(`⚠️ Force unlocking all mutexes: ${reason}`);
                for (const mutex of Object.values(this.mutexes)) {
                    if (mutex.isLocked()) {
                        mutex.forceUnlock(reason);
                    }
                }
            }
        };
        
        // Make mutex manager globally available for debugging
        window.mutexManager = mutexManager;

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ RACE CONDITION MONITOR - DEVELOPMENT DEBUGGING TOOL
          ║ Detects and logs potential race conditions by tracking read/write access
          ║ to shared resources. Helps identify concurrent access patterns.
          ╚═══════════════════════════════════════════════════════════════════════════*/
        class RaceConditionMonitor {
            constructor() {
                this.accessLog = [];
                this.resourceTracking = new Map();
                this.maxLogSize = 1000;
                this.warningThreshold = 5; // ms between conflicting operations
                this.enabled = true; // Can be disabled in production
            }
            
            // Track resource access
            trackAccess(resourceName, operation, operationType = 'read', metadata = {}) {
                if (!this.enabled) return;
                
                const timestamp = performance.now();
                const access = {
                    resourceName,
                    operation,
                    operationType, // 'read', 'write', 'modify'
                    timestamp,
                    stackTrace: this.getStackTrace(),
                    metadata
                };
                
                // Add to access log
                this.accessLog.push(access);
                if (this.accessLog.length > this.maxLogSize) {
                    this.accessLog.shift(); // Remove oldest entry
                }
                
                // Check for potential race conditions
                this.checkForRaceConditions(access);
                
                // Update resource tracking
                if (!this.resourceTracking.has(resourceName)) {
                    this.resourceTracking.set(resourceName, []);
                }
                const resourceAccesses = this.resourceTracking.get(resourceName);
                resourceAccesses.push(access);
                
                // Keep only recent accesses for each resource
                const cutoffTime = timestamp - 1000; // 1 second
                this.resourceTracking.set(resourceName, 
                    resourceAccesses.filter(a => a.timestamp > cutoffTime)
                );
            }
            
            // Check for potential race conditions
            checkForRaceConditions(currentAccess) {
                const { resourceName, operationType, timestamp } = currentAccess;
                const resourceAccesses = this.resourceTracking.get(resourceName) || [];
                
                // Look for conflicting operations within the warning threshold
                const recentAccesses = resourceAccesses.filter(access => 
                    access.timestamp > timestamp - this.warningThreshold &&
                    access.timestamp < timestamp
                );
                
                for (const recentAccess of recentAccesses) {
                    if (this.isConflictingOperation(recentAccess.operationType, operationType)) {
                        this.logRaceConditionWarning(recentAccess, currentAccess);
                    }
                }
            }
            
            // Determine if two operations conflict
            isConflictingOperation(op1, op2) {
                // Write-Write conflicts
                if (op1 === 'write' && op2 === 'write') return true;
                // Write-Read conflicts
                if ((op1 === 'write' && op2 === 'read') || (op1 === 'read' && op2 === 'write')) return true;
                // Write-Modify conflicts
                if ((op1 === 'write' && op2 === 'modify') || (op1 === 'modify' && op2 === 'write')) return true;
                // Modify-Modify conflicts
                if (op1 === 'modify' && op2 === 'modify') return true;
                
                return false;
            }
            
            // Log race condition warning
            logRaceConditionWarning(access1, access2) {
                const timeDiff = access2.timestamp - access1.timestamp;
                // Only log race conditions that are not properly handled by mutexes
                // If both operations are using mutexes, they're properly synchronized
                const isMutexProtected = access1.stackTrace?.includes('AsyncMutex') && access2.stackTrace?.includes('AsyncMutex');
                
                if (!isMutexProtected) {
                    console.warn(`⚠️ POTENTIAL RACE CONDITION DETECTED:`, {
                        resource: access1.resourceName,
                        timeDifference: `${timeDiff.toFixed(2)}ms`,
                        operations: [
                            { type: access1.operationType, operation: access1.operation },
                            { type: access2.operationType, operation: access2.operation }
                        ],
                        stackTraces: [access1.stackTrace, access2.stackTrace]
                    });
                } else {
                    // Just log a debug message for mutex-protected operations
                    console.log(`🔒 Concurrent access detected but properly synchronized via mutex:`, {
                        resource: access1.resourceName,
                        timeDifference: `${timeDiff.toFixed(2)}ms`
                    });
                }
            }
            
            // Get stack trace for debugging
            getStackTrace() {
                try {
                    throw new Error();
                } catch (e) {
                    return e.stack?.split('\n').slice(2, 5).join('\n') || 'Stack trace unavailable';
                }
            }
            
            // Get access report for a resource
            getResourceReport(resourceName) {
                const accesses = this.resourceTracking.get(resourceName) || [];
                return {
                    resourceName,
                    accessCount: accesses.length,
                    recentAccesses: accesses.slice(-10), // Last 10 accesses
                    operations: [...new Set(accesses.map(a => a.operation))]
                };
            }
            
            // Get overall monitoring report
            getMonitoringReport() {
                const resources = Array.from(this.resourceTracking.keys());
                return {
                    totalResources: resources.length,
                    totalAccesses: this.accessLog.length,
                    monitoredResources: resources.map(r => this.getResourceReport(r)),
                    recentWarnings: this.getRecentWarnings()
                };
            }
            
            // Get recent race condition warnings
            getRecentWarnings() {
                // This would need to be implemented to track warnings separately
                // For now, just return a placeholder
                return [];
            }
            
            // Enable/disable monitoring
            setEnabled(enabled) {
                this.enabled = enabled;
                console.log(`🔍 Race Condition Monitor: ${enabled ? 'ENABLED' : 'DISABLED'}`);
            }
            
            // Clear all tracking data
            clear() {
                this.accessLog = [];
                this.resourceTracking.clear();
                console.log('🧹 Race Condition Monitor: Cleared all tracking data');
            }
        }
        
        // Create global race condition monitor
        const raceConditionMonitor = new RaceConditionMonitor();
        window.raceConditionMonitor = raceConditionMonitor;
        
        // Helper function for easy race condition tracking
        window.trackResourceAccess = (resource, operation, type = 'read', metadata = {}) => {
            raceConditionMonitor.trackAccess(resource, operation, type, metadata);
        };

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ UNIFIED DOCK SYSTEM
          ║ Replaces CSS-based dock with canvas-rendered previews matching physics
          ║ Maintains existing functionality while implementing unified appearance
          ╚═══════════════════════════════════════════════════════════════════════════*/
        function rebuildGameDock() {
            return rebuildGameDockAsync();
        }

        // Dock rebuild protection variables
        let dockRebuildInProgress = false;
        let pendingDockRebuild = null;

        async function rebuildGameDockAsync() {
            raceConditionDebugger.trackOperation('rebuildGameDockAsync', 'dock-system');
            
            // If already rebuilding, queue this request
            if (dockRebuildInProgress) {
                debugLog('⚠️ Dock rebuild already in progress, queueing request');
                
                if (!pendingDockRebuild) {
                    pendingDockRebuild = new Promise((resolve) => {
                        const checkInterval = setInterval(() => {
                            if (!dockRebuildInProgress) {
                                clearInterval(checkInterval);
                                rebuildGameDockAsync().then(resolve);
                            }
                        }, 100);
                    });
                }
                return pendingDockRebuild;
            }
            
            dockRebuildInProgress = true;
            
            try {
                debugLog('🔨 Starting dock rebuild...');
            
            // Track dock access for race condition monitoring
            raceConditionMonitor.trackAccess('dock-system', 'rebuildGameDock', 'write', {
                source: 'rebuildGameDockAsync'
            });
            
            // Use dock mutex to prevent concurrent dock operations
            return await dockMutex.execute(async () => {
                // Show initial loading state
                dockLoadingManager.showLoading('Initializing dock...');
                
                const dockingArea = document.getElementById('dockingArea');
            if (!dockingArea) {
                dockLoadingManager.showError('Docking area not found in DOM');
                console.error('❌ Docking area not found!');
                return;
            }

            // Wait for AssetManager to be ready
            if (!window.assetManager) {
                dockLoadingManager.showLoading('Waiting for AssetManager...');
                debugLog('⚠️ AssetManager not available, deferring dock rebuild');
                setTimeout(() => rebuildGameDock(), 100);
                return;
            }

            // Ensure current theme is loaded - check multiple sources for current theme
            let currentTheme = window.assetManager.getCurrentTheme();
            let currentThemeName = currentTheme?.name;
            
            // If AssetManager doesn't have current theme, check theme selector dropdown
            if (!currentThemeName) {
                const themeSelector = document.getElementById('themeSelector');
                if (themeSelector && themeSelector.value) {
                    currentThemeName = themeSelector.value;
                    debugLog(`🔍 Using theme from selector: ${currentThemeName}`);
                }
            }
            
            // If still no theme, use default
            if (!currentThemeName) {
                currentThemeName = CANVAS_CONFIG.defaultTheme;
                debugLog(`🔍 Falling back to default theme: ${currentThemeName}`);
            }
            
            // Load the theme if not already loaded
            if (!currentTheme || currentTheme.name !== currentThemeName) {
                // Additional check to prevent duplicate loading
                if (!window.assetManager.themes[currentThemeName]?.loaded) {
                    debugLog(`⏳ Loading theme '${currentThemeName}' before building dock...`);
                    await window.assetManager.loadTheme(currentThemeName);
                }
                currentTheme = window.assetManager.getCurrentTheme();
            }

            dockingSpecialEffectsManager.reset();
            
            debugLog('🔧 Building dock with loaded theme:', currentTheme?.name);

            // Always use current configuration instead of delegating to GameManager
            // This ensures design mode changes are preserved
            debugLog('🎯 Building dock from current configuration (not delegating to GameManager)');

            // Get current dock shapes from level config or fallback to all shapes
            const dockShapes = window.currentLevelConfig ? window.currentLevelConfig.dockShapes : getAllShapeTypes();
            debugLog('📦 Building dock with shapes:', dockShapes);

            let levelSlotData = [];
            if (window.gameManager && window.gameManager.levelData &&
                window.gameManager.levelData.dock && Array.isArray(window.gameManager.levelData.dock.slots)) {
                levelSlotData = window.gameManager.levelData.dock.slots.slice();
            }

            // Clear existing dock
            dockingArea.innerHTML = '';
            dockingArea.classList.remove('loading');
            
            // Build dock slots with shapes
            dockShapes.forEach((shapeType, index) => {
                const slot = document.createElement('div');
                slot.className = 'shape-slot';
                slot.dataset.slotIndex = index;
                
                // Find corresponding level slot data for special effects
                const levelSlot = levelSlotData.find(slotData => slotData.slotIndex === index);
                
                // Set special type data attribute if available
                if (levelSlot && levelSlot.specialType && levelSlot.specialType.type) {
                    slot.dataset.specialType = levelSlot.specialType.type;
                }
                
                // Create shape preview
                const shapePreview = shapeRenderer.createDockPreview(shapeType, 90);
                if (shapePreview) {
                    shapePreview.classList.add('game-shape');
                    shapePreview.dataset.shape = shapeType;
                    
                    // Add shape ID if available from level data
                    if (levelSlot && levelSlot.shapeId) {
                        shapePreview.dataset.shapeId = levelSlot.shapeId;
                        shapePreview.id = `shape-${levelSlot.shapeId}`;
                    }
                    
                    // Handle LOCKED shapes
                    if (levelSlot && levelSlot.specialType && levelSlot.specialType.type === 'LOCKED') {
                        shapePreview.classList.add('locked');
                        const lockIcon = document.createElement('div');
                        lockIcon.className = 'lock-icon';
                        lockIcon.innerHTML = `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" style="filter: drop-shadow(0 0 2px rgba(0,0,0,0.7));"><rect x="5" y="11" width="14" height="10" rx="2" fill="white" fill-opacity="0.9"/><path d="M8 11V7C8 4.79086 9.79086 3 12 3C14.2091 3 16 4.79086 16 7V11" stroke="white" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" stroke-opacity="0.9"/></svg>`;
                        slot.appendChild(lockIcon);
                    }
                    
                    slot.appendChild(shapePreview);
                    
                    // Register special effects for non-LOCKED special types
                    if (levelSlot && levelSlot.specialType && levelSlot.specialType.type && levelSlot.specialType.type !== 'LOCKED') {
                        console.log(`🎨 Registering special effect for slot ${index}:`, { shapeType: shapeType, specialType: levelSlot.specialType });
                        dockingSpecialEffectsManager.register(shapePreview, levelSlot.specialType);
                    } else if (levelSlot && levelSlot.specialType) {
                        console.log(`⚪ Skipping special effect registration for slot ${index}:`, { 
                            shapeType: shapeType, 
                            specialType: levelSlot.specialType.type,
                            reason: levelSlot.specialType.type === 'LOCKED' ? 'LOCKED type uses CSS styling' : 'No special type'
                        });
                    }
                } else {
                    console.warn(`⚠️ Failed to create shape preview for ${shapeType}`);
                }
                
                dockingArea.appendChild(slot);
                debugLog(`� Added ${shapeType} to dock slot ${index}`);
            });

            console.log(`✅ Dock rebuilt with ${dockShapes.length} shapes`);
            
            // Hide loading state when complete
            dockLoadingManager.hideLoading();
            
            }, 'dock-rebuild'); // Close dockMutex.execute
            } finally {
                dockRebuildInProgress = false;
                pendingDockRebuild = null;
            }
        }

        // Initialize unified dock system (called after level config is ready)
        function initializeUnifiedDockSystem() {
            console.log('� Initializing Unified Dock System...');
            rebuildGameDock();
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ ENHANCED PHYSICS MANAGER WITH EVENT SYSTEM
          ║ Phase 4.1: Implements collision detection, fall detection, and physics events
          ║ Integrates physics events with game state for advanced game mechanics.
          ╚═══════════════════════════════════════════════════════════════════════════*/
        /*
         * PhysicsManager - Matter.js + Canvas2D Integration
         * 
         * Core physics engine management with Canvas2D-only visualization.
         * Handles all physics simulation, collision detection, and visual rendering
         * through optimized Canvas2D operations.
         * 
         * Architecture:
         * • Matter.js physics engine
         * • Canvas2D shape rendering and visualization
         * • Event-driven collision and interaction system
         * • Performance-optimized rendering pipeline
         */
        class PhysicsManager {
            constructor(canvas, physicsData = {}) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                
                // Matter.js aliases for cleaner code
                this.Engine = Matter.Engine;
                this.World = Matter.World;
                this.Bodies = Matter.Bodies;
                this.Body = Matter.Body;
                this.Events = Matter.Events;
                
                // Event tracking
                this.eventCount = 0;
                this.collisionCount = 0;
                this.fallCount = 0;
                
                // Canvas Enhancement System
                // Use shared AssetManager to ensure theme synchronization
                this.assetManager = window.assetManager || new AssetManager();
                if (!window.assetManager) {
                    window.assetManager = this.assetManager;
                }
                console.log('🔗 PhysicsManager: Using shared AssetManager for theme synchronization');
                
                // Use the existing global texture management system
                debugLog('🖼️ PhysicsManager: Using global texture management system');
                this.particleSystem = new ParticleSystem(canvas, this.assetManager);
                
                // Canvas-only renderer system
                this.rendererManager = new RendererManager(canvas);
                
                console.log('🎮 PhysicsManager with Canvas renderer initialized');
                
                // Theme-based rendering properties
                this.backgroundGradient = null;
                this.platformColor = '#8B4513';
                
                console.log('🎨 Canvas Enhancement System initialized');
                
                // Initialize with default theme
                this.initializeDefaultTheme();
                
                // Resize canvas to container
                this.resizeCanvas();
                
                // Create Matter.js world with physics engine
                this.engine = this.Engine.create();
                this.world = this.engine.world;
                
                // Set gravity from physics data or fallback to defaults
                this.engine.world.gravity.x = physicsData.gravity?.x || 0;
                this.engine.world.gravity.y = physicsData.gravity?.y || 1;
                
                // Track all dynamic bodies for rendering and cleanup
                this.dynamicBodies = [];
                // Track platform bodies for clearing when loading from data
                this.platformBodies = [];
                // Store shape defaults and materials for future use
                this.shapeDefaults = physicsData.shapeDefaults || {};
                this.materials = physicsData.materials || {};
                
                // Explosion timer system
                this.explosionTimers = [];
                this.lastExplosionId = 0;

                /*══════════════════════════════════════════════════════════════════════════
                  ║ PULSE MANAGEMENT SYSTEM
                  ║ Handles accelerating pulse effects for fire and timer shapes
                  ╚═══════════════════════════════════════════════════════════════════════════*/
                this.pulseManager = {
                    activePulses: new Map(), // bodyId -> pulseState
                    lastPulseId: 0
                };

                // Camera shake system
                this.cameraShake = {
                    active: false,
                    intensity: 0,
                    duration: 0,
                    elapsed: 0,
                    frequencyX: 0.1,
                    frequencyY: 0.1,
                    offsetX: 0,
                    offsetY: 0
                };
                
                // Setup physics event listeners
                this.setupPhysicsEvents();
                
                // Create game platform and boundaries
                this.createPlatform();
                this.createBoundaries();
                
                // Start render loop
                this.startRenderLoop();
                
                console.log('🌍 Enhanced Physics Manager with Events initialized');
            }

            // Canvas Enhancement: Initialize default theme
            async initializeDefaultTheme() {
                try {
                    // Check if default theme is already loaded
                    if (!this.assetManager.themes[CANVAS_CONFIG.defaultTheme]?.loaded) {
                        await this.assetManager.loadTheme(CANVAS_CONFIG.defaultTheme);
                    }
                    const bgStyle = this.assetManager.getBackgroundStyle();
                    if (bgStyle && bgStyle.type === 'gradient') {
                        this.backgroundGradient = bgStyle.colors;
                    }
                    const platformStyle = this.assetManager.getPlatformStyle();
                    if (platformStyle) {
                        this.platformColor = platformStyle.color;
                    }
                    console.log(`🎨 Default theme initialized: ${CANVAS_CONFIG.defaultTheme}`);
                } catch (error) {
                    console.error('❌ Failed to initialize default theme:', error);
                }
            }


            setupPhysicsEvents() {
                // Matter.js collision detection - when shapes start touching
                this.Events.on(this.engine, 'collisionStart', (event) => {
                    event.pairs.forEach(pair => {
                        this.handleBeginContact(pair);
                    });
                });
                
                // Matter.js collision end - when shapes stop touching  
                this.Events.on(this.engine, 'collisionEnd', (event) => {
                    event.pairs.forEach(pair => {
                        this.handleEndContact(pair);
                    });
                });
                
                console.log('🎯 Matter.js event listeners configured');
            }

            handleBeginContact(pair) {
                const bodyA = pair.bodyA;
                const bodyB = pair.bodyB;
                const userDataA = bodyA.userData || {};
                const userDataB = bodyB.userData || {};

                console.log(`🔍 RAW COLLISION: bodyA.userData =`, userDataA, `bodyB.userData =`, userDataB);

                // VALIDATION: Check userData integrity
                if (Object.keys(userDataA).length === 0 && Object.keys(userDataB).length === 0) {
                    console.error(`❌ CRITICAL: Both collision bodies have empty userData!`);
                    console.error(`  BodyA:`, { id: bodyA.id, label: bodyA.label, parts: bodyA.parts?.length });
                    console.error(`  BodyB:`, { id: bodyB.id, label: bodyB.label, parts: bodyB.parts?.length });
                } else if (Object.keys(userDataA).length === 0) {
                    console.warn(`⚠️ Body A has empty userData:`, { id: bodyA.id, label: bodyA.label, parts: bodyA.parts?.length });
                } else if (Object.keys(userDataB).length === 0) {
                    console.warn(`⚠️ Body B has empty userData:`, { id: bodyB.id, label: bodyB.label, parts: bodyB.parts?.length });
                }

                const isFireA = userDataA.specialType?.type === 'FIRE';
                const isFireB = userDataB.specialType?.type === 'FIRE';
                if (isFireA && isFireB) {
                    // Check if either body is already part of a countdown
                    const existingTimerA = this.explosionTimers.find(t => t.shapes.has(bodyA));
                    const existingTimerB = this.explosionTimers.find(t => t.shapes.has(bodyB));

                    if (!existingTimerA && !existingTimerB) {
                        // Neither is ticking, create a new timer
                        const delayA = userDataA.specialType.explosionDelaySeconds || 1;
                        const delayB = userDataB.specialType.explosionDelaySeconds || 1;
                        const delay = Math.min(delayA, delayB); // Use the shorter delay

                        const newTimer = {
                            id: ++this.lastExplosionId,
                            timeRemaining: delay * 1000,
                            shapes: new Set([bodyA, bodyB])
                        };
                        this.explosionTimers.push(newTimer);
                        bodyA.userData.explosionTimerId = newTimer.id;
                        bodyB.userData.explosionTimerId = newTimer.id;
                        
                        // 🔥 START FIRE PULSING for both shapes
                        this.startPulsing(bodyA, 'fire');
                        this.startPulsing(bodyB, 'fire');
                        console.log(`🔥 Started pulsing for fire collision: ${bodyA.id} & ${bodyB.id}`);
                        
                    } else if (existingTimerA && !existingTimerB) {
                        // Add bodyB to timerA
                        existingTimerA.shapes.add(bodyB);
                        bodyB.userData.explosionTimerId = existingTimerA.id;
                        
                        // 🔥 START PULSING for newly added shape
                        this.startPulsing(bodyB, 'fire');
                        
                    } else if (!existingTimerA && existingTimerB) {
                        // Add bodyA to timerB
                        existingTimerB.shapes.add(bodyA);
                        bodyA.userData.explosionTimerId = existingTimerB.id;
                        
                        // 🔥 START PULSING for newly added shape
                        this.startPulsing(bodyA, 'fire');
                    } else if (existingTimerA && existingTimerB && existingTimerA.id !== existingTimerB.id) {
                        // Merge timers, keep the one with less time remaining
                        const timerToKeep = existingTimerA.timeRemaining < existingTimerB.timeRemaining ? existingTimerA : existingTimerB;
                        const timerToMerge = existingTimerA === timerToKeep ? existingTimerB : existingTimerA;

                        timerToMerge.shapes.forEach(shape => {
                            timerToKeep.shapes.add(shape);
                            shape.userData.explosionTimerId = timerToKeep.id;
                        });

                        // Remove the merged timer
                        this.explosionTimers = this.explosionTimers.filter(t => t.id !== timerToMerge.id);
                    }
                }


                this.collisionCount++;
                this.eventCount++;
                
                // Check for shape-platform collision
                if (this.isShapePlatformCollision(userDataA, userDataB)) {
                    console.log('🎯 PLATFORM COLLISION DETECTED!');
                    this.onShapeLandedOnPlatform(bodyA, bodyB);
                }
                
                // Check for shape-shape collision
                if (this.isShapeShapeCollision(userDataA, userDataB)) {
                    console.log('🔄 SHAPE-SHAPE COLLISION DETECTED!');
                    this.onShapeShapeCollision(bodyA, bodyB);
                }
                
                // Check for ground collision (fall detection)
                console.log('🧪 Testing ground collision...');
                if (this.isGroundCollision(userDataA, userDataB)) {
                    console.log('🔥 GROUND COLLISION DETECTED! Triggering shape fall...');
                    this.onShapeFellOffPlatform(bodyA, bodyB);
                } else {
                    console.log('❌ Ground collision test failed');
                }
                
                console.log(`📍 Collision detected: ${userDataA.type || 'unknown'} vs ${userDataB.type || 'unknown'}`);
            }

            handleEndContact(pair) {
                const bodyA = pair.bodyA;
                const bodyB = pair.bodyB;
                const userDataA = bodyA.userData || {};
                const userDataB = bodyB.userData || {};

            }

            triggerExplosion(position, radius = 50) {
                // Only create particle effects, no force application, as per user request.
                // The radius parameter is kept for potential future use by the particle system.
                this.particleSystem.createThemeParticles('explosion', position.x, position.y, 30);
            }

            cleanupRemovedShapeFromWeighted(removedBodyId) {
                // Clean up references in all weighted shapes
                this.dynamicBodies.forEach(body => {
                    if (body.userData?.specialType?.type === 'WEIGHTED' &&
                        body.userData.shapesOnTop?.has(removedBodyId)) {
                        body.userData.shapesOnTop.delete(removedBodyId);
                        console.log(`⚖️ Cleaned up shape ${removedBodyId} from weighted tracking`);
                    }
                });
            }

            updateSpecialShapes(deltaTime) {
                const bodiesToRemove = [];
                this.dynamicBodies.forEach(body => {
                    const specialType = body.userData.specialType?.type;
                    if (!specialType) return;

                    if (specialType === 'TIMER') {
                        const timerState = body.userData.timerState;
                        if (!timerState) return;
                        if (typeof timerState.initialCountdown !== 'number' || timerState.initialCountdown <= 0) {
                            timerState.initialCountdown = timerState.countdown;
                        }
                        const isWeightOnTop = this.dynamicBodies.some(otherBody =>
                            otherBody.id !== body.id &&
                            Math.abs(otherBody.position.x - body.position.x) < 20 &&
                            otherBody.position.y < body.position.y &&
                            Matter.Query.collides(body, [otherBody]).length > 0
                        );
                        if (isWeightOnTop && !timerState.isTicking) { 
                            timerState.isTicking = true;
                            // 🔥 START TIMER PULSING when timer starts ticking
                            this.startPulsing(body, 'timer');
                            console.log(`⏰ Started timer pulsing for body ${body.id} - countdown: ${timerState.countdown}s`);
                        }
                        if (timerState.isTicking) {
                            timerState.countdown -= deltaTime / 1000;
                            if (timerState.countdown < 0) {
                                timerState.countdown = 0;
                            }
                            if (timerState.countdown <= 0) {
                                this.triggerExplosion(body.position, body.userData.specialType.explosionRadius);
                                bodiesToRemove.push(body);
                                // 🔥 CLEANUP: Stop pulsing when timer explodes
                                this.stopPulsing(body.id);
                            }
                        }
                    }
                    
                    if (specialType === 'WEIGHTED') {
                        const weightState = body.userData.weightState;
                        if (!weightState) return;

                        const specialParams = body.userData.specialType || {};
                        const maxWeight = (typeof specialParams.maxWeight === 'number' && specialParams.maxWeight > 0)
                            ? specialParams.maxWeight
                            : WEIGHTED_DEFAULTS.maxWeight;
                        const overloadDelay = (typeof specialParams.overloadDelayMs === 'number' && specialParams.overloadDelayMs >= 0)
                            ? specialParams.overloadDelayMs
                            : WEIGHTED_DEFAULTS.overloadDelayMs;

                        specialParams.maxWeight = maxWeight;
                        specialParams.overloadDelayMs = overloadDelay;

                        const colors = {
                            ...WEIGHTED_DEFAULTS.indicatorColors,
                            ...(specialParams.indicatorColors || {})
                        };
                        specialParams.indicatorColors = colors;

                        // Use a spatial query to find all bodies stacked on top
                        const bodiesOnTop = this.getBodiesOnTop(body);
                        weightState.currentWeight = this.getRecursiveDescendants(body, this.dynamicBodies).size;
                        weightState.maxWeight = maxWeight;

                        const previousStatus = weightState.status;
                        let newStatus;
                        const currentWeight = weightState.currentWeight;

                        if (currentWeight === 0) {
                            newStatus = 'safe';
                        } else if (currentWeight === 1) {
                            newStatus = 'warning';
                        } else if (currentWeight === 2) {
                            newStatus = 'danger';
                        } else { // currentWeight >= 3
                            newStatus = 'overloaded';
                        }

                        weightState.status = newStatus;
                        specialParams.currentStatus = newStatus;
                        specialParams.currentWeight = weightState.currentWeight;

                        if (previousStatus !== newStatus) {
                            const statusColor = colors[newStatus] || (newStatus === 'overloaded' ? colors.danger : '#FFFFFF');
                            console.log(
                                `⚖️ WEIGHTED status changed to ${newStatus.toUpperCase()} (${statusColor}). ` +
                                `Current weight: ${weightState.currentWeight}/${maxWeight} (Max Weight: ${maxWeight}). ` +
                                `Ranges -> SAFE[0] (${colors.safe}), WARNING[1] (${colors.warning}), DANGER[2] (${colors.danger}), OVERLOADED[${maxWeight}+] (${colors.danger}). ` +
                                `Overload delay: ${(overloadDelay / 1000).toFixed(2)}s.`
                            );
                        }

                        const hasReachedMax = maxWeight > 0 && weightState.currentWeight >= maxWeight;

                        if (hasReachedMax) {
                            if (!weightState.overloadActive) {
                                weightState.overloadActive = true;
                                weightState.overweightTimer = 0;
                                console.log(`⏱️ WEIGHTED overload timer started (Max Weight: ${maxWeight}, Delay: ${(overloadDelay / 1000).toFixed(2)}s).`);
                            }
                            weightState.overweightTimer += deltaTime;
                            if (weightState.overweightTimer >= overloadDelay) {
                                console.log(`💥 WEIGHTED shape exceeded Max Weight ${maxWeight}. Triggering explosion.`);
                                this.triggerExplosion(body.position, specialParams.explosionRadius);
                                bodiesToRemove.push(body);
                                weightState.overloadActive = false;
                                weightState.overweightTimer = 0;
                            }
                        } else if (weightState.overloadActive) {
                            console.log(`✅ WEIGHTED overload timer cancelled. Current weight ${weightState.currentWeight}/${maxWeight}.`);
                            weightState.overloadActive = false;
                            weightState.overweightTimer = 0;
                        } else {
                            weightState.overweightTimer = 0;
                        }
                    }
                });
                
                if (bodiesToRemove.length > 0) {
                    bodiesToRemove.forEach(body => {
                        this.World.remove(this.world, body);
                        this.cleanupRemovedShapeFromWeighted(body.id);
                    });
                    this.dynamicBodies = this.dynamicBodies.filter(b => !bodiesToRemove.some(rem => rem.id === b.id));
                }
            }

            getBodiesOnTop(body) {
                const bodyBounds = body.bounds;
                const queryBounds = {
                    min: { x: bodyBounds.min.x, y: 0 },
                    max: { x: bodyBounds.max.x, y: bodyBounds.min.y }
                };

                // Query for bodies that are in the vertical column above the weighted shape
                const bodiesInRegion = Matter.Query.region(this.dynamicBodies, queryBounds);

                // Filter out the weighted body itself
                return bodiesInRegion.filter(otherBody => otherBody.id !== body.id);
            }

            updateExplosionTimers(deltaTime) {
                for (let i = this.explosionTimers.length - 1; i >= 0; i--) {
                    const timer = this.explosionTimers[i];
                    timer.timeRemaining -= deltaTime;

                    if (timer.timeRemaining <= 0) {
                        // Time's up, explode all shapes in the set
                        timer.shapes.forEach(shapeBody => {
                            // Ensure the body still exists in the world before trying to explode it
                            if (this.dynamicBodies.includes(shapeBody)) {
                                this.triggerExplosion(shapeBody.position, shapeBody.userData.specialType.explosionRadius);
                                this.World.remove(this.world, shapeBody);
                                this.cleanupRemovedShapeFromWeighted(shapeBody.id);
                                this.dynamicBodies = this.dynamicBodies.filter(b => b.id !== shapeBody.id);
                                
                                // 🔥 CLEANUP: Stop pulsing for exploded shape
                                this.stopPulsing(shapeBody.id);
                            }
                        });

                        // Remove this timer
                        this.explosionTimers.splice(i, 1);
                    }
                }
            }

            /*══════════════════════════════════════════════════════════════════════════
              ║ PULSE MANAGEMENT SYSTEM METHODS  
              ║ Handles accelerating pulse effects for fire and timer shapes
              ╚═══════════════════════════════════════════════════════════════════════════*/

            getCurrentPulseInterval(progress) {
                const initialInterval = 3050; // 3.05 seconds
                const finalInterval = 200;    // 0.2 seconds (extremely fast at the end)
    
                // Exponential decrease for more dramatic effect
                const easedProgress = 1 - Math.pow(1 - progress, 3);
                return initialInterval - (initialInterval - finalInterval) * easedProgress;
            }

            calculateTimerPulse(pulseState, currentTime) {
                if (!pulseState.isTicking) return { isPulsing: false, pulseIntensity: 0 };
    
                const totalDuration = pulseState.initialCountdown || 1;
                const remaining = Math.max(pulseState.countdown || 0, 0);
                const progress = Math.min(1 - (remaining / totalDuration), 1); // 0 = start, 1 = expired
    
                // Get current pulse interval in milliseconds
                const currentInterval = this.getCurrentPulseInterval(progress);
    
                // Initialize pulse tracking if not exists
                if (!pulseState.lastPulseTime) {
                    pulseState.lastPulseTime = currentTime;
                    pulseState.pulseStartTime = currentTime;
                    pulseState.isPulseActive = false;
                }
    
                // Check if we should start a new pulse
                const timeSinceLastPulse = currentTime - pulseState.lastPulseTime;
    
                if (!pulseState.isPulseActive && timeSinceLastPulse >= currentInterval) {
                    // Start new pulse
                    pulseState.isPulseActive = true;
                    pulseState.pulseStartTime = currentTime;
                    pulseState.lastPulseTime = currentTime;
                }
    
                // Handle active pulse
                let isPulsing = false;
                let pulseIntensity = 0;
    
                if (pulseState.isPulseActive) {
                    const pulseDuration = 200; // Duration of each pulse in ms
                    const pulseProgress = (currentTime - pulseState.pulseStartTime) / pulseDuration;
        
                    if (pulseProgress >= 1) {
                        // End current pulse
                        pulseState.isPulseActive = false;
                        isPulsing = false;
                        pulseIntensity = 0;
                    } else {
                        // Calculate smooth pulse intensity using sine wave
                        isPulsing = true;
                        pulseIntensity = Math.sin(pulseProgress * Math.PI); // Smooth 0->1->0 curve
                    }
                }
    
                return {
                    isPulsing,
                    pulseIntensity,
                    progress,
                    currentInterval,
                    pulsesPerSecond: 1000 / currentInterval // For debugging/display
                };
            }

            // Calculate fire collision pulse (based on proximity or countdown)
            calculateFirePulse(fireState, currentTime) {
                if (!fireState.isCountingDown) return { isPulsing: false, pulseIntensity: 0 };

                const totalDuration = fireState.explosionDelay || 1000; // Default 1 second
                const elapsed = currentTime - fireState.countdownStartTime;
                const remaining = Math.max(totalDuration - elapsed, 0);
                const progress = Math.min(elapsed / totalDuration, 1); // 0 = start, 1 = explosion

                // Use same pulse interval calculation as timers
                const currentInterval = this.getCurrentPulseInterval(progress);

                // Initialize pulse tracking if not exists
                if (!fireState.lastPulseTime) {
                    fireState.lastPulseTime = currentTime;
                    fireState.pulseStartTime = currentTime;
                    fireState.isPulseActive = false;
                }

                // Check if we should start a new pulse
                const timeSinceLastPulse = currentTime - fireState.lastPulseTime;

                if (!fireState.isPulseActive && timeSinceLastPulse >= currentInterval) {
                    // Start new pulse
                    fireState.isPulseActive = true;
                    fireState.pulseStartTime = currentTime;
                    fireState.lastPulseTime = currentTime;
                }

                // Handle active pulse
                let isPulsing = false;
                let pulseIntensity = 0;

                if (fireState.isPulseActive) {
                    const pulseDuration = 200; // Duration of each pulse in ms
                    const pulseProgress = (currentTime - fireState.pulseStartTime) / pulseDuration;

                    if (pulseProgress >= 1) {
                        // End current pulse
                        fireState.isPulseActive = false;
                        isPulsing = false;
                        pulseIntensity = 0;
                    } else {
                        // Calculate smooth pulse intensity using sine wave
                        isPulsing = true;
                        pulseIntensity = Math.sin(pulseProgress * Math.PI); // Smooth 0->1->0 curve
                    }
                }

                return {
                    isPulsing,
                    pulseIntensity,
                    progress,
                    currentInterval,
                    pulsesPerSecond: 1000 / currentInterval // For debugging/display
                };
            }

            // Update all active pulse states
            updatePulseStates(currentTime) {
                this.pulseManager.activePulses.forEach((pulseState, bodyId) => {
                    const body = this.dynamicBodies.find(b => b.id === bodyId);
                    if (!body) {
                        // Body no longer exists, clean up pulse state
                        this.pulseManager.activePulses.delete(bodyId);
                        return;
                    }

                    const userData = body.userData;
                    if (userData.specialType?.type === 'FIRE') {
                        // Update fire pulse state
                        const pulseResult = this.calculateFirePulse(pulseState, currentTime);
                        Object.assign(pulseState, pulseResult);
                    } else if (userData.specialType?.type === 'TIMER') {
                        // Sync timer data from body's timerState to pulseState
                        const timerState = userData.timerState;
                        if (timerState) {
                            pulseState.isTicking = timerState.isTicking;
                            pulseState.countdown = timerState.countdown;
                            pulseState.initialCountdown = timerState.initialCountdown;
                        }
                        
                        // Update timer pulse state  
                        const pulseResult = this.calculateTimerPulse(pulseState, currentTime);
                        Object.assign(pulseState, pulseResult);
                    }
                });
            }

            // Start pulsing for a shape
            startPulsing(body, pulseType = 'fire') {
                const bodyId = body.id;
                if (this.pulseManager.activePulses.has(bodyId)) {
                    return; // Already pulsing
                }

                const currentTime = performance.now();
                const pulseState = {
                    id: ++this.pulseManager.lastPulseId,
                    bodyId: bodyId,
                    type: pulseType,
                    startTime: currentTime,
                    lastPulseTime: 0,
                    pulseStartTime: 0,
                    isPulseActive: false,
                    isPulsing: false,
                    pulseIntensity: 0,
                    progress: 0,
                    currentInterval: 3050,
                    // Fire-specific
                    isCountingDown: pulseType === 'fire',
                    explosionDelay: body.userData.specialType?.explosionDelaySeconds * 1000 || 1000,
                    countdownStartTime: currentTime,
                    // Timer-specific - get from actual timer state
                    isTicking: pulseType === 'timer' ? (body.userData.timerState?.isTicking || false) : false,
                    initialCountdown: pulseType === 'timer' ? (body.userData.timerState?.initialCountdown || body.userData.timerState?.countdown || 10) : 10000,
                    countdown: pulseType === 'timer' ? (body.userData.timerState?.countdown || 10) : 10000
                };

                this.pulseManager.activePulses.set(bodyId, pulseState);
                console.log(`✨ Started ${pulseType} pulsing for body ${bodyId}`);
            }

            // Stop pulsing for a shape
            stopPulsing(bodyId) {
                if (this.pulseManager.activePulses.has(bodyId)) {
                    this.pulseManager.activePulses.delete(bodyId);
                    console.log(`⏹️ Stopped pulsing for body ${bodyId}`);
                }
            }

            // Apply visual pulse effects to canvas context
            applyPulseEffects(pulseIntensity, hasTexture = false) {
                if (pulseIntensity <= 0) return;

                // Different effects for texture vs fallback colors
                if (hasTexture) {
                    // For textures, use composite operations and filters
                    
                    // 1. Brightness pulse - makes texture flash brighter
                    const brightness = 1 + (pulseIntensity * 0.5); // 0.5x boost at peak
                    this.ctx.filter = `brightness(${brightness})`;
                    
                    // 2. Add white overlay for dramatic effect
                    const overlayAlpha = pulseIntensity * 0.3; // Max 30% white overlay
                    this.ctx.globalCompositeOperation = 'screen';
                    this.ctx.globalAlpha = overlayAlpha;
                    
                } else {
                    // For solid colors, apply white tint overlay
                    const whiteIntensity = pulseIntensity * 0.8; // Strong white pulse
                    this.ctx.globalCompositeOperation = 'screen';
                    this.ctx.globalAlpha = whiteIntensity;
                    this.ctx.fillStyle = 'white';
                }
            }

            // Reset pulse effects after rendering
            resetPulseEffects() {
                this.ctx.filter = 'none';
                this.ctx.globalCompositeOperation = 'source-over';
                this.ctx.globalAlpha = 1.0;
            }

            getRecursiveDescendants(body, allBodies) {
                return this._getRecursiveDescendants(body, allBodies, new Set());
            }

            _getRecursiveDescendants(body, allBodies, visited) {
                if (visited.has(body.id)) {
                    return new Set();
                }
                visited.add(body.id);

                const bodiesOnTop = this.getBodiesOnTop(body);
                let descendants = new Set(bodiesOnTop);

                for (const topBody of bodiesOnTop) {
                    const topBodyDescendants = this._getRecursiveDescendants(topBody, allBodies, visited);
                    for (const d of topBodyDescendants) {
                        descendants.add(d);
                    }
                }
                return descendants;
            }

            isShapePlatformCollision(dataA, dataB) {
                const shapeTypes = ['shape', 'compound', 'rectangle', 'polygon', 'circle'];
                const isAShape = shapeTypes.includes(dataA.type);
                const isBShape = shapeTypes.includes(dataB.type);
                
                return (isAShape && dataB.type === 'platform') ||
                       (dataA.type === 'platform' && isBShape);
            }

            isShapeShapeCollision(dataA, dataB) {
                const shapeTypes = ['shape', 'compound', 'rectangle', 'polygon', 'circle'];
                const isAShape = shapeTypes.includes(dataA.type);
                const isBShape = shapeTypes.includes(dataB.type);
                
                return isAShape && isBShape;
            }

            isGroundCollision(dataA, dataB) {
                // More robust shape type detection
                const shapeTypes = ['shape', 'compound', 'rectangle', 'polygon', 'circle'];
                const isAShape = shapeTypes.includes(dataA.type) || dataA.shapeType;
                const isBShape = shapeTypes.includes(dataB.type) || dataB.shapeType;
                
                // Check for ground collision
                const isAGround = dataA.type === 'ground' || dataA.name === 'fallDetectionBoundary';
                const isBGround = dataB.type === 'ground' || dataB.name === 'fallDetectionBoundary';
                
                const result = (isAShape && isBGround) || (isAGround && isBShape);
                              
                if (result) {
                    console.log(`🎯 Ground collision detected: ${dataA.type || dataA.shapeType || 'unknown'} vs ${dataB.type || dataB.shapeType || 'unknown'}`);
                    console.log(`  - A: type="${dataA.type}", shapeType="${dataA.shapeType}", name="${dataA.name}"`);
                    console.log(`  - B: type="${dataB.type}", shapeType="${dataB.shapeType}", name="${dataB.name}"`);
                } else {
                    console.log(`❌ Not a ground collision: A(${dataA.type || dataA.shapeType || 'unknown'}) vs B(${dataB.type || dataB.shapeType || 'unknown'})`);
                }
                
                return result;
            }

            onShapeLandedOnPlatform(bodyA, bodyB) {
                console.log('🎯 Shape landed on platform!');
                this.showEventNotification('Shape Landed!', 'collision');
                
                // Phase 3: Trigger platform landing animation
                this.triggerCollisionAnimation(bodyA, bodyB, 'platform');
                
                // Trigger game event
                if (window.gameManager) {
                    window.gameManager.onShapeLandedOnPlatform();
                }
            }

            onShapeShapeCollision(bodyA, bodyB) {
                console.log('🔄 Shape collision detected!');
                this.showEventNotification('Shape Contact!', 'balance');
                
                // Phase 3: Trigger collision flash animation
                this.triggerCollisionAnimation(bodyA, bodyB, 'collision');
                
                // Trigger game event
                if (window.gameManager) {
                    window.gameManager.onShapeCollision();
                }
            }

            // Phase 3: Animation trigger helper - PixiJS removed
            triggerCollisionAnimation(bodyA, bodyB, animationType) {
                // PixiJS animation system removed - no animations available
                console.log(`🎬 Animation skipped: ${animationType} (PixiJS removed)`);
                return;
            }

            findShapeBody(bodyA, bodyB) {
                // Return the body that represents a shape (not platform/ground/boundary)
                const userDataA = bodyA.userData || {};
                const userDataB = bodyB.userData || {};
                
                if (userDataA.shapeType && userDataA.type !== 'platform' && userDataA.type !== 'ground' && userDataA.type !== 'boundary') {
                    return bodyA;
                }
                
                if (userDataB.shapeType && userDataB.type !== 'platform' && userDataB.type !== 'ground' && userDataB.type !== 'boundary') {
                    return bodyB;
                }
                
                return null;
            }

            onShapeFellOffPlatform(bodyA, bodyB) {
                console.log('💥 Shape fell off platform!');
                this.fallCount++;
                
                this.showEventNotification('Shape Fell!', 'fall');
                
                // Trigger game event
                if (window.gameManager) {
                    window.gameManager.onShapeFell();
                }
            }

            showEventNotification(message, type) {
                const notification = document.getElementById('eventNotification');
                notification.textContent = message;
                notification.className = `event-notification ${type} show`;
                
                setTimeout(() => {
                    notification.classList.remove('show');
                }, 2000);
            }

            resizeCanvas() {
                const container = this.canvas.parentElement;
                this.canvas.width = container.clientWidth;
                this.canvas.height = container.clientHeight;
                console.log(`📐 Canvas resized to: ${this.canvas.width}x${this.canvas.height}`);
            }

            createBoundaries() {
                // Create invisible ground boundary for fall detection
                const groundY = this.canvas.height + 150; // Extended to +150 (was +50) for longer fall distance
                const groundWidth = this.canvas.width;
                
                const ground = this.Bodies.rectangle(
                    this.canvas.width / 2, 
                    groundY, 
                    groundWidth, 
                    100, 
                    {
                        isStatic: true,
                        render: { visible: false }
                    }
                );
                
                // Set user data for collision detection
                ground.userData = {
                    type: 'ground',
                    name: 'fallDetectionBoundary'
                };
                
                this.World.add(this.world, ground);
                console.log('🚧 Matter.js boundaries created');
            }

            createPlatform() {
                // Restore original angled platform (-50 degrees)
                const platformX = this.canvas.width / 2 - 30;  // Pixel coordinates
                const platformY = this.canvas.height - 20;     // Moved down 100px (was -120, now -20)
                const platformWidth = 200;
                const platformHeight = 20;
                const platformAngle = -0.873; // -50 degrees
                
                // Create angled platform with Matter.js
                const platform = this.Bodies.rectangle(
                    platformX, 
                    platformY, 
                    platformWidth, 
                    platformHeight,
                    {
                        isStatic: true,
                        angle: platformAngle,
                        render: {
                            fillStyle: '#95A5A6',
                            strokeStyle: '#7F8C8D',
                            lineWidth: 2
                        },
                        friction: 0.9,
                        restitution: 0
                    }
                );
                
                // Set user data for collision detection
                platform.userData = {
                    type: 'platform',
                    visible: true,
                    color: '#95A5A6',
                    stroke: '#7F8C8D',
                    strokeWidth: 2,
                    width: platformWidth,
                    height: platformHeight
                };
                
                this.World.add(this.world, platform);
                console.log(`🏗️ Matter.js angled platform created: -50° at (${platformX}, ${platformY})`);
            }

            /**
             * Clear all existing platforms from the physics world.
             */
            clearAllPlatforms() {
                if (!this.platformBodies) {
                    this.platformBodies = [];
                }
                this.platformBodies.forEach((body) => {
                    this.World.remove(this.world, body);
                    this.cleanupRemovedShapeFromWeighted(body.id);
                });
                this.platformBodies = [];
                console.log('🧹 Cleared all existing platforms.');
            }

            /**
             * Create a platform from the provided data configuration.
             * Supports position, scale, rotation, and fallback appearance color.
             * @param {Object} platformData
             */
            createPlatformFromData(platformData) {
                const pos = platformData.transform.position;
                const scale = platformData.transform.scale || { x: 1, y: 1 };
                const rotationDeg = platformData.transform.rotation || 0;
                const rotationRad = rotationDeg * (Math.PI / 180);
                const width = 200 * scale.x;
                const height = 20 * scale.y;
                const platform = this.Bodies.rectangle(
                    pos.x,
                    pos.y,
                    width,
                    height,
                    {
                        isStatic: true,
                        angle: rotationRad,
                        render: {
                            fillStyle: platformData.appearance?.fallbackColor || '#95A5A6',
                            strokeStyle: '#7F8C8D',
                            lineWidth: 2
                        },
                        friction: 0.9,
                        restitution: 0
                    }
                );
                platform.userData = {
                    type: 'platform',
                    id: platformData.id,
                    ...platformData
                };
                this.World.add(this.world, platform);
                if (!this.platformBodies) this.platformBodies = [];
                this.platformBodies.push(platform);
            }

            createCompoundShape(x, y, type, rotation = 0, shapeId = null) {
                // Forward to unified createShape method for consistency
                return this.createShape(x, y, type, rotation, shapeId);
            }

            createShape(x, y, type, rotation = 0, shapeId = null) {
                console.log(`🎯 Creating shape using unified system: ${type} at (${x}, ${y})`);

                // Get dock slot data FIRST to determine userData
                let dockSlotData = null;
                if (shapeId) {
                    dockSlotData = this.gameManager.levelData.dock.slots.find(slot => slot.shapeId === shapeId);
                } else {
                    // Fallback for old behavior (e.g. keyboard shortcuts for testing)
                    dockSlotData = this.gameManager.levelData.dock.slots.find(slot => slot.shapePrefabId === type && !this.dynamicBodies.some(b => b.userData.shapeId === slot.shapeId));
                }

                // Prepare userData BEFORE creating the body
                const shapeUserData = {
                    type: 'shape',
                    shapeType: type,
                    shapeId: dockSlotData?.shapeId || `shape_${Date.now()}`,
                    specialType: dockSlotData?.specialType || { type: 'REGULAR' }
                };

                // Use unified shape creation from master registry
                let body = this.createShapeFromRegistry(x, y, type, rotation, shapeUserData);

                if (!body) {
                    console.error(`❌ UNIFIED SYSTEM FAILED: Could not create shape ${type} - this should not happen!`);
                    return null;
                }

                // Get physics properties from master registry
                const physics = ShapeAttributePropagator.getPhysics(type);
                if (!physics) {
                    console.error(`❌ UNIFIED SYSTEM FAILED: No physics properties found for ${type}`);
                    return null;
                }
                
                // Set Matter.js physics properties from master registry
                body.restitution = physics.restitution;
                body.friction = physics.friction;       
                body.frictionAir = 0.02;   // Reduced air resistance to maintain manual rotation
                
                // Stabilize rotation for a brief moment after drop
                const originalAngularVelocity = body.angularVelocity;
                body.angularVelocity = 0; // Stop any spinning from collision
                
                // After a short delay, allow normal physics
                setTimeout(() => {
                    if (body && body.angularVelocity === 0) {
                        body.frictionAir = 0.05; // Restore normal air resistance
                    }
                }, 100); // Brief stabilization period

                // Initialize special type states
                if (body.userData.specialType.type === 'TIMER') {
                    body.userData.timerState = {
                        countdown: body.userData.specialType.countdownSeconds,
                        initialCountdown: body.userData.specialType.countdownSeconds,
                        isTicking: false
                    };
                }
                if (body.userData.specialType.type === 'WEIGHTED') {
                    const weightedConfig = body.userData.specialType;
                    const maxWeight = (typeof weightedConfig.maxWeight === 'number' && weightedConfig.maxWeight > 0)
                        ? weightedConfig.maxWeight
                        : WEIGHTED_DEFAULTS.maxWeight;
                    const overloadDelay = (typeof weightedConfig.overloadDelayMs === 'number' && weightedConfig.overloadDelayMs >= 0)
                        ? weightedConfig.overloadDelayMs
                        : WEIGHTED_DEFAULTS.overloadDelayMs;

                    weightedConfig.maxWeight = maxWeight;
                    weightedConfig.overloadDelayMs = overloadDelay;
                    weightedConfig.indicatorColors = {
                        ...WEIGHTED_DEFAULTS.indicatorColors,
                        ...(weightedConfig.indicatorColors || {})
                    };

                    body.userData.weightState = {
                        currentWeight: 0,
                        status: 'safe',
                        maxWeight,
                        overweightTimer: 0,
                        overloadActive: false
                    };
                    console.log(`⚖️ Weighted shape initialized with Max Weight ${maxWeight} and overload delay ${(overloadDelay / 1000).toFixed(2)}s.`);
                    if (body.userData.specialType?.type === 'WEIGHTED') {
                        // Initialize shapes tracking
                        body.userData.shapesOnTop = new Set();
                        console.log(`⚖️ Initialized collision tracking for weighted shape`);
                    }
                }
                console.log(`🏷️ Shape userData set:`, body.userData);

                this.World.add(this.world, body);
                this.dynamicBodies.push(body);

                console.log(`✅ Matter.js ${type} created successfully`);
                return body;
            }

            createMatterCompoundShape(x, y, type, rotation, config) {
                console.log(`🎯 Creating Matter.js compound shape: ${type} using SHAPE_CONFIG`);
                
                if (!config.parts || config.parts.length === 0) {
                    console.error(`❌ No parts defined for compound shape: ${type}`);
                    return null;
                }
                
                const bodyParts = [];
                
                // Create each part based on SHAPE_CONFIG specification
                config.parts.forEach((partConfig, index) => {
                    // Use relative positioning for compound body parts
                    const partX = x + (partConfig.offsetX || 0);
                    const partY = y + (partConfig.offsetY || 0);
                    let bodyPart = null;
                    
                    if (partConfig.type === 'rectangle') {
                        bodyPart = this.Bodies.rectangle(partX, partY, partConfig.width, partConfig.height, {
                            render: {
                                fillStyle: partConfig.color || config.color,
                                strokeStyle: partConfig.stroke || config.stroke,
                                lineWidth: config.strokeWidth || 2
                            }
                        });
                    } else if (partConfig.type === 'circle') {
                        bodyPart = this.Bodies.circle(partX, partY, partConfig.radius, {
                            render: {
                                fillStyle: partConfig.color || config.color,
                                strokeStyle: partConfig.stroke || config.stroke,
                                lineWidth: config.strokeWidth || 2
                            }
                        });
                    } else if (partConfig.type === 'diamond') {
                        // Create diamond as a rotated square
                        // For a diamond with width/height, we need to calculate the proper radius
                        const width = partConfig.width || 12;
                        const height = partConfig.height || 12;
                        // Use the smaller dimension and adjust for the rotated square geometry
                        const effectiveSize = Math.min(width, height);
                        const radius = effectiveSize / 2; // Half the size for proper diamond dimensions
                        
                        bodyPart = this.Bodies.polygon(partX, partY, 4, radius, {
                            angle: Math.PI / 4, // 45 degree rotation for diamond
                            render: {
                                fillStyle: partConfig.color || config.color,
                                strokeStyle: partConfig.stroke || config.stroke,
                                lineWidth: config.strokeWidth || 2
                            }
                        });
                    }
                    
                    if (bodyPart) {
                        bodyParts.push(bodyPart);
                        console.log(`✅ Created ${partConfig.type} part at offset (${partConfig.offsetX}, ${partConfig.offsetY})`);
                    }
                });
                
                if (bodyParts.length === 0) {
                    console.error(`❌ No body parts created for compound shape: ${type}`);
                    return null;
                }
                
                // Create compound body and then rotate it smoothly
                const compoundBody = this.Body.create({
                    parts: bodyParts
                });
                
                // Apply rotation after creation to prevent snapping
                if (rotation !== 0) {
                    this.Body.setAngle(compoundBody, rotation);
                }
                
                // CRITICAL: Set userData on compound body AND all parts
                const userData = {
                    type: 'compound',
                    shapeType: type,
                    ...config
                };
                
                compoundBody.userData = userData;
                
                // Also set userData on all parts so collision detection works
                bodyParts.forEach(part => {
                    part.userData = userData;
                });
                
                console.log(`🏷️ Compound shape userData set on main body and ${bodyParts.length} parts:`, userData);
                console.log(`✅ Matter.js compound shape ${type} created with ${bodyParts.length} parts, rotated ${(rotation * 180 / Math.PI).toFixed(1)}°`);
                return compoundBody;
            }

            createMatterSimpleShape(x, y, type, rotation, config) {
                console.log(`🎯 Creating Matter.js simple shape: ${type}`);
                
                let body = null;

                // Create shape based on type
                if (type === 'square') {
                    body = this.Bodies.rectangle(x, y, config.width || 50, config.height || 50, {
                        angle: rotation,
                        render: {
                            fillStyle: config.color || '#FFD700',
                            strokeStyle: config.stroke || '#FFA500',
                            lineWidth: config.strokeWidth || 2
                        }
                    });
                } else if (type === 'triangle') {
                    // Create triangle using polygon but fix the default orientation
                    // Matter.js Bodies.polygon(x, y, 3, radius) creates triangle with different default rotation
                    const sides = 3;
                    const radius = 20; // Match approximate size of our config vertices
                    
                    // Add Math.PI/2 (90 degrees) to align with our triangle config (point up)
                    const adjustedRotation = rotation + Math.PI/2;
                    
                    body = this.Bodies.polygon(x, y, sides, radius, {
                        angle: adjustedRotation,
                        render: {
                            fillStyle: config.color || '#9B59B6',
                            strokeStyle: config.stroke || '#8E44AD',
                            lineWidth: config.strokeWidth || 2
                        }
                    });
                    
                    console.log(`🔺 Triangle created with 90° adjustment, final rotation ${(adjustedRotation * 180 / Math.PI).toFixed(1)}°`);
                } else if (type === 'circle') {
                    body = this.Bodies.circle(x, y, config.radius || 25, {
                        render: {
                            fillStyle: config.color || '#1ABC9C',
                            strokeStyle: config.stroke || '#16A085',
                            lineWidth: config.strokeWidth || 2
                        }
                    });
                }

                if (body) {
                    // Set userData on simple shape body  
                    body.userData = {
                        type: config.type || 'rectangle', // Use config type (rectangle, polygon, circle)
                        shapeType: type,
                        ...config
                    };
                    console.log(`🏷️ Simple shape userData set:`, body.userData);
                }

                console.log(`✅ Matter.js simple shape ${type} created`);
                return body;
            }

            // Unified shape creation using master registry
            createShapeFromRegistry(x, y, shapeType, rotation = 0, userData = null) {
                console.log(`🎯 Creating shape from master registry: ${shapeType}`);
                
                // Debug: Check if MASTER_SHAPE_REGISTRY exists and has the shape
                if (!MASTER_SHAPE_REGISTRY) {
                    console.error(`❌ MASTER_SHAPE_REGISTRY is not defined!`);
                    return null;
                }
                
                if (!MASTER_SHAPE_REGISTRY[shapeType]) {
                    console.error(`❌ Shape type '${shapeType}' not found in master registry. Available shapes:`, Object.keys(MASTER_SHAPE_REGISTRY));
                    return null;
                }
                
                const masterConfig = MASTER_SHAPE_REGISTRY[shapeType];
                console.log(`🔍 DEBUG: Master config for ${shapeType}:`, masterConfig);

                const geometry = masterConfig.geometry;
                const physics = masterConfig.physics;
                const visual = masterConfig.visual;
                
                if (!geometry || !physics || !visual) {
                    console.error(`❌ Incomplete master config for ${shapeType}:`, { geometry, physics, visual });
                    return null;
                }
                
                // Get themed visual properties (colors/textures) for current theme
                const themedShapeConfig = getShapeConfig(shapeType);
                const themedVisual = {
                    color: themedShapeConfig?.color || visual.color,
                    stroke: themedShapeConfig?.stroke || visual.stroke,
                    strokeWidth: themedShapeConfig?.strokeWidth || visual.strokeWidth
                };
                
                console.log(`🎨 Using themed visual for ${shapeType}:`, themedVisual);
                
                let body = null;

                // Create physics body based on geometry type
                console.log(`🔍 DEBUG: Creating ${geometry.type} body for ${shapeType}`);
                switch (geometry.type) {
                    case 'rectangle':
                        body = this.Bodies.rectangle(x, y, geometry.width, geometry.height, {
                            angle: rotation,
                            density: physics.density,
                            friction: physics.friction,
                            restitution: physics.restitution,
                            render: {
                                fillStyle: themedVisual.color,
                                strokeStyle: themedVisual.stroke,
                                lineWidth: themedVisual.strokeWidth
                            }
                        });
                        break;

                    case 'circle':
                        body = this.Bodies.circle(x, y, geometry.radius, {
                            angle: rotation,
                            density: physics.density,
                            friction: physics.friction,
                            restitution: physics.restitution,
                            render: {
                                fillStyle: themedVisual.color,
                                strokeStyle: themedVisual.stroke,
                                lineWidth: themedVisual.strokeWidth
                            }
                        });
                        break;

                    case 'polygon':
                        if (geometry.vertices) {
                            // Create from vertices (like triangle)
                            body = this.Bodies.fromVertices(x, y, [geometry.vertices], {
                                angle: rotation,
                                density: physics.density,
                                friction: physics.friction,
                                restitution: physics.restitution,
                                render: {
                                    fillStyle: themedVisual.color,
                                    strokeStyle: themedVisual.stroke,
                                    lineWidth: themedVisual.strokeWidth
                                }
                            });
                        }
                        break;

                    case 'compound':
                        if (geometry.parts) {
                            body = this.createCompoundFromRegistry(x, y, shapeType, rotation, masterConfig, themedVisual, userData);
                        }
                        break;

                    default:
                        console.error(`❌ Unsupported geometry type: ${geometry.type}`);
                        return null;
                }

                if (body) {
                    // Set userData - use provided userData or create fallback
                    if (userData) {
                        body.userData = userData;
                        console.log(`🏷️ Applied provided userData to ${shapeType}:`, userData);
                    } else {
                        // Fallback for backward compatibility
                        body.userData = {
                            shapeType: shapeType,
                            type: geometry.type,
                            geometry: { ...geometry },
                            physics: { ...physics },
                            visual: { ...themedVisual }  // Use themed visual
                        };
                        console.log(`🏷️ Applied fallback userData to ${shapeType}`);
                    }

                    console.log(`✅ Unified shape ${shapeType} created from master registry with theme colors`);
                } else {
                    console.error(`❌ Failed to create shape ${shapeType} from master registry`);
                }

                return body;
            }

            // Create compound shape from master registry
            createCompoundFromRegistry(x, y, shapeType, rotation, masterConfig, themedVisual, userData = null) {
                const geometry = masterConfig.geometry;
                const physics = masterConfig.physics;
                const visual = themedVisual || masterConfig.visual; // Use themed visual if provided
                const bodyParts = [];

                // Create each part using master registry specifications
                geometry.parts.forEach((partSpec, index) => {
                    const partX = x + (partSpec.offsetX || 0);
                    const partY = y + (partSpec.offsetY || 0);
                    let bodyPart = null;

                    switch (partSpec.type) {
                        case 'rectangle':
                            bodyPart = this.Bodies.rectangle(partX, partY, partSpec.width, partSpec.height, {
                                density: physics.density,
                                friction: physics.friction,
                                restitution: physics.restitution,
                                render: {
                                    fillStyle: visual.color,
                                    strokeStyle: visual.stroke,
                                    lineWidth: visual.strokeWidth
                                }
                            });
                            break;

                        case 'circle':
                            bodyPart = this.Bodies.circle(partX, partY, partSpec.radius, {
                                density: physics.density,
                                friction: physics.friction,
                                restitution: physics.restitution,
                                render: {
                                    fillStyle: visual.color,
                                    strokeStyle: visual.stroke,
                                    lineWidth: visual.strokeWidth
                                }
                            });
                            break;

                        case 'diamond':
                            // Use consistent diamond creation from master registry
                            const width = partSpec.width || 12;
                            const height = partSpec.height || 12;
                            const effectiveSize = Math.min(width, height);
                            const radius = effectiveSize / 2;
                            
                            bodyPart = this.Bodies.polygon(partX, partY, 4, radius, {
                                angle: Math.PI / 4, // 45 degree rotation for diamond
                                density: physics.density,
                                friction: physics.friction,
                                restitution: physics.restitution,
                                render: {
                                    fillStyle: visual.color,
                                    strokeStyle: visual.stroke,
                                    lineWidth: visual.strokeWidth
                                }
                            });
                            break;

                        default:
                            console.warn(`⚠️ Unsupported part type: ${partSpec.type}`);
                            break;
                    }

                    if (bodyPart) {
                        bodyParts.push(bodyPart);
                        console.log(`✅ Created ${partSpec.type} part for ${shapeType} with themed colors`);
                    }
                });

                if (bodyParts.length === 0) {
                    console.error(`❌ No parts created for compound shape: ${shapeType}`);
                    return null;
                }

                // Create compound body
                const compoundBody = this.Body.create({
                    parts: bodyParts
                });

                // Apply physics properties to compound body
                this.Body.setDensity(compoundBody, physics.density);
                compoundBody.friction = physics.friction;
                compoundBody.restitution = physics.restitution;

                // Apply rotation to the entire compound body after creation
                if (rotation !== 0) {
                    this.Body.setAngle(compoundBody, rotation);
                }

                // Set userData for compound body
                if (userData) {
                    compoundBody.userData = userData;
                    console.log(`🏷️ Applied provided userData to compound ${shapeType}:`, userData);
                    
                    // CRITICAL FIX: Apply userData to all parts of the compound body
                    // Access the parts from the compound body's parts array
                    if (compoundBody.parts && compoundBody.parts.length > 1) {
                        // Skip index 0 as it's the main body itself
                        for (let i = 1; i < compoundBody.parts.length; i++) {
                            const part = compoundBody.parts[i];
                            part.userData = { ...userData, partIndex: i };
                            console.log(`🏷️ Applied userData to part ${i} of compound ${shapeType}:`, part.userData);
                        }
                    }
                } else {
                    // Fallback for backward compatibility
                    const fallbackUserData = {
                        shapeType: shapeType,
                        type: 'compound',
                        geometry: { ...geometry },
                        physics: { ...physics },
                        visual: { ...visual }
                    };
                    compoundBody.userData = fallbackUserData;
                    console.log(`🏷️ Applied fallback userData to compound ${shapeType}`);
                    
                    // Apply fallback userData to all parts
                    if (compoundBody.parts && compoundBody.parts.length > 1) {
                        for (let i = 1; i < compoundBody.parts.length; i++) {
                            const part = compoundBody.parts[i];
                            part.userData = { ...fallbackUserData, partIndex: i };
                            console.log(`🏷️ Applied fallback userData to part ${i} of compound ${shapeType}`);
                        }
                    }
                }

                return compoundBody;
            }

            startRenderLoop() {
                let lastTime = 0;
                let frameSkipCounter = 0;
                const targetFPS = 60;
                const minFPS = 30;
                const maxFrameTime = 1000 / minFPS; // 33.33ms
                
                // Cache for gradients and patterns to avoid recreation
                this.renderCache = {
                    gradients: new Map(),
                    patterns: new Map(),
                    lastCacheCleanup: 0
                };
                
                const render = (currentTime) => {
                    const deltaTime = currentTime - lastTime;
                    
                    // Frame skipping for performance when FPS drops below 30
                    if (deltaTime < maxFrameTime || frameSkipCounter === 0) {
                        lastTime = currentTime;
                        frameSkipCounter = 0;

                        // Update camera shake
                        this.updateCameraShake(deltaTime);

                        this.updateSpecialShapes(deltaTime);
                        this.updateExplosionTimers(deltaTime);
                        
                        // Update pulse states for all pulsing shapes
                        this.updatePulseStates(performance.now());

                        // Step Matter.js physics simulation
                        this.Engine.update(this.engine, 1000 / 60); // 60 FPS
                        
                        // Clear canvas (optimized with dirty rectangle if possible)
                        this.clearCanvas();
                        
                        // Enhanced rendering with themes (no camera shake transforms needed)
                        this.renderBackground();
                        this.renderWorld();
                        this.particleSystem.update(16); // ~16ms per frame at 60fps
                        this.particleSystem.render();
                    } else {
                        // Skip frame but increment counter
                        frameSkipCounter++;
                        if (frameSkipCounter > 2) { // Don't skip more than 2 consecutive frames
                            frameSkipCounter = 0;
                        }
                    }
                    
                    // Clean cache periodically (every 5 seconds)
                    if (currentTime - this.renderCache.lastCacheCleanup > 5000) {
                        this.cleanRenderCache();
                        this.renderCache.lastCacheCleanup = currentTime;
                    }
                    
                    requestAnimationFrame(render);
                };
                render(performance.now());
                console.log('🎬 Optimized Matter.js render loop with frame skipping and caching started');
            }
            
            // Optimized canvas clearing with dirty rectangle support
            clearCanvas() {
                // For now, clear entire canvas (dirty rectangle optimization would require tracking changed areas)
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            }
            
            // Clean up cached gradients and patterns
            cleanRenderCache() {
                // Keep cache size reasonable
                if (this.renderCache.gradients.size > 50) {
                    this.renderCache.gradients.clear();
                }
                if (this.renderCache.patterns.size > 20) {
                    this.renderCache.patterns.clear();
                }
                debugLog('🧹 Render cache cleaned');
            }
            
            // Get or create cached gradient
            getCachedGradient(key, createFn) {
                if (!this.renderCache.gradients.has(key)) {
                    this.renderCache.gradients.set(key, createFn());
                }
                return this.renderCache.gradients.get(key);
            }
            
            // Get or create cached pattern
            getCachedPattern(key, createFn) {
                if (!this.renderCache.patterns.has(key)) {
                    this.renderCache.patterns.set(key, createFn());
                }
                return this.renderCache.patterns.get(key);
            }

            // Enhanced background rendering with theme support
            renderBackground() {
                // Clear the canvas background
                this.clearCanvas();
                
                // Get current theme
                const currentTheme = this.assetManager?.getCurrentTheme();
                if (!currentTheme) {
                    // Fallback: render simple gradient
                    this.renderFallbackBackground();
                    return;
                }

                const backgroundConfig = currentTheme.config?.background;
                
                if (backgroundConfig?.type === 'image' && backgroundConfig.image?.url && !backgroundConfig.loadFailed) {
                    // Background image is handled by CSS, but we can add canvas effects if needed
                    this.renderCanvasBackgroundEffects(backgroundConfig);
                } else if (backgroundConfig?.type === 'pattern' && backgroundConfig.pattern?.style) {
                    // Pattern background is handled by CSS, but we can add canvas effects if needed
                    this.renderCanvasBackgroundEffects(backgroundConfig);
                } else if (backgroundConfig?.type === 'gradient') {
                    // Gradient is handled by CSS, but we can add canvas effects if needed
                    this.renderCanvasBackgroundEffects(backgroundConfig);
                } else {
                    // Render fallback on canvas
                    this.renderFallbackBackground(backgroundConfig?.fallbackColor);
                }
            }

            // Helper method for canvas background effects over CSS backgrounds
            renderCanvasBackgroundEffects(backgroundConfig) {
                // This method can be used to add additional canvas-based effects
                // over the CSS background, such as particles, overlays, or animations
                
                // Example: Add subtle texture overlay
                if (backgroundConfig.canvasOverlay) {
                    this.ctx.save();
                    this.ctx.globalAlpha = 0.1;
                    this.ctx.fillStyle = backgroundConfig.canvasOverlay;
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                    this.ctx.restore();
                }
            }

            // Helper method for fallback background rendering
            renderFallbackBackground(fallbackColor = '#2c3e50') {
                // Render a simple background when theme loading fails
                this.ctx.save();
                this.ctx.fillStyle = fallbackColor;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.restore();
            }

            // Render background image
            renderBackgroundImage(backgroundStyle) {
                const image = backgroundStyle.image;
                const config = backgroundStyle.imageConfig;
                
                this.ctx.save();
                
                // Apply image based on configuration
                switch(config.size) {
                    case 'cover':
                        this.drawImageCover(image);
                        break;
                    case 'contain':
                        this.drawImageContain(image);
                        break;
                    case 'auto':
                        this.ctx.drawImage(image, 0, 0);
                        break;
                    default: // "100% 100%" or similar
                        this.ctx.drawImage(image, 0, 0, this.canvas.width, this.canvas.height);
                }
                
                // If there are gradient colors too, overlay them with reduced opacity
                if (backgroundStyle.colors && backgroundStyle.colors.length >= 2) {
                    this.ctx.globalAlpha = 0.3; // Reduce opacity for overlay
                    this.renderBackgroundGradient(backgroundStyle);
                }
                
                this.ctx.restore();
            }

            // Helper to draw image with 'cover' behavior
            drawImageCover(image) {
                const canvasRatio = this.canvas.width / this.canvas.height;
                const imageRatio = image.width / image.height;
                
                let drawWidth, drawHeight, drawX, drawY;
                
                if (imageRatio > canvasRatio) {
                    // Image is wider than canvas ratio
                    drawHeight = this.canvas.height;
                    drawWidth = drawHeight * imageRatio;
                    drawX = (this.canvas.width - drawWidth) / 2;
                    drawY = 0;
                } else {
                    // Image is taller than canvas ratio
                    drawWidth = this.canvas.width;
                    drawHeight = drawWidth / imageRatio;
                    drawX = 0;
                    drawY = (this.canvas.height - drawHeight) / 2;
                }
                
                this.ctx.drawImage(image, drawX, drawY, drawWidth, drawHeight);
            }

            // Helper to draw image with 'contain' behavior
            drawImageContain(image) {
                const canvasRatio = this.canvas.width / this.canvas.height;
                const imageRatio = image.width / image.height;
                
                let drawWidth, drawHeight, drawX, drawY;
                
                if (imageRatio > canvasRatio) {
                    // Fit to canvas width
                    drawWidth = this.canvas.width;
                    drawHeight = drawWidth / imageRatio;
                    drawX = 0;
                    drawY = (this.canvas.height - drawHeight) / 2;
                } else {
                    // Fit to canvas height
                    drawHeight = this.canvas.height;
                    drawWidth = drawHeight * imageRatio;
                    drawX = (this.canvas.width - drawWidth) / 2;
                    drawY = 0;
                }
                
                this.ctx.drawImage(image, drawX, drawY, drawWidth, drawHeight);
            }

            // Render gradient background (extracted from previous method) - Optimized with caching
            renderBackgroundGradient(backgroundStyle) {
                const colors = backgroundStyle.colors;
                if (!colors || colors.length < 2) return;

                // Create cache key for this gradient
                const gradientKey = `bg_${colors.join('_')}_${this.canvas.width}x${this.canvas.height}`;
                
                // Use cached gradient or create new one
                const gradient = this.getCachedGradient(gradientKey, () => {
                    const grad = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
                    const colorStep = 1 / (colors.length - 1);
                    colors.forEach((color, index) => {
                        grad.addColorStop(index * colorStep, color);
                    });
                    return grad;
                });
                
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            }

            // Add subtle texture to background
            renderBackgroundTexture() {
                const currentTheme = this.assetManager.getCurrentTheme();
                if (!currentTheme) {
                    debugLog('🚫 No current theme found for background texture');
                    return;
                }
                
                // Only log texture details when theme changes, not every frame
                if (!this._lastLoggedTextureTheme || this._lastLoggedTextureTheme !== currentTheme.config?.name) {
                    debugLog(`🎨 Background texture - Theme: ${currentTheme.config?.name}, Material: ${currentTheme.config?.platform?.material}`);
                    this._lastLoggedTextureTheme = currentTheme.config?.name;
                }
                
                this.ctx.save();
                this.ctx.globalAlpha = 0.1;
                
                // Add theme-specific background patterns
                const material = currentTheme.config.platform.material;
                
                // Debug log material detection when theme changes
                if (!this._lastLoggedTextureTheme || this._lastLoggedTextureTheme !== currentTheme.config?.name) {
                    console.log(`🔍 Material detected: '${material}' for theme '${currentTheme.config?.name}'`);
                }
                
                switch(material) {
                    case 'wood':
                        if (this._lastLoggedTextureTheme === currentTheme.config?.name) {
                           // console.log('🌳 Rendering wood texture background');
                        }
                        this.renderWoodTexture();
                        break;
                    case 'metal':
                        if (!this._lastLoggedTextureTheme || this._lastLoggedTextureTheme !== currentTheme.config?.name) {
                            debugLog('🔩 Rendering metal texture background (corrugated)');
                        }
                        this.renderMetalTexture();
                        break;
                    case 'steel':  // Added steel material for Metal theme
                        if (!this._lastLoggedTextureTheme || this._lastLoggedTextureTheme !== currentTheme.config?.name) {
                            debugLog('🔩 Rendering steel texture background (corrugated)');
                        }
                        this.renderMetalTexture();
                        break;
                    case 'coral':
                        if (this._lastLoggedTextureTheme === currentTheme.config?.name) {
                            debugLog('🪸 Rendering coral texture background');
                        }
                        this.renderCoralTexture();
                        break;
                    default:
                        if (!this._lastLoggedTextureTheme || this._lastLoggedTextureTheme !== currentTheme.config?.name) {
                            debugLog(`🔲 Rendering default geometric texture (material: '${material}')`);
                        }
                        this.renderGeometricTexture();
                }
                
                this.ctx.restore();
            }

            renderWoodTexture() {
                // Simple wood grain effect
                this.ctx.strokeStyle = '#8B4513';
                this.ctx.lineWidth = 0.5;
                for (let i = 0; i < 20; i++) {
                    const y = (this.canvas.height / 20) * i;
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.canvas.width, y + Math.sin(i) * 5);
                    this.ctx.stroke();
                }
            }

            renderMetalTexture() {
                // Corrugated metal pattern with blue steel tones
                const corrugationWidth = 20;  // Increased width for better visibility
                const corrugationHeight = 4;   // Increased height
                
                this.ctx.save();
                this.ctx.globalAlpha = 0.25;  // Increased opacity for better visibility
                
                console.log(`🔩 Creating corrugated metal pattern: ${this.canvas.width}x${this.canvas.height}`);
                
                // Create horizontal corrugated pattern
                for (let y = 0; y < this.canvas.height; y += corrugationWidth) {
                    // Light ridge
                    this.ctx.fillStyle = '#6495ED';
                    this.ctx.fillRect(0, y, this.canvas.width, corrugationHeight);
                    
                    // Dark valley
                    this.ctx.fillStyle = '#1E3A8A';
                    this.ctx.fillRect(0, y + corrugationHeight, this.canvas.width, corrugationHeight);
                    
                    // Medium transition
                    this.ctx.fillStyle = '#4682B4';
                    this.ctx.fillRect(0, y + corrugationHeight * 2, this.canvas.width, corrugationWidth - corrugationHeight * 2);
                }
                
                // Add subtle diagonal lines for extra texture
                this.ctx.globalAlpha = 0.1;
                this.ctx.strokeStyle = '#87CEEB';
                this.ctx.lineWidth = 1;  // Increased line width
                for (let i = -this.canvas.width; i < this.canvas.width + this.canvas.height; i += 30) {  // Increased spacing
                    this.ctx.beginPath();
                    this.ctx.moveTo(i, 0);
                    this.ctx.lineTo(i + this.canvas.height, this.canvas.height);
                    this.ctx.stroke();
                }
                
                debugLog('✅ Metal texture pattern completed');
                this.ctx.restore();
            }

            renderCoralTexture() {
                // Organic bubble pattern
                this.ctx.fillStyle = '#2E8B57';
                for (let i = 0; i < 50; i++) {
                    const x = Math.random() * this.canvas.width;
                    const y = Math.random() * this.canvas.height;
                    const radius = Math.random() * 3 + 1;
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, radius, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }

            renderGeometricTexture() {
                // Simple dot pattern
                this.ctx.fillStyle = '#cccccc';
                for (let x = 10; x < this.canvas.width; x += 20) {
                    for (let y = 10; y < this.canvas.height; y += 20) {
                        this.ctx.beginPath();
                        this.ctx.arc(x, y, 1, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                }
            }

            // =============================================================================
            // CAMERA SHAKE SYSTEM
            // =============================================================================

            /**
             * Trigger camera shake effect
             * @param {number} intensity - Shake intensity (1-10)
             * @param {number} duration - Duration in milliseconds
             */
            startCameraShake(intensity = 5, duration = 500) {
                console.log(`🚨 startCameraShake called with intensity=${intensity}, duration=${duration}ms`);
                
                this.cameraShake.active = true;
                this.cameraShake.intensity = intensity;
                this.cameraShake.duration = duration;
                this.cameraShake.elapsed = 0;
                this.cameraShake.frequencyX = 0.1 + Math.random() * 0.1; // Randomize frequency
                this.cameraShake.frequencyY = 0.1 + Math.random() * 0.1;
                
                console.log(`✅ Camera shake activated - state:`, this.cameraShake);
                console.log(`🎯 Canvas element:`, this.canvas);
                
                // Immediate test shake to verify it works
                this.canvas.style.transform = `translate(${intensity}px, ${intensity}px)`;
                setTimeout(() => {
                    this.canvas.style.transform = 'translate(0px, 0px)';
                }, 100);
                
                console.log(`📹 Camera shake started: intensity=${intensity}, duration=${duration}ms`);
            }

            /**
             * Update camera shake effect - applies shake directly to canvas element
             * @param {number} deltaTime - Time since last update
             */
            updateCameraShake(deltaTime) {
                if (!this.cameraShake.active) {
                    // Reset canvas position when not shaking
                    this.canvas.style.transform = 'translate(0px, 0px)';
                    return;
                }

                console.log(`🔄 updateCameraShake: elapsed=${this.cameraShake.elapsed}, duration=${this.cameraShake.duration}, intensity=${this.cameraShake.intensity}`);

                this.cameraShake.elapsed += deltaTime;

                if (this.cameraShake.elapsed >= this.cameraShake.duration) {
                    // Shake finished
                    this.cameraShake.active = false;
                    this.canvas.style.transform = 'translate(0px, 0px)';
                    console.log('✅ Camera shake completed');
                    return;
                }

                // Calculate shake progress (1.0 at start, 0.0 at end)
                const progress = 1.0 - (this.cameraShake.elapsed / this.cameraShake.duration);
                const currentIntensity = this.cameraShake.intensity * progress * progress; // Quadratic falloff

                // Generate shake offset using sine waves with different frequencies
                const time = this.cameraShake.elapsed * 0.01; // Convert to suitable time scale
                let offsetX = Math.sin(time * this.cameraShake.frequencyX * 50) * currentIntensity;
                let offsetY = Math.sin(time * this.cameraShake.frequencyY * 47) * currentIntensity; // Different frequency for variety

                // Add random jitter for more chaotic feel
                offsetX += (Math.random() - 0.5) * currentIntensity * 0.5;
                offsetY += (Math.random() - 0.5) * currentIntensity * 0.5;

                console.log(`📳 Applying shake: offsetX=${offsetX.toFixed(1)}, offsetY=${offsetY.toFixed(1)}, currentIntensity=${currentIntensity.toFixed(1)}`);

                // Apply transform to canvas element
                this.canvas.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
            }

            /**
             * Apply camera shake to canvas transform (legacy method - now unused)
             */
            applyCameraShake() {
                // This method is no longer used - shake is applied directly to canvas element
            }

            /**
             * Reset camera shake transform (legacy method - now unused)
             */
            resetCameraShake() {
                // This method is no longer used - shake is applied directly to canvas element
            }

            renderWorld() {
                // Render all Matter.js bodies in the world with optimizations
                const bodies = this.world.bodies;
                const canvasWidth = this.canvas.width;
                const canvasHeight = this.canvas.height;
                const padding = 50; // Extra padding for objects near edge
                
                // Single save/restore for all rendering operations
                this.ctx.save();
                
                for (let i = 0; i < bodies.length; i++) {
                    const body = bodies[i];
                    
                    // Frustum culling - skip off-screen bodies
                    if (this.isBodyOffScreen(body, canvasWidth, canvasHeight, padding)) {
                        continue;
                    }
                    
                    this.renderBody(body);
                    this.renderSpecialEffects(body);
                }
                
                this.ctx.restore();
            }
            
            // Check if a body is off-screen (frustum culling)
            isBodyOffScreen(body, canvasWidth, canvasHeight, padding) {
                const bounds = body.bounds;
                return (
                    bounds.max.x < -padding ||
                    bounds.min.x > canvasWidth + padding ||
                    bounds.max.y < -padding ||
                    bounds.min.y > canvasHeight + padding
                );
            }

            renderBody(body) {
                // Skip rendering invisible bodies
                if (body.render && body.render.visible === false) return;

                // Render Matter.js body parts directly (no coordinate transformation)
                if (body.parts && body.parts.length > 1) {
                    // Compound body - render each part separately
                    for (let i = 1; i < body.parts.length; i++) { // Skip first part (it's the parent)
                        this.renderMatterPart(body.parts[i], body);
                    }
                } else {
                    // Simple body - render directly
                    this.renderMatterPart(body, body);
                }
            }

            renderSpecialEffects(body) {
                const userData = body.userData || {};
                const specialType = userData.specialType?.type;
                if (!specialType) return;

                // This will act as a router for different effects
                switch (specialType) {
                    case 'FIRE':
                        // Spawn 1-2 flame particles per frame for a continuous effect
                        if (this.particleSystem && Math.random() > 0.4) { // 60% chance per frame
                            const flameStyle = { style: 'flame', colors: [] }; // Style object for the particle system
                            if (this.particleSystem.particles.length < this.particleSystem.maxParticles) {
                                this.particleSystem.particles.push(
                                    this.particleSystem.createParticle(flameStyle, body.position.x, body.position.y, 'flame')
                                );
                            }
                        }
                        break;
                    case 'TIMER':
                        this.drawTimerDecal(body);
                        break;
                    case 'WEIGHTED':
                        this.drawWeightedDecal(body);
                        break;
                }
            }

            drawWeightedDecal(body) {
                const ctx = this.ctx;
                const weightState = body.userData.weightState;
                const colors = body.userData.specialType?.indicatorColors;

                if (!weightState || !colors) return;

                const status = weightState.status || 'safe';

                let lightColor = colors.safe;
                if (status === 'warning') {
                    lightColor = colors.warning;
                } else if (status === 'danger') {
                    lightColor = colors.danger;
                } else if (status === 'overloaded') {
                    // Make the light flash when overloaded
                    const flash = Math.sin(performance.now() / 150) > 0;
                    lightColor = flash ? colors.danger : '#333'; // Flash between red and dark gray
                }
                
                ctx.save();
                ctx.translate(body.position.x, body.position.y);
                ctx.rotate(body.angle);

                // Draw traffic light body
                ctx.fillStyle = '#333';
                ctx.fillRect(-8, -4, 16, 8);
                
                // Draw the light
                ctx.beginPath();
                ctx.arc(0, 0, 5, 0, Math.PI * 2);
                ctx.fillStyle = lightColor;
                ctx.fill();
                ctx.strokeStyle = '#555';
                ctx.lineWidth = 1;
                ctx.stroke();

                ctx.restore();
            }

            drawTimerDecal(body) {
                const ctx = this.ctx;
                const timerState = body.userData.timerState;

                if (!timerState) return;

                ctx.save();
                ctx.translate(body.position.x, body.position.y);
                ctx.rotate(body.angle);

                // Draw stopwatch body
                ctx.beginPath();
                ctx.arc(0, 0, 8, 0, Math.PI * 2);
                ctx.fillStyle = '#E0E0E0';
                ctx.fill();
                ctx.strokeStyle = '#757575';
                ctx.lineWidth = 1.5;
                ctx.stroke();

                // Draw stopwatch plunger
                ctx.fillRect(-1.5, -11, 3, 3);

                let totalDuration = timerState.initialCountdown;
                if (typeof totalDuration !== 'number' || totalDuration <= 0) {
                    const fallback = body.userData.specialType?.countdownSeconds;
                    totalDuration = (typeof fallback === 'number' && fallback > 0) ? fallback : 1;
                }
                const remaining = Math.max(typeof timerState.countdown === 'number' ? timerState.countdown : totalDuration, 0);
                const elapsed = Math.min(Math.max(totalDuration - remaining, 0), totalDuration);
                const progress = totalDuration > 0 ? (elapsed / totalDuration) : 0;
                const needleAngle = timerState.isTicking ? progress * Math.PI * 2 : 0;

                ctx.save();
                ctx.rotate(needleAngle);
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(0, -6);
                ctx.lineWidth = 1;
                ctx.strokeStyle = timerState.isTicking ? '#d32f2f' : '#333';
                ctx.stroke();
                ctx.restore();

                ctx.restore();
            }

            renderMatterPart(part, parentBody) {
                // Get render properties from Matter.js body
                const render = part.render || {};
                const userData = parentBody.userData || {};
                
                // Skip invisible parts
                if (render.visible === false) return;
                
                // Theme-based color selection
                let fillColor = render.fillStyle || userData.color || '#95A5A6';
                let strokeColor = render.strokeStyle || userData.stroke || '#7F8C8D';

                // NEW: Add strobe effect for ticking fire shapes
                if (userData.explosionTimerId) {
                    // Flash between white and the original color
                    const flash = Math.floor(performance.now() / 100) % 2 === 0;
                    if (flash) {
                        fillColor = '#FFFFFF'; // White
                    }
                }
                
                // Apply theme colors for platform
                if (userData.type === 'platform' && this.platformColor) {
                    fillColor = this.platformColor;
                    strokeColor = this.darkenColor(this.platformColor, 20);
                }
                
                // Check for image textures
                let textureImage = null;
                let textureConfig = null;
                
                // Use consolidated AssetManager for texture lookup
                if (userData.shapeType && window.assetManager) {
                    debugLog(`🔍 Checking texture for physics body shapeType: ${userData.shapeType}`);
                    
                    // Try direct texture retrieval first
                    textureImage = UnifiedTextureSystem.getShapeTexture(userData.shapeType);
                    if (textureImage) {
                        textureConfig = {
                            repeat: 'repeat',
                            blend: 'multiply',
                            opacity: 0.7
                        };
                        debugLog(`🖼️ Direct AssetManager texture retrieval for ${userData.shapeType}: SUCCESS`);
                    }
                    // Unified fallback check using consolidated texture management
                    else if (UnifiedTextureSystem.isTextureAvailable(userData.shapeType)) {
                        textureImage = UnifiedTextureSystem.getShapeTexture(userData.shapeType);
                        textureConfig = {
                            repeat: 'repeat',
                            blend: 'multiply',
                            opacity: 0.7
                        };
                        debugLog(`🖼️ Unified texture check for ${userData.shapeType}: SUCCESS`);
                    }
                    
                    if (!textureImage) {
                        debugLog(`⚠️ No texture found for physics body ${userData.shapeType}. AssetManager available: ${!!window.assetManager}, Current theme: ${window.assetManager?.currentTheme}`);
                        
                        // Debug: Check what's actually in the assets
                        const currentTheme = window.assetManager?.getCurrentTheme();
                        if (currentTheme) {
                            debugLog(`🔍 Current theme assets:`, currentTheme.assets);
                            debugLog(`🔍 Shape textures available:`, Object.keys(currentTheme.assets?.shapeTextures || {}));
                        }
                    }
                }
                
                // Fallback to legacy system only if no unified texture found
                const shouldUseTexture = CANVAS_CONFIG.enabled && CANVAS_CONFIG.useBackgroundTextures;
                if (!textureImage && shouldUseTexture) {
                    if (userData.type === 'platform') {
                        const platformStyle = this.assetManager.getPlatformStyle();
                        textureImage = platformStyle?.image;
                        textureConfig = platformStyle?.imageConfig;
                    } else if (userData.shapeType) {
                        const shapeStyle = this.assetManager.getShapeStyle(userData.shapeType);
                        textureImage = shapeStyle?.texture;
                        textureConfig = shapeStyle?.textureConfig;
                    }
                }
                
                // Set drawing style
                this.ctx.fillStyle = fillColor;
                this.ctx.strokeStyle = strokeColor;
                this.ctx.lineWidth = render.lineWidth || userData.strokeWidth || 2;
                
                // Render based on shape type
                if (part.circleRadius !== undefined && part.circleRadius > 0) {
                    // Circle - use part's own position (already in world coordinates)
                    this.renderCircleWithTexture(part, textureImage, textureConfig);
                } else if (part.vertices && part.vertices.length > 0) {
                    // Polygon (including rectangles) - vertices are in world coordinates
                    this.renderPolygonWithTexture(part, textureImage, textureConfig);
                } else {
                    console.log(`⚠️ Unknown body type - circleRadius: ${part.circleRadius}, vertices: ${part.vertices ? part.vertices.length : 'none'} for ${userData.type || 'unknown'}`);
                }
            }

// ...existing code...

            renderCircleWithTexture(part, textureImage, textureConfig) {
                // Check if this shape should be pulsing
                const bodyId = part.parent ? part.parent.id : part.id;
                const pulseState = this.pulseManager.activePulses.get(bodyId);
                
                // Apply transformations and fill the circle in local coordinate space so that the texture moves with the shape.
                this.ctx.save();
                
                // Apply pulse effects if active
                if (pulseState && pulseState.isPulsing) {
                    this.applyPulseEffects(pulseState.pulseIntensity, textureImage);
                }
                
                // Apply shape transformations first
                this.ctx.translate(part.position.x, part.position.y);
                if (part.angle) {
                    this.ctx.rotate(part.angle);
                }
                
                // Create the path for the circle with origin at (0,0)
                this.ctx.beginPath();
                this.ctx.arc(0, 0, part.circleRadius, 0, Math.PI * 2);
                
                // Apply texture pattern in transformed space if available
                if (textureImage) {
                    const pattern = this.ctx.createPattern(textureImage, 'repeat');
                    if (pattern) {
                        this.ctx.fillStyle = pattern;
                    }
                }
                // fillStyle is already set to color in renderMatterPart if no texture
                
                this.ctx.fill();
                this.ctx.restore();
                
                // Reset any pulse effects
                if (pulseState && pulseState.isPulsing) {
                    this.resetPulseEffects();
                }
                
                // Draw stroke in world coordinates
                this.ctx.beginPath();
                this.ctx.arc(part.position.x, part.position.y, part.circleRadius, 0, Math.PI * 2);
                this.ctx.stroke();
            }

            renderPolygonWithTexture(part, textureImage, textureConfig) {
                const vertices = part.vertices;
                if (!vertices || vertices.length === 0) return;
                
                // Check if this shape should be pulsing
                const bodyId = part.parent ? part.parent.id : part.id;
                const pulseState = this.pulseManager.activePulses.get(bodyId);
                
                this.ctx.save();
                
                // Apply pulse effects if active
                if (pulseState && pulseState.isPulsing) {
                    this.applyPulseEffects(pulseState.pulseIntensity, textureImage);
                }
                
                // Apply transformations for texture coordinate space
                this.ctx.translate(part.position.x, part.position.y);
                if (part.angle) {
                    this.ctx.rotate(part.angle);
                }
                
                // Create path in local coordinate space
                this.ctx.beginPath();
                const localVertices = vertices.map(v => ({
                    x: v.x - part.position.x,
                    y: v.y - part.position.y
                }));
                
                // Rotate vertices back to local space
                if (part.angle) {
                    const cos = Math.cos(-part.angle);
                    const sin = Math.sin(-part.angle);
                    localVertices.forEach(v => {
                        const x = v.x * cos - v.y * sin;
                        const y = v.x * sin + v.y * cos;
                        v.x = x;
                        v.y = y;
                    });
                }
                
                this.ctx.moveTo(localVertices[0].x, localVertices[0].y);
                for (let i = 1; i < localVertices.length; i++) {
                    this.ctx.lineTo(localVertices[i].x, localVertices[i].y);
                }
                this.ctx.closePath();
                
                // Apply texture in transformed space
                if (textureImage) {
                    const pattern = this.ctx.createPattern(textureImage, 'repeat');
                    if (pattern) {
                        this.ctx.fillStyle = pattern;
                    }
                }
                
                this.ctx.fill();
                this.ctx.restore();
                
                // Reset any pulse effects
                if (pulseState && pulseState.isPulsing) {
                    this.resetPulseEffects();
                }
                
                // Draw stroke in world coordinates
                this.ctx.beginPath();
                this.ctx.moveTo(vertices[0].x, vertices[0].y);
                for (let i = 1; i < vertices.length; i++) {
                    this.ctx.lineTo(vertices[i].x, vertices[i].y);
                }
                this.ctx.closePath();
                this.ctx.stroke();
            }

// ...existing code...

            applyTextureToShape(x, y, width, height, image, textureConfig) {
                if (!image) return;
                
                this.ctx.save();
                
                // Apply blend mode
                if (textureConfig.blend && textureConfig.blend !== 'normal') {
                    this.ctx.globalCompositeOperation = textureConfig.blend;
                }
                
                // Apply opacity
                if (textureConfig.opacity !== undefined) {
                    this.ctx.globalAlpha = textureConfig.opacity;
                }
                
                // Handle texture repeat patterns
                switch(textureConfig.repeat) {
                    case 'repeat':
                        this.drawRepeatedTexture(x, y, width, height, image);
                        break;
                    case 'repeat-x':
                        this.drawRepeatedTextureX(x, y, width, height, image);
                        break;
                    case 'repeat-y':
                        this.drawRepeatedTextureY(x, y, width, height, image);
                        break;
                    case 'no-repeat':
                    default:
                        this.ctx.drawImage(image, x, y, width, height);
                        break;
                }
                
                this.ctx.restore();
            }

            drawRepeatedTexture(x, y, width, height, image) {
                const pattern = this.ctx.createPattern(image, 'repeat');
                if (pattern) {
                    this.ctx.fillStyle = pattern;
                    this.ctx.fillRect(x, y, width, height);
                } else {
                    // Fallback: manual tiling
                    this.manualTileTexture(x, y, width, height, image);
                }
            }

            drawRepeatedTextureX(x, y, width, height, image) {
                const aspectRatio = image.width / image.height;
                const tileHeight = height;
                const tileWidth = tileHeight * aspectRatio;
                
                for (let tx = x; tx < x + width; tx += tileWidth) {
                    const drawWidth = Math.min(tileWidth, x + width - tx);
                    this.ctx.drawImage(image, 0, 0, image.width * (drawWidth / tileWidth), image.height,
                                     tx, y, drawWidth, tileHeight);
                }
            }

            drawRepeatedTextureY(x, y, width, height, image) {
                const aspectRatio = image.width / image.height;
                const tileWidth = width;
                const tileHeight = tileWidth / aspectRatio;
                
                for (let ty = y; ty < y + height; ty += tileHeight) {
                    const drawHeight = Math.min(tileHeight, y + height - ty);
                    this.ctx.drawImage(image, 0, 0, image.width, image.height * (drawHeight / tileHeight),
                                     x, ty, tileWidth, drawHeight);
                }
            }

            manualTileTexture(x, y, width, height, image) {
                const tileWidth = image.width;
                const tileHeight = image.height;
                
                for (let ty = y; ty < y + height; ty += tileHeight) {
                    for (let tx = x; tx < x + width; tx += tileWidth) {
                        const drawWidth = Math.min(tileWidth, x + width - tx);
                        const drawHeight = Math.min(tileHeight, y + height - ty);
                        
                        this.ctx.drawImage(image, 0, 0, 
                                         image.width * (drawWidth / tileWidth), 
                                         image.height * (drawHeight / tileHeight),
                                         tx, ty, drawWidth, drawHeight);
                    }
                }
            }

            getPolygonBounds(vertices) {
                let minX = Infinity, minY = Infinity;
                let maxX = -Infinity, maxY = -Infinity;
                
                vertices.forEach(vertex => {
                    minX = Math.min(minX, vertex.x);
                    minY = Math.min(minY, vertex.y);
                    maxX = Math.max(maxX, vertex.x);
                    maxY = Math.max(maxY, vertex.y);
                });
                
                return {
                    x: minX,
                    y: minY,
                    width: maxX - minX,
                    height: maxY - minY
                };
            }

            getEventStats() {
                return {
                    events: this.eventCount,
                    collisions: this.collisionCount,
                    falls: this.fallCount
                };
            }

            darkenColor(color, amount = 30) {
                // Enhanced color darkening with configurable amount
                if (!color) return '#7F8C8D';
                
                // Convert hex to RGB and darken by specified amount
                const hex = color.replace('#', '');
                const r = Math.max(0, parseInt(hex.substr(0, 2), 16) - amount);
                const g = Math.max(0, parseInt(hex.substr(2, 2), 16) - amount);
                const b = Math.max(0, parseInt(hex.substr(4, 2), 16) - amount);
                
                return `rgb(${r}, ${g}, ${b})`;
            }

            /*╔═══════════════════════════════════════════════════════════════════════════
              ║ CLEAR ALL SHAPES
              ║ Removes all dynamic bodies (shapes) from the physics world while preserving
              ║ static bodies (platform, walls). Used for level resets and shape management.
              ║ Essential for providing a fresh start without recreating the entire world.
              ╚═══════════════════════════════════════════════════════════════════════════*/
            clearAllShapes() {
                // Remove all dynamic bodies from Matter.js world
                this.dynamicBodies.forEach(body => {
                    this.World.remove(this.world, body);
                    this.cleanupRemovedShapeFromWeighted(body.id);
                });
                this.dynamicBodies = [];
                
                console.log('🧹 Cleared all shapes from playfield');
            }

            cleanup() {
                // Remove all dynamic bodies from Matter.js world
                this.dynamicBodies.forEach(body => {
                    this.World.remove(this.world, body);
                    this.cleanupRemovedShapeFromWeighted(body.id);
                });
                this.dynamicBodies = [];
                
                // PixiJS shape clearing removed with PixiJS elimination
                
                // Reset event counters
                this.eventCount = 0;
                this.collisionCount = 0;
                this.fallCount = 0;
                
                console.log('🧹 Matter.js physics cleanup complete');
            }
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ ENHANCED DRAG AND DROP MANAGER WITH ROTATION
          ║ Task 4.2b: Adds rotation functionality during drag and drop operations
          ║ Maintains existing drag & drop functionality while adding rotation controls
          ╚═══════════════════════════════════════════════════════════════════════════*/
        class DragDropManager {
            constructor(physicsManager, gameManager) {
                this.physicsManager = physicsManager;
                this.gameManager = gameManager;
                this.isDragging = false;
                this.draggedElement = null;
                this.draggedShapeType = null;
                this.ghostElement = null;
                
                // Touch offset configuration for mobile devices
                this.touchOffset = {
                    x: 0,      // Horizontal offset (positive = right, negative = left)
                    y: -80,    // Vertical offset (positive = down, negative = up)
                    enabled: true // Enable/disable offset system
                };
                
                // Rotation system
                this.currentRotation = 0; // Current rotation in radians
                this.rotationStep = Math.PI / 6; // 30 degrees per step
                
                // Throttling for smooth dragging - reduce jerkiness
                this.lastMoveTime = 0;
                this.moveThrottleMs = 16; // ~60fps throttling
                this.pendingMove = null;
                
                // Track if drag started from dock
                this.dragStartedFromDock = false;
                
                this.setupEventListeners();
                console.log('🖱️ Streamlined Drag & Drop Manager with touch offset support initialized');
            }

            setupEventListeners() {
                // Mouse events - use throttled movement for smoother dragging
                document.addEventListener('mousedown', (e) => this.handlePointerDown(e));
                document.addEventListener('mousemove', (e) => this.throttledHandlePointerMove(e));
                document.addEventListener('mouseup', (e) => this.handlePointerUp(e));
                
                // Touch events handled by MobileEnhancementManager if present
                // No need for direct touch handling - unified handlers provide better experience
                
                // Keyboard controls
                document.addEventListener('keydown', (e) => this.handleRotationKey(e));
                
                // Desktop rotation zone click handlers
                const leftRotationZone = document.getElementById('leftRotationZone');
                const rightRotationZone = document.getElementById('rightRotationZone');
                
                if (leftRotationZone) {
                    leftRotationZone.addEventListener('click', (e) => {
                        if (this.isDragging) {
                            this.rotateShape(-this.rotationStep); // Counter-clockwise
                            e.preventDefault();
                        }
                    });
                }
                
                if (rightRotationZone) {
                    rightRotationZone.addEventListener('click', (e) => {
                        if (this.isDragging) {
                            this.rotateShape(this.rotationStep); // Clockwise
                            e.preventDefault();
                        }
                    });
                }
                
                debugLog('🖱️ Drag & Drop Manager initialized with unified pointer support');
            }
            
            // Throttled mouse movement to reduce jerkiness
            throttledHandlePointerMove(e) {
                if (!this.isDragging) return;
                
                const now = performance.now();
                if (now - this.lastMoveTime < this.moveThrottleMs) {
                    // Store the most recent event for later processing
                    this.pendingMove = e;
                    return;
                }
                
                this.lastMoveTime = now;
                this.handlePointerMove(e);
                
                // Process any pending move after throttle delay
                if (this.pendingMove && this.pendingMove !== e) {
                    setTimeout(() => {
                        if (this.pendingMove && this.isDragging) {
                            this.handlePointerMove(this.pendingMove);
                            this.pendingMove = null;
                        }
                    }, this.moveThrottleMs);
                }
            }

            handleRotationKey(e) {
                if (!this.isDragging) return;
                
                switch(e.key) {
                    case 'r':
                    case 'R':
                    case 'ArrowRight':
                        this.rotateShape(this.rotationStep); // Rotate clockwise
                        e.preventDefault();
                        break;
                    case 'e':
                    case 'E':
                    case 'ArrowLeft':
                        this.rotateShape(-this.rotationStep); // Rotate counter-clockwise
                        e.preventDefault();
                        break;
                }
            }

            rotateShape(deltaRotation) {
                this.currentRotation += deltaRotation;
                
                // Sound effect integration point
                this.gameManager.playSound('shapeRotation');
                
                if (this.ghostElement) {
                    // Apply both scale, centering translation, and rotation to the ghost element
                    this.ghostElement.style.transform = `translate(-50%, -50%) scale(1.1) rotate(${this.currentRotation}rad)`;
                }
                
                // Update rotation indicator with current angle
                const degrees = Math.round(this.currentRotation * 180 / Math.PI);
                this.updateRotationIndicator(degrees);
                
                console.log(`🔄 Shape rotated: ${degrees}°`);
            }

            handlePointerDown(pointer) {
                if (!this.gameManager?.gameState?.isGameActive) {
                    return;
                }

                const element = document.elementFromPoint(pointer.clientX, pointer.clientY);

                if (element && element.classList.contains('locked')) { return; }

                if (element && element.classList.contains('game-shape')) {
                    // Check if drag started from docking area
                    this.dragStartedFromDock = element.closest('.docking-area') !== null;
                    console.log(`🖱️ Starting drag, from dock: ${this.dragStartedFromDock}`);
                    this.startDrag(element, pointer);
                }
            }

            startDrag(element, pointer) {
                this.isDragging = true;
                this.draggedElement = element;
                this.draggedShapeType = element.dataset.shape;
                this.draggedShapeId = element.dataset.shapeId;
                
                // Initialize rotation based on shape type and dock settings
                if (this.draggedShapeType && this.draggedShapeType.includes('barbell')) {
                    // For barbells, preserve dock orientation setting
                    const barbellOrientationSelect = document.getElementById('barbellOrientation');
                    if (barbellOrientationSelect && barbellOrientationSelect.value === 'vertical') {
                        this.currentRotation = Math.PI / 2; // 90 degrees for vertical barbells
                        console.log(`🔄 Starting barbell drag with vertical dock orientation (90°)`);
                    } else {
                        this.currentRotation = 0; // Horizontal for barbells
                        console.log(`🔄 Starting barbell drag with horizontal dock orientation (0°)`);
                    }
                } else {
                    // For non-barbell shapes, always start at 0
                    this.currentRotation = 0;
                }
                
                // Add visual feedback with ghost effect
                element.classList.add('ghost-active');
                console.log(`👻 Added ghost-active class to element:`, element.className, 'Should be invisible now');

                // --- NEW: Ensure dock shape is properly hidden when dragging ---
                if (this.dragStartedFromDock) {
                    element.style.visibility = 'hidden';
                    element.style.opacity = '0';
                    console.log(`🙈 Hiding dock shape during drag`);
                }
                // --- END NEW ---

                if (this.dragStartedFromDock) {
                    dockingSpecialEffectsManager.setEffectVisibility(element, false);
                }

                // Show rotation indicator
                this.showRotationIndicator();
                
                // Update rotation indicator with initial rotation
                this.updateRotationIndicator(Math.round(this.currentRotation * 180 / Math.PI));
                
                // Create ghost element for dragging
                this.createGhostElement(element, pointer);
                
                console.log(`🟢 Started dragging: ${this.draggedShapeType} with initial rotation ${(this.currentRotation * 180 / Math.PI).toFixed(1)}° (R/E or ←/→ to rotate)`);
            }

            createGhostElement(element, pointer) {
                // Create ghost element like Planck version - using CSS transform rotation
                this.ghostElement = this.createGhostPreview(this.draggedShapeType, 90);
                
                // Add ghost-shape class for CSS styling
                this.ghostElement.classList.add('ghost-shape');
                
                // Apply comprehensive ghost styling to prevent clipping
                this.ghostElement.style.position = 'fixed';
                this.ghostElement.style.pointerEvents = 'none';
                this.ghostElement.style.zIndex = '10000'; // Higher z-index to ensure visibility
                this.ghostElement.style.filter = 'drop-shadow(0 5px 15px rgba(0,0,0,0.3))';
                this.ghostElement.style.visibility = 'visible';
                this.ghostElement.style.opacity = '0.9';
                this.ghostElement.style.display = 'block';
                
                // Use CSS transform with consistent centering, scale, and rotation
                const initialTransform = `translate(-50%, -50%) scale(1.1) rotate(${this.currentRotation}rad)`;
                this.ghostElement.style.transform = initialTransform;
                console.log(`👻 Ghost element created with CSS rotation: ${(this.currentRotation * 180 / Math.PI).toFixed(1)}°`);
                
                // Position at pointer
                this.updateGhostPosition(pointer);
                
                // Append to drag overlay instead of document.body to prevent clipping
                const dragOverlay = document.getElementById('dragOverlay');
                if (dragOverlay) {
                    dragOverlay.appendChild(this.ghostElement);
                    console.log(`👻 Ghost element created in drag overlay for ${this.draggedShapeType}`);
                } else {
                    document.body.appendChild(this.ghostElement);
                    console.log(`👻 Ghost element created in document body for ${this.draggedShapeType} (fallback)`);
                }
            }

            createGhostPreview(shapeType, size) {
                const config = getShapeConfig(shapeType);

                // Create canvas element for ghost preview
                const canvas = document.createElement('canvas');
                canvas.width = size;
                canvas.height = size;
                canvas.className = 'shape-preview ghost-preview';
                canvas.dataset.shape = shapeType;

                const ctx = canvas.getContext('2d');
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';

                const scale = UNIFIED_GAME_CONFIG.performance.scaleMultiplier;

                // Use unified texture checking and retrieval
                const textureImage = UnifiedTextureSystem.isTextureAvailable(shapeType) ? 
                    UnifiedTextureSystem.getShapeTexture(shapeType) : null;

                // Render the ghost with or without texture using the unified rendering system
                shapeRenderer.renderShapeOnCanvas(ctx, shapeType, size / 2, size / 2, 0, scale, textureImage);

                debugLog(`👻 Ghost preview created for: ${shapeType} with scale ${scale}, rotation handled by CSS, textured: ${!!textureImage}`);
                return canvas;
            }

            updateGhostPosition(pointer) {
                if (this.ghostElement) {
                    let x = pointer.clientX;
                    let y = pointer.clientY;
                    
                    // Apply touch offset if dragging from dock and offset is enabled
                    if (this.dragStartedFromDock && this.touchOffset.enabled) {
                        x += this.touchOffset.x;
                        y += this.touchOffset.y;
                    }
                    
                    // Set position using left/top
                    this.ghostElement.style.left = `${x}px`;
                    this.ghostElement.style.top = `${y}px`;
                    
                    // Preserve scale (1.1 during drag) and rotation with centering
                    this.ghostElement.style.transform = `translate(-50%, -50%) scale(1.1) rotate(${this.currentRotation}rad)`;
                }
            }

            handlePointerMove(pointer) {
                if (this.isDragging && this.ghostElement) {
                    // Streamlined: Only update ghost position for optimal performance
                    this.updateGhostPosition(pointer);
                }
            }

            handlePointerUp(pointer) {
                if (!this.isDragging) return;
                
                // Check if dropped in game area
                const gameCanvas = document.getElementById('gameCanvas');
                const canvasRect = gameCanvas.getBoundingClientRect();
                
                // Calculate the actual drop position from ghost element if it exists
                let dropX, dropY;
                if (this.ghostElement) {
                    // Get ghost element's center position
                    const ghostRect = this.ghostElement.getBoundingClientRect();
                    dropX = ghostRect.left + ghostRect.width / 2;
                    dropY = ghostRect.top + ghostRect.height / 2;
                } else {
                    // Fallback to pointer position
                    dropX = pointer.clientX;
                    dropY = pointer.clientY;
                }
                
                if (dropX >= canvasRect.left && 
                    dropX <= canvasRect.right &&
                    dropY >= canvasRect.top && 
                    dropY <= canvasRect.bottom) {
                    
                    // Calculate position relative to canvas using ghost position
                    const x = dropX - canvasRect.left;
                    const y = dropY - canvasRect.top;
                    
                    // Use current rotation as-is (it already includes barbell orientation from dock/ghost)
                    const totalRotation = this.currentRotation;
                    console.log(`🔄 Physics: Using current rotation ${(totalRotation * 180 / Math.PI).toFixed(1)}° for ${this.draggedShapeType}`);
                    
                    // Create physics shape at drop position with total rotation
                    const result = this.physicsManager.createCompoundShape(x, y, this.draggedShapeType, totalRotation, this.draggedShapeId);
                    
                    // Update game state
                    this.gameManager.onShapePlaced(this.draggedShapeType);
                    
                    // --- NEW: Mark slot as empty only when dragging from dock ---
                    if (this.dragStartedFromDock) {
                        // Mark this slot as empty since shape was successfully placed
                        this.markSlotAsEmpty(this.draggedElement);
                        console.log(`🗑️ Removing shape from dock after successful placement`);
                    }
                    // --- END NEW ---
                    
                    console.log(`🎯 Shape dropped: ${this.draggedShapeType} at (${x}, ${y}) with ${(totalRotation * 180 / Math.PI).toFixed(0)}° total rotation`);
                } else {
                    // Shape was not dropped in game area, restore it to dock
                    this.restoreShapeToDock();
                    console.log(`↩️ Shape returned to dock: ${this.draggedShapeType}`);
                }
                
                this.endDrag();
            }

            markSlotAsEmpty(shapeElement) {
                if (!shapeElement) return;
                // Remove the shape from dock and mark slot as empty
                const slot = shapeElement.parentElement;
                dockingSpecialEffectsManager.unregisterByElement(shapeElement);
                shapeElement.remove();
                if (slot) {
                    slot.classList.add('empty');
                }

                console.log(`📦 Dock slot emptied: ${this.draggedShapeType}`);
            }

            restoreShapeToDock() {
                // Restore the shape visibility in the dock
                if (this.draggedElement) {
                    // --- UPDATED: Properly restore visibility and remove ghost effect ---
                    this.draggedElement.style.visibility = 'visible';
                    this.draggedElement.style.opacity = '1';
                    this.draggedElement.classList.remove('ghost-active');
                    console.log(`👁️ Restoring shape visibility in dock`);
                    // --- END UPDATED ---
                    
                    if (this.dragStartedFromDock) {
                        dockingSpecialEffectsManager.setEffectVisibility(this.draggedElement, true);
                    }
                }
                
                // --- UPDATED: Ensure ghost element is immediately cleaned up when returning to dock ---
                this.cleanupGhostElement();
                
                // --- NEW: Run safety cleanup to prevent any orphaned elements ---
                this.ensureCleanDockRestore();
                // --- END NEW ---
            }

            cleanupGhostElement() {
                if (this.ghostElement) {
                    try {
                        // Remove from drag overlay if it exists, otherwise from document.body
                        const dragOverlay = document.getElementById('dragOverlay');
                        if (dragOverlay && dragOverlay.contains(this.ghostElement)) {
                            dragOverlay.removeChild(this.ghostElement);
                            console.log(`🧹 Ghost element removed from drag overlay`);
                        } else if (this.ghostElement.parentNode) {
                            this.ghostElement.parentNode.removeChild(this.ghostElement);
                            console.log(`🧹 Ghost element removed from parent node`);
                        }
                    } catch (error) {
                        console.warn(`⚠️ Error removing ghost element:`, error);
                    }
                    
                    // Clear the reference to ensure garbage collection
                    this.ghostElement = null;
                    console.log(`🗑️ Ghost element reference cleared for garbage collection`);
                }
            }

            // --- NEW: Safety method to ensure complete cleanup on dock restoration ---
            ensureCleanDockRestore() {
                // Remove any orphaned ghost elements that might exist
                const dragOverlay = document.getElementById('dragOverlay');
                if (dragOverlay) {
                    const orphanedGhosts = dragOverlay.querySelectorAll('.ghost-shape, .ghost-preview');
                    orphanedGhosts.forEach(ghost => {
                        if (ghost && ghost.parentNode) {
                            ghost.parentNode.removeChild(ghost);
                            console.log(`🧹 Removed orphaned ghost element`);
                        }
                    });
                }
                
                // Clear any ghost-active classes from dock elements
                const dockShapes = document.querySelectorAll('.docking-area .shape-preview.ghost-active');
                dockShapes.forEach(shape => {
                    shape.classList.remove('ghost-active');
                    shape.style.visibility = 'visible';
                    shape.style.opacity = '1';
                });
                
                console.log(`✅ Dock restoration safety cleanup completed`);
            }
            // --- END NEW ---

            showRotationIndicator() {
                const indicator = document.getElementById('rotationIndicator');
                if (indicator) {
                    indicator.classList.add('show');
                }
            }

            hideRotationIndicator() {
                const indicator = document.getElementById('rotationIndicator');
                if (indicator) {
                    indicator.classList.remove('show');
                }
            }

            updateRotationIndicator(angle) {
                const indicator = document.getElementById('rotationIndicator');
                if (indicator) {
                    indicator.textContent = `🔄 Rotation: ${angle}°`;
                }
            }

            /*╔═══════════════════════════════════════════════════════════════════════════
              ║ STREAMLINED DRAG MANAGEMENT (KEYBOARD ONLY)
              ║ Removed mobile gestures and auto-rotation for optimal performance
              ╚═══════════════════════════════════════════════════════════════════════════*/

            endDrag() {
                // --- UPDATED: Removed redundant visibility restoration to prevent conflicts ---
                // The restoreShapeToDock() method already handles visibility restoration
                // Only clean up ghost-active class if element still exists and wasn't handled by restoreShapeToDock
                if (this.draggedElement && this.draggedElement.classList.contains('ghost-active')) {
                    this.draggedElement.classList.remove('ghost-active');
                }
                // --- END UPDATED ---
                
                // --- UPDATED: Use centralized ghost cleanup method ---
                this.cleanupGhostElement();
                // --- END UPDATED ---
                
                // Hide rotation indicator
                this.hideRotationIndicator();
                
                // Reset all drag state variables
                this.isDragging = false;
                this.draggedElement = null;
                this.draggedShapeType = null;
                this.draggedShapeId = null;
                this.currentRotation = 0;
                this.dragStartedFromDock = false;
            }

            // Configuration method for touch offset
            setTouchOffset(x, y, enabled = true) {
                this.touchOffset.x = x;
                this.touchOffset.y = y;
                this.touchOffset.enabled = enabled;
                console.log(`📱 Touch offset updated: x=${x}, y=${y}, enabled=${enabled}`);
            }

            // Get current touch offset settings
            getTouchOffset() {
                return { ...this.touchOffset };
            }

        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ MOBILE ENHANCEMENT MANAGER 
          ║ Adds mobile touch support and rotation zones while preserving mouse/keyboard
          ║ Detects mobile devices and provides touch-optimized interactions
          ╚═══════════════════════════════════════════════════════════════════════════*/
        class MobileEnhancementManager {
            constructor(dragDropManager) {
                this.dragDropManager = dragDropManager;
                this.isMobileDevice = this.detectMobileDevice();
                this.touchStartTime = 0;
                this.touchThreshold = 10; // Minimum movement for drag
                this.rotationTimer = null;
                this.rotationInterval = 1000; // 1 second intervals for mobile rotation
                this.rotationIncrement = Math.PI / 4; // 45 degrees for mobile
                
                // Rotation zones
                this.rotationZones = {
                    left: {
                        element: document.getElementById('leftRotationZone'),
                        direction: -1, // CCW
                        active: false,
                        bounds: null
                    },
                    right: {
                        element: document.getElementById('rightRotationZone'), 
                        direction: 1, // CW
                        active: false,
                        bounds: null
                    }
                };
                
                if (this.isMobileDevice) {
                    this.setupTouchEnhancements();
                    console.log('📱 Mobile enhancements activated');
                } else {
                    console.log('🖥️ Desktop mode - mobile enhancements disabled');
                }
            }
            
            detectMobileDevice() {
                return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                       (navigator.maxTouchPoints && navigator.maxTouchPoints > 2) ||
                       window.innerWidth <= 768;
            }
            
            setupTouchEnhancements() {
                // Set reference in DragDropManager to prevent duplicate touch handlers
                this.dragDropManager.mobileEnhancementManager = this;
                
                // Unified touch event listeners for mobile-specific features
                document.addEventListener('touchstart', (e) => this.handleUnifiedTouchStart(e), { passive: false });
                document.addEventListener('touchmove', (e) => this.handleUnifiedTouchMove(e), { passive: false });
                document.addEventListener('touchend', (e) => this.handleUnifiedTouchEnd(e), { passive: false });
                
                // Update rotation zone bounds
                this.updateRotationZoneBounds();
                window.addEventListener('resize', () => this.updateRotationZoneBounds());
                
                // Hook into DragDropManager to add mobile features
                this.originalStartDrag = this.dragDropManager.startDrag.bind(this.dragDropManager);
                this.dragDropManager.startDrag = (element, event) => {
                    this.originalStartDrag(element, event);
                    this.showRotationZones();
                };
                
                this.originalEndDrag = this.dragDropManager.endDrag.bind(this.dragDropManager);
                this.dragDropManager.endDrag = () => {
                    this.hideRotationZones();
                    this.stopRotationTimer();
                    this.originalEndDrag();
                };
            }
            
            updateRotationZoneBounds() {
                const canvas = document.getElementById('gameCanvas');
                const canvasRect = canvas.getBoundingClientRect();
                
                this.rotationZones.left.bounds = {
                    left: canvasRect.left,
                    right: canvasRect.left + 80,
                    top: canvasRect.top,
                    bottom: canvasRect.bottom
                };
                
                this.rotationZones.right.bounds = {
                    left: canvasRect.right - 80,
                    right: canvasRect.right,
                    top: canvasRect.top,
                    bottom: canvasRect.bottom
                };
            }
            
            // Unified touch handlers that coordinate drag and rotation functionality
            handleUnifiedTouchStart(event) {
                if (event.touches.length !== 1) return;
                
                const touch = event.touches[0];
                this.touchStartTime = Date.now();
                
                // First check if touching a draggable shape
                const targetShape = touch.target.closest('.game-shape');
                if (targetShape) {
                    // Haptic feedback on touch down for shapes
                    if (navigator.vibrate) {
                        navigator.vibrate(50);
                    }
                    
                    // Delegate to DragDropManager for shape handling
                    const mouseEvent = new MouseEvent('mousedown', {
                        clientX: touch.clientX,
                        clientY: touch.clientY,
                        button: 0
                    });
                    this.dragDropManager.handlePointerDown(mouseEvent);
                    event.preventDefault();
                } else {
                    // Check rotation zones for non-shape touches
                    this.checkRotationZones(touch.clientX, touch.clientY);
                }
            }
            
            handleUnifiedTouchMove(event) {
                if (event.touches.length !== 1) return;
                
                const touch = event.touches[0];
                
                // If dragging, delegate to DragDropManager AND handle rotation zones
                if (this.dragDropManager.isDragging) {
                    // Handle drag movement
                    const mouseEvent = new MouseEvent('mousemove', {
                        clientX: touch.clientX,
                        clientY: touch.clientY
                    });
                    this.dragDropManager.throttledHandlePointerMove(mouseEvent);
                    
                    // Check rotation zones with haptic feedback
                    const wasInZone = this.currentRotationZone;
                    this.checkRotationZones(touch.clientX, touch.clientY);
                    
                    // Haptic feedback when entering rotation zone
                    if (this.currentRotationZone && !wasInZone && navigator.vibrate) {
                        navigator.vibrate(30);
                    }
                    
                    event.preventDefault();
                }
            }

            handleUnifiedTouchEnd(event) {
                const touch = event.changedTouches[0];
                
                // Handle rotation if in rotation zone while dragging
                if (this.currentRotationZone && this.dragDropManager.isDragging) {
                    const rotationDirection = this.currentRotationZone === 'left' ? -1 : 1;
                    this.dragDropManager.rotateShape(rotationDirection * this.dragDropManager.rotationStep);
                    
                    // Stronger haptic feedback for rotation
                    if (navigator.vibrate) {
                        navigator.vibrate([50, 50, 50]);
                    }
                }
                
                // If dragging, delegate to DragDropManager
                if (this.dragDropManager.isDragging) {
                    // Light haptic feedback on drop
                    if (navigator.vibrate) {
                        navigator.vibrate(25);
                    }
                    
                    const mouseEvent = new MouseEvent('mouseup', {
                        clientX: touch.clientX,
                        clientY: touch.clientY,
                        button: 0
                    });
                    this.dragDropManager.handlePointerUp(mouseEvent);
                }
                
                // Clean up rotation zones
                this.hideRotationZones();
                this.stopRotationTimer();
                this.currentRotationZone = null;
                
                event.preventDefault();
            }            checkRotationZones(x, y) {
                let inZone = null;
                
                // Check left zone
                if (this.isPointInZone(x, y, this.rotationZones.left.bounds)) {
                    inZone = 'left';
                }
                // Check right zone
                else if (this.isPointInZone(x, y, this.rotationZones.right.bounds)) {
                    inZone = 'right';
                }
                
                // Update current rotation zone
                this.currentRotationZone = inZone;
                
                // Handle zone entry/exit
                if (inZone && !this.rotationZones[inZone].active) {
                    this.enterRotationZone(inZone);
                } else if (!inZone) {
                    this.exitAllRotationZones();
                }
            }
            
            isPointInZone(x, y, bounds) {
                return bounds && x >= bounds.left && x <= bounds.right && 
                       y >= bounds.top && y <= bounds.bottom;
            }
            
            enterRotationZone(zoneName) {
                const zone = this.rotationZones[zoneName];
                if (!zone || !zone.element) return;
                
                // Exit other zones first
                this.exitAllRotationZones();
                
                // Activate this zone
                zone.active = true;
                zone.element.classList.add('active');
                
                // Start rotation timer
                this.rotationTimer = setInterval(() => {
                    if (this.dragDropManager.isDragging) {
                        this.dragDropManager.currentRotation += zone.direction * this.rotationIncrement;
                        
                        // Update ghost element rotation
                        if (this.dragDropManager.ghostElement) {
                            this.dragDropManager.ghostElement.style.transform = 
                                `translate(-50%, -50%) scale(1.1) rotate(${this.dragDropManager.currentRotation}rad)`;
                        }
                        
                        // Haptic feedback
                        this.playHapticFeedback();
                    }
                }, this.rotationInterval);
                
                console.log(`📱 Entered ${zoneName} rotation zone`);
            }
            
            exitAllRotationZones() {
                Object.keys(this.rotationZones).forEach(zoneName => {
                    const zone = this.rotationZones[zoneName];
                    if (zone.active && zone.element) {
                        zone.active = false;
                        zone.element.classList.remove('active');
                    }
                });
                
                this.stopRotationTimer();
            }
            
            stopRotationTimer() {
                if (this.rotationTimer) {
                    clearInterval(this.rotationTimer);
                    this.rotationTimer = null;
                }
            }
            
            showRotationZones() {
                // Show rotation zones during drag for both mobile and desktop
                Object.values(this.rotationZones).forEach(zone => {
                    if (zone.element) {
                        zone.element.classList.add('visible');
                    }
                });
                console.log('📱 Rotation zones shown');
            }
            
            hideRotationZones() {
                Object.values(this.rotationZones).forEach(zone => {
                    if (zone.element) {
                        zone.element.classList.remove('visible', 'active');
                    }
                });
            }
            
            playHapticFeedback() {
                if (navigator.vibrate) {
                    navigator.vibrate(50); // Short vibration
                }
            }
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ ENHANCED GAME STATE WITH END-LEVEL COUNTDOWN
          ║ Task 4.2c: Implements end-level countdown timer and level failure conditions
          ║ Level fails if any piece falls off screen before countdown expires
          ╚═══════════════════════════════════════════════════════════════════════════*/
        class GameState {
            constructor() {
                this.shapes = [];
                this.placedShapes = [];
                this.isGameActive = true;
                this.isCountdownActive = false;
                this.countdownTime = 3;
                
                // HUD State
                this.level = 1;
                this.score = 0;
                this.coins = 0;
                this.progress = 0; // 0-100%
                
                // Timer System
                this.timerMode = 'elapsed'; // 'elapsed', 'countdown', 'endlevel'
                this.gameTime = 0; // Elapsed seconds
                this.endLevelTime = currentLevelConfig.endLevelDuration; // End level countdown duration from config
                this.endLevelDots = 0;
                
                // Physics Event Tracking
                this.shapeCollisions = 0;
                this.platformLandings = 0;
                this.shapeFalls = 0;
                this.stability = 100; // Stability percentage
                
                // End-Level State
                this.endLevelStarted = false;
                this.levelFailed = false;
                this.levelCompleted = false;
                this.isGameOver = false;
            }

            startEndLevelCountdown() {
                this.endLevelStarted = true;
                this.timerMode = 'endlevel';
                this.endLevelTime = currentLevelConfig.endLevelDuration; // Use configured duration
                this.isCountdownActive = true;
                
                console.log(`⏰ End-level countdown started: ${currentLevelConfig.endLevelDuration} seconds`);
            }

            checkLevelFailure() {
                // Level fails if any shape falls during end-level countdown
                if (this.endLevelStarted && !this.levelCompleted && this.shapeFalls > 0) {
                    this.levelFailed = true;
                    this.isGameActive = false;
                    return true;
                }
                return false;
            }

            resetLevel() {
                this.shapes = [];
                this.placedShapes = [];
                this.isGameActive = true;
                this.isCountdownActive = false;
                this.countdownTime = 3;
                this.gameTime = 0;
                this.timerMode = 'elapsed';
                this.endLevelTime = currentLevelConfig.endLevelDuration;
                this.endLevelDots = 0;
                
                // Reset score and coins to zero for fresh start
                this.score = 0;
                this.coins = 0;
                this.progress = 0;
                
                // Reset physics event tracking
                this.shapeCollisions = 0;
                this.platformLandings = 0;
                this.shapeFalls = 0;
                this.stability = 100;
                
                // Reset end-level state
                this.endLevelStarted = false;
                this.levelFailed = false;
                this.levelCompleted = false;
                this.isGameOver = false;
                
                console.log('🔄 Game state reset for new level');
            }

            addPlacedShape(shapeType) {
                this.placedShapes.push({
                    type: shapeType,
                    timestamp: Date.now()
                });
                
                const totalShapes = currentLevelConfig.dockShapes.length;
                console.log(`📊 Shape placed: ${shapeType} (${this.placedShapes.length}/${totalShapes})`);
            }

            recordPhysicsEvent(eventType) {
                switch(eventType) {
                    case 'collision':
                        this.shapeCollisions++;
                        break;
                    case 'landing':
                        this.platformLandings++;
                        break;
                    case 'fall':
                        this.shapeFalls++;
                        this.stability = Math.max(0, this.stability - 10); // Reduce stability on falls
                        
                        // Check if this fall causes level failure
                        if (this.checkLevelFailure()) {
                            console.log('💥 LEVEL FAILED: Shape fell during end-level countdown!');
                        }
                        break;
                }
            }
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ ENHANCED GAME MANAGER WITH PHYSICS EVENT INTEGRATION
          ║ Phase 4.1: Integrates physics events with game logic and UI updates
          ╚═══════════════════════════════════════════════════════════════════════════*/
        class GameManager {
            constructor(levelData) {
                console.log('🔧 GameManager initialization started with level data:', levelData);
                
                this.levelData = levelData;
                this.gameState = new GameState();
                
                // Store configuration
                this.currentWorld = levelData?.meta?.worldNumber ?? 1;
                this.currentLevel = levelData?.meta?.levelNumber ?? 1;
                
                // Gameplay settings (rotation zones, auto rotation, unlock thresholds, etc.)
                this.gameplaySettings = this.levelData?.gameplay || {};
                
                // Stub managers for unsupported systems
                this.objectiveManager = new ObjectiveManager(this.levelData?.victory, this.levelData?.failure);
                this.starManager = new StarManager(this.levelData?.entities?.stars || []);
                this.onboardingManager = new OnboardingManager(this.levelData?.onboarding);
                
                // Theme overrides and base theme id
                this.baseThemeId = this.levelData?.theme?.baseThemeId || null;
                this.themeOverrides = this.levelData?.theme?.overrides || null;
                
                // Add a flag to ensure the dock animation only plays once
                this.dockAnimationPlayed = false;
                
                // Add flag to prevent duplicate theme applications
                this.levelThemeApplied = false;
                
                // Initialize subsystems in correct order
                this.initPromise = this.initializeAsync();
            }
            
            async initializeAsync() {
                debugLog('⏳ Starting async GameManager initialization...');
                
                // Create initialization chain with proper dependencies
                const initSteps = [
                    { name: 'AssetManager', fn: () => this.ensureAssetManager() },
                    { name: 'Physics', fn: () => this.initializePhysics() },
                    { name: 'DefaultTheme', fn: () => this.physicsManager.initializeDefaultTheme() },
                    { name: 'UI', fn: () => this.setupUI() },
                    { name: 'Events', fn: () => this.setupEventListeners() },
                    { name: 'DragDrop', fn: () => this.initializeDragDrop() },
                    { name: 'Theme', fn: () => this.initializeThemeManager() },
                    { name: 'LevelTheme', fn: () => this.conditionallyApplyLevelTheme() }
                ];
                
                for (const step of initSteps) {
                    try {
                        debugLog(`⚙️ Initializing ${step.name}...`);
                        await step.fn();
                        debugLog(`✅ ${step.name} initialized`);
                    } catch (error) {
                        console.error(`❌ Failed to initialize ${step.name}:`, error);
                        throw error;
                    }
                }
                
                // Make this globally available only after all components are ready
                window.gameManager = this;
                if (this.physicsManager) {
                    this.physicsManager.gameManager = this;
                }
                
                debugLog('✅ GameManager initialization complete');
                debugLog(`🎮 Game Manager initialized for level: "${this.levelData?.meta?.displayName ?? 'Unknown'}"`);
            }
            
            ensureAssetManager() {
                if (!window.assetManager) {
                    window.assetManager = new AssetManager();
                }
            }
            
            initializePhysics() {
                const gameCanvas = document.getElementById('gameCanvas');
                this.canvas = gameCanvas;
                this.physicsManager = new PhysicsManager(gameCanvas, this.levelData.physics || {});
            }
            
            initializeDragDrop() {
                this.dragDropManager = new DragDropManager(this.physicsManager, this);
                this.mobileEnhancementManager = new MobileEnhancementManager(this.dragDropManager);
            }
            
            initializeThemeManager() {
                this.themeManager = new ThemeManager(window.assetManager, this);
            }
            
            async conditionallyApplyLevelTheme() {
                if (this.levelData.theme) {
                    await this.applyLevelTheme();
                }
            }
            
            async rebuildDockFromData(isInitialLoad = false) {
                console.log('🔧 Rebuilding dock from level data...');
                
                // Wait for initialization if needed
                if (this.initPromise && isInitialLoad) {
                    await this.initPromise;
                }
                
                // Set configuration
                window.currentLevelConfig = {
                    dockShapes: this.levelData.dockSlots || getAllShapeTypes()
                };
                
                // Rebuild dock
                await rebuildGameDock();
                
                // Apply appearance
                this.applyDockAppearance();
            }

            triggerDockAnimation() {
                debugLog('Attempting to trigger dock animation...');
                if (this.dockAnimationPlayed) {
                    debugLog('Animation already played. Skipping.');
                    return;
                }

                // Double-check that dock is actually ready for animation
                const dockingArea = document.getElementById('dockingArea');
                if (!dockingArea) {
                    debugLog('Docking area not found. Skipping animation.');
                    return;
                }

                const animConfig = this.levelData?.dock?.animation;
                if (!animConfig || !animConfig.enabled) {
                    debugLog('Animation is disabled in config. Skipping.');
                    dockingArea.classList.remove('loading');
                    return;
                }

                debugLog('Animation config found:', animConfig);

                const shapes = document.querySelectorAll('.docking-area .game-shape');
                if (!shapes.length) {
                    debugLog('No shapes found in the dock to animate. Skipping.');
                    dockingArea.classList.remove('loading');
                    return;
                }

                debugLog(`Found ${shapes.length} shapes to animate.`);

                // Mark animation as started to prevent multiple triggers
                this.dockAnimationPlayed = true;

                const lastShape = shapes[shapes.length - 1];

                const onAnimationEnd = (event) => {
                    // Ensure we only react to the opacity transition to avoid multiple triggers
                    if (event.propertyName !== 'opacity') {
                        return;
                    }
                    const dockingArea = document.getElementById('dockingArea');
                    if (dockingArea) {
                        dockingArea.classList.remove('loading');
                        debugLog('Dock animation complete, removed loading class.');
                    }
                    lastShape.removeEventListener('transitionend', onAnimationEnd);
                };

                lastShape.addEventListener('transitionend', onAnimationEnd);

                shapes.forEach((shape, index) => {
                    // console.log(`Applying animation to shape ${index}`);
                    // Set initial state
                    shape.style.opacity = '0';
                    shape.style.transform = `scale(${animConfig.minScale || 0.1})`;

                    // Stagger the animation start
                    setTimeout(() => {
                        // Add the class to enable transitions
                        shape.classList.add('shape-entrance-animation');

                        // Set transition properties from config
                        shape.style.transitionDuration = `${animConfig.durationMs || 2000}ms`;
                        shape.style.transitionTimingFunction = animConfig.easing || 'cubic-bezier(0.175, 0.885, 0.32, 1.275)';

                        // Trigger the animation by setting the final state
                        // Use a tiny timeout to ensure the initial styles are applied before the transition starts
                        setTimeout(() => {
                            shape.style.opacity = '1';
                            shape.style.transform = 'scale(1)';
                        }, 20);

                    }, index * (animConfig.staggerMs || 100));
                });
            }

            setupUI() {
                // Initialize HUD displays
                this.updateScoreDisplay();
                this.updateCoinDisplay();
                this.updateLevelDisplay();
                this.updateStars(0);
                this.updateDebugInfo();

                // Initialize HUD timer system
                this.startTimer();

                // Event listeners are handled by onclick in HTML - no need for duplicate listener
                debugLog('🎮 GameManager initialized with unified reset system');
            }

            setupEventListeners() {
                // Keyboard controls for testing (fallback)
                document.addEventListener('keydown', (e) => {
                    if (!this.gameState.isGameActive) return;
                    
                    const centerX = this.canvas.width / 2;
                    const dropY = 100;
                    
                    switch(e.key) {
                        case '1':
                            this.physicsManager.createShape(centerX, dropY, 'square');
                            this.onShapePlaced('square');
                            break;
                        case '2':
                            this.physicsManager.createShape(centerX, dropY, 'triangle');
                            this.onShapePlaced('triangle');
                            break;
                        case '3':
                            this.physicsManager.createShape(centerX, dropY, 'circle');
                            this.onShapePlaced('circle');
                            break;
                        case '4':
                            this.physicsManager.createShape(centerX, dropY, 'cross2');
                            this.onShapePlaced('cross2');
                            break;
                        case '5':
                            this.physicsManager.createShape(centerX, dropY, 'l');
                            this.onShapePlaced('l');
                            break;
                        case '6':
                            this.physicsManager.createShape(centerX, dropY, 'cross');
                            this.onShapePlaced('cross');
                            break;
                        case '7':
                            this.physicsManager.createShape(centerX, dropY, 'barbell-one');
                            this.onShapePlaced('barbell-one');
                            break;
                        case '8':
                            this.physicsManager.createShape(centerX, dropY, 'barbell-two');
                            this.onShapePlaced('barbell-two');
                            break;
                        case '9':
                            this.physicsManager.createShape(centerX, dropY, 'diamond-barbell');
                            this.onShapePlaced('diamond-barbell');
                            break;
                    }
                });
            }

            startTimer() {
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                }
                this.timerInterval = setInterval(() => this.updateTimer(), 1000);
            }

            stopTimer() {
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                    this.timerInterval = null;
                }
            }

            // UI Update Methods
            updateScoreDisplay() {
                const scoreElement = document.getElementById('scoreText');
                if (scoreElement) {
                    scoreElement.textContent = this.gameState.score.toLocaleString();
                    
                    // Add animation for score increase
                    scoreElement.classList.add('score-increase');
                    setTimeout(() => {
                        scoreElement.classList.remove('score-increase');
                    }, 600);
                }
            }

            updateCoinDisplay() {
                const coinElement = document.getElementById('coinAmount');
                if (coinElement) {
                    coinElement.textContent = this.gameState.coins.toString();
                    
                    // Add animation for coin increase
                    coinElement.classList.add('coin-increase');
                    setTimeout(() => {
                        coinElement.classList.remove('coin-increase');
                    }, 600);
                }
            }

            updateLevelDisplay() {
                const levelElement = document.getElementById('levelDisplay');
                if (levelElement) {
                    // Use displayName from level data if available
                    if (this.levelData && this.levelData.meta && this.levelData.meta.displayName) {
                        levelElement.textContent = this.levelData.meta.displayName;
                    } else {
                        levelElement.textContent = `World ${this.currentWorld}-${this.currentLevel}`;
                    }
                }
            }

            // Level progression methods
            nextLevel() {
                this.currentLevel++;
                this.updateLevelDisplay();
                console.log(`🏁 Advanced to World ${this.currentWorld}-${this.currentLevel}`);
            }

            nextWorld() {
                this.currentWorld++;
                this.currentLevel = 1;
                this.updateLevelDisplay();
                console.log(`🌍 Advanced to World ${this.currentWorld}-${this.currentLevel}`);
            }

            setLevel(world, level) {
                this.currentWorld = world;
                this.currentLevel = level;
                this.updateLevelDisplay();
                console.log(`📍 Set level to World ${this.currentWorld}-${this.currentLevel}`);
            }

            // Physics Event Handlers
            onShapeLandedOnPlatform() {
                if (!this.gameState.isGameActive) {
                    return;
                }

                console.log('🎯 GameManager: Shape landed on platform - triggering camera shake!');
                this.gameState.recordPhysicsEvent('landing');
                
                // Track consecutive landings for streak bonuses
                this.gameState.consecutiveLandings = (this.gameState.consecutiveLandings || 0) + 1;
                this.gameState.lastAction = 'landing';
                
                // Base rewards
                let scoreBonus = 50;
                let coinBonus = 1;
                
                // Streak multipliers
                if (this.gameState.consecutiveLandings >= 5) {
                    coinBonus += 5; // +5 coins for 5+ streak
                    scoreBonus += 100;
                    this.createCoinShower('LANDING MASTER!', 5);
                } else if (this.gameState.consecutiveLandings >= 3) {
                    coinBonus += 2; // +2 coins for 3+ streak
                    scoreBonus += 50;
                    this.createFloatingText(`🔥 ${this.gameState.consecutiveLandings}x STREAK!`, 
                        document.getElementById('coinAmount'), '#FF6B35');
                }
                
                this.gameState.score += scoreBonus;
                this.gameState.coins += coinBonus;
                this.updateScoreDisplay();
                this.updateCoinDisplay();
                
                // Sound effect integration point
                this.playSound('shapeLanding');
                
                // Create enhanced particle effects
                if (this.physicsManager && this.physicsManager.particleSystem) {
                    const canvasRect = this.physicsManager.canvas.getBoundingClientRect();
                    const platformY = canvasRect.height * 0.85;
                    const x = Math.random() * canvasRect.width * 0.6 + canvasRect.width * 0.2;
                    const particleCount = Math.min(12 + this.gameState.consecutiveLandings * 2, 24);
                    this.physicsManager.particleSystem.createThemeParticles('landing', x, platformY, particleCount);
                }
                
                // Enhanced visual feedback
                const scoreElement = document.getElementById('scoreText');
                const coinElement = document.getElementById('coinAmount');
                
                this.createFloatingText(`+${scoreBonus}`, scoreElement, '#10B981');
                this.createFloatingText(`+${coinBonus}`, coinElement, '#FFD700');
                
                // Extra visual effects for big bonuses
                if (coinBonus > 3) {
                    this.createFloatingText('💰💰💰', coinElement, '#FFD700');
                    this.pulseElement(coinElement, 3);
                }
                

            }

            onShapeCollision() {
                if (!this.gameState.isGameActive) {
                    return;
                }


                this.gameState.recordPhysicsEvent('collision');
                
                // Reset landing streak on collision
                this.gameState.consecutiveLandings = 0;
                
                // Track collision chains for bonus coins
                this.gameState.recentCollisions = (this.gameState.recentCollisions || 0) + 1;
                
                // Base rewards
                let scoreBonus = 25;
                let coinBonus = 0;
                
                // Collision-based coin rewards
                if (this.gameState.recentCollisions % 1 === 0) { // Every collision now gives coins!
                    coinBonus = 1;
                    
                    // Bonus for rapid collisions
                    if (this.gameState.recentCollisions >= 3) {
                        coinBonus += 2; // +2 extra for collision chains
                        scoreBonus += 25;
                        this.createFloatingText('💥 CHAIN REACTION!', document.getElementById('scoreText'), '#FF6B35');
                    }
                }
                
                // Random coin jackpots (5% chance)
                if (Math.random() < 0.05) {
                    const jackpot = Math.floor(Math.random() * 10) + 5; // 5-14 coins
                    coinBonus += jackpot;
                    this.createCoinShower('JACKPOT!', jackpot);
                    
                    // Small celebratory shake for big jackpots
                    if (jackpot >= 10 && this.physicsManager) {
                        this.physicsManager.startCameraShake(4, 300);
                    }
                }
                
                this.gameState.score += scoreBonus;
                this.gameState.coins += coinBonus;
                
                // Sound effect integration point
                this.playSound('shapeCollision');
                
                // Create enhanced particle effects
                if (this.physicsManager && this.physicsManager.particleSystem) {
                    const canvasRect = this.physicsManager.canvas.getBoundingClientRect();
                    const x = Math.random() * canvasRect.width * 0.8 + canvasRect.width * 0.1;
                    const y = Math.random() * canvasRect.height * 0.6 + canvasRect.height * 0.2;
                    const particleCount = Math.min(8 + this.gameState.recentCollisions, 20);
                    this.physicsManager.particleSystem.createThemeParticles('collision', x, y, particleCount);
                }
                
                this.updateScoreDisplay();
                if (coinBonus > 0) {
                    this.updateCoinDisplay();
                    const coinElement = document.getElementById('coinAmount');
                    this.createFloatingText(`+${coinBonus}`, coinElement, '#FFD700');
                }
                
                // Add visual feedback for collision bonuses
                const scoreElement = document.getElementById('scoreText');
                this.createFloatingText(`+${scoreBonus}`, scoreElement, '#4ECDC4');
                
                // Reset collision counter after a pause
                setTimeout(() => {
                    if (this.gameState.lastAction !== 'collision') {
                        this.gameState.recentCollisions = 0;
                    }
                }, 2000);
                
                this.gameState.lastAction = 'collision';
                

            }

            onShapeFell() {
                if (this.gameState.isGameOver) {
                    return;
                }

                
                this.gameState.recordPhysicsEvent('fall');
                
                // Track fall time for stability bonuses
                this.gameState.lastFallTime = Date.now();
                
                // Reset all streaks on fall
                this.gameState.consecutiveLandings = 0;
                this.gameState.recentCollisions = 0;
                
                // Dramatic penalties based on current coin count
                let scorePenalty = 100;
                let coinPenalty = 3; // Increased base penalty
                
                // Scale penalties with current wealth (more coins = bigger penalty)
                if (this.gameState.coins >= 50) {
                    coinPenalty += 7; // -10 coins total for wealthy players
                    scorePenalty += 200;
                    this.createFloatingText('💸 MAJOR LOSS!', document.getElementById('coinAmount'), '#FF4444');
                } else if (this.gameState.coins >= 20) {
                    coinPenalty += 2; // -5 coins total
                    scorePenalty += 100;
                }
                
                // Apply penalties with minimums
                this.gameState.score = Math.max(0, this.gameState.score - scorePenalty);
                this.gameState.coins = Math.max(0, this.gameState.coins - coinPenalty);
                
                this.updateScoreDisplay();
                this.updateCoinDisplay();
                
                // Dramatic visual effects
                const coinElement = document.getElementById('coinAmount');
                const scoreElement = document.getElementById('scoreText');
                
                this.createFloatingText(`-${coinPenalty}`, coinElement, '#FF6B6B');
                this.createFloatingText(`-${scorePenalty}`, scoreElement, '#FF6B6B');
                
                // Shake effect for major losses
                if (coinPenalty >= 5) {
                    this.shakeElement(coinElement, 5);
                    this.createFloatingText('💀💀�', coinElement, '#FF4444');
                }
                
                // Camera shake effect for dramatic falls
                const randomIntensity = Math.floor(Math.random() * 10) + 10;
                const duration = 800;
                
                if (this.physicsManager) {
                    this.physicsManager.startCameraShake(randomIntensity, duration);
                }
                
                this.playSound('shapeFall');

                if (this.gameState.levelFailed) {
                    this.onLevelFailed();
                }

                this.onGameOver('Ground Collision!');
            }

            onShapePlaced(shapeType) {
                if (!this.gameState.isGameActive) {
                    return;
                }

                this.gameState.addPlacedShape(shapeType);
                this.updateDebugInfo();
                
                // Update score
                this.gameState.score += 100;
                document.getElementById('scoreText').textContent = this.gameState.score.toLocaleString();
                
                // Update progress bar using current dock configuration
                const totalShapes = currentLevelConfig.dockShapes.length;
                const progress = (this.gameState.placedShapes.length / totalShapes) * 100;
                document.getElementById('starProgressBar').style.width = progress + '%';
                
                // Update stars based on progress
                this.updateStars(this.gameState.placedShapes.length);
                
                // Check for level completion (start end-level countdown)
                if (this.gameState.placedShapes.length >= totalShapes) {


                    // Coin reward for successfully placing all shapes
                    this.gameState.coins += 5;
                    this.updateCoinDisplay();

                    // Show coin reward particle
                    const coinElement = document.getElementById('coinAmount');
                    this.createFloatingText('+5 All Shapes!', coinElement, '#FFD700');

                    this.gameState.startEndLevelCountdown();
                    this.physicsManager.showEventNotification('End-Level Countdown!', 'balance');
                }

                this.checkUnlockConditions();
            }

            updateStars(shapesPlaced) {
                const stars = document.querySelectorAll('.star');
                const totalShapes = currentLevelConfig.dockShapes.length;
                const progressPercent = (shapesPlaced / totalShapes) * 100;
                
                // Star thresholds: 33.33%, 66.66%, 100%
                const starThresholds = [33.33, 66.66, 100];
                
                stars.forEach((star, index) => {
                    const threshold = starThresholds[index];
                    const shouldBeFilled = progressPercent >= threshold;
                    
                    if (shouldBeFilled && !star.classList.contains('filled')) {
                        // Star should be filled and isn't yet
                        const wasEmpty = !star.classList.contains('filled');
                        star.classList.add('filled');
                        
                        // Add particle effect for newly filled star
                        if (wasEmpty) {
                            setTimeout(() => {
                                this.createFloatingText('⭐', star, '#FFD700');
                            }, 100);
                        }
                    } else if (!shouldBeFilled && star.classList.contains('filled')) {
                        // Star should not be filled but is
                        star.classList.remove('filled');
                    }
                });
                
                // Update progress bar with animation using current dock configuration
                const progressBar = document.getElementById('starProgressBar');
                
                // Smooth progress bar animation
                progressBar.style.transition = 'width 0.5s ease-out';
                progressBar.style.width = progressPercent + '%';
                
                if (shapesPlaced > 0) {
                    this.animateProgressBar(progressBar);
                }
            }

            updateTimer() {
                if (!this.gameState.isGameActive) return;
                
                const timerElement = document.getElementById('gameTimer');
                
                switch(this.gameState.timerMode) {
                    case 'elapsed':
                        this.updateElapsedTimer(timerElement);
                        break;
                    case 'countdown':
                        this.updateCountdownTimer(timerElement);
                        break;
                    case 'endlevel':
                        this.updateEndLevelTimer(timerElement);
                        break;
                }
            }

            updateElapsedTimer(element) {
                const minutes = Math.floor(this.gameState.gameTime / 60);
                const seconds = this.gameState.gameTime % 60;
                element.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                this.gameState.gameTime++;
                
                // Remove any warning classes
                element.classList.remove('timer-warning', 'timer-critical');
            }

            updateCountdownTimer(element) {
                // Use gameTime for countdown timer (starts from configured time and counts down)
                const minutes = Math.floor(this.gameState.gameTime / 60);
                const seconds = this.gameState.gameTime % 60;
                element.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                
                // Remove previous warning classes
                element.classList.remove('timer-warning', 'timer-critical');
                
                // Add warning effects based on time remaining
                if (this.gameState.gameTime <= 5 && this.gameState.gameTime > 0) {
                    element.classList.add('timer-critical');
                } else if (this.gameState.gameTime <= 10) {
                    element.classList.add('timer-warning');
                }
                
                // Countdown: decrease time
                this.gameState.gameTime--;
                
                // Check if countdown reached zero
                if (this.gameState.gameTime < 0) {
                    this.gameState.gameTime = 0; // Prevent negative display
                    element.textContent = '0:00';
                    
                    // Trigger game over due to time up
                    console.log('⏰ Countdown timer reached zero - Game Over!');
                    this.onGameTimeUp();
                }
            }

            updateEndLevelTimer(element) {
                // Create 3-dot display if it doesn't exist
                if (!element.querySelector('.countdown-dots')) {
                    console.log('🔴 Creating dramatic 3-dot countdown display...');
                    element.innerHTML = '';
                    const dotsContainer = document.createElement('div');
                    dotsContainer.className = 'countdown-dots';
                    
                    for (let i = 0; i < 3; i++) {
                        const dot = document.createElement('div');
                        dot.className = 'countdown-dot';
                        dot.id = `countdown-dot-${i}`;
                        dotsContainer.appendChild(dot);
                    }
                    
                    element.appendChild(dotsContainer);
                    this.gameState.endLevelDots = 0;
                    console.log('✅ 3-dot countdown display created!');
                }
                
                // Update dots based on time remaining using configured duration
                const totalDuration = currentLevelConfig.endLevelDuration;
                const timeElapsed = totalDuration - this.gameState.endLevelTime;
                const dotsToShow = Math.min(3, Math.ceil((timeElapsed / totalDuration) * 3));
                console.log(`🔵 Updating dots: ${dotsToShow} active dots, ${this.gameState.endLevelTime}s remaining (total: ${totalDuration}s)`);
                
                for (let i = 0; i < 3; i++) {
                    const dot = document.getElementById(`countdown-dot-${i}`);
                    if (dot) {
                        if (i < dotsToShow) {
                            if (i === dotsToShow - 1 && this.gameState.endLevelTime > 0) {
                                dot.className = 'countdown-dot active';
                            } else {
                                dot.className = 'countdown-dot completed';
                            }
                        } else {
                            dot.className = 'countdown-dot';
                        }
                    }
                }
                
                this.gameState.endLevelTime--;
                
                if (this.gameState.endLevelTime < 0) {
                    console.log('🏆 End level countdown complete! Level finished!');
                    this.triggerLevelCompleteEffects();
                    this.onLevelComplete();
                }
            }

            updateDebugInfo() {
                const debugInfo = document.getElementById('debugInfo');
                const physicsStats = this.physicsManager.getEventStats();
                // Determine total shapes based on loaded level data (for v2.2+ files)
                let totalShapes = 0;
                if (this.levelData && this.levelData.dock && Array.isArray(this.levelData.dock.slots)) {
                    totalShapes = this.levelData.dock.slots.length;
                } else if (window.currentLevelConfig && Array.isArray(window.currentLevelConfig.dockShapes)) {
                    totalShapes = window.currentLevelConfig.dockShapes.length;
                }
                // Count available shapes (not being dragged)
                const availableShapes = document.querySelectorAll('.game-shape:not(.dragging)').length;
                if (debugInfo) {
                    debugInfo.textContent = `Placed: ${this.gameState.placedShapes.length}/${totalShapes} | Dock: ${availableShapes}/${totalShapes} | Events: ${physicsStats.events} | FPS: 60`;
                }
            }

            /**
             * Rebuild the docking area from level data, generating slots and previews.
             */
            rebuildDockFromData(isInitialLoad = false) {
                const dockData = this.levelData?.dock;
                if (!dockData || !Array.isArray(dockData.slots)) {
                    console.error('❌ Dock data is missing or invalid in level file.');
                    return;
                }
                if (window.currentLevelConfig) {
                    window.currentLevelConfig.dockShapes = dockData.slots
                        .map(slot => slot.shapePrefabId)
                        .filter(shape => !!shape);
                    window.currentLevelConfig.dockSlots = dockData.slots.length;
                }
                const dockingArea = document.getElementById('dockingArea');
                if (!dockingArea) {
                    console.error('❌ dockingArea not found!');
                    return;
                }
                dockingSpecialEffectsManager.reset();
                dockingArea.innerHTML = '';
                if (dockData.layout) {
                    dockingArea.style.gridTemplateColumns = `repeat(${dockData.layout.columns}, 1fr)`;
                    dockingArea.style.gridTemplateRows = `repeat(${dockData.layout.rows}, 1fr)`;
                }
                dockData.slots.forEach((slotData) => {
                    const slotDiv = document.createElement('div');
                    slotDiv.className = 'shape-slot';
                    slotDiv.dataset.slotIndex = slotData.slotIndex;
                    if (slotData.specialType && slotData.specialType.type) {
                        slotDiv.dataset.specialType = slotData.specialType.type;
                    }
                    if (slotData.shapePrefabId && typeof shapeRenderer !== 'undefined') {
                        const preview = shapeRenderer.createDockPreview(slotData.shapePrefabId, 90);
                        if (preview) {
                            preview.id = `shape-${slotData.shapeId || slotData.shapePrefabId}`;
                            preview.dataset.shape = slotData.shapePrefabId;
                            preview.dataset.shapeId = slotData.shapeId;
                            preview.className = 'game-shape shape-preview';
                            // Mark locked shapes visually
                            if (slotData.specialType && slotData.specialType.type === 'LOCKED') {
                                preview.classList.add('locked');
                                const lockIcon = document.createElement('div');
                                lockIcon.className = 'lock-icon';
                                lockIcon.innerHTML = `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" style="filter: drop-shadow(0 0 2px rgba(0,0,0,0.7));"><rect x="5" y="11" width="14" height="10" rx="2" fill="white" fill-opacity="0.9"/><path d="M8 11V7C8 4.79086 9.79086 3 12 3C14.2091 3 16 4.79086 16 7V11" stroke="white" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" stroke-opacity="0.9"/></svg>`;
                                slotDiv.appendChild(lockIcon);
                            }
                            slotDiv.appendChild(preview);
                            if (slotData.specialType && slotData.specialType.type && slotData.specialType.type !== 'LOCKED') {
                                console.log(`🎨 Registering special effect for slot ${slotData.slotIndex}:`, { shapeType: slotData.shapePrefabId, specialType: slotData.specialType });
                                dockingSpecialEffectsManager.register(preview, slotData.specialType);
                            } else {
                                console.log(`⚪ Skipping special effect registration for slot ${slotData.slotIndex}:`, { 
                                    shapeType: slotData.shapePrefabId, 
                                    hasSpecialType: !!slotData.specialType,
                                    specialType: slotData.specialType?.type,
                                    isLocked: slotData.specialType?.type === 'LOCKED'
                                });
                            }
                        } else {
                            slotDiv.classList.add('empty');
                        }
                    } else {
                        slotDiv.classList.add('empty');
                    }
                    dockingArea.appendChild(slotDiv);
                });
                console.log(`✅ Dock rebuilt from level data with ${dockData.slots.length} slots.`);

                // Only trigger animation if this is truly a new rebuild
                if (isInitialLoad || !this.dockAnimationPlayed) {
                    if (isInitialLoad) {
                        this.dockAnimationPlayed = false;
                        setTimeout(() => this.triggerDockAnimation(), 100);
                    } else {
                        this.triggerDockAnimation();
                    }
                } else {
                    console.log('Dock animation already played, skipping trigger');
                }
            }

            /**
             * Applies custom appearance styles to the docking area from level data.
             */
            applyDockAppearance() {
                const dockData = this.levelData?.dock;
                if (!dockData || !dockData.appearance) {
                    console.log('🎨 No custom dock appearance found in level data. Using default styles.');
                    return;
                }

                const appearance = dockData.appearance;
                const dockingArea = document.getElementById('dockingArea');
                if (!dockingArea) {
                    console.error('❌ Could not find dockingArea element to apply styles.');
                    return;
                }

                console.log('🎨 Applying custom dock appearance styles...', appearance);

                // Apply styles to the main docking area
                if (appearance.backgroundColor) {
                    dockingArea.style.background = appearance.backgroundColor;
                }
                if (appearance.borderColor) dockingArea.style.borderColor = appearance.borderColor;
                if (appearance.borderWidth) dockingArea.style.borderWidth = appearance.borderWidth;
                if (appearance.borderStyle) dockingArea.style.borderStyle = appearance.borderStyle;
                if (appearance.cornerRadius) dockingArea.style.borderRadius = appearance.cornerRadius;

                if (appearance.position) {
                    if (appearance.position.top) dockingArea.style.top = appearance.position.top;
                    if (appearance.position.left) dockingArea.style.left = appearance.position.left;
                    if (appearance.position.right) dockingArea.style.right = appearance.position.right;
                    if (appearance.position.bottom) dockingArea.style.bottom = appearance.position.bottom;
                }
                if (appearance.size) {
                    if (appearance.size.height) dockingArea.style.height = appearance.size.height;
                }
                if (appearance.spacing) {
                    if (appearance.spacing.padding) dockingArea.style.padding = appearance.spacing.padding;
                    if (appearance.spacing.gap) dockingArea.style.gap = appearance.spacing.gap;
                }

                // Apply styles to the shape slots
                if (appearance.slotAppearance) {
                    const slotAppearance = appearance.slotAppearance;
                    const slots = dockingArea.querySelectorAll('.shape-slot');
                    slots.forEach(slot => {
                        if (slotAppearance.backgroundColor) slot.style.background = slotAppearance.backgroundColor;
                        if (slotAppearance.borderColor) slot.style.borderColor = slotAppearance.borderColor;
                        if (slotAppearance.borderWidth) slot.style.borderWidth = slotAppearance.borderWidth;
                        if (slotAppearance.borderStyle) slot.style.borderStyle = slotAppearance.borderStyle;
                        if (slotAppearance.cornerRadius) slot.style.borderRadius = slotAppearance.cornerRadius;
                    });
                }
                 console.log('✅ Custom dock appearance applied.');
            }

            checkUnlockConditions() {
                if (!this.gameplaySettings.unlockThresholds) return;
                const placedCount = this.gameState.placedShapes.length;
                this.gameplaySettings.unlockThresholds.forEach(threshold => {
                    if (placedCount === threshold.shapesPlayed) {
                        threshold.unlocksShapeInSlot.forEach(slotIndex => {
                            const slot = document.querySelector(`[data-slot-index='${slotIndex}']`);
                            if (slot) {
                                const shapeEl = slot.querySelector('.game-shape');
                                const lockIcon = slot.querySelector('.lock-icon');
                                if (shapeEl && shapeEl.classList.contains('locked')) {
                                    shapeEl.classList.remove('locked');
                                    if (lockIcon) lockIcon.remove();
                                }
                            }
                        });
                    }
                });
            }

            /**
             * Create static platforms from level data.
             */
            createPlatformsFromData() {
                const platforms = this.levelData?.entities?.platforms;
                if (!platforms || !Array.isArray(platforms)) {
                    console.warn('⚠️ No platform data found in level file. Using default single platform.');
                    if (typeof this.physicsManager.createPlatform === 'function') {
                        this.physicsManager.createPlatform();
                    }
                    return;
                }
                if (typeof this.physicsManager.clearAllPlatforms === 'function') {
                    this.physicsManager.clearAllPlatforms();
                }
                platforms.forEach((p) => {
                    if (typeof this.physicsManager.createPlatformFromData === 'function') {
                        this.physicsManager.createPlatformFromData(p);
                    }
                });
                console.log(`✅ Created ${platforms.length} platforms from level data.`);
            }

            /**
             * Applies the theme specified in the level data on initial load.
             */
            async applyLevelTheme() {
                if (this.levelThemeApplied) {
                    debugLog('⚠️ Level theme already applied, skipping');
                    return;
                }
                
                this.levelThemeApplied = true;
                const baseTheme = this.baseThemeId || 'classic';
                console.log(`🎨 Applying level's base theme on load: ${baseTheme}`);
                await UnifiedThemeController.changeTheme(baseTheme, { 
                    source: 'level-theme', 
                    animated: false 
                });
            }

            onGameTimeUp() {
                this.gameState.isGameActive = false;
                console.log('⏰ Time Up! Level Failed!');
            }

            onGameOver(reason = 'Game Over!') {
                if (this.gameState.isGameOver) {
                    return;
                }

                this.gameState.isGameOver = true;
                this.gameState.isGameActive = false;
                this.gameState.isCountdownActive = false;
                this.gameState.endLevelStarted = false;
                this.gameState.levelFailed = true;

                this.stopTimer();

                if (this.dragDropManager) {
                    this.dragDropManager.endDrag();
                }

                if (this.physicsManager) {
                    this.physicsManager.showEventNotification('Game Over!', 'fall');
                }

                console.log(`💀 Game Over! ${reason}`);

                this.showGameOverPopup(reason);
            }

            /*╔═══════════════════════════════════════════════════════════════════════════
              ║ SHOW LEVEL CLEARED POPUP
              ║ Displays a celebratory popup modal when the level is successfully cleared.
              ║ Includes animated title, stars, and button to continue or replay level.
              ╚═══════════════════════════════════════════════════════════════════════════*/
            showLevelClearedPopup() {
                // Create modal overlay
                const modal = document.createElement('div');
                modal.className = 'level-cleared-modal';
                modal.id = 'levelClearedModal';
                
                // Create modal content
                const content = document.createElement('div');
                content.className = 'level-cleared-content';
                
                // Title
                const title = document.createElement('div');
                title.className = 'level-cleared-title';
                title.textContent = 'Level Cleared!';
                
                // Subtitle with score info
                const subtitle = document.createElement('div');
                subtitle.className = 'level-cleared-subtitle';
                subtitle.textContent = `Score: ${this.gameState.score} | Coins: ${this.gameState.coins}`;
                
                // Animated stars
                const stars = document.createElement('div');
                stars.className = 'level-cleared-stars';
                stars.textContent = '⭐ ⭐ ⭐';
                
                // Continue button
                const continueBtn = document.createElement('button');
                continueBtn.className = 'level-cleared-button';
                continueBtn.textContent = 'Continue';
                continueBtn.onclick = () => this.closeLevelClearedPopup();
                
                // Enhanced mobile touch support
                continueBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault(); // Prevent double-tap zoom
                    continueBtn.style.transform = 'scale(0.95)';
                }, { passive: false });
                
                continueBtn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    continueBtn.style.transform = '';
                    // Trigger click after a brief delay to ensure visual feedback
                    setTimeout(() => continueBtn.click(), 50);
                }, { passive: false });
                
                // Replay button
                const replayBtn = document.createElement('button');
                replayBtn.className = 'level-cleared-button';
                replayBtn.textContent = 'Replay Level';
                replayBtn.style.background = 'linear-gradient(135deg, #2196F3 0%, #1976D2 100%)';
                replayBtn.onclick = () => {
                    this.closeLevelClearedPopup();
                    resetLevel();
                };
                
                // Enhanced mobile touch support
                replayBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault(); // Prevent double-tap zoom
                    replayBtn.style.transform = 'scale(0.95)';
                }, { passive: false });
                
                replayBtn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    replayBtn.style.transform = '';
                    // Trigger click after a brief delay to ensure visual feedback
                    setTimeout(() => replayBtn.click(), 50);
                }, { passive: false });
                
                // Assemble modal
                content.appendChild(title);
                content.appendChild(subtitle);
                content.appendChild(stars);
                content.appendChild(continueBtn);
                content.appendChild(replayBtn);
                modal.appendChild(content);
                
                // Add to page
                document.body.appendChild(modal);
                
                // Prevent background scrolling on mobile
                document.body.classList.add('modal-open');
                
                console.log('🎉 Level Cleared popup displayed!');
            }

            closeLevelClearedPopup() {
                const modal = document.getElementById('levelClearedModal');
                if (modal) {
                    modal.style.animation = 'modalFadeIn 0.3s ease-out reverse';
                    // Re-enable background scrolling
                    document.body.classList.remove('modal-open');
                    setTimeout(() => {
                        modal.remove();
                    }, 300);
                }
            }

            showGameOverPopup(reason = 'Game Over!') {
                this.closeGameOverPopup();

                const modal = document.createElement('div');
                modal.className = 'game-over-modal';
                modal.id = 'gameOverModal';

                const content = document.createElement('div');
                content.className = 'game-over-content';

                const title = document.createElement('div');
                title.className = 'game-over-title';
                title.textContent = 'Game Over';

                const message = document.createElement('div');
                message.className = 'game-over-message';
                message.textContent = reason;

                const stats = document.createElement('div');
                stats.className = 'game-over-stats';
                stats.innerHTML = `
                    <div>Score: <strong>${this.gameState.score.toLocaleString()}</strong></div>
                    <div>Coins: <strong>${this.gameState.coins.toLocaleString()}</strong></div>
                    <div>Shapes Placed: <strong>${this.gameState.placedShapes.length}</strong></div>
                `;

                const buttons = document.createElement('div');
                buttons.className = 'game-over-buttons';

                const retryButton = document.createElement('button');
                retryButton.className = 'game-over-button';
                retryButton.textContent = 'Retry Level';
                retryButton.onclick = () => {
                    this.closeGameOverPopup();
                    resetLevel();
                };
                
                // Enhanced mobile touch support
                retryButton.addEventListener('touchstart', (e) => {
                    e.preventDefault(); // Prevent double-tap zoom
                    retryButton.style.transform = 'scale(0.95)';
                }, { passive: false });
                
                retryButton.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    retryButton.style.transform = '';
                    // Trigger click after a brief delay to ensure visual feedback
                    setTimeout(() => retryButton.click(), 50);
                }, { passive: false });

                const closeButton = document.createElement('button');
                closeButton.className = 'game-over-button secondary';
                closeButton.textContent = 'Close';
                closeButton.onclick = () => this.closeGameOverPopup();
                
                // Enhanced mobile touch support  
                closeButton.addEventListener('touchstart', (e) => {
                    e.preventDefault(); // Prevent double-tap zoom
                    closeButton.style.transform = 'scale(0.95)';
                }, { passive: false });
                
                closeButton.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    closeButton.style.transform = '';
                    // Trigger click after a brief delay to ensure visual feedback
                    setTimeout(() => closeButton.click(), 50);
                }, { passive: false });

                buttons.appendChild(retryButton);
                buttons.appendChild(closeButton);

                content.appendChild(title);
                content.appendChild(message);
                content.appendChild(stats);
                content.appendChild(buttons);
                modal.appendChild(content);

                document.body.appendChild(modal);
                
                // Prevent background scrolling on mobile
                document.body.classList.add('modal-open');
            }

            closeGameOverPopup() {
                const modal = document.getElementById('gameOverModal');
                if (modal) {
                    modal.style.animation = 'modalFadeIn 0.3s ease-out reverse';
                    // Re-enable background scrolling
                    document.body.classList.remove('modal-open');
                    setTimeout(() => {
                        if (modal.parentNode) {
                            modal.parentNode.removeChild(modal);
                        }
                    }, 300);
                }
            }

            /*╔═══════════════════════════════════════════════════════════════════════════
              ║ TRIGGER LEVEL COMPLETE EFFECTS
              ║ Creates spectacular visual effects when level is completed successfully.
              ║ Includes cascading star effects, screen flash, and celebration particles.
              ╚═══════════════════════════════════════════════════════════════════════════*/
            triggerLevelCompleteEffects() {
                // Flash effect for completion
                const screen = document.querySelector('.screen');
                if (screen) {
                    screen.style.animation = 'levelCompleteFlash 1s ease-out';
                    setTimeout(() => {
                        screen.style.animation = '';
                    }, 1000);
                }

                // Cascade star effects
                const stars = document.querySelectorAll('.star');
                stars.forEach((star, index) => {
                    setTimeout(() => {
                        star.style.animation = 'starBurst 0.8s ease-out';
                        this.createFloatingText('★', star, '#FFD700');
                    }, index * 150);
                });

                // Multiple celebration particles
                setTimeout(() => {
                    const scoreElement = document.getElementById('scoreText');
                    const coinElement = document.getElementById('coinAmount');

                    if (scoreElement) {
                        this.createFloatingText('🎉', scoreElement, '#FF6B6B');
                    }
                    if (coinElement) {
                        this.createFloatingText('🎊', coinElement, '#4ECDC4');
                    }

                    setTimeout(() => {
                        if (scoreElement) {
                            this.createFloatingText('🏆', scoreElement, '#FFD700');
                        }
                    }, 300);
                }, 500);
            }

            onLevelComplete() {
                this.gameState.isGameActive = false;
                this.gameState.levelCompleted = true;
                console.log('🎯 Level Complete! Score: ' + this.gameState.score);
                
                // Sound effect integration point
                this.playSound('levelComplete');
                
                // Bonus points for completion with particle effects
                this.gameState.score += 500;
                this.gameState.coins += 25; // Increased completion bonus
                
                // Show Level Cleared popup immediately
                this.showLevelClearedPopup();
                
                // Advance to next level after a delay
                setTimeout(() => {
                    this.nextLevel();
                }, 3000); // Increased delay to account for popup
                
                // Create floating text for completion bonus
                const scoreElement = document.getElementById('scoreText');
                this.createFloatingText('+500', scoreElement, '#FFD700');
                
                const coinElement = document.getElementById('coinAmount');
                this.createFloatingText('+25 Complete!', coinElement, '#4ECDC4');
                
                // Stability bonus
                const stabilityBonus = Math.floor(this.gameState.stability * 2);
                this.gameState.score += stabilityBonus;
                
                // Stability coin bonus for high stability (80%+)
                if (this.gameState.stability >= 80) {
                    const coinBonus = Math.floor(this.gameState.stability / 10);
                    this.gameState.coins += coinBonus;
                    
                    setTimeout(() => {
                        this.createFloatingText(`+${coinBonus} Stability`, coinElement, '#10B981');
                    }, 750);
                }
                
                if (stabilityBonus > 0) {
                    setTimeout(() => {
                        this.createFloatingText(`+${stabilityBonus} Stability`, scoreElement, '#10B981');
                    }, 500);
                }
                
                // Update display
                this.updateScoreDisplay();
                this.updateCoinDisplay();
                
                // All stars should be filled with animation
                this.updateStars(3);
                const progressBar = document.getElementById('starProgressBar');
                this.animateProgressBar(progressBar);
                
                this.physicsManager.showEventNotification('Level Complete!', 'collision');
            }

            onLevelFailed() {
                this.gameState.isGameActive = false;
                console.log('💀 Level Failed! Shape fell during countdown.');
                this.physicsManager.showEventNotification('Level Failed!', 'fall');
            }

            resetLevel() {
                console.log('🔄 Resetting level...');

                this.closeGameOverPopup();
                this.stopTimer();

                // Clear all dynamic physics bodies
                this.physicsManager.cleanup();
                
                // Recreate the platform and boundaries
                this.physicsManager.createPlatform();
                this.physicsManager.createBoundaries();
                
                // Reset game state
                this.gameState.resetLevel();
                
                // Restore all shapes to docking area
                this.restoreAllShapesToDock();
                
                // Reset HUD to initial values
                this.updateScoreDisplay();
                this.updateCoinDisplay();
                document.getElementById('starProgressBar').style.width = '0%';
                document.getElementById('gameTimer').textContent = '0:00';
                
                // Reset timer mode to elapsed
                const modeIndicator = document.getElementById('timerModeIndicator');
                modeIndicator.className = 'timer-mode-indicator timer-mode-elapsed';
                modeIndicator.textContent = '⏱';
                
                // Reset all stars
                document.querySelectorAll('.star').forEach(star => {
                    star.classList.remove('filled');
                });
                
                // Update debug info
                this.updateDebugInfo();

                this.startTimer();

                console.log('✅ Level reset complete');
            }

            /*╔═══════════════════════════════════════════════════════════════════════════
              ║ CREATE FLOATING TEXT PARTICLE
              ║ Generates animated floating text particles for visual feedback. Creates
              ║ temporary DOM elements positioned relative to target elements that float
              ║ upward and fade out. Used for score/coin increase notifications.
              ║ Parameters: text - Text to display, element - Reference element, color - Text color
              ╚═══════════════════════════════════════════════════════════════════════════*/
            createFloatingText(text, element, color = '#FFD700') {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.textContent = text;
                particle.style.color = color;
                
                const rect = element.getBoundingClientRect();
                particle.style.left = (rect.left + rect.width / 2) + 'px';
                particle.style.top = rect.top + 'px';
                
                document.body.appendChild(particle);
                
                setTimeout(() => {
                    if (particle.parentNode) {
                        document.body.removeChild(particle);
                    }
                }, 2000);
            }

            /*╔═══════════════════════════════════════════════════════════════════════════
              ║ CREATE COIN SHOWER EFFECT
              ║ Creates a spectacular shower of coin particles for major achievements.
              ║ Multiple floating coins rain down from the coin counter element.
              ║ Used for jackpots, streaks, and other exciting coin-earning events.
              ╚═══════════════════════════════════════════════════════════════════════════*/
            createCoinShower(message, coinCount) {
                const coinElement = document.getElementById('coinAmount');
                const rect = coinElement.getBoundingClientRect();
                
                // Create the main message
                this.createFloatingText(message, coinElement, '#FFD700');
                
                // Create shower of individual coins
                for (let i = 0; i < Math.min(coinCount, 15); i++) {
                    setTimeout(() => {
                        const coin = document.createElement('div');
                        coin.className = 'particle';
                        coin.textContent = '💰';
                        coin.style.fontSize = '20px';
                        coin.style.left = (rect.left + Math.random() * rect.width) + 'px';
                        coin.style.top = rect.top + 'px';
                        coin.style.transform = `translate(${(Math.random() - 0.5) * 200}px, ${Math.random() * -100}px)`;
                        coin.style.opacity = '0';
                        coin.style.transition = 'all 2s ease-out';
                        
                        document.body.appendChild(coin);
                        
                        // Animate the coin
                        setTimeout(() => {
                            coin.style.transform += ` translateY(${Math.random() * 200 + 100}px)`;
                            coin.style.opacity = '1';
                        }, 50);
                        
                        // Remove after animation
                        setTimeout(() => {
                            if (coin.parentNode) {
                                document.body.removeChild(coin);
                            }
                        }, 2500);
                    }, i * 100); // Stagger the coins
                }
            }

            /*╔═══════════════════════════════════════════════════════════════════════════
              ║ PULSE ELEMENT EFFECT
              ║ Makes an element pulse with a glowing effect to draw attention.
              ║ Used for significant coin increases and achievements.
              ╚═══════════════════════════════════════════════════════════════════════════*/
            pulseElement(element, pulses = 3) {
                let count = 0;
                const originalTransform = element.style.transform;
                const originalBoxShadow = element.style.boxShadow;
                
                const pulse = () => {
                    if (count >= pulses) {
                        element.style.transform = originalTransform;
                        element.style.boxShadow = originalBoxShadow;
                        return;
                    }
                    
                    element.style.transform = 'scale(1.2)';
                    element.style.boxShadow = '0 0 20px #FFD700';
                    element.style.transition = 'all 0.2s ease-in-out';
                    
                    setTimeout(() => {
                        element.style.transform = 'scale(1)';
                        element.style.boxShadow = originalBoxShadow;
                        count++;
                        setTimeout(pulse, 300);
                    }, 200);
                };
                
                pulse();
            }

            /*╔═══════════════════════════════════════════════════════════════════════════
              ║ SHAKE ELEMENT EFFECT
              ║ Makes an element shake violently to show dramatic losses or penalties.
              ║ Used when players lose significant amounts of coins.
              ╚═══════════════════════════════════════════════════════════════════════════*/
            shakeElement(element, intensity = 3) {
                const originalTransform = element.style.transform;
                let shakeCount = 0;
                const maxShakes = intensity * 4; // More shakes for higher intensity
                
                const shake = () => {
                    if (shakeCount >= maxShakes) {
                        element.style.transform = originalTransform;
                        element.style.transition = '';
                        return;
                    }
                    
                    const x = (Math.random() - 0.5) * intensity * 4;
                    const y = (Math.random() - 0.5) * intensity * 4;
                    element.style.transform = `translate(${x}px, ${y}px)`;
                    element.style.transition = 'none';
                    
                    shakeCount++;
                    setTimeout(shake, 50);
                };
                
                shake();
            }

            /*╔═══════════════════════════════════════════════════════════════════════════
              ║ ANIMATE PROGRESS BAR
              ║ Provides visual feedback when the progress bar fills. Adds temporary 
              ║ animation class that causes the bar to pulse/glow, then removes it.
              ║ Enhances the user experience when star progress increases.
              ║ Parameters: progressBar - The progress bar DOM element to animate
              ╚═══════════════════════════════════════════════════════════════════════════*/
            animateProgressBar(progressBar) {
                progressBar.classList.add('progress-animate');
                setTimeout(() => progressBar.classList.remove('progress-animate'), 800);
            }

            /*╔═══════════════════════════════════════════════════════════════════════════
              ║ SOUND SYSTEM INTEGRATION POINTS
              ║ Placeholder functions for easy sound effect integration. These functions
              ║ can be enhanced later with actual audio implementation using Web Audio API
              ║ or HTML5 audio elements. Currently logs sound events for development.
              ╚═══════════════════════════════════════════════════════════════════════════*/
            playSound(soundType) {
                // Integration point for sound effects
                // Future enhancement: Load and play actual audio files
                
                switch (soundType) {
                    case 'shapeLanding':
                        // Soft landing sound - positive feedback
                        break;
                    case 'shapeCollision':
                        // Click/tap sound - interaction feedback  
                        break;
                    case 'shapeRotation':
                        // Quick whoosh sound - rotation feedback
                        break;
                    case 'coinEarned':
                        // Coin pickup sound - reward feedback
                        break;
                    case 'starFilled':
                        // Bright ding sound - progress feedback
                        break;
                    case 'levelComplete':
                        // Victory fanfare - completion feedback
                        break;
                    case 'levelFailed':
                        // Disappointment sound - failure feedback
                        break;
                    case 'endLevelCountdown':
                        // Ticking sound - tension building
                        break;
                    default:
                        // Unknown sound type
                }
            }

            restoreAllShapesToDock() {
                // Restore all nine shapes to their dock positions
                const shapes = [
                    { id: 'shape-square', type: 'square', slot: 'slot-square' },
                    { id: 'shape-triangle', type: 'triangle', slot: 'slot-triangle' },
                    { id: 'shape-circle', type: 'circle', slot: 'slot-circle' },
                    { id: 'shape-cross2', type: 'cross2', slot: 'slot-cross2' },
                    { id: 'shape-l', type: 'l', slot: 'slot-l' },
                    { id: 'shape-cross', type: 'cross', slot: 'slot-cross' },
                    { id: 'shape-barbell-one', type: 'barbell-one', slot: 'slot-barbell-one' },
                    { id: 'shape-barbell-two', type: 'barbell-two', slot: 'slot-barbell-two' },
                    { id: 'shape-diamond-barbell', type: 'diamond-barbell', slot: 'slot-diamond-barbell' }
                ];
                
                shapes.forEach(shapeInfo => {
                    const slot = document.getElementById(shapeInfo.slot);
                    if (slot) {
                        slot.classList.remove('empty');
                        
                        // Remove any existing shape in the slot
                        const existingShape = slot.querySelector('.game-shape');
                        if (existingShape) {
                            existingShape.remove();
                        }
                        
                        // Create new shape element
                        const shapeElement = document.createElement('div');
                        shapeElement.className = `game-shape shape-${shapeInfo.type}`;
                        shapeElement.dataset.shape = shapeInfo.type;
                        shapeElement.id = shapeInfo.id;
                        
                        slot.appendChild(shapeElement);
                    }
                });
                

            }
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ PHASE 2: MODE TOGGLE SYSTEM - LEVEL EDITOR FUNCTIONALITY
          ║ Implements the level editor mode toggle system allowing users to switch
          ║ between Play Mode (normal gameplay) and Design Mode (level configuration).
          ║ Includes dock configuration, timer settings, and level parameters.
          ╚═══════════════════════════════════════════════════════════════════════════*/

        // Level configuration state
        let currentMode = 'play';
        let currentLevelConfig = {
            world: 1,
            level: 1,
            timerMode: 'elapsed',
            timerStart: 60,
            endLevelDuration: 5,
            dockSlots: 9,
            barbellOrientation: 'vertical',
            dockShapes: ['square', 'triangle', 'circle', 'cross2', 'l', 'cross', 'barbell-one', 'barbell-two', 'diamond-barbell']
        };

        // Make level config globally available for dock system
        window.currentLevelConfig = currentLevelConfig;

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ TOGGLE MODE SWITCH FUNCTION
          ║ New toggle switch function that switches between Play Mode and Design Mode
          ║ using a compact toggle switch in the HUD instead of separate buttons.
          ╚═══════════════════════════════════════════════════════════════════════════*/
        function toggleModeSwitch() {
            const toggleSwitch = document.getElementById('modeToggleSwitch');
            const slider = toggleSwitch.querySelector('.mode-toggle-slider');
            
            if (currentMode === 'play') {
                toggleMode('design');
                toggleSwitch.classList.add('design-active');
                slider.textContent = '🔧';
            } else {
                toggleMode('play');
                toggleSwitch.classList.remove('design-active');
                slider.textContent = '🎮';
            }
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ TOGGLE MODE FUNCTION (UPDATED)
          ║ Updated to work with new toggle switch instead of separate buttons.
          ╚═══════════════════════════════════════════════════════════════════════════*/
        function toggleMode(mode) {
            const gameContainer = document.getElementById('gameContainer');
            const designSidebar = document.getElementById('designSidebar');
            
            if (mode === 'design') {
                gameContainer.classList.add('design-mode');
                designSidebar.classList.add('active');
                currentMode = 'design';
                
                console.log('🔧 Entered Design Mode - Level Editor Active');
                
                // Sync current dock configuration to design sidebar
                syncDockToDesign();
                generateDockSlots();
            } else {
                gameContainer.classList.remove('design-mode');
                designSidebar.classList.remove('active');
                currentMode = 'play';
                
                console.log('🎮 Entered Play Mode - Game Active');
                
                // Apply design changes before switching back to play mode
                applyDesignChangesToConfig();
                
                // Apply any design changes to the play dock
                rebuildGameDock();
            }
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ APPLY DESIGN CHANGES TO CONFIG
          ║ Automatically applies design mode changes when switching back to play mode.
          ║ Collects all design sidebar values and updates currentLevelConfig.
          ╚═══════════════════════════════════════════════════════════════════════════*/
        function applyDesignChangesToConfig() {
            // Collect dock slot changes from design sidebar
            const dockSlotsContainer = document.getElementById('dockSlotsContainer');
            
            if (dockSlotsContainer) {
                const slotSelectors = dockSlotsContainer.querySelectorAll('select');
                const newDockShapes = [];
                
                slotSelectors.forEach(select => {
                    if (select.value && select.value !== 'none') {
                        newDockShapes.push(select.value);
                    }
                });
                
                // Apply the new dock configuration (even if empty - user may want to remove shapes)
                currentLevelConfig.dockShapes = newDockShapes;
                currentLevelConfig.dockSlots = newDockShapes.length;
                console.log('🔧 Applied dock configuration from design mode:', newDockShapes);
            }
            
            // Collect other level configuration changes
            const worldLevelValue = document.getElementById('levelNumber')?.value;
            if (worldLevelValue) {
                const parts = worldLevelValue.split('-');
                currentLevelConfig.world = parseInt(parts[0]) || 1;
                currentLevelConfig.level = parseInt(parts[1]) || 1;
            }
            
            const timerMode = document.getElementById('timerMode')?.value;
            if (timerMode) {
                currentLevelConfig.timerMode = timerMode;
            }
            
            const timerStart = document.getElementById('timerStart')?.value;
            if (timerStart) {
                currentLevelConfig.timerStart = parseInt(timerStart);
            }
            
            const endLevelDuration = document.getElementById('endLevelDuration')?.value;
            if (endLevelDuration) {
                currentLevelConfig.endLevelDuration = parseInt(endLevelDuration);
            }
            
            // Apply barbell orientation setting
            const barbellOrientation = document.getElementById('barbellOrientation')?.value;
            if (barbellOrientation) {
                currentLevelConfig.barbellOrientation = barbellOrientation;
                console.log('🔧 Applied barbell orientation from design mode:', barbellOrientation);
            }
            
            console.log('✅ Auto-applied design changes to config:', currentLevelConfig);
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ SYNC DOCK TO DESIGN
          ║ Reads the current dock configuration from the game and updates the design
          ║ sidebar to match. Ensures design mode reflects the actual game state.
          ║ Used when entering design mode to show current level configuration.
          ╚═══════════════════════════════════════════════════════════════════════════*/
        function syncDockToDesign() {
            // Use the configuration as the source of truth instead of reading from DOM
            // This ensures design mode shows the current configuration, not the DOM state
            
            // Update UI controls to match current configuration
            const slotCountInput = document.getElementById('dockSlotCount');
            if (slotCountInput) {
                slotCountInput.value = currentLevelConfig.dockSlots || currentLevelConfig.dockShapes.length;
            }
            
            // Sync barbell orientation dropdown to match current config
            const barbellOrientationSelect = document.getElementById('barbellOrientation');
            if (barbellOrientationSelect && currentLevelConfig.barbellOrientation) {
                barbellOrientationSelect.value = currentLevelConfig.barbellOrientation;
                debugLog('🔧 Synced barbell orientation dropdown to:', currentLevelConfig.barbellOrientation);
            }
            
            debugLog('🔄 Synced design UI to current config - dock shapes:', currentLevelConfig.dockShapes);
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ GENERATE DOCK SLOTS
          ║ Creates the dynamic dock slot configuration UI in the design sidebar.
          ║ Generates dropdown selectors for each dock slot allowing shape assignment.
          ║ Preserves existing shape assignments when slot count changes.
          ╚═══════════════════════════════════════════════════════════════════════════*/
        function generateDockSlots() {
            const dockContainer = document.getElementById('dockSlotsContainer');
            const slotCount = parseInt(document.getElementById('dockSlotCount').value);
            
            if (!dockContainer) return;
            
            dockContainer.innerHTML = '';
            
            // Ensure we have enough shapes in the configuration
            const allShapes = ['square', 'triangle', 'circle', 'l', 'cross', 'cross2', 
                              'barbell-one', 'barbell-two', 'diamond-barbell'];
            
            // Preserve existing shapes or use defaults
            if (currentLevelConfig.dockShapes.length !== slotCount) {
                const newShapes = [];
                for (let i = 0; i < slotCount; i++) {
                    if (i < currentLevelConfig.dockShapes.length) {
                        newShapes.push(currentLevelConfig.dockShapes[i]);
                    } else {
                        newShapes.push(allShapes[i % allShapes.length]);
                    }
                }
                currentLevelConfig.dockShapes = newShapes;
            }
            
            // Generate configuration UI for each slot
            for (let i = 0; i < slotCount; i++) {
                const slotDiv = document.createElement('div');
                slotDiv.className = 'dock-slot-config';
                const selectedShape = currentLevelConfig.dockShapes[i];
                
                slotDiv.innerHTML = `
                    <div style="font-weight: bold; margin-bottom: 3px;">Slot ${i + 1}</div>
                    <select onchange="updateDockShape(${i}, this.value)" style="width: 100%; background: rgba(0,0,0,0.3); color: white; border: 1px solid rgba(255,255,255,0.3); padding: 2px;">
                        <option value="square" ${selectedShape === 'square' ? 'selected' : ''}>Square</option>
                        <option value="triangle" ${selectedShape === 'triangle' ? 'selected' : ''}>Triangle</option>
                        <option value="circle" ${selectedShape === 'circle' ? 'selected' : ''}>Circle</option>
                        <option value="l" ${selectedShape === 'l' ? 'selected' : ''}>L-Shape</option>
                        <option value="cross" ${selectedShape === 'cross' ? 'selected' : ''}>Green Cross</option>
                        <option value="cross2" ${selectedShape === 'cross2' ? 'selected' : ''}>Pink Cross</option>
                        <option value="barbell-one" ${selectedShape === 'barbell-one' ? 'selected' : ''}>One-Ended Barbell</option>
                        <option value="barbell-two" ${selectedShape === 'barbell-two' ? 'selected' : ''}>Two-Ended Barbell</option>
                        <option value="diamond-barbell" ${selectedShape === 'diamond-barbell' ? 'selected' : ''}>Diamond Barbell</option>
                    </select>
                `;
                dockContainer.appendChild(slotDiv);
            }
            
            currentLevelConfig.dockSlots = slotCount;
            console.log('🎛️ Generated dock slots configuration:', slotCount);
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ UPDATE DOCK SHAPE
          ║ Updates a specific dock slot's shape assignment in the level configuration.
          ║ Called when user changes shape selection in design sidebar dropdown.
          ║ Parameters: slotIndex - Index of slot to update, shape - New shape type
          ╚═══════════════════════════════════════════════════════════════════════════*/
        function updateDockShape(slotIndex, shape) {
            if (slotIndex < currentLevelConfig.dockShapes.length) {
                currentLevelConfig.dockShapes[slotIndex] = shape;
                console.log(`🔄 Updated slot ${slotIndex + 1} to ${shape}`);
            }
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ UPDATE BARBELL ORIENTATION
          ║ Changes the barbell orientation in the dock (vertical vs horizontal).
          ║ Applies CSS classes to the docking area to control barbell display.
          ║ Called when user changes barbell orientation setting in design sidebar.
          ╚═══════════════════════════════════════════════════════════════════════════*/
        function updateBarbellOrientation() {
            const orientation = document.getElementById('barbellOrientation').value;
            currentLevelConfig.barbellOrientation = orientation;
            
            // Rebuild the dock to apply rotation changes to barbell previews
            rebuildGameDock();
            
            console.log(`🔄 Updated barbell orientation to ${orientation} - dock rebuilt with rotated previews`);
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ APPLY LEVEL CHANGES
          ║ Applies all design sidebar configuration changes to the active game.
          ║ Updates level info, timer settings, and rebuilds the dock layout.
          ║ Provides visual feedback to confirm changes were applied.
          ╚═══════════════════════════════════════════════════════════════════════════*/
        function applyLevelChanges() {
            // Save current configuration from sidebar
            const worldLevelValue = document.getElementById('levelNumber').value;
            const parts = worldLevelValue.split('-');
            currentLevelConfig.world = parseInt(parts[0]) || 1;
            currentLevelConfig.level = parseInt(parts[1]) || 1;
            currentLevelConfig.timerMode = document.getElementById('timerMode').value;
            currentLevelConfig.timerStart = parseInt(document.getElementById('timerStart').value);
            currentLevelConfig.endLevelDuration = parseInt(document.getElementById('endLevelDuration').value);
            
            // Update game UI
            updateGameUI();
            
            // Apply timer changes if countdown mode is selected
            if (currentLevelConfig.timerMode === 'countdown' && window.gameManager && window.gameManager.gameState) {
                const startTime = currentLevelConfig.timerStart || 60;
                window.gameManager.gameState.gameTime = startTime;
                
                // Update timer display
                const timerElement = document.getElementById('gameTimer');
                if (timerElement) {
                    const minutes = Math.floor(startTime / 60);
                    const seconds = startTime % 60;
                    timerElement.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                }
                
                console.log('⏳ Applied countdown timer start value:', startTime);
            }
            
            // Rebuild dock with new configuration
            rebuildGameDock();
            
            // Show feedback
            const btn = document.getElementById('applyChangesBtn');
            const originalText = btn.textContent;
            btn.textContent = 'Applied!';
            btn.style.background = 'linear-gradient(135deg, #27ae60 0%, #229954 100%)';
            setTimeout(() => {
                btn.textContent = originalText;
                btn.style.background = 'linear-gradient(135deg, #27ae60 0%, #229954 100%)';
            }, 1500);
            
            console.log('✅ Applied level changes:', currentLevelConfig);
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ UPDATE TIMER MODE CONFIG
          ║ Updates timer mode configuration when user changes dropdown in design sidebar.
          ║ Immediately applies the new timer mode to current level configuration and UI.
          ╚═══════════════════════════════════════════════════════════════════════════*/
        function updateTimerModeConfig() {
            // Update current level config with new timer mode
            const timerModeSelect = document.getElementById('timerMode');
            currentLevelConfig.timerMode = timerModeSelect.value;
            
            // Update game state if game manager exists
            if (window.gameManager && window.gameManager.gameState) {
                window.gameManager.gameState.timerMode = timerModeSelect.value;
                
                // Initialize timer based on mode
                if (timerModeSelect.value === 'countdown') {
                    // Set countdown timer to start value
                    const startTime = currentLevelConfig.timerStart || 60;
                    window.gameManager.gameState.gameTime = startTime;
                    
                    // Update timer display immediately
                    const timerElement = document.getElementById('gameTimer');
                    if (timerElement) {
                        const minutes = Math.floor(startTime / 60);
                        const seconds = startTime % 60;
                        timerElement.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                    }
                } else if (timerModeSelect.value === 'elapsed') {
                    // Reset to 0 for elapsed timer
                    window.gameManager.gameState.gameTime = 0;
                    
                    // Update timer display immediately
                    const timerElement = document.getElementById('gameTimer');
                    if (timerElement) {
                        timerElement.textContent = '0:00';
                    }
                }
            }
            
            // Update timer UI to reflect new mode
            const modeIndicator = document.getElementById('timerModeIndicator');
            if (modeIndicator && timerModeSelect.value === 'countdown') {
                modeIndicator.className = 'timer-mode-indicator timer-mode-countdown';
                modeIndicator.textContent = '⏳';
            } else if (modeIndicator && timerModeSelect.value === 'elapsed') {
                modeIndicator.className = 'timer-mode-indicator timer-mode-elapsed';
                modeIndicator.textContent = '⏱';
            } else if (modeIndicator && timerModeSelect.value === 'none') {
                modeIndicator.className = 'timer-mode-indicator timer-mode-elapsed';
                modeIndicator.textContent = '⚪';
            }
            
            console.log('🕒 Updated timer mode to:', timerModeSelect.value);
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ UPDATE GAME UI
          ║ Updates the game's UI elements to reflect current level configuration.
          ║ Updates level display and other HUD elements based on design settings.
          ╚═══════════════════════════════════════════════════════════════════════════*/
        function updateGameUI() {
            const levelDisplay = document.getElementById('levelDisplay');
            if (levelDisplay) {
                levelDisplay.textContent = `World ${currentLevelConfig.world}-${currentLevelConfig.level}`;
            }
            
            console.log(`🎮 Updated game UI for World ${currentLevelConfig.world}-${currentLevelConfig.level}`);
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ THEME CYCLING (GLOBAL WRAPPER) - SIMPLIFIED
          ║ Simple theme cycling that uses the existing dropdown functionality.
          ║ Just cycles through the dropdown options and triggers applyTheme().
          ╚═══════════════════════════════════════════════════════════════════════════*/
        function cycleThemes() {
            debugLog('🎨 Cycling themes via button');
            
            const themeSelector = document.getElementById('themeSelector');
            const enhancedSelector = document.getElementById('enhancedThemeSelect');
            
            if (enhancedSelector && enhancedSelector.style.display !== 'none') {
                // Enhanced themes are active - cycle through them
                const themes = ['wood', 'metal', 'stone', 'neon', 'paper', 'candy'];
                const currentIndex = themes.indexOf(enhancedSelector.value);
                const nextIndex = (currentIndex + 1) % themes.length;
                const nextTheme = themes[nextIndex];
                
                enhancedSelector.value = nextTheme;
                // Use ThemeChangeQueue
                window.themeChangeQueue.changeTheme(nextTheme, 'cycle-button-enhanced');
            } else if (themeSelector) {
                // Classic themes - cycle through them
                const options = Array.from(themeSelector.options);
                const currentIndex = themeSelector.selectedIndex;
                const nextIndex = (currentIndex + 1) % options.length;
                
                themeSelector.selectedIndex = nextIndex;
                const nextTheme = options[nextIndex].value;
                // Use ThemeChangeQueue
                window.themeChangeQueue.changeTheme(nextTheme, 'cycle-button-classic');
            }
        }
        
        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ RESET LEVEL (GLOBAL WRAPPER) - ENHANCED
          ║ Enhanced reset function that properly resets timer, restores shapes to dock,
          ║ and clears physics simulation. Handles both design mode and play mode resets.
          ╚═══════════════════════════════════════════════════════════════════════════*/
        function resetLevel() {
            debugLog('🔄 Resetting level...');

            if (window.gameManager) {
                window.gameManager.dockAnimationPlayed = false;
            }
            
            // Clear all shapes from playfield
            if (window.gameManager && window.gameManager.physicsManager) {
                window.gameManager.physicsManager.clearAllShapes();
                debugLog('🧹 Cleared physics shapes');
            }
            
            // Reset timer and game state
            if (window.gameManager && window.gameManager.gameState) {
                // Reset timer to 0:00
                window.gameManager.gameState.gameTime = 0;
                window.gameManager.gameState.endLevelTime = currentLevelConfig.endLevelDuration;
                
                // Apply current timer mode from config
                window.gameManager.gameState.timerMode = currentLevelConfig.timerMode || 'elapsed';
                
                // Update timer display
                const timerElement = document.getElementById('gameTimer');
                if (timerElement) {
                    if (currentLevelConfig.timerMode === 'countdown') {
                        // For countdown, start from configured start time
                        const startTime = currentLevelConfig.timerStart || 60;
                        window.gameManager.gameState.gameTime = startTime;
                        const minutes = Math.floor(startTime / 60);
                        const seconds = startTime % 60;
                        timerElement.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                    } else {
                        // For elapsed timer, start at 0:00
                        timerElement.textContent = '0:00';
                    }
                }
                
                // Update timer mode indicator based on current config
                const modeIndicator = document.getElementById('timerModeIndicator');
                if (modeIndicator) {
                    if (currentLevelConfig.timerMode === 'countdown') {
                        modeIndicator.className = 'timer-mode-indicator timer-mode-countdown';
                        modeIndicator.textContent = '⏳';
                    } else if (currentLevelConfig.timerMode === 'elapsed') {
                        modeIndicator.className = 'timer-mode-indicator timer-mode-elapsed';
                        modeIndicator.textContent = '⏱';
                    } else if (currentLevelConfig.timerMode === 'none') {
                        modeIndicator.className = 'timer-mode-indicator timer-mode-elapsed';
                        modeIndicator.textContent = '⚪';
                    }
                }
                
                debugLog('⏰ Reset timer and game state with mode:', currentLevelConfig.timerMode);
            }
            
            // Rebuild dock with current configuration (preserves design mode settings)
            rebuildGameDock();
            
            // Trigger dock animation after reset (only if not already played)
            if (window.gameManager && typeof window.gameManager.triggerDockAnimation === 'function' && !window.gameManager.dockAnimationPlayed) {
                setTimeout(() => {
                    console.log('🎬 Triggering dock animation after level reset');
                    window.gameManager.triggerDockAnimation();
                }, 100); // Small delay to ensure dock is fully rebuilt
            }
            
            // Force reinitialize drag and drop system after dock rebuild
            if (window.gameManager && window.gameManager.dragDropManager) {
                console.log('🔄 Drag and drop system already initialized');
                
                // Verify all shapes are interactive
                const dockShapes = document.querySelectorAll('.game-shape');
                console.log(`🎯 Found ${dockShapes.length} shapes after reset:`, 
                    Array.from(dockShapes).map(s => s.dataset.shape));
                    
                // Ensure all shapes are visible and interactive
                dockShapes.forEach(shape => {
                    shape.style.visibility = 'visible';
                    shape.classList.remove('dragging', 'ghost-active');
                });
            }
            
            // Reset additional game state elements
            if (window.gameManager) {
                // Reset shape counters
                if (window.gameManager.gameState) {
                    window.gameManager.gameState.shapesPlaced = 0;
                    window.gameManager.gameState.isGameActive = true;
                    window.gameManager.gameState.isLevelComplete = false;
                    window.gameManager.gameState.isGameOver = false;
                    
                    // Reset placed shapes array - this fixes the "placed" count not resetting
                    window.gameManager.gameState.placedShapes = [];
                    
                    // Fix #2: Reset score and coins to zero
                    window.gameManager.gameState.score = 0;
                    window.gameManager.gameState.coins = 0;
                    
                    // Update displays
                    document.getElementById('scoreText').textContent = '0';
                    document.getElementById('coinAmount').textContent = '0';
                }
                
                // Reset progress bar
                const progressBar = document.getElementById('starProgressBar');
                if (progressBar) {
                    progressBar.style.width = '0%';
                }
                
                // Reset stars
                document.querySelectorAll('.star').forEach(star => {
                    star.classList.remove('filled');
                });
                
                console.log('🎮 Reset game state elements including score and coins');
            }
            
            // Update debug info to reflect reset state
            if (window.gameManager && window.gameManager.updateDebugInfo) {
                window.gameManager.updateDebugInfo();
            }

            if (window.gameManager) {
                window.gameManager.closeGameOverPopup();
                window.gameManager.startTimer();
            }

            console.log('✅ Level reset completed');
        }

        // Mobile Debug Toggle for Testing
        let mobileDebugMode = false;
        let originalMobileDetection = null;
        function toggleMobileDebug() {
            mobileDebugMode = !mobileDebugMode;
            const button = document.getElementById('mobileDebugButton');
            
            if (!window.gameManager?.mobileEnhancementManager) {
                console.log('❌ Mobile enhancement manager not found');
                console.log('Available gameManager properties:', Object.keys(window.gameManager || {}));
                return;
            }
            
            const mobileManager = window.gameManager.mobileEnhancementManager;
            
            if (mobileDebugMode) {
                // Store original detection result
                if (originalMobileDetection === null) {
                    originalMobileDetection = mobileManager.detectMobileDevice();
                }
                
                // Force mobile mode for testing
                window.gameManager.dragDropManager.isMobileDevice = true;
                mobileManager.isMobileDevice = true;
                
                // Update rotation zone bounds and show zones
                mobileManager.updateRotationZoneBounds();
                mobileManager.showRotationZones();
                
                button.style.background = 'linear-gradient(135deg, #27ae60 0%, #2ecc71 100%)';
                button.title = 'Mobile Debug: ON (Click to disable)';
                console.log('📱 Mobile Debug Mode: ON - Rotation zones should be visible');
                console.log('📱 Rotation zones bounds:', {
                    left: mobileManager.rotationZones.left.bounds,
                    right: mobileManager.rotationZones.right.bounds
                });
            } else {
                // Restore original device detection
                const originalDetection = originalMobileDetection || mobileManager.detectMobileDevice();
                window.gameManager.dragDropManager.isMobileDevice = originalDetection;
                mobileManager.isMobileDevice = originalDetection;
                
                if (!originalDetection) {
                    mobileManager.hideRotationZones();
                }
                
                button.style.background = 'linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%)';
                button.title = 'Mobile Debug: OFF (Click to enable)';
                console.log('📱 Mobile Debug Mode: OFF');
            }
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ CANVAS ENHANCEMENT THEME MANAGEMENT FUNCTIONS
          ║ User interface functions for theme switching and canvas configuration
          ╚═══════════════════════════════════════════════════════════════════════════*/

        // Toggle canvas enhancements on/off
        function toggleCanvasEnhancements() {
            const enableCanvas = document.getElementById('enableCanvas');
            CANVAS_CONFIG.enabled = enableCanvas.checked;
            
            console.log(`🎨 Canvas enhancements: ${CANVAS_CONFIG.enabled ? 'ON' : 'OFF'}`);
            
            // Apply change immediately
            if (window.gameManager) {
                if (CANVAS_CONFIG.enabled) {
                    // Re-initialize current theme
                    const currentTheme = window.gameManager.themeManager.getCurrentTheme();
                    UnifiedThemeController.changeTheme(currentTheme, { 
                        source: 'canvas-enhancement', 
                        animated: false 
                    });
                } else {
                    // Reset to basic appearance
                    window.gameManager.physicsManager.backgroundGradient = null;
                }
            }
        }

        // Toggle particle effects
        function toggleParticleEffects() {
            const enableParticles = document.getElementById('enableParticles');
            CANVAS_CONFIG.useParticles = enableParticles.checked;
            
            console.log(`🎨 Particle effects: ${CANVAS_CONFIG.useParticles ? 'ON' : 'OFF'}`);
            
            if (!CANVAS_CONFIG.useParticles && window.gameManager) {
                // Clear existing particles
                window.gameManager.physicsManager.particleSystem.particles = [];
            }
        }

        // Touch offset configuration functions
        function toggleTouchOffset() {
            const enableTouchOffset = document.getElementById('enableTouchOffset');
            if (window.gameManager && window.gameManager.dragDropManager) {
                const currentOffset = window.gameManager.dragDropManager.getTouchOffset();
                window.gameManager.dragDropManager.setTouchOffset(
                    currentOffset.x, 
                    currentOffset.y, 
                    enableTouchOffset.checked
                );
                console.log(`📱 Touch offset: ${enableTouchOffset.checked ? 'ON' : 'OFF'}`);
            }
        }

        function updateTouchOffset() {
            const offsetX = parseInt(document.getElementById('touchOffsetX').value);
            const offsetY = parseInt(document.getElementById('touchOffsetY').value);
            const enabled = document.getElementById('enableTouchOffset').checked;
            
            if (window.gameManager && window.gameManager.dragDropManager) {
                window.gameManager.dragDropManager.setTouchOffset(offsetX, offsetY, enabled);
                updateTouchOffsetDisplay();
                console.log(`📱 Touch offset updated: X=${offsetX}px, Y=${offsetY}px`);
            }
        }

        function updateTouchOffsetDisplay() {
            const offsetX = document.getElementById('touchOffsetX').value;
            const offsetY = document.getElementById('touchOffsetY').value;
            
            document.getElementById('touchOffsetXValue').textContent = `${offsetX}px`;
            document.getElementById('touchOffsetYValue').textContent = `${offsetY}px`;
        }

        // Toggle shape animations  
        function toggleAnimations() {
            const enableAnimations = document.getElementById('enableAnimations');
            CANVAS_CONFIG.useAnimations = enableAnimations.checked;
            
            console.log(`🎨 Shape animations: ${CANVAS_CONFIG.useAnimations ? 'ON' : 'OFF'}`);
        }

        // Initialize theme selector UI state
        function initializeThemeUI() {
            // Set initial checkbox states
            document.getElementById('enableCanvas').checked = CANVAS_CONFIG.enabled;
            document.getElementById('enableParticles').checked = CANVAS_CONFIG.useParticles;
            document.getElementById('enableAnimations').checked = CANVAS_CONFIG.useAnimations;
            
            // Set initial theme
            document.getElementById('themeSelector').value = CANVAS_CONFIG.defaultTheme;
            
            console.log('🎨 Theme UI initialized');
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ UNIFIED THEME CONTROLLER - SINGLE ENTRY POINT FOR ALL THEME CHANGES
          ║ Centralized theme management to replace scattered theme application calls
          ╚═══════════════════════════════════════════════════════════════════════════*/
        class UnifiedThemeController {
            static currentThemeChange = null;
            static themeChangeQueue = new Map();
            
            static async changeTheme(themeName, options = {}) {
                raceConditionDebugger.trackOperation('UnifiedThemeController.changeTheme', `${themeName}-${options.source || 'unknown'}`);
                
                const {
                    source = 'unified',
                    animated = true,
                    priority = 'normal',
                    overrides = null
                } = options;

                // Check if we're already changing to this theme
                const changeKey = `${themeName}-${source}`;
                
                if (this.themeChangeQueue.has(changeKey)) {
                    debugLog(`⚠️ Theme change to ${themeName} from ${source} already in progress`);
                    return this.themeChangeQueue.get(changeKey);
                }

                console.log(`🎨 UnifiedThemeController: Starting theme change to ${themeName} from ${source}`);
                
                // Create the change promise
                const changePromise = themeMutex.execute(async () => {
                    // Check if theme is already active
                    if (window.assetManager?.currentTheme === themeName && 
                        window.gameManager?.themeManager?.currentTheme === themeName) {
                        debugLog(`✅ Theme ${themeName} already active, skipping change`);
                        return true;
                    }
                    
                    try {
                        // Phase 1: Clear previous theme
                        await this._clearPreviousTheme();
                        
                        // Phase 2: Load new theme assets
                        await this._loadThemeAssets(themeName);
                        
                        // Phase 3: Apply theme to all subsystems
                        await this._applyToAllSystems(themeName, animated);
                        
                        // Phase 4: Apply overrides if provided
                        if (overrides) {
                            await this._applyThemeOverrides(themeName, overrides);
                        }
                        
                        // Phase 5: Rebuild UI
                        await this._rebuildUI();
                        
                        // Phase 6: Sync UI controls
                        this._syncUIControls(themeName);
                        
                        console.log(`✅ UnifiedThemeController: Successfully changed theme to ${themeName}`);
                        
                    } catch (error) {
                        console.error(`❌ UnifiedThemeController: Failed to change theme to ${themeName}:`, error);
                        throw error;
                    }
                }, `unified-theme-change-${themeName}`);
                
                // Store in queue
                this.themeChangeQueue.set(changeKey, changePromise);
                
                try {
                    const result = await changePromise;
                    return result;
                } finally {
                    // Clean up
                    this.themeChangeQueue.delete(changeKey);
                }
            }

            static async _clearPreviousTheme() {
                try {
                    if (typeof clearPreviousThemeTextures === 'function') {
                        clearPreviousThemeTextures();
                    }
                    console.log('✅ Previous theme cleared');
                } catch (error) {
                    console.warn('⚠️ Error clearing previous theme:', error);
                }
            }

            static async _loadThemeAssets(themeName) {
                try {
                    // Check if theme is already loaded to avoid redundant loading
                    if (!window.assetManager.themes[themeName]?.loaded) {
                        await window.assetManager.loadTheme(themeName);
                    }
                    console.log(`✅ Theme assets loaded for ${themeName}`);
                } catch (error) {
                    console.warn(`⚠️ Failed to load theme assets for ${themeName}:`, error);
                    // Continue with fallback colors
                }
            }

            static async _applyToAllSystems(themeName, animated) {
                try {
                    // Load the theme first through AssetManager
                    if (window.assetManager && typeof window.assetManager.loadTheme === 'function') {
                        await window.assetManager.loadTheme(themeName);
                        debugLog(`🎨 Theme loaded through AssetManager: ${themeName}`);
                    }
                    
                    // Apply background to CSS (handled by AssetManager.loadTheme, but ensure it's applied)
                    if (window.assetManager && typeof window.assetManager.applyBackgroundToCSS === 'function') {
                        const theme = window.assetManager.getCurrentTheme();
                        if (theme) {
                            window.assetManager.applyBackgroundToCSS({ name: themeName, ...theme.config });
                        }
                    }
                    
                    // Update physics manager if needed
                    if (window.gameManager?.physicsManager) {
                        // Trigger background re-render on next frame
                        window.gameManager.physicsManager.backgroundUpdateNeeded = true;
                    }
                    
                    // Apply theme colors to SHAPE_CONFIG for fallback colors
                    if (typeof applyThemeColorsToShapeConfig === 'function') {
                        applyThemeColorsToShapeConfig(themeName);
                    }

                    // Apply to ThemeManager if available
                    const themeManager = window.gameManager?.themeManager;
                    if (themeManager && typeof themeManager.switchTheme === 'function') {
                        await themeManager.switchTheme(themeName, animated);
                    }

                    // Apply material textures for non-classic themes
                    if (themeName !== 'classic') {
                        const textureManager = window.textureManager;
                        if (textureManager && typeof textureManager.applyTextureTheme === 'function') {
                            await textureManager.applyTextureTheme(themeName);
                        }
                    }

                    // Rebuild dock with new theme
                    if (typeof rebuildGameDock === 'function') {
                        await rebuildGameDock();
                    }

                    // Update current theme reference
                    if (!window.currentTheme) {
                        window.currentTheme = { shapes: {}, platform: {}, background: {} };
                    }
                    window.currentTheme.name = themeName;

                    debugLog(`✅ Theme applied to all systems: ${themeName}`);
                } catch (error) {
                    console.error(`❌ Error applying theme to systems:`, error);
                    throw error;
                }
            }

            static async _applyThemeOverrides(themeName, overrides) {
                try {
                    // This method will be implemented in todo #9
                    console.log(`🔄 Theme overrides will be applied for ${themeName}:`, overrides);
                } catch (error) {
                    console.warn('⚠️ Error applying theme overrides:', error);
                }
            }

            static async _rebuildUI() {
                try {
                    // Only rebuild dock once
                    if (typeof rebuildGameDock === 'function') {
                        await rebuildGameDock();
                    }

                    // Only trigger animation if not already played
                    if (window.gameManager && !window.gameManager.dockAnimationPlayed) {
                        setTimeout(() => {
                            if (window.gameManager && !window.gameManager.dockAnimationPlayed) {
                                console.log('🎬 Triggering dock animation after theme rebuild');
                                window.gameManager.triggerDockAnimation();
                                window.gameManager.dockAnimationPlayed = true;
                            }
                        }, 100);
                    }

                    console.log('✅ UI rebuilt after theme change');
                } catch (error) {
                    console.error('❌ Error rebuilding UI:', error);
                    throw error;
                }
            }

            static _syncUIControls(themeName) {
                try {
                    const selectors = ['themeSelector', 'enhancedThemeSelect'];
                    selectors.forEach(id => {
                        const select = document.getElementById(id);
                        if (select && select.value !== themeName) {
                            select.value = themeName;
                        }
                    });
                    console.log('✅ UI controls synced');
                } catch (error) {
                    console.warn('⚠️ Error syncing UI controls:', error);
                }
            }

            // Legacy compatibility methods
            static async applyTheme(themeName, source = 'legacy') {
                return this.changeTheme(themeName, { source });
            }

            static async loadTheme(themeName) {
                return window.assetManager.loadTheme(themeName);
            }
        }

        // Make globally available
        window.UnifiedThemeController = UnifiedThemeController;

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ THEME CHANGE QUEUE - RACE CONDITION PREVENTION
          ║ Centralized theme change management to prevent multiple theme change 
          ║ sources from causing conflicts and race conditions
          ╚═══════════════════════════════════════════════════════════════════════════*/
        class ThemeChangeQueue {
            constructor() {
                this.isChanging = false;
                this.pendingChange = null;
            }
            
            async changeTheme(themeName, source = 'unknown') {
                // Track theme access for race condition monitoring
                raceConditionMonitor.trackAccess('theme-system', 'changeTheme', 'write', {
                    themeName,
                    source
                });
                
                // Delegate to UnifiedThemeController for coordinated theme changes
                return await UnifiedThemeController.changeTheme(themeName, { source });
            }
        }

        // Create global instance
        window.themeChangeQueue = new ThemeChangeQueue();

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ RENDERER CONTROL FUNCTIONS
          ║ Canvas-only rendering system controls
          ╚═══════════════════════════════════════════════════════════════════════════*/
        
        // Switch renderer based on selection (Canvas only)
        function switchRenderer() {
            const rendererSelect = document.getElementById('rendererSelect');
            const selectedRenderer = rendererSelect.value;
            
            if (!window.gameManager || !window.gameManager.physicsManager.rendererManager) {
                console.warn('⚠️ Game not initialized yet');
                return;
            }
            
            const rendererManager = window.gameManager.physicsManager.rendererManager;
            
            // Force Canvas only since PixiJS has been removed
            let success = rendererManager.switchRenderer('canvas');
            
            if (success) {
                const currentRenderer = rendererManager.getCurrentRenderer();
                console.log(`✅ Switched to: ${currentRenderer.toUpperCase()}`);
            } else {
                console.warn('⚠️ Renderer switch failed');
            }
        }

        // Initialize and synchronize both theme dropdowns
        function initializeThemeSync() {
            const visualThemeSelect = document.getElementById('themeSelector');
            const enhancedThemeSelect = document.getElementById('enhancedThemeSelect');
            
            if (visualThemeSelect && enhancedThemeSelect) {
                // Ensure both dropdowns have the same default value
                const defaultTheme = 'classic';
                visualThemeSelect.value = defaultTheme;
                enhancedThemeSelect.value = defaultTheme;
                
                console.log(`🔄 Initialized both theme dropdowns to: ${defaultTheme}`);
            }
            
            // Initialize theme button icon
            console.log('🎨 Theme button initialized');
        }

        // Update applyTheme function to use ThemeChangeQueue
        async function applyTheme(themeName, source = 'visual') {
            await window.themeChangeQueue.changeTheme(themeName, source);
        }

        
        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ CLEAR PREVIOUS THEME TEXTURES - GLOBAL TEXTURE UNLOADING
          ║ Clears all texture data from previous themes to prevent texture persistence.
          ║ This ensures clean transitions between all themes (Wood→Stone, Metal→Classic, etc.)
          ╚═══════════════════════════════════════════════════════════════════════════*/
        function clearPreviousThemeTextures() {
            try {
                if (window.currentTheme) {
                    if (window.currentTheme.shapes && window.currentTheme.shapes.textures) {
                        delete window.currentTheme.shapes.textures;
                    }
                    if (window.currentTheme.background && window.currentTheme.background.image) {
                        delete window.currentTheme.background.image;
                    }
                    if (window.currentTheme.platform && window.currentTheme.platform.image) {
                        delete window.currentTheme.platform.image;
                    }
                }
                
                if (window.textureManager && window.textureManager.textureCache && window.textureManager.textureCache.size !== undefined) {
                    const cacheSize = window.textureManager.textureCache.size;
                    if (cacheSize > 0) {
                        window.textureManager.textureCache.clear();
                        
                        Object.keys(SHAPE_CONFIG).forEach(shapeType => {
                            if (SHAPE_CONFIG[shapeType].texture) {
                                delete SHAPE_CONFIG[shapeType].texture;
                            }
                            if (SHAPE_CONFIG[shapeType].hasTexture) {
                                delete SHAPE_CONFIG[shapeType].hasTexture;
                            }
                            if (SHAPE_CONFIG[shapeType].textureUrl) {
                                delete SHAPE_CONFIG[shapeType].textureUrl;
                            }
                        });
                    }
                }
            } catch (error) {
                console.error('Error clearing previous theme textures:', error);
            }
        }
        
        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ APPLY THEME COLORS TO SHAPE CONFIG
          ║ Applies the appropriate theme colors to SHAPE_CONFIG after texture clearing.
          ║ Ensures shapes show correct fallback colors for each theme.
          ╚═══════════════════════════════════════════════════════════════════════════*/
        function applyThemeColorsToShapeConfig(themeName) {
            try {
                // Get colors from THEME_DEFINITIONS instead of hardcoded palettes
                let colors = null;
                
                // Try to get colors from the theme definition first
                if (THEME_DEFINITIONS[themeName] && THEME_DEFINITIONS[themeName].shapes && THEME_DEFINITIONS[themeName].shapes.colors) {
                    colors = THEME_DEFINITIONS[themeName].shapes.colors;
                    console.log(`🎨 Using theme definition colors for ${themeName}:`, colors);
                } else {
                    // Fallback to hardcoded colors if theme definition doesn't have shape colors
                    const fallbackColors = {
                        classic: {
                            square: { color: '#F39C12', stroke: '#E67E22' },
                            triangle: { color: '#9B59B6', stroke: '#8E44AD' },
                            circle: { color: '#1ABC9C', stroke: '#16A085' },
                            cross2: { color: '#3498DB', stroke: '#2980B9' },
                            l: { color: '#8E44AD', stroke: '#732D91' },
                            cross: { color: '#E74C3C', stroke: '#C0392B' },
                            'barbell-one': { color: '#16A085', stroke: '#138D75' },
                            'barbell-two': { color: '#D35400', stroke: '#BA4A00' },
                            'diamond-barbell': { color: '#C0392B', stroke: '#A93226' }
                        },
                        wood: {
                            square: { color: '#D2691E', stroke: '#8B4513' },
                            triangle: { color: '#CD853F', stroke: '#A0522D' },
                            circle: { color: '#DEB887', stroke: '#D2691E' },
                            cross2: { color: '#F4A460', stroke: '#CD853F' },
                            l: { color: '#8B4513', stroke: '#A0522D' },
                            cross: { color: '#CD7F32', stroke: '#DAA520' },
                            'barbell-one': { color: '#D2691E', stroke: '#8B4513' },
                            'barbell-two': { color: '#CD853F', stroke: '#A0522D' },
                            'diamond-barbell': { color: '#DAA520', stroke: '#B8860B' }
                        }
                    };
                    
                    colors = fallbackColors[themeName] || fallbackColors.classic;
                    console.log(`⚠️ Using fallback colors for ${themeName}, theme definition colors not found`);
                }
                
                // Apply colors to SHAPE_CONFIG
                Object.keys(colors).forEach(shapeType => {
                    if (SHAPE_CONFIG[shapeType]) {
                        SHAPE_CONFIG[shapeType].color = colors[shapeType].color;
                        SHAPE_CONFIG[shapeType].stroke = colors[shapeType].stroke;
                        if (colors[shapeType].strokeWidth) {
                            SHAPE_CONFIG[shapeType].strokeWidth = colors[shapeType].strokeWidth;
                        }
                        console.log(`🎨 Applied ${themeName} colors to ${shapeType}: ${colors[shapeType].color}`);
                    }
                });
                
                console.log(`✅ Successfully applied ${themeName} theme colors to SHAPE_CONFIG`);
                
            } catch (error) {
                console.error(`Error applying ${themeName} theme colors:`, error);
            }
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ VERSION CHANGELOG - BSH GAME V18
          ╚═══════════════════════════════════════════════════════════════════════════*/
        /*
         * V18 CHANGELOG (September 2025):
         * 
         * MAJOR CHANGES:
         * ✅ Complete PixiJS removal (8-phase process)
         * ✅ Canvas2D-only rendering architecture
         * ✅ Code optimization: 1,932 lines removed (18.6% reduction)
         * ✅ Eliminated external CDN dependencies
         * ✅ Improved performance on older devices
         * ✅ Enhanced browser compatibility
         * 
         * REMOVED COMPONENTS:
         * • PixiJS CDN script import (~200KB)
         * • PixiManager class and all PixiJS integration
         * • PixiShapeRenderer and PixiJS shape system
         * • PIXI_CONFIG configuration object
         * • All PixiJS UI controls and settings
         * • Dual-renderer architecture complexity
         * 
         * PRESERVED FEATURES:
         * • Complete physics system (Matter.js)
         * • All 15+ shape types with textures
         * • 10+ theme system with visual customization
         * • Responsive design and mobile support
         * • Drag & drop mechanics
         * • Performance monitoring
         * • Debug and development tools
         * 
         * PERFORMANCE IMPROVEMENTS:
         * • ~200KB smaller bundle size
         * • Faster initialization (no PixiJS loading)
         * • Reduced memory usage
         * • Better compatibility with older browsers
         * • Simplified maintenance and debugging
         */

        // Initialize theme synchronization on page load
        document.addEventListener('DOMContentLoaded', function() {
            initializeThemeSync();
            
            // Mobile-friendly handlers for HUD icon buttons
            // Helper to attach touch handlers without interfering with existing click handlers
            function addTouchHandler(element, callback) {
                if (!element) return;
                element.addEventListener('touchstart', (e) => {
                    // Prevent default to avoid triggering the delayed click event on mobile
                    e.preventDefault();
                    e.stopPropagation();
                    callback();
                }, { passive: false });
            }
            // Cycle themes on touch
            addTouchHandler(document.getElementById('themeButton'), () => {
                try {
                    if (typeof cycleThemes === 'function') cycleThemes();
                } catch (err) {
                    console.error('Error cycling themes via touch:', err);
                }
            });
            // Reset level on touch
            addTouchHandler(document.getElementById('resetButton'), () => {
                try {
                    if (typeof resetLevel === 'function') resetLevel();
                } catch (err) {
                    console.error('Error resetting level via touch:', err);
                }
            });
        });


        // =============================================================================
        // DYNAMIC COIN BONUS SYSTEM
        // =============================================================================

        function startCoinBonusSystem() {
            // Random coin bonuses every 15-30 seconds
            setInterval(() => {
                if (!gameManager || !gameManager.gameState.isGameActive) return;
                
                const randomEvent = Math.random();
                const coinElement = document.getElementById('coinAmount');
                
                if (randomEvent < 0.3) { // 30% chance
                    // Small bonus coins
                    const bonus = Math.floor(Math.random() * 3) + 1; // 1-3 coins
                    gameManager.gameState.coins += bonus;
                    gameManager.updateCoinDisplay();
                    gameManager.createFloatingText(`🎁 +${bonus}`, coinElement, '#32CD32');
                    console.log(`🎁 Random coin bonus: +${bonus}`);
                    
                } else if (randomEvent < 0.35) { // 5% chance
                    // Medium jackpot
                    const jackpot = Math.floor(Math.random() * 8) + 5; // 5-12 coins
                    gameManager.gameState.coins += jackpot;
                    gameManager.updateCoinDisplay();
                    gameManager.createCoinShower('LUCKY BONUS!', jackpot);
                    console.log(`🍀 Lucky bonus: +${jackpot} coins`);
                    
                } else if (randomEvent < 0.37) { // 2% chance  
                    // Big jackpot
                    const megaJackpot = Math.floor(Math.random() * 15) + 10; // 10-24 coins
                    gameManager.gameState.coins += megaJackpot;
                    gameManager.updateCoinDisplay();
                    gameManager.createCoinShower('MEGA JACKPOT!', megaJackpot);
                    gameManager.pulseElement(coinElement, 5);
                    console.log(`💎 MEGA JACKPOT: +${megaJackpot} coins`);
                }
            }, Math.random() * 15000 + 15000); // Every 15-30 seconds
            
            // Stability bonus system - rewards for keeping shapes stable
            setInterval(() => {
                if (!gameManager || !gameManager.gameState.isGameActive) return;
                if (gameManager.gameState.placedShapes.length === 0) return;
                
                // Check if shapes haven't fallen recently
                const timeSinceLastFall = Date.now() - (gameManager.gameState.lastFallTime || 0);
                if (timeSinceLastFall > 30000) { // 30 seconds of stability
                    const stabilityBonus = Math.floor(Math.random() * 4) + 2; // 2-5 coins
                    gameManager.gameState.coins += stabilityBonus;
                    gameManager.updateCoinDisplay();
                    
                    const coinElement = document.getElementById('coinAmount');
                    gameManager.createFloatingText(`⚖️ STABLE +${stabilityBonus}`, coinElement, '#4ECDC4');
                    console.log(`⚖️ Stability bonus: +${stabilityBonus} coins`);
                }
            }, 30000); // Check every 30 seconds
            
            console.log('🎰 Dynamic coin bonus system activated!');
        }




        // Initialize game when page loads
        let gameManager;
        
        // Consolidate texture management to use AssetManager as the single source
        if (!window.assetManager) {
            window.assetManager = new AssetManager();
            debugLog('🖼️ Global AssetManager initialized');
        }
        // Ensure backward compatibility with textureManager references
        window.textureManager = window.assetManager;
        
        // Use unified initialization to prevent race conditions
        window.addEventListener('load', async () => {
            console.log('🔧 Page loaded, starting unified initialization...');
            
            try {
                await GameInitializer.initialize();
                console.log('✅ Unified initialization complete');
            } catch (error) {
                console.error('❌ Unified initialization failed:', error);
            }
        });

        // =============================================================================
        // IMAGE TEXTURE HELPER FUNCTIONS
        // =============================================================================

        /**
         * Load a texture image for shapes
         * @param {string} imageUrl - URL or path to the image
         * @param {string} shapeName - Name of shape ('square', 'triangle', 'circle', etc.)
         * @param {Object} options - Texture options
         * @returns {Promise<boolean>} Success/failure
         */
        async function loadShapeTexture(imageUrl, shapeName = 'square', options = {}) {
            try {
                debugLog(`🖼️ Loading texture for ${shapeName}: ${imageUrl}`);
                
                // Default texture options
                const textureConfig = {
                    url: imageUrl,
                    repeat: options.repeat || 'repeat',
                    blendMode: options.blendMode || 'source-over',
                    opacity: options.opacity || 1.0,
                    scale: options.scale || 1.0
                };

                // Add texture to current theme
                if (!window.currentTheme) {
                    window.currentTheme = { shapes: {}, platform: {}, background: {} };
                }
                if (!window.currentTheme.shapes) {
                    window.currentTheme.shapes = {};
                }
                if (!window.currentTheme.shapes.textures) {
                    window.currentTheme.shapes.textures = {};
                }
                window.currentTheme.shapes.textures[shapeName] = textureConfig;
                debugLog(`✅ Set texture config for ${shapeName}:`, textureConfig);
                debugLog(`🔍 Current theme textures:`, window.currentTheme.shapes.textures);

                // Also update THEME_DEFINITIONS so the regular theme loading system knows about this texture
                if (window.currentTheme.name && THEME_DEFINITIONS[window.currentTheme.name]) {
                    const themeDef = THEME_DEFINITIONS[window.currentTheme.name];
                    if (themeDef.shapes && themeDef.shapes.textures && themeDef.shapes.textures[shapeName]) {
                        themeDef.shapes.textures[shapeName].url = imageUrl;
                        debugLog(`🔄 Updated THEME_DEFINITIONS for ${window.currentTheme.name}.${shapeName}`);
                    }
                }

                // Load the image
                const success = await window.assetManager.loadImage(imageUrl);
                if (success) {
                    debugLog(`✅ Texture loaded successfully for ${shapeName}`);
                    return true;
                } else {
                    console.warn(`❌ Failed to load texture for ${shapeName}`);
                    return false;
                }
            } catch (error) {
                console.error(`❌ Error loading texture for ${shapeName}:`, error);
                return false;
            }
        }

        /**
         * Load a texture image for platforms
         * @param {string} imageUrl - URL or path to the image
         * @param {Object} options - Texture options
         * @returns {Promise<boolean>} Success/failure
         */
        async function loadPlatformTexture(imageUrl, options = {}) {
            try {
                console.log(`🖼️ Loading platform texture: ${imageUrl}`);
                
                // Default texture options
                const textureConfig = {
                    url: imageUrl,
                    repeat: options.repeat || 'repeat',
                    blendMode: options.blendMode || 'source-over',
                    opacity: options.opacity || 1.0,
                    scale: options.scale || 1.0
                };

                // Add texture to current theme
                window.currentTheme.platform.image = textureConfig;

                // Load the image
                const success = await window.assetManager.loadImage(imageUrl);
                if (success) {
                    console.log(`✅ Platform texture loaded successfully`);
                    return true;
                } else {
                    console.warn(`❌ Failed to load platform texture`);
                    return false;
                }
            } catch (error) {
                console.error(`❌ Error loading platform texture:`, error);
                return false;
            }
        }

        /**
         * Load a background image
         * @param {string} imageUrl - URL or path to the image
         * @param {Object} options - Background options
         * @returns {Promise<boolean>} Success/failure
         */
        async function loadBackgroundImage(imageUrl, options = {}) {
            try {
                console.log(`🖼️ Loading background image: ${imageUrl}`);
                
                // Default background options
                const backgroundConfig = {
                    url: imageUrl,
                    mode: options.mode || 'cover', // 'cover', 'contain', 'stretch', 'tile'
                    opacity: options.opacity || 1.0,
                    blur: options.blur || 0,
                    brightness: options.brightness || 1.0
                };

                // Add background to current theme
                window.currentTheme.background.image = backgroundConfig;

                // Load the image
                const success = await window.assetManager.loadImage(imageUrl);
                if (success) {
                    console.log(`✅ Background image loaded successfully`);
                    return true;
                } else {
                    console.warn(`❌ Failed to load background image`);
                    return false;
                }
            } catch (error) {
                console.error(`❌ Error loading background image:`, error);
                return false;
            }
        }

        /**
         * Clear all textures and return to gradient/solid colors
         */
        function clearAllTextures() {
            console.log('🧹 Clearing all textures...');
            
            // Clear background image
            if (window.currentTheme.background.image) {
                delete window.currentTheme.background.image;
            }
            
            // Clear platform texture
            if (window.currentTheme.platform.image) {
                delete window.currentTheme.platform.image;
            }
            
            // Clear shape textures
            if (window.currentTheme.shapes.textures) {
                delete window.currentTheme.shapes.textures;
            }
            
            console.log('✅ All textures cleared - back to gradients and solid colors');
        }

        // Make functions globally available
        window.loadShapeTexture = loadShapeTexture;
        window.loadPlatformTexture = loadPlatformTexture;
        window.loadBackgroundImage = loadBackgroundImage;
        window.clearAllTextures = clearAllTextures;

// Fix the applyEnhancedTheme function
window.applyEnhancedTheme = function() {
    const enhancedThemeSelect = document.getElementById('enhancedThemeSelect');
    const selectedTheme = enhancedThemeSelect.value;
    
    console.log(`������ Applying enhanced theme: ${selectedTheme}`);
    
    // Initialize texture manager if needed using AssetManager
    if (!window.textureManager && window.gameManager && window.gameManager.physicsManager) {
        window.textureManager = window.gameManager.physicsManager.assetManager;
    }
    
    // Apply the texture theme
    if (selectedTheme === 'wood') {
        window.textureManager.applyTextureTheme('wood').then(success => {
            if (success) {
                console.log('✅ Wood textures applied successfully!');
                // Rebuild dock to apply textures to shape previews
                rebuildGameDock();
                console.log('🔄 Dock rebuilt with textures');
            } else {
                console.log('⚠️ Failed to apply wood textures');
            }
        });
    } else {
        // Clear textures for non-wood themes
        if (window.textureManager.loadedTextures.size > 0) {
            window.textureManager.loadedTextures.clear();
            
            // Clear texture references from SHAPE_CONFIG
            Object.keys(SHAPE_CONFIG).forEach(shapeType => {
                delete SHAPE_CONFIG[shapeType].texture;
            });
            
            // Rebuild dock without textures
            rebuildGameDock();
        }
    }
};

// Initialize texture manager on page load using AssetManager
if (!window.textureManager && window.gameManager && window.gameManager.physicsManager) {
    window.textureManager = window.gameManager.physicsManager.assetManager;
    console.log('🖼️ Global textureManager set to use AssetManager');
}

/*╔═══════════════════════════════════════════════════════════════════════════
  ║ BACKGROUND TESTING FUNCTIONS
  ║ Manual testing utilities for background image system
  ╚═══════════════════════════════════════════════════════════════════════════*/

// Test cycling through all themes to verify background loading
window.testBackgroundSystem = function() {
    console.log('🧪 Testing Background System');
    console.log('============================');
    
    const themes = Object.keys(THEME_DEFINITIONS);
    let currentIndex = 0;
    
    function testNextTheme() {
        if (currentIndex >= themes.length) {
            console.log('✅ All themes tested');
            return;
        }
        
        const themeName = themes[currentIndex];
        console.log(`🎨 Testing theme: ${themeName}`);
        
        UnifiedThemeController.changeTheme(themeName, { source: 'test' })
            .then(() => {
                console.log(`✅ Theme ${themeName} applied successfully`);
                currentIndex++;
                
                // Test next theme after 3 seconds
                setTimeout(testNextTheme, 3000);
            })
            .catch(error => {
                console.error(`❌ Theme ${themeName} failed:`, error);
                currentIndex++;
                setTimeout(testNextTheme, 1000);
            });
    }
    
    testNextTheme();
};

// Test individual background image loading
window.testBackgroundLoading = function() {
    console.log('🧪 Testing Background Loading');
    console.log('==============================');
    
    // Test individual background loading
    const testUrls = [
        'assets/bkg/bkg1.png',
        'assets/bkg/nonexistent.png', // Should fail gracefully
        'assets/textures/stone/granite.txt',
        'assets/textures/metal/steel.txt'
    ];
    
    testUrls.forEach(async (url, index) => {
        try {
            const img = await window.assetManager.loadBackgroundImage(url);
            console.log(`✅ Background ${index + 1} loaded: ${url}`, img);
        } catch (error) {
            console.log(`❌ Background ${index + 1} failed: ${url}`, error.message);
        }
    });
};

// Test pattern backgrounds specifically
window.testPatternBackgrounds = function() {
    console.log('🧪 Testing Pattern Backgrounds');
    console.log('===============================');
    
    const patternThemes = ['stone', 'metal'];
    let currentIndex = 0;
    
    function testNextPattern() {
        if (currentIndex >= patternThemes.length) {
            console.log('✅ All pattern themes tested');
            // Switch back to classic for comparison
            setTimeout(() => testTheme('classic'), 1000);
            return;
        }
        
        const themeName = patternThemes[currentIndex];
        console.log(`🎨 Testing ${themeName} pattern background...`);
        
        testTheme(themeName)
            .then(() => {
                const themeConfig = THEME_DEFINITIONS[themeName];
                if (themeConfig.background.type === 'pattern') {
                    console.log(`✅ ${themeName} pattern applied:`, themeConfig.background.pattern.type);
                    console.log(`   Pattern style:`, themeConfig.background.pattern.style.substring(0, 100) + '...');
                }
                currentIndex++;
                setTimeout(testNextPattern, 4000); // Give more time to see the pattern
            })
            .catch(error => {
                console.error(`❌ ${themeName} pattern failed:`, error);
                currentIndex++;
                setTimeout(testNextPattern, 1000);
            });
    }
    
    testNextPattern();
};

// Test stone pattern with immediate visual feedback
window.testStonePatternNow = function() {
    console.log('🧪 Testing NEW stone pattern');
    
    const viewport = document.querySelector('.game-viewport');
    
    // Clear all existing classes
    viewport.classList.remove('stone-pattern', 'metal-pattern', 'theme-background');
    
    // Apply stone pattern directly
    viewport.classList.add('stone-pattern');
    
    console.log('✅ Stone pattern class applied');
    console.log('Viewport classes:', viewport.className);
    
    // Force browser to recalculate styles
    viewport.offsetHeight; 
    
    setTimeout(() => {
        const computed = getComputedStyle(viewport, '::before');
        console.log('::before styles:', {
            content: computed.content,
            position: computed.position,
            background: computed.background,
            opacity: computed.opacity,
            zIndex: computed.zIndex
        });
    }, 100);
};

// Emergency fallback - apply pattern with inline styles
window.forceStonePattern = function() {
    console.log('🚨 FORCING stone pattern with inline styles');
    
    const viewport = document.querySelector('.game-viewport');
    
    // Create a style element with very specific CSS
    const style = document.createElement('style');
    style.innerHTML = `
        .force-stone::before {
            content: '' !important;
            position: absolute !important;
            top: 0 !important;
            left: 0 !important;
            width: 100% !important;
            height: 100% !important;
            z-index: -1 !important;
            background: linear-gradient(45deg, #8B4513 0%, #A0522D 50%, #696969 100%) !important;
            opacity: 0.7 !important;
        }
    `;
    document.head.appendChild(style);
    
    viewport.classList.remove('stone-pattern', 'metal-pattern', 'theme-background');
    viewport.classList.add('force-stone');
    
    console.log('✅ Emergency stone pattern applied');
};

// Test stone pattern specifically
window.testStonePattern = function() {
    console.log('🧪 Testing stone pattern specifically');
    
    // Apply stone theme
    window.themeController.applyTheme('stone');
    
    // Wait a moment then check what happened
    setTimeout(() => {
        const viewport = document.querySelector('.game-viewport');
        console.log('Viewport classes:', viewport.className);
        console.log('Viewport computed styles:', {
            backgroundImage: getComputedStyle(viewport).backgroundImage,
            backgroundColor: getComputedStyle(viewport).backgroundColor
        });
        
        // Check ::before pseudo-element if possible
        const beforeStyles = getComputedStyle(viewport, '::before');
        console.log('::before pseudo styles:', {
            backgroundImage: beforeStyles.backgroundImage,
            opacity: beforeStyles.opacity,
            content: beforeStyles.content,
            display: beforeStyles.display,
            position: beforeStyles.position
        });
        
    }, 100);
};

// Clear all backgrounds and reset to default
window.clearAllBackgrounds = function() {
    console.log('🧹 Clearing all backgrounds');
    if (window.assetManager) {
        window.assetManager.clearBackgroundCSS();
        window.assetManager.backgroundImageCache.clear();
        console.log('✅ Background system cleared');
    }
};

// Test specific theme
window.testTheme = function(themeName) {
    console.log(`🎨 Testing individual theme: ${themeName}`);
    return UnifiedThemeController.changeTheme(themeName, { source: 'manual-test' })
        .then(() => console.log(`✅ ${themeName} theme applied`))
        .catch(error => console.error(`❌ ${themeName} theme failed:`, error));
};

// Inspect CSS properties set by background system
window.inspectBackgroundCSS = function() {
    const viewport = document.querySelector('.game-viewport');
    if (!viewport) {
        console.log('❌ Game viewport not found');
        return;
    }
    
    console.log('🔍 Background CSS Properties:');
    console.log('==============================');
    console.log('Has theme-background class:', viewport.classList.contains('theme-background'));
    console.log('--background-image:', viewport.style.getPropertyValue('--background-image'));
    console.log('--background-opacity:', viewport.style.getPropertyValue('--background-opacity'));
    console.log('background-color:', viewport.style.backgroundColor);
    
    // Check computed styles on ::before pseudo-element
    const beforeStyles = getComputedStyle(viewport, '::before');
    console.log('Computed ::before styles:');
    console.log('  background-image:', beforeStyles.backgroundImage);
    console.log('  opacity:', beforeStyles.opacity);
    console.log('  background-size:', beforeStyles.backgroundSize);
    console.log('  background-position:', beforeStyles.backgroundPosition);
};

/*══════════════════════════════════════════════════════════════════════════
  ║ PULSE SYSTEM TESTING FUNCTIONS
  ║ Test and debug the new accelerating pulse effects
  ╚═══════════════════════════════════════════════════════════════════════════*/

// Test fire shape pulsing by creating two fire shapes and making them collide
window.testFirePulsing = function() {
    console.log('🔥 Testing fire shape pulsing effects');
    
    if (!window.physicsManager) {
        console.error('❌ PhysicsManager not available');
        return;
    }
    
    // Clear existing shapes
    window.physicsManager.clearAllShapes();
    
    // Create two fire shapes
    const fireConfig = {
        specialType: {
            type: 'FIRE',
            explosionDelaySeconds: 2, // 2 second delay
            explosionRadius: 50
        }
    };
    
    // Create first fire shape
    const fire1 = window.physicsManager.createBodyFromConfig(300, 200, 'triangle', 0, fireConfig);
    const fire2 = window.physicsManager.createBodyFromConfig(500, 200, 'circle', 0, fireConfig);
    
    if (fire1 && fire2) {
        console.log('✅ Created fire shapes:', fire1.id, fire2.id);
        
        // Give them velocity to collide
        window.physicsManager.Body.setVelocity(fire1, { x: 2, y: 0 });
        window.physicsManager.Body.setVelocity(fire2, { x: -2, y: 0 });
        
        console.log('🎯 Fire shapes should collide and start pulsing with accelerating effects');
    } else {
        console.error('❌ Failed to create fire shapes');
    }
};

// Test timer shape pulsing  
window.testTimerPulsing = function() {
    console.log('⏰ Testing timer shape pulsing effects');
    
    if (!window.physicsManager) {
        console.error('❌ PhysicsManager not available');
        return;
    }
    
    // Create timer shape with short countdown
    const timerConfig = {
        specialType: {
            type: 'TIMER',
            countdownDuration: 5000, // 5 seconds
            action: 'explode'
        }
    };
    
    const timer = window.physicsManager.createBodyFromConfig(400, 300, 'hexagon', 0, timerConfig);
    
    if (timer) {
        console.log('✅ Created timer shape:', timer.id);
        console.log('Timer state:', timer.userData.timerState);
        
        // Start the timer pulsing
        window.physicsManager.startPulsing(timer, 'timer');
        
        // Check pulse state after starting
        setTimeout(() => {
            const pulseState = window.physicsManager.pulseManager.activePulses.get(timer.id);
            console.log(`Timer ${timer.id} pulse state after start:`, pulseState);
        }, 100);
        
        console.log('⏰ Timer should pulse with accelerating frequency as countdown approaches zero');
    } else {
        console.error('❌ Failed to create timer shape');
    }
};

// Quick test timer with weight trigger
window.quickTimerTest = function() {
    console.log('🚀 Quick Timer Test Starting...');
    
    if (!window.physicsManager) {
        console.error('❌ PhysicsManager not available');
        return;
    }
    
    // Find existing timer shapes first
    const existingTimers = Matter.Composite.allBodies(engine.world).filter(body => 
        body.userData?.specialType?.type === 'TIMER'
    );
    
    if (existingTimers.length > 0) {
        const testTimer = existingTimers[0];
        console.log(`⏰ Found existing timer ${testTimer.id}, testing pulsing...`);
        console.log('Timer state:', testTimer.userData.timerState);
        
        // Manually start pulsing to test
        window.physicsManager.startPulsing(testTimer, 'timer');
        
        // Check pulse state 
        setTimeout(() => {
            const pulseState = window.physicsManager.pulseManager.activePulses.get(testTimer.id);
            console.log(`✅ Timer pulse state:`, pulseState);
            
            if (pulseState && pulseState.isPulsing) {
                console.log('✅ Timer pulsing is active!');
            } else {
                console.log('❌ Timer pulsing not working');
            }
        }, 200);
    } else {
        console.log('❌ No existing timer shapes found in level');
    }
};

window.debugPulseStates = function() {
    console.log('🔍 Active Pulse States Debug');
    console.log('============================');
    
    if (!window.physicsManager || !window.physicsManager.pulseManager) {
        console.error('❌ Pulse manager not available');
        return;
    }
    
    const pulseManager = window.physicsManager.pulseManager;
    console.log(`Active pulses: ${pulseManager.activePulses.size}`);
    
    pulseManager.activePulses.forEach((pulseState, bodyId) => {
        console.log(`Body ${bodyId}:`, {
            type: pulseState.type,
            isPulsing: pulseState.isPulsing,
            pulseIntensity: pulseState.pulseIntensity?.toFixed(3),
            progress: pulseState.progress?.toFixed(3),
            currentInterval: `${pulseState.currentInterval}ms`,
            pulsesPerSecond: pulseState.pulsesPerSecond?.toFixed(2)
        });
    });
};

// Test pulse effects on different texture types
window.testPulseOnTextures = function() {
    console.log('🖼️ Testing pulse effects on different texture types');
    
    // Test with classic theme (gradient background)
    window.themeController.applyTheme('classic').then(() => {
        console.log('🎨 Applied classic theme - testing with gradient background');
        window.testFirePulsing();
    });
    
    setTimeout(() => {
        // Test with wood theme (image texture)
        window.themeController.applyTheme('wood').then(() => {
            console.log('🌳 Applied wood theme - testing with image texture');
            window.testFirePulsing();
        });
    }, 3000);
};

// Stress test multiple pulsing shapes
window.testMultiplePulses = function() {
    console.log('🚀 Stress testing multiple pulsing shapes');
    
    if (!window.physicsManager) {
        console.error('❌ PhysicsManager not available');
        return;
    }
    
    window.physicsManager.clearAllShapes();
    
    const shapes = ['triangle', 'circle', 'square', 'hexagon', 'pentagon'];
    const positions = [
        [200, 200], [400, 200], [600, 200],
        [300, 350], [500, 350]
    ];
    
    positions.forEach((pos, i) => {
        const config = {
            specialType: {
                type: Math.random() > 0.5 ? 'FIRE' : 'TIMER',
                explosionDelaySeconds: 1 + Math.random() * 2,
                explosionRadius: 30 + Math.random() * 20,
                countdownDuration: 3000 + Math.random() * 4000
            }
        };
        
        const shape = window.physicsManager.createBodyFromConfig(pos[0], pos[1], shapes[i], 0, config);
        if (shape) {
            window.physicsManager.startPulsing(shape, config.specialType.type.toLowerCase());
        }
    });
    
    console.log('✅ Created 5 shapes with different pulse types and timings');
};

debugLog('✅ Texture loading system fixed and initialized');
debugLog('🧪 Background testing functions added: testBackgroundSystem(), testBackgroundLoading(), testPatternBackgrounds(), clearAllBackgrounds(), testTheme(), inspectBackgroundCSS()');
debugLog('🎨 Enhanced stone and metal themes with CSS patterns: granite texture and brushed steel effects');
debugLog('🔥 Pulse system testing functions added: testFirePulsing(), testTimerPulsing(), debugPulseStates(), testPulseOnTextures(), testMultiplePulses()');

    </script>
</body>
</html>
