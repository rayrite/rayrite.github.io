<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Art of Balance - v10</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }

        html {
            overflow: hidden; /* Prevent scrolling on the game */
            height: 100%;
        }

        @import url('https://fonts.googleapis.com/css2?family=Fredoka:wght@400;500;600;700&display=swap');
        
        body {
            font-family: 'Fredoka', sans-serif;
            background: linear-gradient(135deg, #87CEEB 0%, #98FB98 100%);
            height: 100vh;
            height: 100dvh; /* Dynamic viewport height for mobile */
            overflow: hidden; /* Prevent scrolling */
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* New Responsive Game Viewport */
        .game-viewport {
            width: 100vw;
            height: 100vh;
            height: 100dvh;
            display: flex;
            flex-direction: column;
            max-width: min(100vw, 500px); /* Cap width at 500px on desktop */
            max-height: min(100vh, 889px); /* 500 * 16/9 for aspect ratio */
            margin: 0 auto;
            background: linear-gradient(135deg, #FF6B6B 0%, #4ECDC4 100%);
            position: relative;
            aspect-ratio: 9/16;
            overflow: visible; /* Allow dragged elements to extend beyond viewport */
            box-shadow: 0 0 50px rgba(0,0,0,0.3);
        }

        /* Border system for larger screens */
        @media (min-width: 501px) {
            body {
                background: linear-gradient(135deg, #87CEEB 0%, #98FB98 100%);
                padding: 20px;
            }
            
            .game-viewport {
                border-radius: 20px;
                box-shadow: 0 10px 50px rgba(0,0,0,0.4);
            }
        }

        /* Game HUD - Top Section */
        .game-hud {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: clamp(70px, 12vh, 90px); /* Responsive height */
            background: linear-gradient(135deg, #FF6B6B 0%, #4ECDC4 100%);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: clamp(6px, 2vw, 15px); /* Responsive padding */
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 100;
        }

        /* Left Section - Score and Star Meter */
        .left-section {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            color: white;
            font-weight: bold;
            justify-content: space-between;
            height: 100%;
            min-width: 0; /* Prevent flex overflow */
        }

        .score-display {
            display: flex;
            align-items: center;
            gap: clamp(4px, 1.5vw, 8px); /* Responsive gap */
            margin-bottom: 3px;
        }

        .trophy-icon {
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
            width: clamp(18px, 4vw, 24px); /* Responsive icon size */
            height: clamp(18px, 4vw, 24px);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(8px, 2vw, 12px); /* Responsive font */
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            border: 2px solid #B8860B;
            flex-shrink: 0; /* Prevent shrinking */
        }

        .score-text {
            font-size: clamp(14px, 4vw, 18px); /* Responsive font size */
            font-weight: 700;
            color: #FFE4B5;
            text-shadow: 0 2px 4px rgba(0,0,0,0.4);
            white-space: nowrap; /* Prevent text wrapping */
        }

        .star-progress-container {
            position: relative;
            width: clamp(100px, 25vw, 140px); /* Responsive width */
            height: clamp(14px, 3vw, 18px); /* Responsive height */
            background: rgba(255,255,255,0.25);
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.3);
            overflow: hidden;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.3);
            cursor: pointer; /* Indicate interactivity */
        }

        .progress-area {
            position: relative;
            width: clamp(100px, 25vw, 140px); /* Match container width */
            height: clamp(28px, 6vw, 36px); /* Responsive height for better touch */
        }

        .star-progress-container {
            margin-top: clamp(12px, 3vw, 18px); /* Responsive margin */
        }

        .star-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #8B5CF6 0%, #A855F7 50%, #C084FC 100%);
            border-radius: 7px;
            transition: width 0.8s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            box-shadow: 0 0 6px rgba(139, 92, 246, 0.6);
        }

        /* White progress markers inside the bar */
        .progress-markers {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 100%;
            pointer-events: none;
            z-index: 2;
        }

        .progress-marker {
            position: absolute;
            top: 0;
            width: 2px;
            height: 100%;
            background: rgba(255,255,255,0.8);
            border-radius: 1px;
        }

        .progress-marker:nth-child(1) {
            left: 33.33%;
            transform: translateX(-50%);
        }

        .progress-marker:nth-child(2) {
            left: 66.66%;
            transform: translateX(-50%);
        }

        .progress-marker:nth-child(3) {
            left: 90%;
            transform: translateX(-50%);
        }

        .star-markers {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 16px;
            width: 120px;
            pointer-events: none;
            z-index: 10;
        }

        .star {
            width: 14px;
            height: 14px;
            background: rgba(255,255,255,0.3);
            clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%);
            box-shadow: 0 2px 6px rgba(0,0,0,0.5);
            border: 1px solid rgba(255,255,255,0.6);
            transition: all 0.5s ease;
            position: absolute;
        }

        /* Position stars directly above the white markers */
        .star:nth-child(1) {
            left: 33.33%;
            transform: translateX(-50%);
        }

        .star:nth-child(2) {
            left: 66.66%;
            transform: translateX(-50%);
        }

        .star:nth-child(3) {
            left: 90%;
            transform: translateX(-50%);
        }

        .star.filled {
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
            border: 2px solid #B8860B;
            transform: translateX(-50%) scale(1.3);
            box-shadow: 0 0 20px rgba(255, 215, 0, 1), 0 2px 6px rgba(0,0,0,0.6);
            animation: starPulse 0.5s ease-out;
            z-index: 15;
        }

        /* Middle Section - Timer */
        .middle-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            gap: clamp(3px, 1vw, 6px); /* Responsive gap */
            min-width: 0; /* Prevent overflow */
        }

        /* Level Display */
        .level-display {
            font-size: clamp(11px, 3vw, 14px); /* Responsive font size */
            font-weight: 600;
            color: #FFE4B5;
            text-shadow: 0 1px 2px rgba(0,0,0,0.4);
            background: rgba(0,0,0,0.15);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            padding: clamp(3px, 1vw, 6px) clamp(6px, 2vw, 10px); /* Responsive padding */
            min-width: clamp(50px, 12vw, 70px); /* Responsive min-width */
            text-align: center;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
            white-space: nowrap;
        }

        .timer-container {
            background: rgba(0,0,0,0.2);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 12px;
            padding: clamp(6px, 2vw, 10px) clamp(8px, 3vw, 14px); /* Responsive padding */
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: clamp(60px, 15vw, 80px); /* Responsive min-width */
            min-height: 44px; /* Minimum touch target */
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }

        .timer-container:hover {
            background: rgba(0,0,0,0.3);
            transform: translateY(-1px);
        }

        .timer-text {
            font-size: clamp(12px, 3.5vw, 16px); /* Responsive font size */
            font-weight: 600;
            color: #FFE4B5;
            text-shadow: 0 1px 2px rgba(0,0,0,0.4);
            font-variant-numeric: tabular-nums;
            transition: all 0.3s ease;
            white-space: nowrap;
        }

        .timer-text.timer-warning {
            color: #FFA500;
            text-shadow: 0 0 10px rgba(255, 165, 0, 0.6);
        }

        .timer-text.timer-critical {
            color: #FF4444;
            text-shadow: 0 0 15px rgba(255, 68, 68, 0.8);
            animation: timerPulse 1s infinite;
        }

        @keyframes timerPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        /* Right Section - Settings, Reset, and Coins */
        .right-section {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            justify-content: space-between;
            height: 100%;
            min-width: 0; /* Prevent overflow */
        }

        .top-buttons {
            display: flex;
            gap: clamp(6px, 2vw, 10px); /* Responsive gap */
            align-items: center;
            flex-wrap: wrap; /* Allow wrapping on very small screens */
        }

        .settings-button, .reset-button {
            width: clamp(32px, 8vw, 44px); /* Responsive size with 44px max for touch */
            height: clamp(32px, 8vw, 44px);
            min-width: 44px; /* Minimum touch target */
            min-height: 44px;
            background: rgba(0,0,0,0.2);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            color: #FFE4B5;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            position: relative;
        }

        .settings-button:hover, .reset-button:hover {
            background: rgba(0,0,0,0.3);
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(0,0,0,0.4);
        }

        .settings-button:active, .reset-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }

        .reset-icon {
            width: clamp(12px, 3vw, 16px); /* Responsive icon size */
            height: clamp(12px, 3vw, 16px);
            color: #FFE4B5;
            font-size: clamp(10px, 3vw, 14px); /* Responsive font */
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .pause-icon {
            width: clamp(12px, 3vw, 16px);
            height: clamp(12px, 3vw, 16px);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 2px;
        }

        .pause-bar {
            width: 3px;
            height: clamp(10px, 3vw, 14px); /* Responsive height */
            background: #FFE4B5;
            border-radius: 1px;
        }

        .coin-counter {
            display: flex;
            align-items: center;
            gap: clamp(4px, 1.5vw, 7px); /* Responsive gap */
            background: rgba(0,0,0,0.2);
            padding: clamp(4px, 1.5vw, 7px) clamp(8px, 2.5vw, 12px); /* Responsive padding */
            border-radius: 10px;
            border: 1px solid rgba(255,255,255,0.2);
            cursor: pointer;
            transition: all 0.3s ease;
            min-height: 44px; /* Minimum touch target */
            min-width: 60px; /* Minimum width for readability */
        }

        .coin-counter:hover {
            background: rgba(0,0,0,0.3);
            transform: translateY(-1px);
        }

        .coin-icon {
            width: clamp(14px, 4vw, 18px); /* Responsive icon size */
            height: clamp(14px, 4vw, 18px);
            font-size: clamp(10px, 3vw, 14px); /* Responsive font */
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .coin-amount {
            font-size: clamp(12px, 3.5vw, 16px); /* Responsive font size */
            font-weight: 600;
            color: #FFE4B5;
            text-shadow: 0 1px 2px rgba(0,0,0,0.4);
            white-space: nowrap; /* Prevent text wrapping */
        }

        /* Timer Mode Indicator */
        .timer-mode-indicator {
            position: absolute;
            top: -5px;
            right: -5px;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            font-size: 8px;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            border: 1px solid rgba(255,255,255,0.3);
        }

        .timer-mode-elapsed {
            background: linear-gradient(135deg, #8B5CF6 0%, #7C3AED 100%);
        }

        .timer-mode-countdown {
            background: linear-gradient(135deg, #EF4444 0%, #DC2626 100%);
        }

        .timer-mode-endlevel {
            background: linear-gradient(135deg, #10B981 0%, #059669 100%);
        }

        /* Docking Area - Shape Selection */
        .docking-area {
            position: absolute;
            top: clamp(70px, 12vh, 90px); /* Match HUD height */
            left: 0;
            right: 0;
            height: clamp(120px, 20vh, 160px); /* Responsive height */
            background: #34495e;
            display: grid;
            grid-template-columns: repeat(5, 1fr); /* Equal column distribution */
            grid-template-rows: repeat(2, 1fr); /* Equal row distribution */
            gap: clamp(4px, 1.5vw, 10px); /* Responsive gap */
            padding: clamp(4px, 2vw, 8px); /* Responsive padding */
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            z-index: 50;
            align-items: center;
            justify-items: center;
            overflow: visible; /* Allow shapes to extend beyond docking area */
        }

        .shape-slot {
            width: 100%;
            height: 100%;
            min-width: clamp(50px, 12vw, 70px); /* Responsive minimum size */
            min-height: clamp(50px, 12vw, 70px);
            max-width: 80px; /* Prevent too large on desktop */
            max-height: 80px;
            background: rgba(255,255,255,0.1);
            border: 2px dashed rgba(255,255,255,0.3);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            transition: all 0.3s ease;
            padding: 0;
            margin: 0;
            overflow: visible;
            box-sizing: border-box;
            cursor: pointer; /* Indicate interactivity */
        }

        .shape-slot:hover {
            background: rgba(255,255,255,0.15);
            border-color: rgba(255,255,255,0.5);
            transform: scale(1.05);
        }

        .shape-slot.empty {
            border-color: rgba(255,255,255,0.1);
            background: rgba(255,255,255,0.05);
        }

        .shape-slot.empty:hover {
            border-color: rgba(255,255,255,0.2);
            background: rgba(255,255,255,0.1);
        }

        .game-shape {
            cursor: grab;
            transition: all 0.3s ease;
            position: relative;
            z-index: 60;
            width: 100%; /* Fill slot */
            height: 100%;
            min-width: 44px; /* Minimum touch target */
            min-height: 44px;
        }

        .game-shape:active {
            cursor: grabbing;
            transform: scale(1.15); /* Slightly larger feedback on touch */
            filter: drop-shadow(0 5px 15px rgba(0,0,0,0.4));
            transition: all 0.1s ease; /* Quick response for touch */
        }

        .game-shape:hover {
            transform: scale(1.1);
            filter: drop-shadow(0 3px 10px rgba(0,0,0,0.3));
        }

        .game-shape.dragging {
            z-index: 1000;
            transform: scale(1.2); /* Slightly larger when dragging */
            filter: drop-shadow(0 8px 20px rgba(0,0,0,0.4));
        }

        /* Enhanced touch feedback for mobile */
        @media (pointer: coarse) {
            .game-shape {
                transition: all 0.2s ease; /* Longer transitions on touch devices */
            }
            
            .game-shape:active {
                transform: scale(1.2); /* Larger feedback on touch devices */
                transition: all 0.05s ease; /* Very quick response */
            }
            
            .shape-slot:active {
                background: rgba(255,255,255,0.2);
                border-color: rgba(255,255,255,0.7);
                transform: scale(1.02);
                transition: all 0.05s ease;
            }
        }
        
        /* End Level Countdown - 3 Dot Display */
        .countdown-dots {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            padding: 8px 12px;
        }

        .countdown-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: rgba(255,255,255,0.3);
            transition: all 0.3s ease;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }

        .countdown-dot.active {
            background: linear-gradient(135deg, #10B981 0%, #059669 100%);
            transform: scale(1.7);
            box-shadow: 0 0 12px rgba(16, 185, 129, 0.8);
            animation: dotPulse 0.6s ease-in-out;
        }

        .countdown-dot.completed {
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
            transform: scale(1.8);
            box-shadow: 0 0 8px rgba(255, 215, 0, 0.6);
        }

        @keyframes dotPulse {
            0%, 100% { transform: scale(1.3); }
            50% { transform: scale(1.6); }
        }

        /* Particle Effects */
        .particle {
            position: fixed;
            pointer-events: none;
            z-index: 9999;
            font-size: 14px;
            font-weight: bold;
            opacity: 1;
            animation: particleFloat 2s ease-out forwards;
        }

        @keyframes particleFloat {
            0% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
            100% {
                opacity: 0;
                transform: translateY(-40px) scale(0);
            }
        }

        @keyframes starBurst {
            0% {
                opacity: 1;
                transform: scale(0) rotate(0deg);
            }
            50% {
                opacity: 0.8;
                transform: scale(1.5) rotate(180deg);
            }
            100% {
                opacity: 0;
                transform: scale(2) rotate(360deg);
            }
        }

        .progress-animate {
            animation: progressPulse 0.8s ease-out;
        }

        @keyframes progressPulse {
            0% { transform: scaleY(1); }
            50% { transform: scaleY(1.1); box-shadow: 0 0 15px rgba(255, 215, 0, 0.6); }
            100% { transform: scaleY(1); }
        }

        /* Enhanced Star Animations */
        .star.filled {
            animation: starFill 0.5s ease-out;
        }

        @keyframes starFill {
            0% { transform: scale(0) rotate(0deg); opacity: 0; }
            50% { transform: scale(1.3) rotate(180deg); opacity: 1; }
            100% { transform: scale(1) rotate(360deg); opacity: 1; }
        }

        /* Score Text Animation */
        .score-text {
            transition: all 0.3s ease;
        }

        .score-text.score-increase {
            animation: scoreBoost 0.6s ease-out;
        }

        @keyframes scoreBoost {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); color: #FFD700; }
            100% { transform: scale(1); }
        }

        /* Coin Animation */
        .coin-amount {
            transition: all 0.3s ease;
        }

        .coin-amount.coin-increase {
            animation: coinBoost 0.6s ease-out;
        }

        @keyframes coinBoost {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); color: #FFD700; text-shadow: 0 0 10px #FFD700; }
            100% { transform: scale(1); }
        }

        /* Enhanced Coin Animations */
        @keyframes coinShower {
            0% { 
                transform: translateY(0) rotate(0deg); 
                opacity: 1; 
            }
            50% { 
                transform: translateY(-50px) rotate(180deg); 
                opacity: 0.8; 
            }
            100% { 
                transform: translateY(100px) rotate(360deg); 
                opacity: 0; 
            }
        }

        @keyframes coinPulse {
            0%, 100% { 
                transform: scale(1); 
                box-shadow: 0 0 5px rgba(255, 215, 0, 0.3); 
            }
            50% { 
                transform: scale(1.3); 
                box-shadow: 0 0 25px rgba(255, 215, 0, 0.8); 
            }
        }

        @keyframes coinShake {
            0%, 100% { transform: translateX(0); }
            10% { transform: translateX(-2px) rotate(-1deg); }
            20% { transform: translateX(2px) rotate(1deg); }
            30% { transform: translateX(-3px) rotate(-1deg); }
            40% { transform: translateX(3px) rotate(1deg); }
            50% { transform: translateX(-2px) rotate(-1deg); }
            60% { transform: translateX(2px) rotate(1deg); }
            70% { transform: translateX(-1px) rotate(-1deg); }
            80% { transform: translateX(1px) rotate(1deg); }
            90% { transform: translateX(-1px) rotate(-1deg); }
        }

        /* Particle Effects */
        .particle {
            position: fixed;
            pointer-events: none;
            font-size: 18px;
            font-weight: bold;
            z-index: 9999;
            animation: floatUp 2s ease-out forwards;
        }

        /* Level Complete Effects */
        @keyframes levelCompleteFlash {
            0%, 100% { filter: brightness(1); }
            25% { filter: brightness(1.3) saturate(1.2); }
            50% { filter: brightness(1.1) saturate(1.1); }
            75% { filter: brightness(1.2) saturate(1.15); }
        }

        /* Level Cleared Popup Modal */
        .level-cleared-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            opacity: 0;
            animation: modalFadeIn 0.5s ease-out forwards;
        }

        .level-cleared-content {
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
            transform: scale(0.5);
            animation: modalPopIn 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55) forwards;
        }

        .level-cleared-title {
            font-size: 48px;
            font-weight: bold;
            color: #8B4513;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            animation: titlePulse 1s ease-in-out infinite alternate;
        }

        .level-cleared-subtitle {
            font-size: 24px;
            color: #654321;
            margin-bottom: 30px;
            font-weight: 600;
        }

        .level-cleared-stars {
            font-size: 60px;
            margin: 20px 0;
            animation: starsSparkle 2s ease-in-out infinite;
        }

        .level-cleared-button {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            margin: 10px;
        }

        .level-cleared-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
        }

        @keyframes modalFadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes modalPopIn {
            from { 
                transform: scale(0.5) rotate(-10deg);
                opacity: 0;
            }
            to { 
                transform: scale(1) rotate(0deg);
                opacity: 1;
            }
        }

        @keyframes titlePulse {
            from { transform: scale(1); }
            to { transform: scale(1.05); }
        }

        @keyframes starsSparkle {
            0%, 100% { 
                transform: scale(1) rotate(0deg);
                filter: brightness(1);
            }
            50% { 
                transform: scale(1.1) rotate(5deg);
                filter: brightness(1.3);
            }
        }

        /* Global Drag Overlay - Ensure dragging works across entire viewport */
        #dragOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 9998;
            overflow: visible;
        }

        .ghost-shape {
            position: fixed !important;
            pointer-events: none !important;
            z-index: 10000 !important; /* Increased z-index */
            visibility: visible !important;
            opacity: 0.9 !important;
            display: block !important;
            transition: transform 0.2s ease-out !important;
        }

        /* Rotation Visual Feedback */
        /* Enhanced Mobile Touch Interactions */
        .game-shape {
            touch-action: none;
            cursor: grab;
            transition: transform 0.2s ease;
        }

        .game-shape:hover {
            transform: scale(1.05);
        }

        .game-shape:active {
            cursor: grabbing;
            transform: scale(1.1);
        }

        .game-shape.ghost-active {
            opacity: 0.3;
            transform: scale(0.9);
            transition: all 0.3s ease;
        }

        /* Touch Feedback */
        .touch-ripple {
            position: fixed;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.6);
            pointer-events: none;
            z-index: 9998;
            animation: rippleEffect 0.6s ease-out forwards;
        }

        @keyframes rippleEffect {
            0% { transform: scale(0); opacity: 1; }
            100% { transform: scale(4); opacity: 0; }
        }

        .rotation-indicator {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: bold;
            z-index: 10000;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .rotation-indicator.show {
            opacity: 1;
        }

        /* Enhanced Drag Feedback */
        .game-shape.ghost-active {
            opacity: 0.3;
            transform: scale(0.9);
            transition: all 0.3s ease;
        }

        /* Shape Visual Designs - REMOVED: Now using unified canvas-based system */
        /* All shape appearances now handled by PhysicsShapeRenderer and SHAPE_CONFIG */

        /* Canvas preview styling for dock */
        .shape-preview {
            width: 46px;
            height: 46px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .shape-preview:hover {
            filter: brightness(1.1);
            transform: scale(1.05);
        }

        /* Ghost effect for dragged shapes */
        .shape-preview.ghost-active {
            opacity: 0.3;
            transform: scale(0.9);
            transition: all 0.3s ease;
        }

        /* Game shape base styles for drag/drop functionality */
        .game-shape {
            display: block;
            position: relative;
        }

        .game-shape.ghost-active {
            opacity: 0.3;
        }

        /* Mode Toggle Inside HUD */
        .mode-toggle-switch {
            position: relative;
            width: 60px;
            height: 28px;
            background: rgba(52, 73, 94, 0.8);
            border-radius: 14px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .mode-toggle-switch.design-active {
            background: rgba(52, 152, 219, 0.8);
            border-color: #3498db;
        }

        .mode-toggle-slider {
            position: absolute;
            top: 2px;
            left: 2px;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
        }

        .mode-toggle-switch.design-active .mode-toggle-slider {
            transform: translateX(28px);
        }

        .mode-toggle-labels {
            position: absolute;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            white-space: nowrap;
            color: rgba(255, 255, 255, 0.8);
        }

        /* Design Mode Sidebar */
        .design-sidebar {
            position: fixed;
            top: 0;
            left: -350px;
            width: 350px;
            height: 100vh;
            background: linear-gradient(180deg, #2c3e50 0%, #34495e 100%);
            box-shadow: 5px 0 20px rgba(0,0,0,0.3);
            transition: left 0.4s ease;
            z-index: 999;
            overflow-y: auto;
            color: white;
        }

        .design-sidebar.active {
            left: 0;
        }

        .design-mode .game-viewport {
            margin-left: 350px;
            transition: margin-left 0.4s ease;
        }

        .sidebar-header {
            padding: 20px;
            background: rgba(0,0,0,0.2);
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .sidebar-title {
            font-size: 16px;
            font-weight: bold;
            color: #3498db;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .sidebar-section {
            padding: 15px 20px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .config-group {
            margin-bottom: 12px;
        }

        .config-label {
            display: block;
            font-size: 13px;
            font-weight: 500;
            margin-bottom: 5px;
            color: #bdc3c7;
        }

        .config-input, .config-select {
            width: 100%;
            padding: 8px 12px;
            background: rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 6px;
            color: white;
            font-size: 14px;
        }

        .config-input:focus, .config-select:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 5px rgba(52, 152, 219, 0.3);
        }

        .config-sub-group {
            margin-left: 20px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .config-sub-group .config-label {
            min-width: 100px;
            margin-bottom: 0;
            font-size: 12px;
        }

        .config-sub-group input[type="range"] {
            flex: 1;
            margin: 0;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
        }

        .range-value {
            min-width: 50px;
            text-align: right;
            font-size: 12px;
            color: #FFE4B5;
            font-weight: 600;
            background: rgba(0,0,0,0.2);
            padding: 2px 6px;
            border-radius: 4px;
        }

        .config-btn {
            width: 100%;
            padding: 10px;
            background: linear-gradient(135deg, #27ae60 0%, #229954 100%);
            color: white;
            border: none;
            border-radius: 6px;
            font-weight: bold;
            cursor: pointer;
            margin-top: 8px;
            transition: all 0.3s ease;
        }

        .config-btn:hover {
            background: linear-gradient(135deg, #229954 0%, #1e8449 100%);
            transform: translateY(-1px);
        }

        /* v9: Theme Selector Styles */
        .checkbox-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 8px;
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            color: #ecf0f1;
            cursor: pointer;
        }

        .checkbox-label input[type="checkbox"] {
            width: 16px;
            height: 16px;
            accent-color: #27ae60;
        }

        .theme-preview {
            width: 100%;
            height: 40px;
            border-radius: 4px;
            margin: 4px 0 8px 0;
            background: linear-gradient(135deg, #87CEEB 0%, #4ECDC4 50%, #90EE90 100%);
            border: 2px solid transparent;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .theme-preview:hover {
            border-color: #27ae60;
            transform: scale(1.02);
        }

        .theme-preview.active {
            border-color: #27ae60;
            box-shadow: 0 0 10px rgba(39, 174, 96, 0.5);
        }

        .dock-slot-config {
            background: rgba(0,0,0,0.2);
            padding: 8px;
            border-radius: 6px;
            margin-bottom: 8px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .game-canvas-container {
            position: absolute;
            top: calc(clamp(70px, 12vh, 90px) + clamp(120px, 20vh, 160px)); /* HUD + Docking height */
            left: 0;
            right: 0;
            bottom: 0; /* Use full available space */
            background: linear-gradient(135deg, #87CEEB 0%, #98FB98 100%);
            border-radius: 0;
            overflow: visible; /* Allow dragged shapes to extend beyond canvas boundaries */
        }

        #gameCanvas {
            width: 100%;
            height: 100%;
            display: block;
            background: transparent;
            cursor: crosshair;
        }

        /* Debug Info */
        .debug-info {
            position: absolute;
            bottom: clamp(5px, 2vh, 15px); /* Responsive bottom position */
            left: clamp(5px, 2vw, 15px); /* Responsive left position */
            color: white;
            font-size: clamp(10px, 2.5vw, 12px); /* Responsive font size */
            opacity: 0.7;
            font-family: monospace;
            background: rgba(0,0,0,0.7);
            padding: clamp(4px, 1.5vw, 8px); /* Responsive padding */
            border-radius: 6px;
            z-index: 100;
            max-width: 70vw; /* Prevent overflow */
            word-break: break-word;
        }

        /* Event Notifications */
        .event-notification {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: clamp(12px, 3vw, 20px) clamp(16px, 4vw, 24px); /* Responsive padding */
            border-radius: 12px;
            font-size: clamp(14px, 4vw, 18px); /* Responsive font size */
            font-weight: bold;
            z-index: 1000;
            opacity: 0;
            transition: all 0.3s ease;
            pointer-events: none;
            max-width: 80vw; /* Prevent overflow on small screens */
            min-width: 200px; /* Minimum readable width */
            text-align: center;
        }

        .event-notification.show {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1.1);
        }

        .event-notification.fall {
            background: rgba(231, 76, 60, 0.9);
            border: 2px solid #e74c3c;
        }

        .event-notification.collision {
            background: rgba(46, 204, 113, 0.9);
            border: 2px solid #2ecc71;
        }

        .event-notification.balance {
            background: rgba(52, 152, 219, 0.9);
            border: 2px solid #3498db;
        }

        /* Animations */
        @keyframes starPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.3); }
            100% { transform: scale(1.2); }
        }

        /* Test Controls (REMOVED - Debug squares eliminated) */

        /* Responsive Design - Mobile First */
        @media (max-width: 500px) {
            body {
                padding: 0;
            }
            
            .game-viewport {
                width: 100vw;
                height: 100vh;
                height: 100dvh;
                border-radius: 0;
                box-shadow: none;
                max-width: none;
                max-height: none;
                aspect-ratio: unset; /* Allow full screen on mobile */
                padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
            }
            
            .game-hud {
                height: clamp(60px, 10vh, 70px); /* Slightly smaller on mobile */
                padding: clamp(4px, 1.5vw, 8px);
            }
            
            .docking-area {
                height: clamp(100px, 18vh, 140px); /* Adjust for mobile */
                gap: clamp(3px, 1vw, 6px);
                padding: clamp(3px, 1vw, 6px);
            }
            
            .shape-slot {
                min-width: clamp(45px, 15vw, 60px); /* Optimize for mobile touch */
                min-height: clamp(45px, 15vw, 60px);
            }
            
            .game-canvas-container {
                border-radius: 0;
                top: calc(clamp(60px, 10vh, 70px) + clamp(100px, 18vh, 140px)); /* Updated for mobile HUD + docking */
            }
            
            /* Enhanced touch targets on mobile */
            .settings-button, .reset-button {
                min-width: 48px; /* Larger touch targets */
                min-height: 48px;
            }
            
            .timer-container {
                min-height: 48px; /* Better touch target */
            }
            
            .coin-counter {
                min-height: 48px; /* Better touch target */
                padding: 6px 10px;
            }
            
            /* Hide design mode on mobile */
            .design-sidebar {
                display: none;
            }
        }

        /* Tablet Portrait */
        @media (min-width: 501px) and (max-width: 1024px) and (orientation: portrait) {
            .game-viewport {
                max-width: 600px;
                max-height: 1067px; /* 600 * 16/9 */
            }
        }

        /* Desktop and Large Screens */
        @media (min-width: 1025px) {
            body {
                padding: 40px 20px;
            }
            
            .game-viewport {
                max-width: 500px;
                max-height: 889px; /* 500 * 16/9 */
                border-radius: 25px;
            }
        }

        /* Rotation Zones - Mobile Enhancement */
        .rotation-zone {
            position: absolute;
            width: 80px;
            height: 100%;
            top: 0;
            border: 2px dashed rgba(74, 144, 226, 0.4);
            border-radius: 10px;
            transition: all 0.3s ease;
            pointer-events: none;
            opacity: 0.3; /* Make visible for testing */
            z-index: 1000;
            display: block; /* Always visible for testing */
        }

        .rotation-zone.left {
            left: 0;
            background: linear-gradient(to right, rgba(229, 115, 115, 0.2), transparent);
            border-color: rgba(229, 115, 115, 0.4);
        }

        .rotation-zone.right {
            right: 0;
            background: linear-gradient(to left, rgba(129, 199, 132, 0.2), transparent);
            border-color: rgba(129, 199, 132, 0.4);
        }

        .rotation-zone.visible {
            display: block;
            opacity: 1;
        }

        .rotation-zone.active {
            border-color: rgba(74, 144, 226, 1);
            box-shadow: 0 0 20px rgba(74, 144, 226, 0.4);
        }

        .rotation-zone.left.active {
            background: linear-gradient(to right, rgba(229, 115, 115, 0.4), transparent);
            border-color: rgba(229, 115, 115, 1);
            box-shadow: 0 0 20px rgba(229, 115, 115, 0.4);
        }

        .rotation-zone.right.active {
            background: linear-gradient(to left, rgba(129, 199, 132, 0.4), transparent);
            border-color: rgba(129, 199, 132, 1);
            box-shadow: 0 0 20px rgba(129, 199, 132, 0.4);
        }

        .rotation-zone::before {
            content: "↺";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2rem;
            color: rgba(255, 255, 255, 0.8);
            animation: zonePulse 2s infinite;
        }

        .rotation-zone.right::before {
            content: "↻";
        }

        .rotation-zone.active::before {
            animation: zoneRotate 1s linear infinite;
            color: rgba(255, 255, 255, 1);
        }

        @keyframes zonePulse {
            0%, 100% { opacity: 0.6; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
        }

        @keyframes zoneRotate {
            from { transform: translate(-50%, -50%) rotate(0deg); }
            to { transform: translate(-50%, -50%) rotate(360deg); }
        }
        
    </style>
</head>
<body>
    <!-- Global drag overlay to prevent clipping -->
    <div id="dragOverlay"></div>
    
    <div class="game-viewport" id="gameContainer">
        <!-- Mobile Rotation Zones -->
        <div id="leftRotationZone" class="rotation-zone left"></div>
        <div id="rightRotationZone" class="rotation-zone right"></div>
            
            <!-- Game HUD -->
            <div class="game-hud">
                <div class="left-section">
                    <div class="score-display">
                        <div class="trophy-icon">🏆</div>
                        <span class="score-text" id="scoreText">0</span>
                    </div>
                    <div class="progress-area">
                        <div class="star-progress-container" onclick="initializeProgressBarInteraction()">
                            <div class="star-progress-bar" id="starProgressBar" style="width: 0%;"></div>
                            <div class="progress-markers">
                                <div class="progress-marker"></div>
                                <div class="progress-marker"></div>
                                <div class="progress-marker"></div>
                            </div>
                        </div>
                        <div class="star-markers">
                            <div class="star"></div>
                            <div class="star"></div>
                            <div class="star"></div>
                        </div>
                    </div>
                </div>

                <div class="middle-section">
                    <div class="level-display" id="levelDisplay">World 1-1</div>
                    <div class="timer-container" id="timerContainer" onclick="switchTimerMode()">
                        <span class="timer-text" id="gameTimer">0:00</span>
                        <div class="timer-mode-indicator timer-mode-elapsed" id="timerModeIndicator">⏱</div>
                    </div>
                </div>

                <div class="right-section">
                    <div class="top-buttons">
                        <!-- Commented out pause button for mode toggle -->
                        <!-- <div class="settings-button" id="pauseButton">
                            <div class="pause-icon">
                                <div class="pause-bar"></div>
                                <div class="pause-bar"></div>
                            </div>
                        </div> -->
                        
                        <!-- Phase 2: Mode Toggle Switch -->
                        <div class="mode-toggle-switch" id="modeToggleSwitch" onclick="toggleModeSwitch()">
                            <div class="mode-toggle-slider">🎮</div>
                            <div class="mode-toggle-labels">Play/Design</div>
                        </div>
                        
                        <div class="reset-button" id="resetButton" onclick="resetLevel()">
                            <div class="reset-icon">⟲</div>
                        </div>
                        
                        <div class="reset-button" id="mobileDebugButton" onclick="toggleMobileDebug()" style="background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%);">
                            <div class="reset-icon">📱</div>
                        </div>
                    </div>
                    <div class="coin-counter" id="coinCounter" onclick="animateCoin()">
                        <div class="coin-icon">💰</div>
                        <span class="coin-amount" id="coinAmount">0</span>
                    </div>
                </div>
            </div>

            <!-- Docking Area -->
            <div class="docking-area" id="dockingArea">
                <div class="shape-slot" id="slot-square">
                    <div class="game-shape shape-square" data-shape="square" id="shape-square"></div>
                </div>
                <div class="shape-slot" id="slot-triangle">
                    <div class="game-shape shape-triangle" data-shape="triangle" id="shape-triangle"></div>
                </div>
                <div class="shape-slot" id="slot-circle">
                    <div class="game-shape shape-circle" data-shape="circle" id="shape-circle"></div>
                </div>
                <div class="shape-slot" id="slot-cross2">
                    <div class="game-shape shape-cross2" data-shape="cross2" id="shape-cross2"></div>
                </div>
                <div class="shape-slot" id="slot-l">
                    <div class="game-shape shape-l" data-shape="l" id="shape-l"></div>
                </div>
                <div class="shape-slot" id="slot-cross">
                    <div class="game-shape shape-cross" data-shape="cross" id="shape-cross"></div>
                </div>
                <div class="shape-slot" id="slot-barbell-one">
                    <div class="game-shape shape-barbell-one" data-shape="barbell-one" id="shape-barbell-one"></div>
                </div>
                <div class="shape-slot" id="slot-barbell-two">
                    <div class="game-shape shape-barbell-two" data-shape="barbell-two" id="shape-barbell-two"></div>
                </div>
                <div class="shape-slot" id="slot-diamond-barbell">
                    <div class="game-shape shape-diamond-barbell" data-shape="diamond-barbell" id="shape-diamond-barbell"></div>
                </div>
            </div>

            <!-- Game Canvas Area -->
            <div class="game-canvas-container">
                <canvas id="gameCanvas"></canvas>
            </div>

            <!-- Event Notification System -->
            <div class="event-notification" id="eventNotification"></div>

            <!-- Debug Info -->
            <div class="debug-info" id="debugInfo">
                Shapes: 0/9 | Events: 0 | Collisions: 0 | FPS: 60
            </div>

            <!-- Rotation Indicator -->
            <div class="rotation-indicator" id="rotationIndicator">
                🔄 R/E or ←/→ to rotate
            </div>
    </div>

    <!-- Phase 2: Design Mode Sidebar -->
    <div class="design-sidebar" id="designSidebar">
        <div class="sidebar-header">
            <h2>🔧 Level Editor</h2>
            <p>Configure level settings and dock layout</p>
        </div>

        <!-- Level Configuration -->
        <div class="sidebar-section">
            <div class="sidebar-title">📋 Level Configuration</div>
            
            <div class="config-group">
                <label class="config-label">World-Level</label>
                <input type="text" class="config-input" id="levelNumber" value="1-1" placeholder="1-1">
            </div>

            <div class="config-group">
                <label class="config-label">Timer Mode</label>
                <select class="config-select" id="timerMode" onchange="updateTimerModeConfig()">
                    <option value="none">No Timer</option>
                    <option value="elapsed" selected>Count-Up Timer</option>
                    <option value="countdown">Count-Down Timer</option>
                </select>
            </div>
            
            <div class="config-group">
                <label class="config-label">Starting Timer Value</label>
                <input type="number" class="config-input" id="timerStart" value="60" min="0" max="3600" placeholder="Seconds">
            </div>
            
            <div class="config-group">
                <label class="config-label">End-Level Countdown</label>
                <input type="number" class="config-input" id="endLevelDuration" value="5" min="3" max="15" placeholder="Seconds">
            </div>
        </div>

        <!-- v9: Theme Selection -->
        <div class="sidebar-section">
            <div class="sidebar-title">🎨 Theme Selection</div>
            
            <div class="config-group">
                <label class="config-label">Visual Theme</label>
                <select class="config-select" id="themeSelector" onchange="changeTheme()">
                    <option value="classic" selected>Classic Puzzle</option>
                    <option value="underwater">Ocean Adventure</option>
                    <option value="space">Cosmic Voyage</option>
                    <option value="forest">Enchanted Forest</option>
                </select>
            </div>

            <div class="config-group">
                <label class="config-label">Canvas Enhancements</label>
                <div class="checkbox-group">
                    <label class="checkbox-label">
                        <input type="checkbox" id="enableCanvas" checked onchange="toggleCanvasEnhancements()">
                        Enable Advanced Graphics
                    </label>
                    <label class="checkbox-label">
                        <input type="checkbox" id="enableParticles" checked onchange="toggleParticleEffects()">
                        Particle Effects
                    </label>
                    <label class="checkbox-label">
                        <input type="checkbox" id="enableAnimations" checked onchange="toggleAnimations()">
                        Shape Animations
                    </label>
                </div>
            </div>

            <div class="config-group">
                <label class="config-label">Mobile Touch Offset</label>
                <div class="checkbox-group">
                    <label class="checkbox-label">
                        <input type="checkbox" id="enableTouchOffset" checked onchange="toggleTouchOffset()">
                        Enable Touch Offset
                    </label>
                </div>
                <div class="config-sub-group">
                    <label class="config-label">X Offset (Horizontal)</label>
                    <input type="range" id="touchOffsetX" min="-100" max="100" value="0" 
                           onchange="updateTouchOffset()" oninput="updateTouchOffsetDisplay()">
                    <span class="range-value" id="touchOffsetXValue">0px</span>
                </div>
                <div class="config-sub-group">
                    <label class="config-label">Y Offset (Vertical)</label>
                    <input type="range" id="touchOffsetY" min="-150" max="50" value="-80" 
                           onchange="updateTouchOffset()" oninput="updateTouchOffsetDisplay()">
                    <span class="range-value" id="touchOffsetYValue">-80px</span>
                </div>
            </div>
        </div>

        <!-- Dock Configuration -->
        <div class="sidebar-section">
            <div class="sidebar-title">🔧 Dock Configuration</div>
            
            <div class="config-group">
                <label class="config-label">Number of Dock Slots</label>
                <input type="number" class="config-input" id="dockSlotCount" value="9" min="3" max="12" onchange="generateDockSlots()">
            </div>
            
            <div class="config-group">
                <label class="config-label">Barbell Orientation in Dock</label>
                <select class="config-select" id="barbellOrientation" onchange="updateBarbellOrientation()">
                    <option value="vertical" selected>Vertical (90°)</option>
                    <option value="horizontal">Horizontal (0°)</option>
                </select>
            </div>
            
            <div class="config-group">
                <label class="config-label">Shape Assignment</label>
                <div id="dockSlotsContainer">
                    <!-- Dynamic dock slots will be generated here -->
                </div>
            </div>
        </div>

        <!-- Actions -->
        <div class="sidebar-section">
            <div class="sidebar-title">⚡ Actions</div>
            
            <button class="config-btn" id="applyChangesBtn" onclick="applyLevelChanges()">
                Apply Level Changes
            </button>
            
            <button class="config-btn" onclick="resetLevel()" style="background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);">
                Reset Level
            </button>
            
            <button class="config-btn" onclick="syncDockToDesign()" style="background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);">
                Sync Current Dock
            </button>
        </div>
    </div>



    <!-- Matter.js Physics Engine -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    
    <script>
        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ CANVAS ENHANCEMENT CONFIGURATION v9
          ║ Feature flags and settings for texture, theme, and visual enhancement system
          ╚═══════════════════════════════════════════════════════════════════════════*/
        const CANVAS_CONFIG = {
            // Feature flags
            enabled: true,                    // Master switch for canvas enhancements
            useTextures: true,               // Enable texture system for shapes
            useThemes: true,                 // Enable theme switching
            useParticles: true,              // Enable particle effects
            useAnimations: true,             // Enable shape animations
            useBackgroundTextures: true,     // Enable background textures
            usePlatformTextures: true,       // Enable platform textures
            
            // Performance settings
            maxParticles: 50,                // Maximum particles on screen
            textureQuality: 'high',          // 'low', 'medium', 'high'
            enableLOD: true,                 // Level of detail for small shapes
            cacheTextures: true,             // Cache rendered textures
            
            // Default theme and fallback behavior
            defaultTheme: 'classic',
            fallbackToSolid: true,           // Use solid colors if textures fail
            showLoadingProgress: true,       // Show loading indicators
            
            // Debug options
            debugMode: false,                // Show texture loading info
            showBounds: false,               // Show texture boundaries
            logAssetLoading: true            // Console logging for asset loading
        };

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ THEME DEFINITIONS - VISUAL THEMES FOR THE GAME
          ║ Each theme defines complete visual styling for all game elements
          ╚═══════════════════════════════════════════════════════════════════════════*/
        const THEME_DEFINITIONS = {
            classic: {
                name: "Classic Puzzle",
                description: "Clean, geometric shapes with simple colors",
                background: {
                    type: "gradient",
                    colors: ["#87CEEB", "#4ECDC4", "#90EE90"],
                    texture: null,
                    // Image background support
                    image: {
                        url: null,          // "path/to/background.jpg"
                        repeat: "no-repeat", // "repeat", "repeat-x", "repeat-y", "no-repeat"
                        position: "center",  // "center", "top", "bottom", "left", "right"
                        size: "cover"        // "cover", "contain", "auto", "100% 100%"
                    }
                },
                platform: {
                    texture: null,  // Will use solid color initially
                    color: "#8B4513",
                    material: "wood",
                    pattern: "solid",
                    // Platform image texture support
                    image: {
                        url: null,          // "path/to/platform-texture.jpg"
                        repeat: "repeat",    // How to repeat the texture
                        blend: "multiply",   // How to blend with base color
                        opacity: 0.8        // Texture opacity (0-1)
                    }
                },
                shapes: {
                    useTextures: false,      // Start with solid colors
                    baseTexturePath: null,
                    specialEffects: ["shadow"],
                    animations: ["bounce"],
                    // Shape texture mapping
                    textures: {
                        square: { url: null, repeat: "repeat", blend: "multiply", opacity: 0.7 },
                        circle: { url: null, repeat: "repeat", blend: "multiply", opacity: 0.7 },
                        triangle: { url: null, repeat: "repeat", blend: "multiply", opacity: 0.7 },
                        cross: { url: null, repeat: "repeat", blend: "multiply", opacity: 0.7 },
                        cross2: { url: null, repeat: "repeat", blend: "multiply", opacity: 0.7 },
                        l: { url: null, repeat: "repeat", blend: "multiply", opacity: 0.7 },
                        "barbell-one": { url: null, repeat: "repeat", blend: "multiply", opacity: 0.7 },
                        "barbell-two": { url: null, repeat: "repeat", blend: "multiply", opacity: 0.7 },
                        "diamond-barbell": { url: null, repeat: "repeat", blend: "multiply", opacity: 0.7 }
                    }
                },
                particles: {
                    style: "geometric",
                    colors: ["#FFD700", "#FF6B6B", "#4ECDC4"]
                }
            },
            
            underwater: {
                name: "Ocean Adventure", 
                description: "Dive into an underwater world with sea creatures",
                background: {
                    type: "gradient",
                    colors: ["#006994", "#0077be", "#4da6ff"],
                    texture: "coral_bubbles",
                    // Ocean background image support
                    image: {
                        url: null,          // "textures/ocean-background.jpg"
                        repeat: "no-repeat",
                        position: "center", 
                        size: "cover"
                    }
                },
                platform: {
                    texture: "coral_bubbles",
                    color: "#2E8B57",
                    material: "coral",
                    pattern: "bubbles",
                    // Coral platform texture
                    image: {
                        url: null,          // "textures/coral-platform.jpg"
                        repeat: "repeat-x",
                        blend: "overlay",
                        opacity: 0.6
                    }
                },
                shapes: {
                    useTextures: true,
                    baseTexturePath: "textures/ocean/",
                    specialEffects: ["bubble", "flow"],
                    animations: ["float", "wave"],
                    textures: {
                        square: { url: null, repeat: "repeat", blend: "overlay", opacity: 0.8 },
                        circle: { url: null, repeat: "repeat", blend: "overlay", opacity: 0.8 },
                        triangle: { url: null, repeat: "repeat", blend: "overlay", opacity: 0.8 },
                        cross: { url: null, repeat: "repeat", blend: "overlay", opacity: 0.8 },
                        cross2: { url: null, repeat: "repeat", blend: "overlay", opacity: 0.8 },
                        l: { url: null, repeat: "repeat", blend: "overlay", opacity: 0.8 },
                        "barbell-one": { url: null, repeat: "repeat", blend: "overlay", opacity: 0.8 },
                        "barbell-two": { url: null, repeat: "repeat", blend: "overlay", opacity: 0.8 },
                        "diamond-barbell": { url: null, repeat: "repeat", blend: "overlay", opacity: 0.8 }
                    }
                },
                particles: {
                    style: "bubbles",
                    colors: ["#00CED1", "#40E0D0", "#48CAE4"]
                }
            },
            
            space: {
                name: "Cosmic Voyage",
                description: "Journey through space with planets and stars", 
                background: {
                    type: "gradient",
                    colors: ["#0B1426", "#1a237e", "#3949ab"],
                    texture: null,
                    // Space background image support
                    image: {
                        url: null,          // "textures/space-background.jpg"
                        repeat: "no-repeat",
                        position: "center",
                        size: "cover"
                    }
                },
                platform: {
                    texture: null,
                    color: "#708090",
                    material: "metal",
                    pattern: "tech",
                    // Metal platform texture
                    image: {
                        url: null,          // "textures/metal-platform.jpg"
                        repeat: "repeat",
                        blend: "hard-light",
                        opacity: 0.9
                    }
                },
                shapes: {
                    useTextures: true,
                    baseTexturePath: "textures/space/",
                    specialEffects: ["starlight", "cosmic"],
                    animations: ["rotate", "pulse"],
                    textures: {
                        square: { url: null, repeat: "repeat", blend: "screen", opacity: 0.6 },
                        circle: { url: null, repeat: "repeat", blend: "screen", opacity: 0.6 },
                        triangle: { url: null, repeat: "repeat", blend: "screen", opacity: 0.6 },
                        cross: { url: null, repeat: "repeat", blend: "screen", opacity: 0.6 },
                        cross2: { url: null, repeat: "repeat", blend: "screen", opacity: 0.6 },
                        l: { url: null, repeat: "repeat", blend: "screen", opacity: 0.6 },
                        "barbell-one": { url: null, repeat: "repeat", blend: "screen", opacity: 0.6 },
                        "barbell-two": { url: null, repeat: "repeat", blend: "screen", opacity: 0.6 },
                        "diamond-barbell": { url: null, repeat: "repeat", blend: "screen", opacity: 0.6 }
                    }
                },
                particles: {
                    style: "stardust", 
                    colors: ["#FFD700", "#FF1493", "#00BFFF"]
                }
            },
            
            forest: {
                name: "Enchanted Forest",
                description: "Magical woodland with natural elements",
                background: {
                    type: "gradient",
                    colors: ["#2E7D32", "#4CAF50", "#8BC34A"],
                    texture: null,
                    // Forest background image support
                    image: {
                        url: null,          // "textures/forest-background.jpg"
                        repeat: "no-repeat",
                        position: "center",
                        size: "cover"
                    }
                },
                platform: {
                    texture: null,
                    color: "#8B4513", 
                    material: "wood",
                    pattern: "natural",
                    // Wood platform texture
                    image: {
                        url: null,          // "textures/wood-platform.jpg"
                        repeat: "repeat",
                        blend: "multiply",
                        opacity: 0.7
                    }
                },
                shapes: {
                    useTextures: true,
                    baseTexturePath: "textures/forest/",
                    specialEffects: ["leaf", "sparkle", "magic"],
                    animations: ["sway", "glow"],
                    textures: {
                        square: { url: null, repeat: "repeat", blend: "multiply", opacity: 0.8 },
                        circle: { url: null, repeat: "repeat", blend: "multiply", opacity: 0.8 },
                        triangle: { url: null, repeat: "repeat", blend: "multiply", opacity: 0.8 },
                        cross: { url: null, repeat: "repeat", blend: "multiply", opacity: 0.8 },
                        cross2: { url: null, repeat: "repeat", blend: "multiply", opacity: 0.8 },
                        l: { url: null, repeat: "repeat", blend: "multiply", opacity: 0.8 },
                        "barbell-one": { url: null, repeat: "repeat", blend: "multiply", opacity: 0.8 },
                        "barbell-two": { url: null, repeat: "repeat", blend: "multiply", opacity: 0.8 },
                        "diamond-barbell": { url: null, repeat: "repeat", blend: "multiply", opacity: 0.8 }
                    }
                },
                particles: {
                    style: "nature",
                    colors: ["#228B22", "#DAA520", "#FF6347"]
                }
            }
        };

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ UNIFIED SHAPE CONFIGURATION - PHYSICS-FIRST APPROACH
          ║ Single source of truth for ALL shape appearances and properties
          ║ Eliminates dual CSS/Canvas systems in favor of physics-based rendering
          ╚═══════════════════════════════════════════════════════════════════════════*/
        const SHAPE_CONFIG = {
            square: {
                // Visual properties
                color: '#F39C12',
                stroke: '#E67E22',
                strokeWidth: 2,

                // Physical properties  
                width: 35,
                height: 35,
                density: 0.5,
                friction: 0.7,
                restitution: 0.2,

                // Rendering properties
                type: 'rectangle',
                borderRadius: 3
            },

            triangle: {
                color: '#9B59B6',
                stroke: '#8E44AD', 
                strokeWidth: 2,

                // Triangle vertices (relative to center)
                vertices: [
                    { x: 0, y: -15 },      // Top point
                    { x: -17.5, y: 15 },   // Bottom left
                    { x: 17.5, y: 15 }     // Bottom right
                ],
                density: 0.5,
                friction: 0.7,
                restitution: 0.2,

                type: 'polygon'
            },

            circle: {
                color: '#1ABC9C',
                stroke: '#16A085',
                strokeWidth: 2,

                radius: 17.5,
                density: 0.5,
                friction: 0.7,
                restitution: 0.2,

                type: 'circle'
            },

            cross: {
                color: '#E74C3C',         // Changed from green to red for better contrast
                stroke: '#C0392B',
                strokeWidth: 2,

                // Cross consists of two overlapping rectangles
                parts: [
                    {
                        type: 'rectangle',
                        width: 15,
                        height: 35,
                        offsetX: 0,
                        offsetY: 0
                    },
                    {
                        type: 'rectangle', 
                        width: 35,
                        height: 15,
                        offsetX: 0,
                        offsetY: 0
                    }
                ],
                density: 0.5,
                friction: 0.7,
                restitution: 0.2,

                type: 'compound'
            },

            cross2: {
                color: '#3498DB',         // Changed from pink to blue for better contrast
                stroke: '#2980B9',
                strokeWidth: 2,

                parts: [
                    {
                        type: 'rectangle',
                        width: 15,
                        height: 35,
                        offsetX: 0,
                        offsetY: 0
                    },
                    {
                        type: 'rectangle',
                        width: 35, 
                        height: 15,
                        offsetX: 0,
                        offsetY: 0
                    }
                ],
                density: 0.5,
                friction: 0.7,
                restitution: 0.2,

                type: 'compound'
            },

            l: {
                color: '#8E44AD',         // Changed from orange to purple for variety
                stroke: '#732D91',
                strokeWidth: 2,

                // L-shape consists of two rectangles
                parts: [
                    {
                        type: 'rectangle',
                        width: 15,
                        height: 35,
                        offsetX: -7.5,      // Left side
                        offsetY: 0
                    },
                    {
                        type: 'rectangle',
                        width: 15,
                        height: 15, 
                        offsetX: 7.5,       // Right extension
                        offsetY: 10         // Bottom alignment
                    }
                ],
                density: 0.5,
                friction: 0.7,
                restitution: 0.2,

                type: 'compound'
            },

            'barbell-one': {
                color: '#16A085',
                stroke: '#138D75',
                strokeWidth: 2,

                parts: [
                    {
                        type: 'rectangle',
                        width: 31,
                        height: 5,
                        offsetX: -12,
                        offsetY: 0,
                        color: '#E74C3C',   // Bar color
                        stroke: '#C0392B'
                    },
                    {
                        type: 'circle',
                        radius: 8,
                        offsetX: 12,
                        offsetY: 0,
                        color: '#3498DB',   // Weight color
                        stroke: '#2980B9'
                    }
                ],
                density: 0.5,
                friction: 0.7,
                restitution: 0.2,

                type: 'compound'
            },

            'barbell-two': {
                color: '#D35400',
                stroke: '#BA4A00',
                strokeWidth: 2,

                parts: [
                    {
                        type: 'rectangle',
                        width: 26,
                        height: 5,
                        offsetX: 0,
                        offsetY: 0,
                        color: '#E74C3C',
                        stroke: '#C0392B'
                    },
                    {
                        type: 'circle',
                        radius: 9,
                        offsetX: -17,
                        offsetY: 0,
                        color: '#3498DB',
                        stroke: '#2980B9'
                    },
                    {
                        type: 'circle',
                        radius: 9,
                        offsetX: 17,
                        offsetY: 0,
                        color: '#3498DB',
                        stroke: '#2980B9'
                    }
                ],
                density: 0.5,
                friction: 0.7,
                restitution: 0.2,

                type: 'compound'
            },

            'diamond-barbell': {
                color: '#C0392B',
                stroke: '#A93226',
                strokeWidth: 2,

                parts: [
                    {
                        type: 'rectangle',
                        width: 26,
                        height: 5,
                        offsetX: -13,
                        offsetY: 0,
                        color: '#E74C3C',
                        stroke: '#C0392B'
                    },
                    {
                        type: 'diamond',
                        width: 12,
                        height: 12,
                        offsetX: 13,
                        offsetY: 0,
                        color: '#F39C12',
                        stroke: '#E67E22'
                    }
                ],
                density: 0.5,
                friction: 0.7,
                restitution: 0.2,

                type: 'compound'
            }
        };

        // Utility functions for shape configuration
        function getShapeConfig(shapeType) {
            return SHAPE_CONFIG[shapeType] || null;
        }

        function getAllShapeTypes() {
            return Object.keys(SHAPE_CONFIG);
        }

        function validateShapeConfig() {
            // Validation logic can be added here
            return true;
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ ASSET MANAGER - HANDLES TEXTURE LOADING AND THEME ASSETS
          ║ Provides centralized asset management with fallbacks and caching
          ╚═══════════════════════════════════════════════════════════════════════════*/
        class AssetManager {
            constructor() {
                this.themes = {};
                this.currentTheme = CANVAS_CONFIG.defaultTheme;
                this.loadingProgress = 0;
                this.isLoaded = false;
                this.textureCache = new Map();
                this.loadingCallbacks = [];
                this.imageCache = new Map(); // Cache for loaded images
                this.loadingPromises = new Map(); // Track loading promises
            }

            async loadTheme(themeName) {
                if (!CANVAS_CONFIG.enabled || !CANVAS_CONFIG.useThemes) {
                    console.log('📦 Asset Manager: Canvas enhancements disabled');
                    return;
                }

                console.log(`📦 Loading theme: ${themeName}`);
                
                try {
                    const themeConfig = THEME_DEFINITIONS[themeName];
                    if (!themeConfig) {
                        console.error(`❌ Theme not found: ${themeName}`);
                        return;
                    }

                    // Initialize theme structure
                    this.themes[themeName] = {
                        config: themeConfig,
                        assets: {
                            backgroundImage: null,
                            platformImage: null,
                            shapeTextures: {}
                        },
                        loaded: false
                    };

                    // Load all images for this theme
                    await this.loadThemeImages(themeName, themeConfig);
                    
                    this.themes[themeName].loaded = true;
                    this.loadingProgress = 100;
                    this.isLoaded = true;
                    
                    console.log(`✅ Theme loaded: ${themeName}`);
                    this.notifyLoadingComplete(themeName);
                    
                } catch (error) {
                    console.error(`❌ Failed to load theme ${themeName}:`, error);
                    this.loadingProgress = 0;
                }
            }

            async loadThemeImages(themeName, themeConfig) {
                const loadPromises = [];
                const theme = this.themes[themeName];

                // Load background image
                if (themeConfig.background.image && themeConfig.background.image.url) {
                    const bgPromise = this.loadImage(themeConfig.background.image.url)
                        .then(img => {
                            theme.assets.backgroundImage = img;
                            console.log(`🖼️ Background image loaded for ${themeName}`);
                        })
                        .catch(err => {
                            console.warn(`⚠️ Background image failed for ${themeName}:`, err.message);
                        });
                    loadPromises.push(bgPromise);
                }

                // Load platform image
                if (themeConfig.platform.image && themeConfig.platform.image.url) {
                    const platformPromise = this.loadImage(themeConfig.platform.image.url)
                        .then(img => {
                            theme.assets.platformImage = img;
                            console.log(`🏗️ Platform image loaded for ${themeName}`);
                        })
                        .catch(err => {
                            console.warn(`⚠️ Platform image failed for ${themeName}:`, err.message);
                        });
                    loadPromises.push(platformPromise);
                }

                // Load shape textures
                if (themeConfig.shapes.textures) {
                    Object.keys(themeConfig.shapes.textures).forEach(shapeType => {
                        const textureConfig = themeConfig.shapes.textures[shapeType];
                        if (textureConfig.url) {
                            const shapePromise = this.loadImage(textureConfig.url)
                                .then(img => {
                                    theme.assets.shapeTextures[shapeType] = img;
                                    console.log(`🔶 Shape texture loaded for ${shapeType} in ${themeName}`);
                                })
                                .catch(err => {
                                    console.warn(`⚠️ Shape texture failed for ${shapeType} in ${themeName}:`, err.message);
                                });
                            loadPromises.push(shapePromise);
                        }
                    });
                }

                // Wait for all images to load (or fail)
                await Promise.allSettled(loadPromises);
                
                const successCount = loadPromises.length;
                console.log(`📦 Theme ${themeName}: Attempted to load ${successCount} images`);
            }

            async loadImage(url) {
                // Check cache first
                if (this.imageCache.has(url)) {
                    return this.imageCache.get(url);
                }

                // Check if already loading
                if (this.loadingPromises.has(url)) {
                    return this.loadingPromises.get(url);
                }

                // Create loading promise
                const loadPromise = new Promise((resolve, reject) => {
                    const img = new Image();
                    img.crossOrigin = 'anonymous'; // Enable CORS for external images
                    
                    img.onload = () => {
                        this.imageCache.set(url, img);
                        this.loadingPromises.delete(url);
                        resolve(img);
                    };
                    
                    img.onerror = () => {
                        this.loadingPromises.delete(url);
                        reject(new Error(`Failed to load image: ${url}`));
                    };
                    
                    img.src = url;
                    
                    // Set timeout for image loading
                    setTimeout(() => {
                        if (!img.complete) {
                            this.loadingPromises.delete(url);
                            reject(new Error(`Image load timeout: ${url}`));
                        }
                    }, 10000); // 10 second timeout
                });

                this.loadingPromises.set(url, loadPromise);
                return loadPromise;
            }

            // Get loaded image assets
            getBackgroundImage(themeName = null) {
                const theme = themeName ? this.getTheme(themeName) : this.getCurrentTheme();
                return theme?.assets?.backgroundImage || null;
            }

            getPlatformImage(themeName = null) {
                const theme = themeName ? this.getTheme(themeName) : this.getCurrentTheme();
                return theme?.assets?.platformImage || null;
            }

            getShapeTexture(shapeType, themeName = null) {
                const theme = themeName ? this.getTheme(themeName) : this.getCurrentTheme();
                return theme?.assets?.shapeTextures?.[shapeType] || null;
            }

            // Clear cache (useful for development)
            clearImageCache() {
                this.imageCache.clear();
                this.loadingPromises.clear();
                console.log('🧹 Image cache cleared');
            }

            getTheme(themeName) {
                return this.themes[themeName] || null;
            }

            getCurrentTheme() {
                return this.getTheme(this.currentTheme);
            }

            getBackgroundStyle(themeName = null) {
                const theme = themeName ? this.getTheme(themeName) : this.getCurrentTheme();
                if (!theme) return null;
                
                const bgConfig = theme.config.background;
                const bgImage = this.getBackgroundImage(themeName);
                
                return {
                    type: bgConfig.type,
                    colors: bgConfig.colors,
                    image: bgImage,
                    imageConfig: bgConfig.image || null
                };
            }

            getPlatformStyle(themeName = null) {
                const theme = themeName ? this.getTheme(themeName) : this.getCurrentTheme();
                if (!theme) return null;
                
                const platformConfig = theme.config.platform;
                const platformImage = this.getPlatformImage(themeName);
                
                return {
                    ...platformConfig,
                    image: platformImage,
                    imageConfig: platformConfig.image || null
                };
            }

            getShapeStyle(shapeType, themeName = null) {
                const theme = themeName ? this.getTheme(themeName) : this.getCurrentTheme();
                if (!theme) return null;
                
                const shapeConfig = theme.config.shapes;
                const shapeTexture = this.getShapeTexture(shapeType, themeName);
                
                if (shapeConfig.textures && shapeConfig.textures[shapeType]) {
                    return {
                        useTextures: shapeConfig.useTextures,
                        texture: shapeTexture,
                        textureConfig: shapeConfig.textures[shapeType]
                    };
                }
                
                return {
                    useTextures: false,
                    texture: null,
                    textureConfig: null
                };
            }

            getParticleStyle(themeName = null) {
                const theme = themeName ? this.getTheme(themeName) : this.getCurrentTheme();
                if (!theme) return null;
                
                return theme.config.particles;
            }

            notifyLoadingComplete(themeName) {
                this.loadingCallbacks.forEach(callback => {
                    try {
                        callback(themeName);
                    } catch (error) {
                        console.error('❌ Error in loading callback:', error);
                    }
                });
            }

            onThemeLoaded(callback) {
                this.loadingCallbacks.push(callback);
            }
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ THEME MANAGER - HANDLES THEME SWITCHING AND VISUAL UPDATES
          ║ Coordinates theme changes across all game systems
          ╚═══════════════════════════════════════════════════════════════════════════*/
        class ThemeManager {
            constructor(assetManager, gameManager) {
                this.assetManager = assetManager;
                this.gameManager = gameManager;
                this.currentTheme = CANVAS_CONFIG.defaultTheme;
                this.isTransitioning = false;
                this.transitionCallbacks = [];
            }

            async switchTheme(themeName, animated = true) {
                if (!CANVAS_CONFIG.enabled || !CANVAS_CONFIG.useThemes) {
                    console.log('🎨 Theme Manager: Theme switching disabled');
                    return;
                }

                if (this.isTransitioning || !THEME_DEFINITIONS[themeName]) {
                    console.log(`🎨 Cannot switch to theme: ${themeName}`);
                    return;
                }

                console.log(`🎨 Switching theme from ${this.currentTheme} to ${themeName}`);
                this.isTransitioning = true;

                try {
                    // Load the new theme
                    await this.assetManager.loadTheme(themeName);
                    
                    // Update visual elements
                    this.updateBackgroundStyle(themeName);
                    this.updatePlatformStyle(themeName);
                    
                    // Update current theme
                    this.currentTheme = themeName;
                    this.assetManager.currentTheme = themeName;
                    
                    // Notify listeners
                    this.notifyThemeChanged(themeName);
                    
                    console.log(`✅ Theme switched to: ${themeName}`);
                    
                } catch (error) {
                    console.error(`❌ Failed to switch theme to ${themeName}:`, error);
                } finally {
                    this.isTransitioning = false;
                }
            }

            updateBackgroundStyle(themeName) {
                const bgStyle = this.assetManager.getBackgroundStyle(themeName);
                if (!bgStyle || !this.gameManager?.physicsManager) return;

                // Update the physics manager's background rendering
                if (bgStyle.type === 'gradient') {
                    this.gameManager.physicsManager.backgroundGradient = bgStyle.colors;
                    console.log(`🎨 Updated background gradient for ${themeName}:`, bgStyle.colors);
                }
            }

            updatePlatformStyle(themeName) {
                const platformStyle = this.assetManager.getPlatformStyle(themeName);
                if (!platformStyle || !this.gameManager?.physicsManager) return;

                // Update platform color
                this.gameManager.physicsManager.platformColor = platformStyle.color;
                console.log(`🎨 Updated platform color for ${themeName}:`, platformStyle.color);
            }

            getAvailableThemes() {
                return Object.keys(THEME_DEFINITIONS);
            }

            getCurrentTheme() {
                return this.currentTheme;
            }

            onThemeChanged(callback) {
                this.transitionCallbacks.push(callback);
            }

            notifyThemeChanged(themeName) {
                this.transitionCallbacks.forEach(callback => {
                    try {
                        callback(themeName);
                    } catch (error) {
                        console.error('❌ Error in theme change callback:', error);
                    }
                });
            }
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ PARTICLE SYSTEM - THEME-BASED VISUAL EFFECTS
          ║ Creates and manages particle effects based on current theme
          ╚═══════════════════════════════════════════════════════════════════════════*/
        class ParticleSystem {
            constructor(canvas, assetManager) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.assetManager = assetManager;
                this.particles = [];
                this.maxParticles = CANVAS_CONFIG.maxParticles;
                this.ambientParticleTimer = 0;
                this.ambientParticleInterval = 1000; // Spawn ambient particle every 1 second
            }

            createThemeParticles(type, x, y, count = 5) {
                if (!CANVAS_CONFIG.enabled || !CANVAS_CONFIG.useParticles) return;

                const particleStyle = this.assetManager.getParticleStyle();
                if (!particleStyle) return;

                for (let i = 0; i < Math.min(count, this.maxParticles - this.particles.length); i++) {
                    this.particles.push(this.createParticle(particleStyle, x, y, type));
                }
            }

            createParticle(style, x, y, type) {
                const colors = style.colors;
                const color = colors[Math.floor(Math.random() * colors.length)];
                
                return {
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4 - 2,
                    life: 1.0,
                    decay: 0.02 + Math.random() * 0.02,
                    size: 2 + Math.random() * 3,
                    color: color,
                    style: style.style
                };
            }

            createAmbientParticle() {
                if (!CANVAS_CONFIG.enabled || !CANVAS_CONFIG.useParticles) return;
                if (this.particles.length >= this.maxParticles) return;

                const particleStyle = this.assetManager.getParticleStyle();
                if (!particleStyle) return;

                // Create particles from random positions around the canvas edges
                const side = Math.floor(Math.random() * 4); // 0=top, 1=right, 2=bottom, 3=left
                let x, y, vx, vy;

                switch(side) {
                    case 0: // Top
                        x = Math.random() * this.canvas.width;
                        y = -10;
                        vx = (Math.random() - 0.5) * 2;
                        vy = Math.random() * 2 + 1;
                        break;
                    case 1: // Right  
                        x = this.canvas.width + 10;
                        y = Math.random() * this.canvas.height;
                        vx = -Math.random() * 2 - 1;
                        vy = (Math.random() - 0.5) * 2;
                        break;
                    case 2: // Bottom
                        x = Math.random() * this.canvas.width;
                        y = this.canvas.height + 10;
                        vx = (Math.random() - 0.5) * 2;
                        vy = -Math.random() * 2 - 1;
                        break;
                    case 3: // Left
                        x = -10;
                        y = Math.random() * this.canvas.height;
                        vx = Math.random() * 2 + 1;
                        vy = (Math.random() - 0.5) * 2;
                        break;
                }

                const colors = particleStyle.colors;
                const color = colors[Math.floor(Math.random() * colors.length)];
                
                this.particles.push({
                    x: x,
                    y: y,
                    vx: vx,
                    vy: vy,
                    life: 1.0,
                    decay: 0.01 + Math.random() * 0.01, // Slower decay for ambient particles
                    size: 1 + Math.random() * 2, // Smaller ambient particles
                    color: color,
                    style: particleStyle.style,
                    isAmbient: true
                });
            }

            update(deltaTime) {
                if (!CANVAS_CONFIG.useParticles) return;

                // Spawn ambient background particles periodically
                this.ambientParticleTimer += deltaTime;
                if (this.ambientParticleTimer >= this.ambientParticleInterval) {
                    this.createAmbientParticle();
                    this.ambientParticleTimer = 0;
                }

                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const particle = this.particles[i];
                    
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.vy += 0.1; // Gravity
                    particle.life -= particle.decay;
                    
                    if (particle.life <= 0) {
                        this.particles.splice(i, 1);
                    }
                }
            }

            render() {
                if (!CANVAS_CONFIG.useParticles) return;

                this.particles.forEach(particle => {
                    this.ctx.save();
                    this.ctx.globalAlpha = particle.life;
                    this.ctx.fillStyle = particle.color;
                    
                    if (particle.style === 'bubbles') {
                        this.ctx.strokeStyle = particle.color;
                        this.ctx.lineWidth = 1;
                        this.ctx.beginPath();
                        this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        this.ctx.stroke();
                    } else {
                        this.ctx.beginPath();
                        this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                    
                    this.ctx.restore();
                });
            }
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ PHYSICS-BASED SHAPE RENDERER
          ║ Renders shapes consistently using physics configuration
          ║ Used for both dock previews and physics simulation
          ╚═══════════════════════════════════════════════════════════════════════════*/
        class PhysicsShapeRenderer {
            renderShapeOnCanvas(ctx, shapeType, x, y, rotation = 0, scale = 1) {
                console.log(`🎨 renderShapeOnCanvas: ${shapeType} at (${x},${y})`);
                const config = getShapeConfig(shapeType);
                if (!config) {
                    console.error(`❌ No config found for renderShapeOnCanvas: ${shapeType}`);
                    return;
                }

                console.log(`📐 Config for ${shapeType}:`, config);

                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.scale(scale, scale);

                switch (config.type) {
                    case 'rectangle':
                        console.log(`📦 Drawing rectangle for ${shapeType}`);
                        this.drawRectangle(ctx, config);
                        break;
                    case 'circle':
                        console.log(`⭕ Drawing circle for ${shapeType}`);
                        this.drawCircle(ctx, config);
                        break;
                    case 'polygon':
                        console.log(`🔷 Drawing polygon for ${shapeType}`);
                        this.drawPolygon(ctx, config);
                        break;
                    case 'compound':
                        console.log(`🔗 Drawing compound shape for ${shapeType}`);
                        this.drawCompoundShape(ctx, config);
                        break;
                    default:
                        console.error(`❌ Unknown shape type: ${config.type} for ${shapeType}`);
                }

                ctx.restore();
                console.log(`✅ Rendered ${shapeType}`);
            }

            createDockPreview(shapeType, size = 90) {
                console.log(`🎨 createDockPreview called for: ${shapeType}, size: ${size}`);
                const config = getShapeConfig(shapeType);
                if (!config) {
                    console.error(`❌ No config found for shape: ${shapeType}`);
                    return null;
                }
                
                // Use larger canvas to accommodate full-size shape rendering
                const canvas = document.createElement('canvas');
                canvas.width = size;
                canvas.height = size;
                canvas.className = `shape-preview`;
                canvas.dataset.shape = shapeType;

                const ctx = canvas.getContext('2d');
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';

                // Use 2x scale for full-size display, matching 2x physics scale (30→60)
                const scale = 1.9;
                console.log(`📐 Shape ${shapeType}: using enlarged scale=${scale} for full-size display`);
                
                // Check barbell orientation setting for dock preview rotation
                let rotation = 0;
                if (shapeType && shapeType.includes('barbell')) {
                    const barbellOrientationSelect = document.getElementById('barbellOrientation');
                    if (barbellOrientationSelect && barbellOrientationSelect.value === 'vertical') {
                        rotation = Math.PI / 2; // 90 degrees for vertical orientation
                        console.log(`🔄 Applying vertical rotation (90°) to ${shapeType}`);
                    }
                }
                
                // Render the shape in the center of the preview canvas
                this.renderShapeOnCanvas(ctx, shapeType, size / 2, size / 2, rotation, scale);
                
                console.log(`✅ Canvas preview created for: ${shapeType} with scale ${scale}, rotation ${(rotation * 180 / Math.PI).toFixed(0)}°`);
                return canvas;
            }

            drawRectangle(ctx, config) {
                const { width, height, color, stroke, strokeWidth } = config;
                ctx.fillStyle = color;
                ctx.strokeStyle = stroke;
                ctx.lineWidth = strokeWidth;

                ctx.fillRect(-width / 2, -height / 2, width, height);
                ctx.strokeRect(-width / 2, -height / 2, width, height);
            }

            drawCircle(ctx, config) {
                const { radius, color, stroke, strokeWidth } = config;
                ctx.fillStyle = color;
                ctx.strokeStyle = stroke;
                ctx.lineWidth = strokeWidth;

                ctx.beginPath();
                ctx.arc(0, 0, radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
            }

            drawPolygon(ctx, config) {
                const { vertices, color, stroke, strokeWidth } = config;
                ctx.fillStyle = color;
                ctx.strokeStyle = stroke;
                ctx.lineWidth = strokeWidth;

                ctx.beginPath();
                ctx.moveTo(vertices[0].x, vertices[0].y);
                for (let i = 1; i < vertices.length; i++) {
                    ctx.lineTo(vertices[i].x, vertices[i].y);
                }
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            }

            drawCompoundShape(ctx, config) {
                for (const part of config.parts) {
                    ctx.save();
                    ctx.translate(part.offsetX || 0, part.offsetY || 0);

                    const partConfig = {
                        ...config,
                        ...part,
                        color: part.color || config.color,
                        stroke: part.stroke || config.stroke
                    };

                    switch (part.type) {
                        case 'rectangle':
                            this.drawRectangle(ctx, partConfig);
                            break;
                        case 'circle':
                            this.drawCircle(ctx, partConfig);
                            break;
                        case 'diamond':
                            this.drawDiamond(ctx, partConfig);
                            break;
                    }
                    ctx.restore();
                }
            }

            drawDiamond(ctx, config) {
                // For dock preview consistency, render diamond exactly as physics will:
                // as a rotated rectangle to match the planck.Box(..., Math.PI/4) creation
                const { width, height, color, stroke, strokeWidth } = config;
                ctx.fillStyle = color;
                ctx.strokeStyle = stroke;
                ctx.lineWidth = strokeWidth;

                ctx.save();
                // Apply the same rotation that's used in physics fixture creation
                ctx.rotate(Math.PI / 4);
                ctx.fillRect(-width / 2, -height / 2, width, height);
                ctx.strokeRect(-width / 2, -height / 2, width, height);
                ctx.restore();
            }
        }

        // Global shape renderer instance
        const shapeRenderer = new PhysicsShapeRenderer();

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ UNIFIED DOCK SYSTEM
          ║ Replaces CSS-based dock with canvas-rendered previews matching physics
          ║ Maintains existing functionality while implementing unified appearance
          ╚═══════════════════════════════════════════════════════════════════════════*/
        function rebuildGameDock() {
            console.log('🔧 rebuildGameDock() called');
            const dockingArea = document.getElementById('dockingArea');
            if (!dockingArea) {
                console.error('❌ dockingArea not found!');
                return;
            }

            // Get current dock shapes from level config or fallback to all shapes
            const dockShapes = window.currentLevelConfig ? window.currentLevelConfig.dockShapes : getAllShapeTypes();
            console.log('📦 Building dock with shapes:', dockShapes);
            console.log('📦 Current level config exists:', !!window.currentLevelConfig);
            console.log('📦 Shape renderer available:', !!shapeRenderer);
            
            // Clear and rebuild dock with canvas previews
            dockingArea.innerHTML = '';
            console.log('🧹 Cleared existing dock content');
            
            dockShapes.forEach((shapeType, index) => {
                console.log(`🏗️ Creating slot ${index + 1} for: ${shapeType}`);
                const slotDiv = document.createElement('div');
                slotDiv.className = 'shape-slot'; // Ensure no 'empty' class on fresh slots
                slotDiv.id = `slot-${shapeType}`;

                if (shapeType && shapeRenderer) {
                    // Create full-size canvas preview using unified renderer
                    const canvasPreview = shapeRenderer.createDockPreview(shapeType, 90);
                    if (canvasPreview) {
                        canvasPreview.id = `shape-${shapeType}`;
                        canvasPreview.dataset.shape = shapeType;
                        canvasPreview.className = 'game-shape shape-preview';
                        canvasPreview.style.visibility = 'visible'; // Ensure visibility is reset
                        slotDiv.appendChild(canvasPreview);
                        console.log(`✅ Created canvas preview for: ${shapeType}`);
                    } else {
                        console.error(`❌ Failed to create canvas preview for: ${shapeType}`);
                        // Create a temporary colored div fallback
                        const fallback = document.createElement('div');
                        fallback.className = 'game-shape shape-preview';
                        fallback.dataset.shape = shapeType;
                        fallback.id = `shape-${shapeType}`;
                        fallback.style.width = '50px';
                        fallback.style.height = '50px';
                        fallback.style.backgroundColor = getShapeConfig(shapeType)?.color || '#95A5A6';
                        fallback.style.border = '2px solid #7F8C8D';
                        fallback.style.borderRadius = '4px';
                        fallback.style.visibility = 'visible';
                        fallback.textContent = shapeType.charAt(0).toUpperCase();
                        slotDiv.appendChild(fallback);
                        console.log(`⚠️ Created fallback preview for: ${shapeType}`);
                    }
                } else {
                    console.warn(`⚠️ Empty slot or no renderer for: ${shapeType}`);
                    slotDiv.classList.add('empty');
                }
                
                dockingArea.appendChild(slotDiv);
                console.log(`📍 Added slot for ${shapeType} to dock`);
            });

            console.log(`✅ Game dock rebuilt with ${dockShapes.length} slots total`);
        }

        // Initialize unified dock system (called after level config is ready)
        function initializeUnifiedDockSystem() {
            console.log('� Initializing Unified Dock System...');
            rebuildGameDock();
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ ENHANCED PHYSICS MANAGER WITH EVENT SYSTEM
          ║ Phase 4.1: Implements collision detection, fall detection, and physics events
          ║ Integrates physics events with game state for advanced game mechanics.
          ╚═══════════════════════════════════════════════════════════════════════════*/
        class PhysicsManager {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                
                // Matter.js aliases for cleaner code
                this.Engine = Matter.Engine;
                this.World = Matter.World;
                this.Bodies = Matter.Bodies;
                this.Body = Matter.Body;
                this.Events = Matter.Events;
                
                // Event tracking
                this.eventCount = 0;
                this.collisionCount = 0;
                this.fallCount = 0;
                
                // Canvas Enhancement System v9
                this.assetManager = new AssetManager();
                this.particleSystem = new ParticleSystem(canvas, this.assetManager);
                
                // Theme-based rendering properties
                this.backgroundGradient = null;
                this.platformColor = '#8B4513';
                
                console.log('🎨 Canvas Enhancement System initialized');
                
                // Initialize with default theme
                this.initializeDefaultTheme();
                
                // Resize canvas to container
                this.resizeCanvas();
                
                // Create Matter.js world with physics engine
                this.engine = this.Engine.create();
                this.world = this.engine.world;
                
                // Set gravity (Matter.js uses different scale than Planck.js)
                this.engine.world.gravity.x = 0;
                this.engine.world.gravity.y = 1; // 1 pixel/frame² gravity
                
                // Track all dynamic bodies for rendering and cleanup
                this.dynamicBodies = [];
                
                // Camera shake system
                this.cameraShake = {
                    active: false,
                    intensity: 0,
                    duration: 0,
                    elapsed: 0,
                    frequencyX: 0.1,
                    frequencyY: 0.1,
                    offsetX: 0,
                    offsetY: 0
                };
                
                // Setup physics event listeners
                this.setupPhysicsEvents();
                
                // Create game platform and boundaries
                this.createPlatform();
                this.createBoundaries();
                
                // Start render loop
                this.startRenderLoop();
                
                console.log('🌍 Enhanced Physics Manager with Events initialized');
            }

            // Canvas Enhancement v9: Initialize default theme
            async initializeDefaultTheme() {
                try {
                    await this.assetManager.loadTheme(CANVAS_CONFIG.defaultTheme);
                    const bgStyle = this.assetManager.getBackgroundStyle();
                    if (bgStyle && bgStyle.type === 'gradient') {
                        this.backgroundGradient = bgStyle.colors;
                    }
                    const platformStyle = this.assetManager.getPlatformStyle();
                    if (platformStyle) {
                        this.platformColor = platformStyle.color;
                    }
                    console.log(`🎨 Default theme initialized: ${CANVAS_CONFIG.defaultTheme}`);
                } catch (error) {
                    console.error('❌ Failed to initialize default theme:', error);
                }
            }

            setupPhysicsEvents() {
                // Matter.js collision detection - when shapes start touching
                this.Events.on(this.engine, 'collisionStart', (event) => {
                    event.pairs.forEach(pair => {
                        this.handleBeginContact(pair);
                    });
                });
                
                // Matter.js collision end - when shapes stop touching  
                this.Events.on(this.engine, 'collisionEnd', (event) => {
                    event.pairs.forEach(pair => {
                        this.handleEndContact(pair);
                    });
                });
                
                console.log('🎯 Matter.js event listeners configured');
            }

            handleBeginContact(pair) {
                const bodyA = pair.bodyA;
                const bodyB = pair.bodyB;
                const userDataA = bodyA.userData || {};
                const userDataB = bodyB.userData || {};
                
                console.log(`🔍 RAW COLLISION: bodyA.userData =`, userDataA, `bodyB.userData =`, userDataB);
                
                this.collisionCount++;
                this.eventCount++;
                
                // Check for shape-platform collision
                if (this.isShapePlatformCollision(userDataA, userDataB)) {
                    console.log('🎯 PLATFORM COLLISION DETECTED!');
                    this.onShapeLandedOnPlatform(bodyA, bodyB);
                }
                
                // Check for shape-shape collision
                if (this.isShapeShapeCollision(userDataA, userDataB)) {
                    console.log('🔄 SHAPE-SHAPE COLLISION DETECTED!');
                    this.onShapeShapeCollision(bodyA, bodyB);
                }
                
                // Check for ground collision (fall detection)
                console.log('🧪 Testing ground collision...');
                if (this.isGroundCollision(userDataA, userDataB)) {
                    console.log('🔥 GROUND COLLISION DETECTED! Triggering shape fall...');
                    this.onShapeFellOffPlatform(bodyA, bodyB);
                } else {
                    console.log('❌ Ground collision test failed');
                }
                
                console.log(`📍 Collision detected: ${userDataA.type || 'unknown'} vs ${userDataB.type || 'unknown'}`);
            }

            handleEndContact(pair) {
                // Handle when objects stop touching
                const bodyA = pair.bodyA;
                const bodyB = pair.bodyB;
                
                // Could implement "unstable" detection here
                // console.log('📤 Contact ended');
            }

            isShapePlatformCollision(dataA, dataB) {
                const shapeTypes = ['shape', 'compound', 'rectangle', 'polygon', 'circle'];
                const isAShape = shapeTypes.includes(dataA.type);
                const isBShape = shapeTypes.includes(dataB.type);
                
                return (isAShape && dataB.type === 'platform') ||
                       (dataA.type === 'platform' && isBShape);
            }

            isShapeShapeCollision(dataA, dataB) {
                const shapeTypes = ['shape', 'compound', 'rectangle', 'polygon', 'circle'];
                const isAShape = shapeTypes.includes(dataA.type);
                const isBShape = shapeTypes.includes(dataB.type);
                
                return isAShape && isBShape;
            }

            isGroundCollision(dataA, dataB) {
                const shapeTypes = ['shape', 'compound', 'rectangle', 'polygon', 'circle'];
                const isAShape = shapeTypes.includes(dataA.type);
                const isBShape = shapeTypes.includes(dataB.type);
                
                const result = (isAShape && dataB.type === 'ground') ||
                              (dataA.type === 'ground' && isBShape);
                              
                if (result) {
                    console.log(`🎯 Ground collision detected: ${dataA.type} vs ${dataB.type} - isAShape: ${isAShape}, isBShape: ${isBShape}`);
                }
                
                return result;
            }

            onShapeLandedOnPlatform(bodyA, bodyB) {
                console.log('🎯 Shape landed on platform!');
                this.showEventNotification('Shape Landed!', 'collision');
                
                // Trigger game event
                if (window.gameManager) {
                    window.gameManager.onShapeLandedOnPlatform();
                }
            }

            onShapeShapeCollision(bodyA, bodyB) {
                console.log('🔄 Shape collision detected!');
                this.showEventNotification('Shape Contact!', 'balance');
                
                // Trigger game event
                if (window.gameManager) {
                    window.gameManager.onShapeCollision();
                }
            }

            onShapeFellOffPlatform(bodyA, bodyB) {
                console.log('💥 Shape fell off platform!');
                this.fallCount++;
                
                this.showEventNotification('Shape Fell!', 'fall');
                
                // Trigger game event
                if (window.gameManager) {
                    window.gameManager.onShapeFell();
                }
            }

            showEventNotification(message, type) {
                const notification = document.getElementById('eventNotification');
                notification.textContent = message;
                notification.className = `event-notification ${type} show`;
                
                setTimeout(() => {
                    notification.classList.remove('show');
                }, 2000);
            }

            resizeCanvas() {
                const container = this.canvas.parentElement;
                this.canvas.width = container.clientWidth;
                this.canvas.height = container.clientHeight;
                console.log(`📐 Canvas resized to: ${this.canvas.width}x${this.canvas.height}`);
            }

            createBoundaries() {
                // Create invisible ground boundary for fall detection
                const groundY = this.canvas.height + 150; // Extended to +150 (was +50) for longer fall distance
                const groundWidth = this.canvas.width;
                
                const ground = this.Bodies.rectangle(
                    this.canvas.width / 2, 
                    groundY, 
                    groundWidth, 
                    100, 
                    {
                        isStatic: true,
                        render: { visible: false }
                    }
                );
                
                // Set user data for collision detection
                ground.userData = {
                    type: 'ground',
                    name: 'fallDetectionBoundary'
                };
                
                this.World.add(this.world, ground);
                console.log('🚧 Matter.js boundaries created');
            }

            createPlatform() {
                // Restore original angled platform from v1 (-50 degrees)
                const platformX = this.canvas.width / 2 - 30;  // Pixel coordinates
                const platformY = this.canvas.height - 20;     // Moved down 100px (was -120, now -20)
                const platformWidth = 200;
                const platformHeight = 20;
                const platformAngle = -0.873; // -50 degrees
                
                // Create angled platform with Matter.js
                const platform = this.Bodies.rectangle(
                    platformX, 
                    platformY, 
                    platformWidth, 
                    platformHeight,
                    {
                        isStatic: true,
                        angle: platformAngle,
                        render: {
                            fillStyle: '#95A5A6',
                            strokeStyle: '#7F8C8D',
                            lineWidth: 2
                        },
                        friction: 0.9,
                        restitution: 0
                    }
                );
                
                // Set user data for collision detection
                platform.userData = {
                    type: 'platform',
                    visible: true,
                    color: '#95A5A6',
                    stroke: '#7F8C8D',
                    strokeWidth: 2,
                    width: platformWidth,
                    height: platformHeight
                };
                
                this.World.add(this.world, platform);
                console.log(`🏗️ Matter.js angled platform created: -50° at (${platformX}, ${platformY})`);
            }

            createCompoundShape(x, y, type, rotation = 0) {
                // Forward to unified createShape method for consistency
                return this.createShape(x, y, type, rotation);
            }

            createShape(x, y, type, rotation = 0) {
                const config = getShapeConfig(type);
                if (!config) {
                    console.error(`Unknown shape type: ${type}`);
                    return null;
                }

                // V9: Matter.js compound shape creation with perfect collision detection
                console.log(`🎯 Creating Matter.js shape: ${type} at (${x}, ${y})`);

                let body;

                // Handle compound shapes (shapes with parts) using SHAPE_CONFIG
                if (config.type === 'compound' && config.parts) {
                    body = this.createMatterCompoundShape(x, y, type, rotation, config);
                } else {
                    // Handle simple shapes with standard Matter.js bodies
                    body = this.createMatterSimpleShape(x, y, type, rotation, config);
                }

                if (body) {
                    // Set Matter.js physics properties from config
                    body.restitution = config.restitution || 0.1;      // Reduced bounce to prevent rotation changes
                    body.friction = config.friction || 0.9;       
                    body.frictionAir = 0.02;   // Reduced air resistance to maintain manual rotation
                    
                    // Stabilize rotation for a brief moment after drop
                    const originalAngularVelocity = body.angularVelocity;
                    body.angularVelocity = 0; // Stop any spinning from collision
                    
                    // After a short delay, allow normal physics
                    setTimeout(() => {
                        if (body && body.angularVelocity === 0) {
                            body.frictionAir = 0.05; // Restore normal air resistance
                        }
                    }, 100); // Brief stabilization period

                    // Set user data for collision detection and rendering
                    body.userData = {
                        type: 'shape',
                        shapeType: type,
                        ...config
                    };
                    
                    console.log(`🏷️ Shape userData set:`, body.userData);

                    this.World.add(this.world, body);
                    this.dynamicBodies.push(body);

                    console.log(`✅ Matter.js ${type} created successfully`);
                    return body;
                }

                console.error(`❌ Failed to create Matter.js shape: ${type}`);
                return null;
            }

            createMatterCompoundShape(x, y, type, rotation, config) {
                console.log(`🎯 Creating Matter.js compound shape: ${type} using SHAPE_CONFIG`);
                
                if (!config.parts || config.parts.length === 0) {
                    console.error(`❌ No parts defined for compound shape: ${type}`);
                    return null;
                }
                
                const bodyParts = [];
                
                // Create each part based on SHAPE_CONFIG specification
                config.parts.forEach((partConfig, index) => {
                    // Use relative positioning for compound body parts
                    const partX = x + (partConfig.offsetX || 0);
                    const partY = y + (partConfig.offsetY || 0);
                    let bodyPart = null;
                    
                    if (partConfig.type === 'rectangle') {
                        bodyPart = this.Bodies.rectangle(partX, partY, partConfig.width, partConfig.height, {
                            render: {
                                fillStyle: partConfig.color || config.color,
                                strokeStyle: partConfig.stroke || config.stroke,
                                lineWidth: config.strokeWidth || 2
                            }
                        });
                    } else if (partConfig.type === 'circle') {
                        bodyPart = this.Bodies.circle(partX, partY, partConfig.radius, {
                            render: {
                                fillStyle: partConfig.color || config.color,
                                strokeStyle: partConfig.stroke || config.stroke,
                                lineWidth: config.strokeWidth || 2
                            }
                        });
                    } else if (partConfig.type === 'diamond') {
                        // Create diamond as a rotated square
                        const size = partConfig.width || partConfig.height || 12;
                        bodyPart = this.Bodies.polygon(partX, partY, 4, size / Math.sqrt(2), {
                            angle: Math.PI / 4, // 45 degree rotation for diamond
                            render: {
                                fillStyle: partConfig.color || config.color,
                                strokeStyle: partConfig.stroke || config.stroke,
                                lineWidth: config.strokeWidth || 2
                            }
                        });
                    }
                    
                    if (bodyPart) {
                        bodyParts.push(bodyPart);
                        console.log(`✅ Created ${partConfig.type} part at offset (${partConfig.offsetX}, ${partConfig.offsetY})`);
                    }
                });
                
                if (bodyParts.length === 0) {
                    console.error(`❌ No body parts created for compound shape: ${type}`);
                    return null;
                }
                
                // Create compound body and then rotate it smoothly
                const compoundBody = this.Body.create({
                    parts: bodyParts
                });
                
                // Apply rotation after creation to prevent snapping
                if (rotation !== 0) {
                    this.Body.setAngle(compoundBody, rotation);
                }
                
                // CRITICAL: Set userData on compound body AND all parts
                const userData = {
                    type: 'compound',
                    shapeType: type,
                    ...config
                };
                
                compoundBody.userData = userData;
                
                // Also set userData on all parts so collision detection works
                bodyParts.forEach(part => {
                    part.userData = userData;
                });
                
                console.log(`🏷️ Compound shape userData set on main body and ${bodyParts.length} parts:`, userData);
                console.log(`✅ Matter.js compound shape ${type} created with ${bodyParts.length} parts, rotated ${(rotation * 180 / Math.PI).toFixed(1)}°`);
                return compoundBody;
            }

            createMatterSimpleShape(x, y, type, rotation, config) {
                console.log(`🎯 Creating Matter.js simple shape: ${type}`);
                
                let body = null;

                // Create shape based on type
                if (type === 'square') {
                    body = this.Bodies.rectangle(x, y, config.width || 50, config.height || 50, {
                        angle: rotation,
                        render: {
                            fillStyle: config.color || '#FFD700',
                            strokeStyle: config.stroke || '#FFA500',
                            lineWidth: config.strokeWidth || 2
                        }
                    });
                } else if (type === 'triangle') {
                    // Create triangle using polygon but fix the default orientation
                    // Matter.js Bodies.polygon(x, y, 3, radius) creates triangle with different default rotation
                    const sides = 3;
                    const radius = 20; // Match approximate size of our config vertices
                    
                    // Add Math.PI/2 (90 degrees) to align with our triangle config (point up)
                    const adjustedRotation = rotation + Math.PI/2;
                    
                    body = this.Bodies.polygon(x, y, sides, radius, {
                        angle: adjustedRotation,
                        render: {
                            fillStyle: config.color || '#9B59B6',
                            strokeStyle: config.stroke || '#8E44AD',
                            lineWidth: config.strokeWidth || 2
                        }
                    });
                    
                    console.log(`🔺 Triangle created with 90° adjustment, final rotation ${(adjustedRotation * 180 / Math.PI).toFixed(1)}°`);
                } else if (type === 'circle') {
                    body = this.Bodies.circle(x, y, config.radius || 25, {
                        render: {
                            fillStyle: config.color || '#1ABC9C',
                            strokeStyle: config.stroke || '#16A085',
                            lineWidth: config.strokeWidth || 2
                        }
                    });
                }

                if (body) {
                    // Set userData on simple shape body  
                    body.userData = {
                        type: config.type || 'rectangle', // Use config type (rectangle, polygon, circle)
                        shapeType: type,
                        ...config
                    };
                    console.log(`🏷️ Simple shape userData set:`, body.userData);
                }

                console.log(`✅ Matter.js simple shape ${type} created`);
                return body;
            }

            startRenderLoop() {
                let lastTime = 0;
                const render = (currentTime) => {
                    const deltaTime = currentTime - lastTime;
                    lastTime = currentTime;
                    
                    // Update camera shake
                    this.updateCameraShake(deltaTime);
                    
                    // Step Matter.js physics simulation
                    this.Engine.update(this.engine, 1000 / 60); // 60 FPS
                    
                    // Clear canvas
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    
                    // v9: Enhanced rendering with themes (no camera shake transforms needed)
                    this.renderBackground();
                    this.renderWorld();
                    this.particleSystem.update(16); // ~16ms per frame at 60fps
                    this.particleSystem.render();
                    
                    requestAnimationFrame(render);
                };
                render(performance.now());
                console.log('🎬 Matter.js render loop with Canvas Enhancement and Camera Shake started');
            }

            // v9: Enhanced background rendering with theme support
            renderBackground() {
                if (!CANVAS_CONFIG.enabled || !CANVAS_CONFIG.useBackgroundTextures) {
                    return; // Use default CSS background
                }

                const backgroundStyle = this.assetManager.getBackgroundStyle();
                if (!backgroundStyle) return;

                // Check if we have a background image
                if (backgroundStyle.image && backgroundStyle.imageConfig) {
                    this.renderBackgroundImage(backgroundStyle);
                } else if (backgroundStyle.colors && backgroundStyle.colors.length >= 2) {
                    this.renderBackgroundGradient(backgroundStyle);
                }
                
                // Add texture overlay if configured
                this.renderBackgroundTexture();
            }

            // Render background image
            renderBackgroundImage(backgroundStyle) {
                const image = backgroundStyle.image;
                const config = backgroundStyle.imageConfig;
                
                this.ctx.save();
                
                // Apply image based on configuration
                switch(config.size) {
                    case 'cover':
                        this.drawImageCover(image);
                        break;
                    case 'contain':
                        this.drawImageContain(image);
                        break;
                    case 'auto':
                        this.ctx.drawImage(image, 0, 0);
                        break;
                    default: // "100% 100%" or similar
                        this.ctx.drawImage(image, 0, 0, this.canvas.width, this.canvas.height);
                }
                
                // If there are gradient colors too, overlay them with reduced opacity
                if (backgroundStyle.colors && backgroundStyle.colors.length >= 2) {
                    this.ctx.globalAlpha = 0.3; // Reduce opacity for overlay
                    this.renderBackgroundGradient(backgroundStyle);
                }
                
                this.ctx.restore();
            }

            // Helper to draw image with 'cover' behavior
            drawImageCover(image) {
                const canvasRatio = this.canvas.width / this.canvas.height;
                const imageRatio = image.width / image.height;
                
                let drawWidth, drawHeight, drawX, drawY;
                
                if (imageRatio > canvasRatio) {
                    // Image is wider than canvas ratio
                    drawHeight = this.canvas.height;
                    drawWidth = drawHeight * imageRatio;
                    drawX = (this.canvas.width - drawWidth) / 2;
                    drawY = 0;
                } else {
                    // Image is taller than canvas ratio
                    drawWidth = this.canvas.width;
                    drawHeight = drawWidth / imageRatio;
                    drawX = 0;
                    drawY = (this.canvas.height - drawHeight) / 2;
                }
                
                this.ctx.drawImage(image, drawX, drawY, drawWidth, drawHeight);
            }

            // Helper to draw image with 'contain' behavior
            drawImageContain(image) {
                const canvasRatio = this.canvas.width / this.canvas.height;
                const imageRatio = image.width / image.height;
                
                let drawWidth, drawHeight, drawX, drawY;
                
                if (imageRatio > canvasRatio) {
                    // Fit to canvas width
                    drawWidth = this.canvas.width;
                    drawHeight = drawWidth / imageRatio;
                    drawX = 0;
                    drawY = (this.canvas.height - drawHeight) / 2;
                } else {
                    // Fit to canvas height
                    drawHeight = this.canvas.height;
                    drawWidth = drawHeight * imageRatio;
                    drawX = (this.canvas.width - drawWidth) / 2;
                    drawY = 0;
                }
                
                this.ctx.drawImage(image, drawX, drawY, drawWidth, drawHeight);
            }

            // Render gradient background (extracted from previous method)
            renderBackgroundGradient(backgroundStyle) {
                const colors = backgroundStyle.colors;
                if (!colors || colors.length < 2) return;

                // Create linear gradient background
                const gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
                
                // Distribute colors evenly across gradient
                const colorStep = 1 / (colors.length - 1);
                colors.forEach((color, index) => {
                    gradient.addColorStop(index * colorStep, color);
                });
                
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            }

            // v9: Add subtle texture to background
            renderBackgroundTexture() {
                const currentTheme = this.assetManager.getCurrentTheme();
                if (!currentTheme) return;
                
                this.ctx.save();
                this.ctx.globalAlpha = 0.1;
                
                // Add theme-specific background patterns
                switch(currentTheme.config.platform.material) {
                    case 'wood':
                        this.renderWoodTexture();
                        break;
                    case 'metal':
                        this.renderMetalTexture();
                        break;
                    case 'coral':
                        this.renderCoralTexture();
                        break;
                    default:
                        this.renderGeometricTexture();
                }
                
                this.ctx.restore();
            }

            renderWoodTexture() {
                // Simple wood grain effect
                this.ctx.strokeStyle = '#8B4513';
                this.ctx.lineWidth = 0.5;
                for (let i = 0; i < 20; i++) {
                    const y = (this.canvas.height / 20) * i;
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.canvas.width, y + Math.sin(i) * 5);
                    this.ctx.stroke();
                }
            }

            renderMetalTexture() {
                // Diagonal line pattern
                this.ctx.strokeStyle = '#708090';
                this.ctx.lineWidth = 0.3;
                for (let i = -this.canvas.width; i < this.canvas.width + this.canvas.height; i += 10) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(i, 0);
                    this.ctx.lineTo(i + this.canvas.height, this.canvas.height);
                    this.ctx.stroke();
                }
            }

            renderCoralTexture() {
                // Organic bubble pattern
                this.ctx.fillStyle = '#2E8B57';
                for (let i = 0; i < 50; i++) {
                    const x = Math.random() * this.canvas.width;
                    const y = Math.random() * this.canvas.height;
                    const radius = Math.random() * 3 + 1;
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, radius, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }

            renderGeometricTexture() {
                // Simple dot pattern
                this.ctx.fillStyle = '#cccccc';
                for (let x = 10; x < this.canvas.width; x += 20) {
                    for (let y = 10; y < this.canvas.height; y += 20) {
                        this.ctx.beginPath();
                        this.ctx.arc(x, y, 1, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                }
            }

            // =============================================================================
            // CAMERA SHAKE SYSTEM
            // =============================================================================

            /**
             * Trigger camera shake effect
             * @param {number} intensity - Shake intensity (1-10)
             * @param {number} duration - Duration in milliseconds
             */
            startCameraShake(intensity = 5, duration = 500) {
                console.log(`🚨 startCameraShake called with intensity=${intensity}, duration=${duration}ms`);
                
                this.cameraShake.active = true;
                this.cameraShake.intensity = intensity;
                this.cameraShake.duration = duration;
                this.cameraShake.elapsed = 0;
                this.cameraShake.frequencyX = 0.1 + Math.random() * 0.1; // Randomize frequency
                this.cameraShake.frequencyY = 0.1 + Math.random() * 0.1;
                
                console.log(`✅ Camera shake activated - state:`, this.cameraShake);
                console.log(`🎯 Canvas element:`, this.canvas);
                
                // Immediate test shake to verify it works
                this.canvas.style.transform = `translate(${intensity}px, ${intensity}px)`;
                setTimeout(() => {
                    this.canvas.style.transform = 'translate(0px, 0px)';
                }, 100);
                
                console.log(`📹 Camera shake started: intensity=${intensity}, duration=${duration}ms`);
            }

            /**
             * Update camera shake effect - applies shake directly to canvas element
             * @param {number} deltaTime - Time since last update
             */
            updateCameraShake(deltaTime) {
                if (!this.cameraShake.active) {
                    // Reset canvas position when not shaking
                    this.canvas.style.transform = 'translate(0px, 0px)';
                    return;
                }

                console.log(`🔄 updateCameraShake: elapsed=${this.cameraShake.elapsed}, duration=${this.cameraShake.duration}, intensity=${this.cameraShake.intensity}`);

                this.cameraShake.elapsed += deltaTime;

                if (this.cameraShake.elapsed >= this.cameraShake.duration) {
                    // Shake finished
                    this.cameraShake.active = false;
                    this.canvas.style.transform = 'translate(0px, 0px)';
                    console.log('✅ Camera shake completed');
                    return;
                }

                // Calculate shake progress (1.0 at start, 0.0 at end)
                const progress = 1.0 - (this.cameraShake.elapsed / this.cameraShake.duration);
                const currentIntensity = this.cameraShake.intensity * progress * progress; // Quadratic falloff

                // Generate shake offset using sine waves with different frequencies
                const time = this.cameraShake.elapsed * 0.01; // Convert to suitable time scale
                let offsetX = Math.sin(time * this.cameraShake.frequencyX * 50) * currentIntensity;
                let offsetY = Math.sin(time * this.cameraShake.frequencyY * 47) * currentIntensity; // Different frequency for variety

                // Add random jitter for more chaotic feel
                offsetX += (Math.random() - 0.5) * currentIntensity * 0.5;
                offsetY += (Math.random() - 0.5) * currentIntensity * 0.5;

                console.log(`📳 Applying shake: offsetX=${offsetX.toFixed(1)}, offsetY=${offsetY.toFixed(1)}, currentIntensity=${currentIntensity.toFixed(1)}`);

                // Apply transform to canvas element
                this.canvas.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
            }

            /**
             * Apply camera shake to canvas transform (legacy method - now unused)
             */
            applyCameraShake() {
                // This method is no longer used - shake is applied directly to canvas element
            }

            /**
             * Reset camera shake transform (legacy method - now unused)
             */
            resetCameraShake() {
                // This method is no longer used - shake is applied directly to canvas element
            }

            renderWorld() {
                // Render all Matter.js bodies in the world
                const bodies = this.world.bodies;
                for (let i = 0; i < bodies.length; i++) {
                    this.renderBody(bodies[i]);
                }
            }

            renderBody(body) {
                // Skip rendering invisible bodies
                if (body.render && body.render.visible === false) return;
                
                // V9: Render Matter.js body parts directly (no coordinate transformation)
                if (body.parts && body.parts.length > 1) {
                    // Compound body - render each part separately
                    for (let i = 1; i < body.parts.length; i++) { // Skip first part (it's the parent)
                        this.renderMatterPart(body.parts[i], body);
                    }
                } else {
                    // Simple body - render directly
                    this.renderMatterPart(body, body);
                }
            }

            renderMatterPart(part, parentBody) {
                // Get render properties from Matter.js body
                const render = part.render || {};
                const userData = parentBody.userData || {};
                
                // Skip invisible parts
                if (render.visible === false) return;
                
                // v9: Theme-based color selection
                let fillColor = render.fillStyle || userData.color || '#95A5A6';
                let strokeColor = render.strokeStyle || userData.stroke || '#7F8C8D';
                
                // Apply theme colors for platform
                if (userData.type === 'platform' && this.platformColor) {
                    fillColor = this.platformColor;
                    strokeColor = this.darkenColor(this.platformColor, 20);
                }
                
                // v9: Check for image textures
                const shouldUseTexture = CANVAS_CONFIG.enabled && CANVAS_CONFIG.useBackgroundTextures;
                let textureImage = null;
                let textureConfig = null;
                
                if (shouldUseTexture) {
                    if (userData.type === 'platform') {
                        const platformStyle = this.assetManager.getPlatformStyle();
                        textureImage = platformStyle?.image;
                        textureConfig = platformStyle?.imageConfig;
                    } else if (userData.shapeType) {
                        const shapeStyle = this.assetManager.getShapeStyle(userData.shapeType);
                        textureImage = shapeStyle?.texture;
                        textureConfig = shapeStyle?.textureConfig;
                    }
                }
                
                // Set drawing style
                this.ctx.fillStyle = fillColor;
                this.ctx.strokeStyle = strokeColor;
                this.ctx.lineWidth = render.lineWidth || userData.strokeWidth || 2;
                
                // Render based on shape type
                if (part.circleRadius !== undefined && part.circleRadius > 0) {
                    // Circle - use part's own position (already in world coordinates)
                    this.renderCircleWithTexture(part, textureImage, textureConfig);
                } else if (part.vertices && part.vertices.length > 0) {
                    // Polygon (including rectangles) - vertices are in world coordinates
                    this.renderPolygonWithTexture(part, textureImage, textureConfig);
                } else {
                    console.log(`⚠️ Unknown body type - circleRadius: ${part.circleRadius}, vertices: ${part.vertices ? part.vertices.length : 'none'} for ${userData.type || 'unknown'}`);
                }
            }

            renderCircleWithTexture(part, textureImage, textureConfig) {
                this.ctx.save();
                
                // Create circular clipping path
                this.ctx.beginPath();
                this.ctx.arc(part.position.x, part.position.y, part.circleRadius, 0, Math.PI * 2);
                
                if (textureImage && textureConfig) {
                    // Fill with texture
                    this.ctx.clip();
                    this.applyTextureToShape(part.position.x - part.circleRadius, 
                                           part.position.y - part.circleRadius,
                                           part.circleRadius * 2, 
                                           part.circleRadius * 2,
                                           textureImage, textureConfig);
                } else {
                    // Fill with solid color
                    this.ctx.fill();
                }
                
                // Restore for stroke
                this.ctx.restore();
                
                // Draw stroke
                this.ctx.beginPath();
                this.ctx.arc(part.position.x, part.position.y, part.circleRadius, 0, Math.PI * 2);
                this.ctx.stroke();
            }

            renderPolygonWithTexture(part, textureImage, textureConfig) {
                const vertices = part.vertices;
                
                this.ctx.save();
                
                // Create polygon clipping path
                this.ctx.beginPath();
                this.ctx.moveTo(vertices[0].x, vertices[0].y);
                for (let i = 1; i < vertices.length; i++) {
                    this.ctx.lineTo(vertices[i].x, vertices[i].y);
                }
                this.ctx.closePath();
                
                if (textureImage && textureConfig) {
                    // Get bounding box for texture positioning
                    const bounds = this.getPolygonBounds(vertices);
                    
                    // Fill with texture
                    this.ctx.clip();
                    this.applyTextureToShape(bounds.x, bounds.y, bounds.width, bounds.height,
                                           textureImage, textureConfig);
                } else {
                    // Fill with solid color
                    this.ctx.fill();
                }
                
                // Restore for stroke
                this.ctx.restore();
                
                // Draw stroke
                this.ctx.beginPath();
                this.ctx.moveTo(vertices[0].x, vertices[0].y);
                for (let i = 1; i < vertices.length; i++) {
                    this.ctx.lineTo(vertices[i].x, vertices[i].y);
                }
                this.ctx.closePath();
                this.ctx.stroke();
            }

            applyTextureToShape(x, y, width, height, image, textureConfig) {
                if (!image) return;
                
                this.ctx.save();
                
                // Apply blend mode
                if (textureConfig.blend && textureConfig.blend !== 'normal') {
                    this.ctx.globalCompositeOperation = textureConfig.blend;
                }
                
                // Apply opacity
                if (textureConfig.opacity !== undefined) {
                    this.ctx.globalAlpha = textureConfig.opacity;
                }
                
                // Handle texture repeat patterns
                switch(textureConfig.repeat) {
                    case 'repeat':
                        this.drawRepeatedTexture(x, y, width, height, image);
                        break;
                    case 'repeat-x':
                        this.drawRepeatedTextureX(x, y, width, height, image);
                        break;
                    case 'repeat-y':
                        this.drawRepeatedTextureY(x, y, width, height, image);
                        break;
                    case 'no-repeat':
                    default:
                        this.ctx.drawImage(image, x, y, width, height);
                        break;
                }
                
                this.ctx.restore();
            }

            drawRepeatedTexture(x, y, width, height, image) {
                const pattern = this.ctx.createPattern(image, 'repeat');
                if (pattern) {
                    this.ctx.fillStyle = pattern;
                    this.ctx.fillRect(x, y, width, height);
                } else {
                    // Fallback: manual tiling
                    this.manualTileTexture(x, y, width, height, image);
                }
            }

            drawRepeatedTextureX(x, y, width, height, image) {
                const aspectRatio = image.width / image.height;
                const tileHeight = height;
                const tileWidth = tileHeight * aspectRatio;
                
                for (let tx = x; tx < x + width; tx += tileWidth) {
                    const drawWidth = Math.min(tileWidth, x + width - tx);
                    this.ctx.drawImage(image, 0, 0, image.width * (drawWidth / tileWidth), image.height,
                                     tx, y, drawWidth, tileHeight);
                }
            }

            drawRepeatedTextureY(x, y, width, height, image) {
                const aspectRatio = image.width / image.height;
                const tileWidth = width;
                const tileHeight = tileWidth / aspectRatio;
                
                for (let ty = y; ty < y + height; ty += tileHeight) {
                    const drawHeight = Math.min(tileHeight, y + height - ty);
                    this.ctx.drawImage(image, 0, 0, image.width, image.height * (drawHeight / tileHeight),
                                     x, ty, tileWidth, drawHeight);
                }
            }

            manualTileTexture(x, y, width, height, image) {
                const tileWidth = image.width;
                const tileHeight = image.height;
                
                for (let ty = y; ty < y + height; ty += tileHeight) {
                    for (let tx = x; tx < x + width; tx += tileWidth) {
                        const drawWidth = Math.min(tileWidth, x + width - tx);
                        const drawHeight = Math.min(tileHeight, y + height - ty);
                        
                        this.ctx.drawImage(image, 0, 0, 
                                         image.width * (drawWidth / tileWidth), 
                                         image.height * (drawHeight / tileHeight),
                                         tx, ty, drawWidth, drawHeight);
                    }
                }
            }

            getPolygonBounds(vertices) {
                let minX = Infinity, minY = Infinity;
                let maxX = -Infinity, maxY = -Infinity;
                
                vertices.forEach(vertex => {
                    minX = Math.min(minX, vertex.x);
                    minY = Math.min(minY, vertex.y);
                    maxX = Math.max(maxX, vertex.x);
                    maxY = Math.max(maxY, vertex.y);
                });
                
                return {
                    x: minX,
                    y: minY,
                    width: maxX - minX,
                    height: maxY - minY
                };
            }

            getEventStats() {
                return {
                    events: this.eventCount,
                    collisions: this.collisionCount,
                    falls: this.fallCount
                };
            }

            darkenColor(color, amount = 30) {
                // v9: Enhanced color darkening with configurable amount
                if (!color) return '#7F8C8D';
                
                // Convert hex to RGB and darken by specified amount
                const hex = color.replace('#', '');
                const r = Math.max(0, parseInt(hex.substr(0, 2), 16) - amount);
                const g = Math.max(0, parseInt(hex.substr(2, 2), 16) - amount);
                const b = Math.max(0, parseInt(hex.substr(4, 2), 16) - amount);
                
                return `rgb(${r}, ${g}, ${b})`;
            }

            /*╔═══════════════════════════════════════════════════════════════════════════
              ║ CLEAR ALL SHAPES
              ║ Removes all dynamic bodies (shapes) from the physics world while preserving
              ║ static bodies (platform, walls). Used for level resets and shape management.
              ║ Essential for providing a fresh start without recreating the entire world.
              ╚═══════════════════════════════════════════════════════════════════════════*/
            clearAllShapes() {
                // Remove all dynamic bodies from Matter.js world
                this.dynamicBodies.forEach(body => {
                    this.World.remove(this.world, body);
                });
                this.dynamicBodies = [];
                
                console.log('🧹 Cleared all shapes from playfield');
            }

            cleanup() {
                // Remove all dynamic bodies from Matter.js world
                this.dynamicBodies.forEach(body => {
                    this.World.remove(this.world, body);
                });
                this.dynamicBodies = [];
                
                // Reset event counters
                this.eventCount = 0;
                this.collisionCount = 0;
                this.fallCount = 0;
                
                console.log('🧹 Matter.js physics cleanup complete');
            }
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ ENHANCED DRAG AND DROP MANAGER WITH ROTATION
          ║ Task 4.2b: Adds rotation functionality during drag and drop operations
          ║ Maintains existing drag & drop functionality while adding rotation controls
          ╚═══════════════════════════════════════════════════════════════════════════*/
        class DragDropManager {
            constructor(physicsManager, gameManager) {
                this.physicsManager = physicsManager;
                this.gameManager = gameManager;
                this.isDragging = false;
                this.draggedElement = null;
                this.draggedShapeType = null;
                this.ghostElement = null;
                
                // Touch offset configuration for mobile devices
                this.touchOffset = {
                    x: 0,      // Horizontal offset (positive = right, negative = left)
                    y: -80,    // Vertical offset (positive = down, negative = up)
                    enabled: true // Enable/disable offset system
                };
                
                // Rotation system
                this.currentRotation = 0; // Current rotation in radians
                this.rotationStep = Math.PI / 6; // 30 degrees per step
                
                // Throttling for smooth dragging - reduce jerkiness
                this.lastMoveTime = 0;
                this.moveThrottleMs = 16; // ~60fps throttling
                this.pendingMove = null;
                
                // Track if drag started from dock
                this.dragStartedFromDock = false;
                
                this.setupEventListeners();
                console.log('🖱️ Streamlined Drag & Drop Manager with touch offset support initialized');
            }

            setupEventListeners() {
                // Mouse events - use throttled movement for smoother dragging
                document.addEventListener('mousedown', (e) => this.handlePointerDown(e));
                document.addEventListener('mousemove', (e) => this.throttledHandlePointerMove(e));
                document.addEventListener('mouseup', (e) => this.handlePointerUp(e));
                
                // Touch events for mobile support
                document.addEventListener('touchstart', (e) => this.handleTouchStart(e), { passive: false });
                document.addEventListener('touchmove', (e) => this.handleTouchMove(e), { passive: false });
                document.addEventListener('touchend', (e) => this.handleTouchEnd(e), { passive: false });
                
                // Keyboard controls
                document.addEventListener('keydown', (e) => this.handleRotationKey(e));
                
                console.log('🖱️ Drag & Drop Manager initialized with touch support');
            }
            
            // Throttled mouse movement to reduce jerkiness
            throttledHandlePointerMove(e) {
                if (!this.isDragging) return;
                
                const now = performance.now();
                if (now - this.lastMoveTime < this.moveThrottleMs) {
                    // Store the most recent event for later processing
                    this.pendingMove = e;
                    return;
                }
                
                this.lastMoveTime = now;
                this.handlePointerMove(e);
                
                // Process any pending move after throttle delay
                if (this.pendingMove && this.pendingMove !== e) {
                    setTimeout(() => {
                        if (this.pendingMove && this.isDragging) {
                            this.handlePointerMove(this.pendingMove);
                            this.pendingMove = null;
                        }
                    }, this.moveThrottleMs);
                }
            }

            handleRotationKey(e) {
                if (!this.isDragging) return;
                
                switch(e.key) {
                    case 'r':
                    case 'R':
                    case 'ArrowRight':
                        this.rotateShape(this.rotationStep); // Rotate clockwise
                        e.preventDefault();
                        break;
                    case 'e':
                    case 'E':
                    case 'ArrowLeft':
                        this.rotateShape(-this.rotationStep); // Rotate counter-clockwise
                        e.preventDefault();
                        break;
                }
            }

            rotateShape(deltaRotation) {
                this.currentRotation += deltaRotation;
                
                // Sound effect integration point
                this.gameManager.playSound('shapeRotation');
                
                if (this.ghostElement) {
                    // Apply both scale, centering translation, and rotation to the ghost element
                    this.ghostElement.style.transform = `translate(-50%, -50%) scale(1.1) rotate(${this.currentRotation}rad)`;
                }
                
                // Update rotation indicator with current angle
                const degrees = Math.round(this.currentRotation * 180 / Math.PI);
                this.updateRotationIndicator(degrees);
                
                console.log(`🔄 Shape rotated: ${degrees}°`);
            }

            handlePointerDown(pointer) {
                const element = document.elementFromPoint(pointer.clientX, pointer.clientY);
                
                if (element && element.classList.contains('game-shape')) {
                    // Check if drag started from docking area
                    this.dragStartedFromDock = element.closest('.docking-area') !== null;
                    console.log(`🖱️ Starting drag, from dock: ${this.dragStartedFromDock}`);
                    this.startDrag(element, pointer);
                }
            }

            startDrag(element, pointer) {
                this.isDragging = true;
                this.draggedElement = element;
                this.draggedShapeType = element.dataset.shape;
                
                // Initialize rotation based on shape type and dock settings
                if (this.draggedShapeType && this.draggedShapeType.includes('barbell')) {
                    // For barbells, preserve dock orientation setting
                    const barbellOrientationSelect = document.getElementById('barbellOrientation');
                    if (barbellOrientationSelect && barbellOrientationSelect.value === 'vertical') {
                        this.currentRotation = Math.PI / 2; // 90 degrees for vertical barbells
                        console.log(`🔄 Starting barbell drag with vertical dock orientation (90°)`);
                    } else {
                        this.currentRotation = 0; // Horizontal for barbells
                        console.log(`🔄 Starting barbell drag with horizontal dock orientation (0°)`);
                    }
                } else {
                    // For non-barbell shapes, always start at 0
                    this.currentRotation = 0;
                }
                
                // Add visual feedback with ghost effect
                element.classList.add('ghost-active');
                
                // Show rotation indicator
                this.showRotationIndicator();
                
                // Update rotation indicator with initial rotation
                this.updateRotationIndicator(Math.round(this.currentRotation * 180 / Math.PI));
                
                // Create ghost element for dragging
                this.createGhostElement(element, pointer);
                
                console.log(`🟢 Started dragging: ${this.draggedShapeType} with initial rotation ${(this.currentRotation * 180 / Math.PI).toFixed(1)}° (R/E or ←/→ to rotate)`);
            }

            createGhostElement(element, pointer) {
                // Create ghost element like Planck version - using CSS transform rotation
                this.ghostElement = this.createGhostPreview(this.draggedShapeType, 90);
                
                // Add ghost-shape class for CSS styling
                this.ghostElement.classList.add('ghost-shape');
                
                // Apply comprehensive ghost styling to prevent clipping
                this.ghostElement.style.position = 'fixed';
                this.ghostElement.style.pointerEvents = 'none';
                this.ghostElement.style.zIndex = '10000'; // Higher z-index to ensure visibility
                this.ghostElement.style.filter = 'drop-shadow(0 5px 15px rgba(0,0,0,0.3))';
                this.ghostElement.style.visibility = 'visible';
                this.ghostElement.style.opacity = '0.9';
                this.ghostElement.style.display = 'block';
                
                // Use CSS transform with consistent centering, scale, and rotation
                const initialTransform = `translate(-50%, -50%) scale(1.1) rotate(${this.currentRotation}rad)`;
                this.ghostElement.style.transform = initialTransform;
                console.log(`👻 Ghost element created with CSS rotation: ${(this.currentRotation * 180 / Math.PI).toFixed(1)}°`);
                
                // Position at pointer
                this.updateGhostPosition(pointer);
                
                // Append to drag overlay instead of document.body to prevent clipping
                const dragOverlay = document.getElementById('dragOverlay');
                if (dragOverlay) {
                    dragOverlay.appendChild(this.ghostElement);
                    console.log(`👻 Ghost element created in drag overlay for ${this.draggedShapeType}`);
                } else {
                    document.body.appendChild(this.ghostElement);
                    console.log(`👻 Ghost element created in document body for ${this.draggedShapeType} (fallback)`);
                }
            }

            createGhostPreview(shapeType, size) {
                // Create canvas element for ghost preview (no rotation - handled by CSS transform)
                const canvas = document.createElement('canvas');
                canvas.width = size;
                canvas.height = size;
                canvas.className = 'shape-preview ghost-preview';
                canvas.dataset.shape = shapeType;

                const ctx = canvas.getContext('2d');
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';

                // Use same scale as dock preview for consistency  
                const scale = 1.9;
                
                // Render with no rotation - rotation handled by CSS transform like Planck version
                shapeRenderer.renderShapeOnCanvas(ctx, shapeType, size / 2, size / 2, 0, scale);
                
                console.log(`👻 Ghost preview created for: ${shapeType} with scale ${scale}, rotation handled by CSS`);
                return canvas;
            }

            // Streamlined rotation method (like Planck version)
            rotateShape(delta) {
                this.currentRotation += delta;
                if (this.ghostElement) {
                    // Update CSS transform with consistent centering, scale, and rotation
                    this.ghostElement.style.transform = `translate(-50%, -50%) scale(1.1) rotate(${this.currentRotation}rad)`;
                }
                this.updateRotationIndicator(Math.round(this.currentRotation * 180 / Math.PI));
                if (this.gameManager && this.gameManager.playSound) {
                    this.gameManager.playSound('shapeRotation');
                }
            }

            updateGhostPosition(pointer) {
                if (this.ghostElement) {
                    let x = pointer.clientX;
                    let y = pointer.clientY;
                    
                    // Apply touch offset if dragging from dock and offset is enabled
                    if (this.dragStartedFromDock && this.touchOffset.enabled) {
                        x += this.touchOffset.x;
                        y += this.touchOffset.y;
                    }
                    
                    // Set position using left/top
                    this.ghostElement.style.left = `${x}px`;
                    this.ghostElement.style.top = `${y}px`;
                    
                    // Preserve scale (1.1 during drag) and rotation with centering
                    this.ghostElement.style.transform = `translate(-50%, -50%) scale(1.1) rotate(${this.currentRotation}rad)`;
                }
            }

            handlePointerMove(pointer) {
                if (this.isDragging && this.ghostElement) {
                    // Streamlined: Only update ghost position for optimal performance
                    this.updateGhostPosition(pointer);
                }
            }

            handlePointerUp(pointer) {
                if (!this.isDragging) return;
                
                // Check if dropped in game area
                const gameCanvas = document.getElementById('gameCanvas');
                const canvasRect = gameCanvas.getBoundingClientRect();
                
                // Calculate the actual drop position from ghost element if it exists
                let dropX, dropY;
                if (this.ghostElement) {
                    // Get ghost element's center position
                    const ghostRect = this.ghostElement.getBoundingClientRect();
                    dropX = ghostRect.left + ghostRect.width / 2;
                    dropY = ghostRect.top + ghostRect.height / 2;
                } else {
                    // Fallback to pointer position
                    dropX = pointer.clientX;
                    dropY = pointer.clientY;
                }
                
                if (dropX >= canvasRect.left && 
                    dropX <= canvasRect.right &&
                    dropY >= canvasRect.top && 
                    dropY <= canvasRect.bottom) {
                    
                    // Calculate position relative to canvas using ghost position
                    const x = dropX - canvasRect.left;
                    const y = dropY - canvasRect.top;
                    
                    // Use current rotation as-is (it already includes barbell orientation from dock/ghost)
                    const totalRotation = this.currentRotation;
                    console.log(`🔄 Physics: Using current rotation ${(totalRotation * 180 / Math.PI).toFixed(1)}° for ${this.draggedShapeType}`);
                    
                    // Log rotation for debugging
                    console.log(`🔍 DEBUG: Dropping ${this.draggedShapeType} with total rotation: ${totalRotation} radians (${(totalRotation * 180 / Math.PI).toFixed(1)}°)`);
                    
                    // Create physics shape at drop position with total rotation
                    this.physicsManager.createCompoundShape(x, y, this.draggedShapeType, totalRotation);
                    
                    // Update game state
                    this.gameManager.onShapePlaced(this.draggedShapeType);
                    
                    // Mark this slot as empty since shape was successfully placed
                    this.markSlotAsEmpty(this.draggedElement);
                    
                    console.log(`🎯 Shape dropped: ${this.draggedShapeType} at (${x}, ${y}) with ${(totalRotation * 180 / Math.PI).toFixed(0)}° total rotation`);
                } else {
                    // Shape was not dropped in game area, restore it to dock
                    this.restoreShapeToDock();
                    console.log(`↩️ Shape returned to dock: ${this.draggedShapeType}`);
                }
                
                this.endDrag();
            }

            markSlotAsEmpty(shapeElement) {
                // Remove the shape from dock and mark slot as empty
                const slot = shapeElement.parentElement;
                shapeElement.remove();
                slot.classList.add('empty');
                
                console.log(`📦 Dock slot emptied: ${this.draggedShapeType}`);
            }

            restoreShapeToDock() {
                // Restore the shape visibility in the dock
                if (this.draggedElement) {
                    this.draggedElement.style.visibility = 'visible';
                }
            }

            showRotationIndicator() {
                const indicator = document.getElementById('rotationIndicator');
                if (indicator) {
                    indicator.classList.add('show');
                }
            }

            hideRotationIndicator() {
                const indicator = document.getElementById('rotationIndicator');
                if (indicator) {
                    indicator.classList.remove('show');
                }
            }

            updateRotationIndicator(angle) {
                const indicator = document.getElementById('rotationIndicator');
                if (indicator) {
                    indicator.textContent = `🔄 Rotation: ${angle}°`;
                }
            }

            /*╔═══════════════════════════════════════════════════════════════════════════
              ║ STREAMLINED DRAG MANAGEMENT (KEYBOARD ONLY)
              ║ Removed mobile gestures and auto-rotation for optimal performance
              ╚═══════════════════════════════════════════════════════════════════════════*/

            // Simplified cleanup method (no auto-rotation timers to clear)
            stopMobileRotation() {
                // Keep method for compatibility, but no timers to clear
            }

            endDrag() {
                if (this.draggedElement) {
                    this.draggedElement.classList.remove('ghost-active');
                    
                    // If shape is still in dock (not removed), restore visibility
                    if (this.draggedElement.parentElement) {
                        this.draggedElement.style.visibility = 'visible';
                    }
                }
                
                if (this.ghostElement) {
                    // Remove from drag overlay if it exists, otherwise from document.body
                    const dragOverlay = document.getElementById('dragOverlay');
                    if (dragOverlay && dragOverlay.contains(this.ghostElement)) {
                        dragOverlay.removeChild(this.ghostElement);
                    } else if (this.ghostElement.parentNode) {
                        this.ghostElement.parentNode.removeChild(this.ghostElement);
                    }
                    this.ghostElement = null;
                }
                
                // Hide rotation indicator
                this.hideRotationIndicator();
                
                this.isDragging = false;
                this.draggedElement = null;
                this.draggedShapeType = null;
                this.currentRotation = 0;
                this.dragStartedFromDock = false;
            }

            // Configuration method for touch offset
            setTouchOffset(x, y, enabled = true) {
                this.touchOffset.x = x;
                this.touchOffset.y = y;
                this.touchOffset.enabled = enabled;
                console.log(`📱 Touch offset updated: x=${x}, y=${y}, enabled=${enabled}`);
            }

            // Get current touch offset settings
            getTouchOffset() {
                return { ...this.touchOffset };
            }

            // Touch event handlers for mobile support
            handleTouchStart(event) {
                if (event.touches.length !== 1) return;
                
                const touch = event.touches[0];
                
                // Add haptic feedback if supported
                if (navigator.vibrate && touch.target.closest('.game-shape')) {
                    navigator.vibrate(50); // Light haptic feedback
                }
                
                // Convert touch to mouse-like event
                const mouseEvent = new MouseEvent('mousedown', {
                    clientX: touch.clientX,
                    clientY: touch.clientY,
                    button: 0
                });
                
                this.handlePointerDown(mouseEvent);
                event.preventDefault();
            }
            
            handleTouchMove(event) {
                if (event.touches.length !== 1 || !this.isDragging) return;
                
                const touch = event.touches[0];
                
                // Convert touch to mouse-like event
                const mouseEvent = new MouseEvent('mousemove', {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
                
                this.throttledHandlePointerMove(mouseEvent);
                event.preventDefault();
            }
            
            handleTouchEnd(event) {
                if (!this.isDragging) return;
                
                const touch = event.changedTouches[0];
                
                // Light haptic feedback on drop if supported
                if (navigator.vibrate) {
                    navigator.vibrate(25); // Subtle feedback on drop
                }
                
                // Convert touch to mouse-like event
                const mouseEvent = new MouseEvent('mouseup', {
                    clientX: touch.clientX,
                    clientY: touch.clientY,
                    button: 0
                });
                
                this.handlePointerUp(mouseEvent);
                event.preventDefault();
            }
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ MOBILE ENHANCEMENT MANAGER 
          ║ Adds mobile touch support and rotation zones while preserving mouse/keyboard
          ║ Detects mobile devices and provides touch-optimized interactions
          ╚═══════════════════════════════════════════════════════════════════════════*/
        class MobileEnhancementManager {
            constructor(dragDropManager) {
                this.dragDropManager = dragDropManager;
                this.isMobileDevice = this.detectMobileDevice();
                this.touchStartTime = 0;
                this.touchThreshold = 10; // Minimum movement for drag
                this.rotationTimer = null;
                this.rotationInterval = 1000; // 1 second intervals for mobile rotation
                this.rotationIncrement = Math.PI / 4; // 45 degrees for mobile
                
                // Rotation zones
                this.rotationZones = {
                    left: {
                        element: document.getElementById('leftRotationZone'),
                        direction: -1, // CCW
                        active: false,
                        bounds: null
                    },
                    right: {
                        element: document.getElementById('rightRotationZone'), 
                        direction: 1, // CW
                        active: false,
                        bounds: null
                    }
                };
                
                if (this.isMobileDevice) {
                    this.setupTouchEnhancements();
                    console.log('📱 Mobile enhancements activated');
                } else {
                    console.log('🖥️ Desktop mode - mobile enhancements disabled');
                }
            }
            
            detectMobileDevice() {
                return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                       (navigator.maxTouchPoints && navigator.maxTouchPoints > 2) ||
                       window.innerWidth <= 768;
            }
            
            setupTouchEnhancements() {
                // Add touch event listeners for mobile-specific rotation zone features
                document.addEventListener('touchstart', (e) => this.handleTouchStart(e), { passive: false });
                document.addEventListener('touchmove', (e) => this.handleTouchMove(e), { passive: false });
                document.addEventListener('touchend', (e) => this.handleTouchEnd(e), { passive: false });
                
                // Update rotation zone bounds
                this.updateRotationZoneBounds();
                window.addEventListener('resize', () => this.updateRotationZoneBounds());
                
                // Hook into DragDropManager to add mobile features
                this.originalStartDrag = this.dragDropManager.startDrag.bind(this.dragDropManager);
                this.dragDropManager.startDrag = (element, event) => {
                    this.originalStartDrag(element, event);
                    this.showRotationZones();
                };
                
                this.originalEndDrag = this.dragDropManager.endDrag.bind(this.dragDropManager);
                this.dragDropManager.endDrag = () => {
                    this.hideRotationZones();
                    this.stopRotationTimer();
                    this.originalEndDrag();
                };
            }
            
            // Enable mouse events for debugging on desktop
            enableMouseSupport() {
                if (this.mouseEventsAdded) return;
                
                // Hook into DragDropManager mouse events for rotation zones
                const originalHandlePointerMove = this.dragDropManager.handlePointerMove.bind(this.dragDropManager);
                this.dragDropManager.handlePointerMove = (event) => {
                    originalHandlePointerMove(event);
                    
                    // Check rotation zones if dragging
                    if (this.dragDropManager.isDragging && this.isMobileDevice) {
                        this.checkRotationZones(event.clientX, event.clientY);
                    }
                };
                
                this.mouseEventsAdded = true;
                console.log('🖱️ Mouse support enabled for rotation zones');
            }
            
            disableMouseSupport() {
                // Note: This would require storing original methods to restore them
                // For now, we'll just flag that mouse support was added
                this.mouseEventsAdded = false;
                console.log('🖱️ Mouse support disabled for rotation zones');
            }
            
            updateRotationZoneBounds() {
                const canvas = document.getElementById('gameCanvas');
                const canvasRect = canvas.getBoundingClientRect();
                
                this.rotationZones.left.bounds = {
                    left: canvasRect.left,
                    right: canvasRect.left + 80,
                    top: canvasRect.top,
                    bottom: canvasRect.bottom
                };
                
                this.rotationZones.right.bounds = {
                    left: canvasRect.right - 80,
                    right: canvasRect.right,
                    top: canvasRect.top,
                    bottom: canvasRect.bottom
                };
            }
            
            handleTouchStart(event) {
                if (event.touches.length !== 1) return;
                
                const touch = event.touches[0];
                const element = document.elementFromPoint(touch.clientX, touch.clientY);
                
                // Only handle rotation zones here - let DragDropManager handle shape dragging
                this.checkRotationZones(touch.clientX, touch.clientY);
                
                this.touchStartTime = Date.now();
            }
            
            handleTouchMove(event) {
                if (!this.dragDropManager.isDragging) return;
                if (event.touches.length !== 1) return;
                
                const touch = event.touches[0];
                
                // Check rotation zones with haptic feedback
                const wasInZone = this.currentRotationZone;
                this.checkRotationZones(touch.clientX, touch.clientY);
                
                // Haptic feedback when entering rotation zone
                if (this.currentRotationZone && !wasInZone && navigator.vibrate) {
                    navigator.vibrate(30); // Light feedback when entering rotation zone
                }
                
                event.preventDefault();
            }

            handleTouchEnd(event) {
                // Rotation handling on touch end
                if (this.currentRotationZone && this.dragDropManager.isDragging) {
                    const rotationDirection = this.currentRotationZone === 'left' ? -1 : 1;
                    this.dragDropManager.rotateShape(rotationDirection * this.dragDropManager.rotationStep);
                    
                    // Stronger haptic feedback for rotation
                    if (navigator.vibrate) {
                        navigator.vibrate([50, 50, 50]); // Pattern for rotation feedback
                    }
                }
                
                this.hideRotationZones();
                this.stopRotationTimer();
                this.currentRotationZone = null;
                
                event.preventDefault();
            }            checkRotationZones(x, y) {
                let inZone = null;
                
                // Debug logging
                console.log(`📍 Checking rotation zones at (${x}, ${y})`);
                
                // Check left zone
                if (this.isPointInZone(x, y, this.rotationZones.left.bounds)) {
                    inZone = 'left';
                    console.log('📍 In LEFT rotation zone');
                }
                // Check right zone
                else if (this.isPointInZone(x, y, this.rotationZones.right.bounds)) {
                    inZone = 'right';
                    console.log('📍 In RIGHT rotation zone');
                }
                
                // Handle zone entry/exit
                if (inZone && !this.rotationZones[inZone].active) {
                    this.enterRotationZone(inZone);
                } else if (!inZone) {
                    this.exitAllRotationZones();
                }
            }
            
            isPointInZone(x, y, bounds) {
                return bounds && x >= bounds.left && x <= bounds.right && 
                       y >= bounds.top && y <= bounds.bottom;
            }
            
            enterRotationZone(zoneName) {
                const zone = this.rotationZones[zoneName];
                if (!zone || !zone.element) return;
                
                // Exit other zones first
                this.exitAllRotationZones();
                
                // Activate this zone
                zone.active = true;
                zone.element.classList.add('active');
                
                // Start rotation timer
                this.rotationTimer = setInterval(() => {
                    if (this.dragDropManager.isDragging) {
                        this.dragDropManager.currentRotation += zone.direction * this.rotationIncrement;
                        
                        // Update ghost element rotation
                        if (this.dragDropManager.ghostElement) {
                            this.dragDropManager.ghostElement.style.transform = 
                                `translate(-50%, -50%) scale(1.1) rotate(${this.dragDropManager.currentRotation}rad)`;
                        }
                        
                        // Haptic feedback
                        this.playHapticFeedback();
                    }
                }, this.rotationInterval);
                
                console.log(`📱 Entered ${zoneName} rotation zone`);
            }
            
            exitAllRotationZones() {
                Object.keys(this.rotationZones).forEach(zoneName => {
                    const zone = this.rotationZones[zoneName];
                    if (zone.active && zone.element) {
                        zone.active = false;
                        zone.element.classList.remove('active');
                    }
                });
                
                this.stopRotationTimer();
            }
            
            stopRotationTimer() {
                if (this.rotationTimer) {
                    clearInterval(this.rotationTimer);
                    this.rotationTimer = null;
                }
            }
            
            showRotationZones() {
                if (!this.isMobileDevice) return;
                
                Object.values(this.rotationZones).forEach(zone => {
                    if (zone.element) {
                        zone.element.classList.add('visible');
                    }
                });
            }
            
            hideRotationZones() {
                Object.values(this.rotationZones).forEach(zone => {
                    if (zone.element) {
                        zone.element.classList.remove('visible', 'active');
                    }
                });
            }
            
            playHapticFeedback() {
                if (navigator.vibrate) {
                    navigator.vibrate(50); // Short vibration
                }
            }
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ ENHANCED GAME STATE WITH END-LEVEL COUNTDOWN
          ║ Task 4.2c: Implements end-level countdown timer and level failure conditions
          ║ Level fails if any piece falls off screen before countdown expires
          ╚═══════════════════════════════════════════════════════════════════════════*/
        class GameState {
            constructor() {
                this.shapes = [];
                this.placedShapes = [];
                this.isGameActive = true;
                this.isCountdownActive = false;
                this.countdownTime = 3;
                
                // HUD State
                this.level = 1;
                this.score = 0;
                this.coins = 0;
                this.progress = 0; // 0-100%
                
                // Timer System
                this.timerMode = 'elapsed'; // 'elapsed', 'countdown', 'endlevel'
                this.gameTime = 0; // Elapsed seconds
                this.endLevelTime = currentLevelConfig.endLevelDuration; // End level countdown duration from config
                this.endLevelDots = 0;
                
                // Physics Event Tracking
                this.shapeCollisions = 0;
                this.platformLandings = 0;
                this.shapeFalls = 0;
                this.stability = 100; // Stability percentage
                
                // End-Level State
                this.endLevelStarted = false;
                this.levelFailed = false;
                this.levelCompleted = false;
            }

            startEndLevelCountdown() {
                this.endLevelStarted = true;
                this.timerMode = 'endlevel';
                this.endLevelTime = currentLevelConfig.endLevelDuration; // Use configured duration
                this.isCountdownActive = true;
                
                console.log(`⏰ End-level countdown started: ${currentLevelConfig.endLevelDuration} seconds`);
            }

            checkLevelFailure() {
                // Level fails if any shape falls during end-level countdown
                if (this.endLevelStarted && !this.levelCompleted && this.shapeFalls > 0) {
                    this.levelFailed = true;
                    this.isGameActive = false;
                    return true;
                }
                return false;
            }

            resetLevel() {
                this.shapes = [];
                this.placedShapes = [];
                this.isGameActive = true;
                this.isCountdownActive = false;
                this.countdownTime = 3;
                this.gameTime = 0;
                this.timerMode = 'elapsed';
                this.endLevelTime = currentLevelConfig.endLevelDuration;
                this.endLevelDots = 0;
                
                // Reset score and coins to zero for fresh start
                this.score = 0;
                this.coins = 0;
                this.progress = 0;
                
                // Reset physics event tracking
                this.shapeCollisions = 0;
                this.platformLandings = 0;
                this.shapeFalls = 0;
                this.stability = 100;
                
                // Reset end-level state
                this.endLevelStarted = false;
                this.levelFailed = false;
                this.levelCompleted = false;
                
                console.log('🔄 Game state reset for new level');
            }

            addPlacedShape(shapeType) {
                this.placedShapes.push({
                    type: shapeType,
                    timestamp: Date.now()
                });
                
                const totalShapes = currentLevelConfig.dockShapes.length;
                console.log(`📊 Shape placed: ${shapeType} (${this.placedShapes.length}/${totalShapes})`);
            }

            recordPhysicsEvent(eventType) {
                switch(eventType) {
                    case 'collision':
                        this.shapeCollisions++;
                        break;
                    case 'landing':
                        this.platformLandings++;
                        break;
                    case 'fall':
                        this.shapeFalls++;
                        this.stability = Math.max(0, this.stability - 10); // Reduce stability on falls
                        
                        // Check if this fall causes level failure
                        if (this.checkLevelFailure()) {
                            console.log('💥 LEVEL FAILED: Shape fell during end-level countdown!');
                        }
                        break;
                }
            }
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ ENHANCED GAME MANAGER WITH PHYSICS EVENT INTEGRATION
          ║ Phase 4.1: Integrates physics events with game logic and UI updates
          ╚═══════════════════════════════════════════════════════════════════════════*/
        class GameManager {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.physicsManager = new PhysicsManager(this.canvas);
                this.gameState = new GameState();
                this.dragDropManager = new DragDropManager(this.physicsManager, this);
                this.mobileEnhancementManager = new MobileEnhancementManager(this.dragDropManager);
                
                // v9: Canvas Enhancement System
                this.themeManager = new ThemeManager(this.physicsManager.assetManager, this);
                
                // Level management (Super Mario Bros style)
                this.currentWorld = 1;
                this.currentLevel = 1;
                
                // Make this globally available for physics events
                window.gameManager = this;
                
                this.setupUI();
                this.setupEventListeners();
                
                console.log('🎮 Enhanced Game Manager with Physics Events initialized');
            }

            setupUI() {
                // Initialize HUD displays
                this.updateScoreDisplay();
                this.updateCoinDisplay();
                this.updateLevelDisplay();
                this.updateStars(0);
                this.updateDebugInfo();
                
                // Initialize HUD timer system
                this.timerInterval = setInterval(() => this.updateTimer(), 1000);
                
                // Event listeners are handled by onclick in HTML - no need for duplicate listener
                console.log('🎮 GameManager initialized with unified reset system');
            }

            setupEventListeners() {
                // Keyboard controls for testing (fallback)
                document.addEventListener('keydown', (e) => {
                    if (!this.gameState.isGameActive) return;
                    
                    const centerX = this.canvas.width / 2;
                    const dropY = 100;
                    
                    switch(e.key) {
                        case '1':
                            this.physicsManager.createShape(centerX, dropY, 'square');
                            this.onShapePlaced('square');
                            break;
                        case '2':
                            this.physicsManager.createShape(centerX, dropY, 'triangle');
                            this.onShapePlaced('triangle');
                            break;
                        case '3':
                            this.physicsManager.createShape(centerX, dropY, 'circle');
                            this.onShapePlaced('circle');
                            break;
                        case '4':
                            this.physicsManager.createShape(centerX, dropY, 'cross2');
                            this.onShapePlaced('cross2');
                            break;
                        case '5':
                            this.physicsManager.createShape(centerX, dropY, 'l');
                            this.onShapePlaced('l');
                            break;
                        case '6':
                            this.physicsManager.createShape(centerX, dropY, 'cross');
                            this.onShapePlaced('cross');
                            break;
                        case '7':
                            this.physicsManager.createShape(centerX, dropY, 'barbell-one');
                            this.onShapePlaced('barbell-one');
                            break;
                        case '8':
                            this.physicsManager.createShape(centerX, dropY, 'barbell-two');
                            this.onShapePlaced('barbell-two');
                            break;
                        case '9':
                            this.physicsManager.createShape(centerX, dropY, 'diamond-barbell');
                            this.onShapePlaced('diamond-barbell');
                            break;
                    }
                });
            }

            // UI Update Methods
            updateScoreDisplay() {
                const scoreElement = document.getElementById('scoreText');
                if (scoreElement) {
                    scoreElement.textContent = this.gameState.score.toLocaleString();
                    
                    // Add animation for score increase
                    scoreElement.classList.add('score-increase');
                    setTimeout(() => {
                        scoreElement.classList.remove('score-increase');
                    }, 600);
                }
            }

            updateCoinDisplay() {
                const coinElement = document.getElementById('coinAmount');
                if (coinElement) {
                    coinElement.textContent = this.gameState.coins.toString();
                    
                    // Add animation for coin increase
                    coinElement.classList.add('coin-increase');
                    setTimeout(() => {
                        coinElement.classList.remove('coin-increase');
                    }, 600);
                }
            }

            updateLevelDisplay() {
                const levelElement = document.getElementById('levelDisplay');
                if (levelElement) {
                    levelElement.textContent = `World ${this.currentWorld}-${this.currentLevel}`;
                }
            }

            // Level progression methods
            nextLevel() {
                this.currentLevel++;
                this.updateLevelDisplay();
                console.log(`🏁 Advanced to World ${this.currentWorld}-${this.currentLevel}`);
            }

            nextWorld() {
                this.currentWorld++;
                this.currentLevel = 1;
                this.updateLevelDisplay();
                console.log(`🌍 Advanced to World ${this.currentWorld}-${this.currentLevel}`);
            }

            setLevel(world, level) {
                this.currentWorld = world;
                this.currentLevel = level;
                this.updateLevelDisplay();
                console.log(`📍 Set level to World ${this.currentWorld}-${this.currentLevel}`);
            }

            // Physics Event Handlers
            onShapeLandedOnPlatform() {
                console.log('🎯 GameManager: Shape landed on platform - triggering camera shake!');
                this.gameState.recordPhysicsEvent('landing');
                
                // Track consecutive landings for streak bonuses
                this.gameState.consecutiveLandings = (this.gameState.consecutiveLandings || 0) + 1;
                this.gameState.lastAction = 'landing';
                
                // Base rewards
                let scoreBonus = 50;
                let coinBonus = 1;
                
                // Streak multipliers
                if (this.gameState.consecutiveLandings >= 5) {
                    coinBonus += 5; // +5 coins for 5+ streak
                    scoreBonus += 100;
                    this.createCoinShower('LANDING MASTER!', 5);
                } else if (this.gameState.consecutiveLandings >= 3) {
                    coinBonus += 2; // +2 coins for 3+ streak
                    scoreBonus += 50;
                    this.createFloatingText(`🔥 ${this.gameState.consecutiveLandings}x STREAK!`, 
                        document.getElementById('coinAmount'), '#FF6B35');
                }
                
                this.gameState.score += scoreBonus;
                this.gameState.coins += coinBonus;
                this.updateScoreDisplay();
                this.updateCoinDisplay();
                
                // Sound effect integration point
                this.playSound('shapeLanding');
                
                // Create enhanced particle effects
                if (this.physicsManager && this.physicsManager.particleSystem) {
                    const canvasRect = this.physicsManager.canvas.getBoundingClientRect();
                    const platformY = canvasRect.height * 0.85;
                    const x = Math.random() * canvasRect.width * 0.6 + canvasRect.width * 0.2;
                    const particleCount = Math.min(12 + this.gameState.consecutiveLandings * 2, 24);
                    this.physicsManager.particleSystem.createThemeParticles('landing', x, platformY, particleCount);
                }
                
                // Enhanced visual feedback
                const scoreElement = document.getElementById('scoreText');
                const coinElement = document.getElementById('coinAmount');
                
                this.createFloatingText(`+${scoreBonus}`, scoreElement, '#10B981');
                this.createFloatingText(`+${coinBonus}`, coinElement, '#FFD700');
                
                // Extra visual effects for big bonuses
                if (coinBonus > 3) {
                    this.createFloatingText('💰💰💰', coinElement, '#FFD700');
                    this.pulseElement(coinElement, 3);
                }
                
                console.log(`🎯 Landing streak: ${this.gameState.consecutiveLandings}, Coins: +${coinBonus}`);
            }

            onShapeCollision() {
                console.log('🔄 GameManager: Shape collision - triggering camera shake!');
                this.gameState.recordPhysicsEvent('collision');
                
                // Reset landing streak on collision
                this.gameState.consecutiveLandings = 0;
                
                // Track collision chains for bonus coins
                this.gameState.recentCollisions = (this.gameState.recentCollisions || 0) + 1;
                
                // Base rewards
                let scoreBonus = 25;
                let coinBonus = 0;
                
                // Collision-based coin rewards
                if (this.gameState.recentCollisions % 1 === 0) { // Every collision now gives coins!
                    coinBonus = 1;
                    
                    // Bonus for rapid collisions
                    if (this.gameState.recentCollisions >= 3) {
                        coinBonus += 2; // +2 extra for collision chains
                        scoreBonus += 25;
                        this.createFloatingText('💥 CHAIN REACTION!', document.getElementById('scoreText'), '#FF6B35');
                    }
                }
                
                // Random coin jackpots (5% chance)
                if (Math.random() < 0.05) {
                    const jackpot = Math.floor(Math.random() * 10) + 5; // 5-14 coins
                    coinBonus += jackpot;
                    this.createCoinShower('JACKPOT!', jackpot);
                    
                    // Small celebratory shake for big jackpots
                    if (jackpot >= 10 && this.physicsManager) {
                        this.physicsManager.startCameraShake(4, 300);
                    }
                }
                
                this.gameState.score += scoreBonus;
                this.gameState.coins += coinBonus;
                
                // Sound effect integration point
                this.playSound('shapeCollision');
                
                // Create enhanced particle effects
                if (this.physicsManager && this.physicsManager.particleSystem) {
                    const canvasRect = this.physicsManager.canvas.getBoundingClientRect();
                    const x = Math.random() * canvasRect.width * 0.8 + canvasRect.width * 0.1;
                    const y = Math.random() * canvasRect.height * 0.6 + canvasRect.height * 0.2;
                    const particleCount = Math.min(8 + this.gameState.recentCollisions, 20);
                    this.physicsManager.particleSystem.createThemeParticles('collision', x, y, particleCount);
                }
                
                this.updateScoreDisplay();
                if (coinBonus > 0) {
                    this.updateCoinDisplay();
                    const coinElement = document.getElementById('coinAmount');
                    this.createFloatingText(`+${coinBonus}`, coinElement, '#FFD700');
                }
                
                // Add visual feedback for collision bonuses
                const scoreElement = document.getElementById('scoreText');
                this.createFloatingText(`+${scoreBonus}`, scoreElement, '#4ECDC4');
                
                // Reset collision counter after a pause
                setTimeout(() => {
                    if (this.gameState.lastAction !== 'collision') {
                        this.gameState.recentCollisions = 0;
                    }
                }, 2000);
                
                this.gameState.lastAction = 'collision';
                
                console.log(`🔄 Collision chain: ${this.gameState.recentCollisions}, Coins: +${coinBonus}`);
            }

            onShapeFell() {
                console.log('💥 GameManager: Shape fell - triggering camera shake!');
                this.gameState.recordPhysicsEvent('fall');
                
                // Track fall time for stability bonuses
                this.gameState.lastFallTime = Date.now();
                
                // Reset all streaks on fall
                this.gameState.consecutiveLandings = 0;
                this.gameState.recentCollisions = 0;
                
                // Dramatic penalties based on current coin count
                let scorePenalty = 100;
                let coinPenalty = 3; // Increased base penalty
                
                // Scale penalties with current wealth (more coins = bigger penalty)
                if (this.gameState.coins >= 50) {
                    coinPenalty += 7; // -10 coins total for wealthy players
                    scorePenalty += 200;
                    this.createFloatingText('💸 MAJOR LOSS!', document.getElementById('coinAmount'), '#FF4444');
                } else if (this.gameState.coins >= 20) {
                    coinPenalty += 2; // -5 coins total
                    scorePenalty += 100;
                }
                
                // Apply penalties with minimums
                this.gameState.score = Math.max(0, this.gameState.score - scorePenalty);
                this.gameState.coins = Math.max(0, this.gameState.coins - coinPenalty);
                
                this.updateScoreDisplay();
                this.updateCoinDisplay();
                
                // Dramatic visual effects
                const coinElement = document.getElementById('coinAmount');
                const scoreElement = document.getElementById('scoreText');
                
                this.createFloatingText(`-${coinPenalty}`, coinElement, '#FF6B6B');
                this.createFloatingText(`-${scorePenalty}`, scoreElement, '#FF6B6B');
                
                // Shake effect for major losses
                if (coinPenalty >= 5) {
                    this.shakeElement(coinElement, 5);
                    this.createFloatingText('💀💀�', coinElement, '#FF4444');
                }
                
                // Camera shake effect for dramatic falls - RANDOM INTENSITY
                const randomIntensity = Math.floor(Math.random() * 10) + 10; // Random 10-19 intensity
                const duration = 800;
                console.log(`🔥 ATTEMPTING CAMERA SHAKE: intensity=${randomIntensity}, duration=${duration}ms`);
                
                if (this.physicsManager) {
                    console.log('✅ PhysicsManager found, calling startCameraShake...');
                    this.physicsManager.startCameraShake(randomIntensity, duration);
                } else {
                    console.log('❌ PhysicsManager not found!');
                }
                
                // Sound effect integration point
                this.playSound('shapeFall');
                
                console.log(`💥 FALL PENALTY: -${coinPenalty} coins, -${scorePenalty} points`);
                
                // Check if level failed due to fall during countdown
                if (this.gameState.levelFailed) {
                    this.onLevelFailed();
                    return;
                }
                
                // Check if this should trigger game over (outside of end-level countdown)
                if (!this.gameState.endLevelStarted && this.gameState.shapeFalls >= 3) {
                    this.onGameOver();
                }
            }

            onShapePlaced(shapeType) {
                this.gameState.addPlacedShape(shapeType);
                this.updateDebugInfo();
                
                // Update score
                this.gameState.score += 100;
                document.getElementById('scoreText').textContent = this.gameState.score.toLocaleString();
                
                // Update progress bar using current dock configuration
                const totalShapes = currentLevelConfig.dockShapes.length;
                const progress = (this.gameState.placedShapes.length / totalShapes) * 100;
                document.getElementById('starProgressBar').style.width = progress + '%';
                
                // Update stars based on progress
                this.updateStars(this.gameState.placedShapes.length);
                
                // Check for level completion (start end-level countdown)
                if (this.gameState.placedShapes.length >= totalShapes) {
                    console.log(`🎯 All ${totalShapes} shapes placed! Starting end-level countdown...`);
                    
                    // Coin reward for successfully placing all shapes
                    this.gameState.coins += 5;
                    this.updateCoinDisplay();
                    
                    // Show coin reward particle
                    const coinElement = document.getElementById('coinAmount');
                    this.createFloatingText('+5 All Shapes!', coinElement, '#FFD700');
                    
                    this.gameState.startEndLevelCountdown();
                    this.physicsManager.showEventNotification('End-Level Countdown!', 'balance');
                }
            }

            updateStars(shapesPlaced) {
                const stars = document.querySelectorAll('.star');
                const totalShapes = currentLevelConfig.dockShapes.length;
                const progressPercent = (shapesPlaced / totalShapes) * 100;
                
                // Star thresholds: 33.33%, 66.66%, 100%
                const starThresholds = [33.33, 66.66, 100];
                
                stars.forEach((star, index) => {
                    const threshold = starThresholds[index];
                    const shouldBeFilled = progressPercent >= threshold;
                    
                    if (shouldBeFilled && !star.classList.contains('filled')) {
                        // Star should be filled and isn't yet
                        const wasEmpty = !star.classList.contains('filled');
                        star.classList.add('filled');
                        
                        // Add particle effect for newly filled star
                        if (wasEmpty) {
                            setTimeout(() => {
                                this.createFloatingText('⭐', star, '#FFD700');
                            }, 100);
                        }
                    } else if (!shouldBeFilled && star.classList.contains('filled')) {
                        // Star should not be filled but is
                        star.classList.remove('filled');
                    }
                });
                
                // Update progress bar with animation using current dock configuration
                const progressBar = document.getElementById('starProgressBar');
                
                // Smooth progress bar animation
                progressBar.style.transition = 'width 0.5s ease-out';
                progressBar.style.width = progressPercent + '%';
                
                if (shapesPlaced > 0) {
                    this.animateProgressBar(progressBar);
                }
            }

            updateTimer() {
                if (!this.gameState.isGameActive) return;
                
                const timerElement = document.getElementById('gameTimer');
                
                switch(this.gameState.timerMode) {
                    case 'elapsed':
                        this.updateElapsedTimer(timerElement);
                        break;
                    case 'countdown':
                        this.updateCountdownTimer(timerElement);
                        break;
                    case 'endlevel':
                        this.updateEndLevelTimer(timerElement);
                        break;
                }
            }

            updateElapsedTimer(element) {
                const minutes = Math.floor(this.gameState.gameTime / 60);
                const seconds = this.gameState.gameTime % 60;
                element.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                this.gameState.gameTime++;
                
                // Remove any warning classes
                element.classList.remove('timer-warning', 'timer-critical');
            }

            updateCountdownTimer(element) {
                // Use gameTime for countdown timer (starts from configured time and counts down)
                const minutes = Math.floor(this.gameState.gameTime / 60);
                const seconds = this.gameState.gameTime % 60;
                element.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                
                // Remove previous warning classes
                element.classList.remove('timer-warning', 'timer-critical');
                
                // Add warning effects based on time remaining
                if (this.gameState.gameTime <= 5 && this.gameState.gameTime > 0) {
                    element.classList.add('timer-critical');
                } else if (this.gameState.gameTime <= 10) {
                    element.classList.add('timer-warning');
                }
                
                // Countdown: decrease time
                this.gameState.gameTime--;
                
                // Check if countdown reached zero
                if (this.gameState.gameTime < 0) {
                    this.gameState.gameTime = 0; // Prevent negative display
                    element.textContent = '0:00';
                    
                    // Trigger game over due to time up
                    console.log('⏰ Countdown timer reached zero - Game Over!');
                    this.onGameTimeUp();
                }
            }

            updateEndLevelTimer(element) {
                // Create 3-dot display if it doesn't exist
                if (!element.querySelector('.countdown-dots')) {
                    console.log('🔴 Creating dramatic 3-dot countdown display...');
                    element.innerHTML = '';
                    const dotsContainer = document.createElement('div');
                    dotsContainer.className = 'countdown-dots';
                    
                    for (let i = 0; i < 3; i++) {
                        const dot = document.createElement('div');
                        dot.className = 'countdown-dot';
                        dot.id = `countdown-dot-${i}`;
                        dotsContainer.appendChild(dot);
                    }
                    
                    element.appendChild(dotsContainer);
                    this.gameState.endLevelDots = 0;
                    console.log('✅ 3-dot countdown display created!');
                }
                
                // Update dots based on time remaining using configured duration
                const totalDuration = currentLevelConfig.endLevelDuration;
                const timeElapsed = totalDuration - this.gameState.endLevelTime;
                const dotsToShow = Math.min(3, Math.ceil((timeElapsed / totalDuration) * 3));
                console.log(`🔵 Updating dots: ${dotsToShow} active dots, ${this.gameState.endLevelTime}s remaining (total: ${totalDuration}s)`);
                
                for (let i = 0; i < 3; i++) {
                    const dot = document.getElementById(`countdown-dot-${i}`);
                    if (dot) {
                        if (i < dotsToShow) {
                            if (i === dotsToShow - 1 && this.gameState.endLevelTime > 0) {
                                dot.className = 'countdown-dot active';
                            } else {
                                dot.className = 'countdown-dot completed';
                            }
                        } else {
                            dot.className = 'countdown-dot';
                        }
                    }
                }
                
                this.gameState.endLevelTime--;
                
                if (this.gameState.endLevelTime < 0) {
                    console.log('🏆 End level countdown complete! Level finished!');
                    this.triggerLevelCompleteEffects();
                    this.onLevelComplete();
                }
            }

            updateDebugInfo() {
                const debugInfo = document.getElementById('debugInfo');
                const physicsStats = this.physicsManager.getEventStats();
                const totalShapes = currentLevelConfig.dockShapes.length;
                
                // Fix #4: Count available shapes properly - shapes that are visible and not being dragged
                const availableShapes = document.querySelectorAll('.game-shape:not(.dragging)').length;
                
                debugInfo.textContent = `Placed: ${this.gameState.placedShapes.length}/${totalShapes} | Dock: ${availableShapes}/${totalShapes} | Events: ${physicsStats.events} | FPS: 60`;
            }

            onGameTimeUp() {
                this.gameState.isGameActive = false;
                console.log('⏰ Time Up! Level Failed!');
            }

            onGameOver() {
                this.gameState.isGameActive = false;
                console.log('💀 Game Over! Too many shapes fell.');
            }

            /*╔═══════════════════════════════════════════════════════════════════════════
              ║ SHOW LEVEL CLEARED POPUP
              ║ Displays a celebratory popup modal when the level is successfully cleared.
              ║ Includes animated title, stars, and button to continue or replay level.
              ╚═══════════════════════════════════════════════════════════════════════════*/
            showLevelClearedPopup() {
                // Create modal overlay
                const modal = document.createElement('div');
                modal.className = 'level-cleared-modal';
                modal.id = 'levelClearedModal';
                
                // Create modal content
                const content = document.createElement('div');
                content.className = 'level-cleared-content';
                
                // Title
                const title = document.createElement('div');
                title.className = 'level-cleared-title';
                title.textContent = 'Level Cleared!';
                
                // Subtitle with score info
                const subtitle = document.createElement('div');
                subtitle.className = 'level-cleared-subtitle';
                subtitle.textContent = `Score: ${this.gameState.score} | Coins: ${this.gameState.coins}`;
                
                // Animated stars
                const stars = document.createElement('div');
                stars.className = 'level-cleared-stars';
                stars.textContent = '⭐ ⭐ ⭐';
                
                // Continue button
                const continueBtn = document.createElement('button');
                continueBtn.className = 'level-cleared-button';
                continueBtn.textContent = 'Continue';
                continueBtn.onclick = () => this.closeLevelClearedPopup();
                
                // Replay button
                const replayBtn = document.createElement('button');
                replayBtn.className = 'level-cleared-button';
                replayBtn.textContent = 'Replay Level';
                replayBtn.style.background = 'linear-gradient(135deg, #2196F3 0%, #1976D2 100%)';
                replayBtn.onclick = () => {
                    this.closeLevelClearedPopup();
                    resetLevel();
                };
                
                // Assemble modal
                content.appendChild(title);
                content.appendChild(subtitle);
                content.appendChild(stars);
                content.appendChild(continueBtn);
                content.appendChild(replayBtn);
                modal.appendChild(content);
                
                // Add to page
                document.body.appendChild(modal);
                
                console.log('🎉 Level Cleared popup displayed!');
            }

            closeLevelClearedPopup() {
                const modal = document.getElementById('levelClearedModal');
                if (modal) {
                    modal.style.animation = 'modalFadeIn 0.3s ease-out reverse';
                    setTimeout(() => {
                        modal.remove();
                    }, 300);
                }
            }

            /*╔═══════════════════════════════════════════════════════════════════════════
              ║ TRIGGER LEVEL COMPLETE EFFECTS
              ║ Creates spectacular visual effects when level is completed successfully.
              ║ Includes cascading star effects, screen flash, and celebration particles.
              ╚═══════════════════════════════════════════════════════════════════════════*/
            triggerLevelCompleteEffects() {
                // Flash effect for completion
                const screen = document.querySelector('.screen');
                screen.style.animation = 'levelCompleteFlash 1s ease-out';
                setTimeout(() => {
                    screen.style.animation = '';
                }, 1000);
                
                // Cascade star effects
                const stars = document.querySelectorAll('.star');
                stars.forEach((star, index) => {
                    setTimeout(() => {
                        star.style.animation = 'starBurst 0.8s ease-out';
                        this.createFloatingText('★', star, '#FFD700');
                    }, index * 150);
                });
                
                // Multiple celebration particles
                setTimeout(() => {
                    const scoreElement = document.getElementById('scoreText');
                    const coinElement = document.getElementById('coinAmount');
                    
                    this.createFloatingText('🎉', scoreElement, '#FF6B6B');
                    this.createFloatingText('🎊', coinElement, '#4ECDC4');
                    
                    setTimeout(() => {
                        this.createFloatingText('🏆', scoreElement, '#FFD700');
                    }, 300);
                }, 500);
            }

            onLevelComplete() {
                this.gameState.isGameActive = false;
                this.gameState.levelCompleted = true;
                console.log('🎯 Level Complete! Score: ' + this.gameState.score);
                
                // Sound effect integration point
                this.playSound('levelComplete');
                
                // Bonus points for completion with particle effects
                this.gameState.score += 500;
                this.gameState.coins += 25; // Increased completion bonus
                
                // Show Level Cleared popup immediately
                this.showLevelClearedPopup();
                
                // Advance to next level after a delay
                setTimeout(() => {
                    this.nextLevel();
                }, 3000); // Increased delay to account for popup
                
                // Create floating text for completion bonus
                const scoreElement = document.getElementById('scoreText');
                this.createFloatingText('+500', scoreElement, '#FFD700');
                
                const coinElement = document.getElementById('coinAmount');
                this.createFloatingText('+25 Complete!', coinElement, '#4ECDC4');
                
                // Stability bonus
                const stabilityBonus = Math.floor(this.gameState.stability * 2);
                this.gameState.score += stabilityBonus;
                
                // Stability coin bonus for high stability (80%+)
                if (this.gameState.stability >= 80) {
                    const coinBonus = Math.floor(this.gameState.stability / 10);
                    this.gameState.coins += coinBonus;
                    
                    setTimeout(() => {
                        this.createFloatingText(`+${coinBonus} Stability`, coinElement, '#10B981');
                    }, 750);
                }
                
                if (stabilityBonus > 0) {
                    setTimeout(() => {
                        this.createFloatingText(`+${stabilityBonus} Stability`, scoreElement, '#10B981');
                    }, 500);
                }
                
                // Update display
                this.updateScoreDisplay();
                this.updateCoinDisplay();
                
                // All stars should be filled with animation
                this.updateStars(3);
                const progressBar = document.getElementById('starProgressBar');
                this.animateProgressBar(progressBar);
                
                this.physicsManager.showEventNotification('Level Complete!', 'collision');
            }

            onLevelFailed() {
                this.gameState.isGameActive = false;
                console.log('💀 Level Failed! Shape fell during countdown.');
                this.physicsManager.showEventNotification('Level Failed!', 'fall');
            }

            resetLevel() {
                console.log('🔄 Resetting level...');
                
                // Clear all dynamic physics bodies
                this.physicsManager.cleanup();
                
                // Recreate the platform and boundaries
                this.physicsManager.createPlatform();
                this.physicsManager.createBoundaries();
                
                // Reset game state
                this.gameState.resetLevel();
                
                // Restore all shapes to docking area
                this.restoreAllShapesToDock();
                
                // Reset HUD to initial values
                this.updateScoreDisplay();
                this.updateCoinDisplay();
                document.getElementById('starProgressBar').style.width = '0%';
                document.getElementById('gameTimer').textContent = '0:00';
                
                // Reset timer mode to elapsed
                const modeIndicator = document.getElementById('timerModeIndicator');
                modeIndicator.className = 'timer-mode-indicator timer-mode-elapsed';
                modeIndicator.textContent = '⏱';
                
                // Reset all stars
                document.querySelectorAll('.star').forEach(star => {
                    star.classList.remove('filled');
                });
                
                // Update debug info
                this.updateDebugInfo();
                
                console.log('✅ Level reset complete');
            }

            /*╔═══════════════════════════════════════════════════════════════════════════
              ║ CREATE FLOATING TEXT PARTICLE
              ║ Generates animated floating text particles for visual feedback. Creates
              ║ temporary DOM elements positioned relative to target elements that float
              ║ upward and fade out. Used for score/coin increase notifications.
              ║ Parameters: text - Text to display, element - Reference element, color - Text color
              ╚═══════════════════════════════════════════════════════════════════════════*/
            createFloatingText(text, element, color = '#FFD700') {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.textContent = text;
                particle.style.color = color;
                
                const rect = element.getBoundingClientRect();
                particle.style.left = (rect.left + rect.width / 2) + 'px';
                particle.style.top = rect.top + 'px';
                
                document.body.appendChild(particle);
                
                setTimeout(() => {
                    if (particle.parentNode) {
                        document.body.removeChild(particle);
                    }
                }, 2000);
            }

            /*╔═══════════════════════════════════════════════════════════════════════════
              ║ CREATE COIN SHOWER EFFECT
              ║ Creates a spectacular shower of coin particles for major achievements.
              ║ Multiple floating coins rain down from the coin counter element.
              ║ Used for jackpots, streaks, and other exciting coin-earning events.
              ╚═══════════════════════════════════════════════════════════════════════════*/
            createCoinShower(message, coinCount) {
                const coinElement = document.getElementById('coinAmount');
                const rect = coinElement.getBoundingClientRect();
                
                // Create the main message
                this.createFloatingText(message, coinElement, '#FFD700');
                
                // Create shower of individual coins
                for (let i = 0; i < Math.min(coinCount, 15); i++) {
                    setTimeout(() => {
                        const coin = document.createElement('div');
                        coin.className = 'particle';
                        coin.textContent = '💰';
                        coin.style.fontSize = '20px';
                        coin.style.left = (rect.left + Math.random() * rect.width) + 'px';
                        coin.style.top = rect.top + 'px';
                        coin.style.transform = `translate(${(Math.random() - 0.5) * 200}px, ${Math.random() * -100}px)`;
                        coin.style.opacity = '0';
                        coin.style.transition = 'all 2s ease-out';
                        
                        document.body.appendChild(coin);
                        
                        // Animate the coin
                        setTimeout(() => {
                            coin.style.transform += ` translateY(${Math.random() * 200 + 100}px)`;
                            coin.style.opacity = '1';
                        }, 50);
                        
                        // Remove after animation
                        setTimeout(() => {
                            if (coin.parentNode) {
                                document.body.removeChild(coin);
                            }
                        }, 2500);
                    }, i * 100); // Stagger the coins
                }
            }

            /*╔═══════════════════════════════════════════════════════════════════════════
              ║ PULSE ELEMENT EFFECT
              ║ Makes an element pulse with a glowing effect to draw attention.
              ║ Used for significant coin increases and achievements.
              ╚═══════════════════════════════════════════════════════════════════════════*/
            pulseElement(element, pulses = 3) {
                let count = 0;
                const originalTransform = element.style.transform;
                const originalBoxShadow = element.style.boxShadow;
                
                const pulse = () => {
                    if (count >= pulses) {
                        element.style.transform = originalTransform;
                        element.style.boxShadow = originalBoxShadow;
                        return;
                    }
                    
                    element.style.transform = 'scale(1.2)';
                    element.style.boxShadow = '0 0 20px #FFD700';
                    element.style.transition = 'all 0.2s ease-in-out';
                    
                    setTimeout(() => {
                        element.style.transform = 'scale(1)';
                        element.style.boxShadow = originalBoxShadow;
                        count++;
                        setTimeout(pulse, 300);
                    }, 200);
                };
                
                pulse();
            }

            /*╔═══════════════════════════════════════════════════════════════════════════
              ║ SHAKE ELEMENT EFFECT
              ║ Makes an element shake violently to show dramatic losses or penalties.
              ║ Used when players lose significant amounts of coins.
              ╚═══════════════════════════════════════════════════════════════════════════*/
            shakeElement(element, intensity = 3) {
                const originalTransform = element.style.transform;
                let shakeCount = 0;
                const maxShakes = intensity * 4; // More shakes for higher intensity
                
                const shake = () => {
                    if (shakeCount >= maxShakes) {
                        element.style.transform = originalTransform;
                        element.style.transition = '';
                        return;
                    }
                    
                    const x = (Math.random() - 0.5) * intensity * 4;
                    const y = (Math.random() - 0.5) * intensity * 4;
                    element.style.transform = `translate(${x}px, ${y}px)`;
                    element.style.transition = 'none';
                    
                    shakeCount++;
                    setTimeout(shake, 50);
                };
                
                shake();
            }

            /*╔═══════════════════════════════════════════════════════════════════════════
              ║ ANIMATE PROGRESS BAR
              ║ Provides visual feedback when the progress bar fills. Adds temporary 
              ║ animation class that causes the bar to pulse/glow, then removes it.
              ║ Enhances the user experience when star progress increases.
              ║ Parameters: progressBar - The progress bar DOM element to animate
              ╚═══════════════════════════════════════════════════════════════════════════*/
            animateProgressBar(progressBar) {
                progressBar.classList.add('progress-animate');
                setTimeout(() => progressBar.classList.remove('progress-animate'), 800);
            }

            /*╔═══════════════════════════════════════════════════════════════════════════
              ║ SOUND SYSTEM INTEGRATION POINTS
              ║ Placeholder functions for easy sound effect integration. These functions
              ║ can be enhanced later with actual audio implementation using Web Audio API
              ║ or HTML5 audio elements. Currently logs sound events for development.
              ╚═══════════════════════════════════════════════════════════════════════════*/
            playSound(soundType) {
                // Integration point for sound effects
                // Future enhancement: Load and play actual audio files
                console.log(`🔊 Sound: ${soundType}`);
                
                switch (soundType) {
                    case 'shapeLanding':
                        // Soft landing sound - positive feedback
                        break;
                    case 'shapeCollision':
                        // Click/tap sound - interaction feedback  
                        break;
                    case 'shapeRotation':
                        // Quick whoosh sound - rotation feedback
                        break;
                    case 'coinEarned':
                        // Coin pickup sound - reward feedback
                        break;
                    case 'starFilled':
                        // Bright ding sound - progress feedback
                        break;
                    case 'levelComplete':
                        // Victory fanfare - completion feedback
                        break;
                    case 'levelFailed':
                        // Disappointment sound - failure feedback
                        break;
                    case 'endLevelCountdown':
                        // Ticking sound - tension building
                        break;
                    default:
                        console.log(`Unknown sound type: ${soundType}`);
                }
            }

            restoreAllShapesToDock() {
                // Restore all nine shapes to their dock positions
                const shapes = [
                    { id: 'shape-square', type: 'square', slot: 'slot-square' },
                    { id: 'shape-triangle', type: 'triangle', slot: 'slot-triangle' },
                    { id: 'shape-circle', type: 'circle', slot: 'slot-circle' },
                    { id: 'shape-cross2', type: 'cross2', slot: 'slot-cross2' },
                    { id: 'shape-l', type: 'l', slot: 'slot-l' },
                    { id: 'shape-cross', type: 'cross', slot: 'slot-cross' },
                    { id: 'shape-barbell-one', type: 'barbell-one', slot: 'slot-barbell-one' },
                    { id: 'shape-barbell-two', type: 'barbell-two', slot: 'slot-barbell-two' },
                    { id: 'shape-diamond-barbell', type: 'diamond-barbell', slot: 'slot-diamond-barbell' }
                ];
                
                shapes.forEach(shapeInfo => {
                    const slot = document.getElementById(shapeInfo.slot);
                    if (slot) {
                        slot.classList.remove('empty');
                        
                        // Remove any existing shape in the slot
                        const existingShape = slot.querySelector('.game-shape');
                        if (existingShape) {
                            existingShape.remove();
                        }
                        
                        // Create new shape element
                        const shapeElement = document.createElement('div');
                        shapeElement.className = `game-shape shape-${shapeInfo.type}`;
                        shapeElement.dataset.shape = shapeInfo.type;
                        shapeElement.id = shapeInfo.id;
                        
                        slot.appendChild(shapeElement);
                    }
                });
                
                console.log('🔄 All 9 shapes restored to docking area');
            }
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ PHASE 2: MODE TOGGLE SYSTEM - LEVEL EDITOR FUNCTIONALITY
          ║ Implements the level editor mode toggle system allowing users to switch
          ║ between Play Mode (normal gameplay) and Design Mode (level configuration).
          ║ Includes dock configuration, timer settings, and level parameters.
          ╚═══════════════════════════════════════════════════════════════════════════*/

        // Level configuration state
        let currentMode = 'play';
        let currentLevelConfig = {
            world: 1,
            level: 1,
            timerMode: 'elapsed',
            timerStart: 60,
            endLevelDuration: 5,
            dockSlots: 9,
            barbellOrientation: 'vertical',
            dockShapes: ['square', 'triangle', 'circle', 'cross2', 'l', 'cross', 'barbell-one', 'barbell-two', 'diamond-barbell']
        };

        // Make level config globally available for dock system
        window.currentLevelConfig = currentLevelConfig;

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ TOGGLE MODE SWITCH FUNCTION
          ║ New toggle switch function that switches between Play Mode and Design Mode
          ║ using a compact toggle switch in the HUD instead of separate buttons.
          ╚═══════════════════════════════════════════════════════════════════════════*/
        function toggleModeSwitch() {
            const toggleSwitch = document.getElementById('modeToggleSwitch');
            const slider = toggleSwitch.querySelector('.mode-toggle-slider');
            
            if (currentMode === 'play') {
                toggleMode('design');
                toggleSwitch.classList.add('design-active');
                slider.textContent = '🔧';
            } else {
                toggleMode('play');
                toggleSwitch.classList.remove('design-active');
                slider.textContent = '🎮';
            }
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ TOGGLE MODE FUNCTION (UPDATED)
          ║ Updated to work with new toggle switch instead of separate buttons.
          ╚═══════════════════════════════════════════════════════════════════════════*/
        function toggleMode(mode) {
            const gameContainer = document.getElementById('gameContainer');
            const designSidebar = document.getElementById('designSidebar');
            
            if (mode === 'design') {
                gameContainer.classList.add('design-mode');
                designSidebar.classList.add('active');
                currentMode = 'design';
                
                console.log('🔧 Entered Design Mode - Level Editor Active');
                
                // Sync current dock configuration to design sidebar
                syncDockToDesign();
                generateDockSlots();
            } else {
                gameContainer.classList.remove('design-mode');
                designSidebar.classList.remove('active');
                currentMode = 'play';
                
                console.log('🎮 Entered Play Mode - Game Active');
                
                // Apply any design changes to the play dock
                rebuildGameDock();
            }
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ SYNC DOCK TO DESIGN
          ║ Reads the current dock configuration from the game and updates the design
          ║ sidebar to match. Ensures design mode reflects the actual game state.
          ║ Used when entering design mode to show current level configuration.
          ╚═══════════════════════════════════════════════════════════════════════════*/
        function syncDockToDesign() {
            const currentShapes = [];
            const dockingArea = document.getElementById('dockingArea');
            
            if (dockingArea) {
                const shapes = dockingArea.querySelectorAll('.game-shape');
                shapes.forEach(shape => {
                    const shapeType = shape.getAttribute('data-shape');
                    if (shapeType) {
                        currentShapes.push(shapeType);
                    }
                });
                
                if (currentShapes.length > 0) {
                    currentLevelConfig.dockShapes = currentShapes;
                    currentLevelConfig.dockSlots = currentShapes.length;
                    
                    // Update UI controls
                    const slotCountInput = document.getElementById('dockSlotCount');
                    if (slotCountInput) {
                        slotCountInput.value = currentShapes.length;
                    }
                }
            }
            
            console.log('🔄 Synced current dock to design:', currentLevelConfig.dockShapes);
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ GENERATE DOCK SLOTS
          ║ Creates the dynamic dock slot configuration UI in the design sidebar.
          ║ Generates dropdown selectors for each dock slot allowing shape assignment.
          ║ Preserves existing shape assignments when slot count changes.
          ╚═══════════════════════════════════════════════════════════════════════════*/
        function generateDockSlots() {
            const dockContainer = document.getElementById('dockSlotsContainer');
            const slotCount = parseInt(document.getElementById('dockSlotCount').value);
            
            if (!dockContainer) return;
            
            dockContainer.innerHTML = '';
            
            // Ensure we have enough shapes in the configuration
            const allShapes = ['square', 'triangle', 'circle', 'l', 'cross', 'cross2', 
                              'barbell-one', 'barbell-two', 'diamond-barbell'];
            
            // Preserve existing shapes or use defaults
            if (currentLevelConfig.dockShapes.length !== slotCount) {
                const newShapes = [];
                for (let i = 0; i < slotCount; i++) {
                    if (i < currentLevelConfig.dockShapes.length) {
                        newShapes.push(currentLevelConfig.dockShapes[i]);
                    } else {
                        newShapes.push(allShapes[i % allShapes.length]);
                    }
                }
                currentLevelConfig.dockShapes = newShapes;
            }
            
            // Generate configuration UI for each slot
            for (let i = 0; i < slotCount; i++) {
                const slotDiv = document.createElement('div');
                slotDiv.className = 'dock-slot-config';
                const selectedShape = currentLevelConfig.dockShapes[i];
                
                slotDiv.innerHTML = `
                    <div style="font-weight: bold; margin-bottom: 3px;">Slot ${i + 1}</div>
                    <select onchange="updateDockShape(${i}, this.value)" style="width: 100%; background: rgba(0,0,0,0.3); color: white; border: 1px solid rgba(255,255,255,0.3); padding: 2px;">
                        <option value="square" ${selectedShape === 'square' ? 'selected' : ''}>Square</option>
                        <option value="triangle" ${selectedShape === 'triangle' ? 'selected' : ''}>Triangle</option>
                        <option value="circle" ${selectedShape === 'circle' ? 'selected' : ''}>Circle</option>
                        <option value="l" ${selectedShape === 'l' ? 'selected' : ''}>L-Shape</option>
                        <option value="cross" ${selectedShape === 'cross' ? 'selected' : ''}>Green Cross</option>
                        <option value="cross2" ${selectedShape === 'cross2' ? 'selected' : ''}>Pink Cross</option>
                        <option value="barbell-one" ${selectedShape === 'barbell-one' ? 'selected' : ''}>One-Ended Barbell</option>
                        <option value="barbell-two" ${selectedShape === 'barbell-two' ? 'selected' : ''}>Two-Ended Barbell</option>
                        <option value="diamond-barbell" ${selectedShape === 'diamond-barbell' ? 'selected' : ''}>Diamond Barbell</option>
                    </select>
                `;
                dockContainer.appendChild(slotDiv);
            }
            
            currentLevelConfig.dockSlots = slotCount;
            console.log('🎛️ Generated dock slots configuration:', slotCount);
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ UPDATE DOCK SHAPE
          ║ Updates a specific dock slot's shape assignment in the level configuration.
          ║ Called when user changes shape selection in design sidebar dropdown.
          ║ Parameters: slotIndex - Index of slot to update, shape - New shape type
          ╚═══════════════════════════════════════════════════════════════════════════*/
        function updateDockShape(slotIndex, shape) {
            if (slotIndex < currentLevelConfig.dockShapes.length) {
                currentLevelConfig.dockShapes[slotIndex] = shape;
                console.log(`🔄 Updated slot ${slotIndex + 1} to ${shape}`);
            }
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ UPDATE BARBELL ORIENTATION
          ║ Changes the barbell orientation in the dock (vertical vs horizontal).
          ║ Applies CSS classes to the docking area to control barbell display.
          ║ Called when user changes barbell orientation setting in design sidebar.
          ╚═══════════════════════════════════════════════════════════════════════════*/
        function updateBarbellOrientation() {
            const orientation = document.getElementById('barbellOrientation').value;
            currentLevelConfig.barbellOrientation = orientation;
            
            // Rebuild the dock to apply rotation changes to barbell previews
            rebuildGameDock();
            
            console.log(`🔄 Updated barbell orientation to ${orientation} - dock rebuilt with rotated previews`);
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ APPLY LEVEL CHANGES
          ║ Applies all design sidebar configuration changes to the active game.
          ║ Updates level info, timer settings, and rebuilds the dock layout.
          ║ Provides visual feedback to confirm changes were applied.
          ╚═══════════════════════════════════════════════════════════════════════════*/
        function applyLevelChanges() {
            // Save current configuration from sidebar
            const worldLevelValue = document.getElementById('levelNumber').value;
            const parts = worldLevelValue.split('-');
            currentLevelConfig.world = parseInt(parts[0]) || 1;
            currentLevelConfig.level = parseInt(parts[1]) || 1;
            currentLevelConfig.timerMode = document.getElementById('timerMode').value;
            currentLevelConfig.timerStart = parseInt(document.getElementById('timerStart').value);
            currentLevelConfig.endLevelDuration = parseInt(document.getElementById('endLevelDuration').value);
            
            // Update game UI
            updateGameUI();
            
            // Apply timer changes if countdown mode is selected
            if (currentLevelConfig.timerMode === 'countdown' && window.gameManager && window.gameManager.gameState) {
                const startTime = currentLevelConfig.timerStart || 60;
                window.gameManager.gameState.gameTime = startTime;
                
                // Update timer display
                const timerElement = document.getElementById('gameTimer');
                if (timerElement) {
                    const minutes = Math.floor(startTime / 60);
                    const seconds = startTime % 60;
                    timerElement.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                }
                
                console.log('⏳ Applied countdown timer start value:', startTime);
            }
            
            // Rebuild dock with new configuration
            rebuildGameDock();
            
            // Show feedback
            const btn = document.getElementById('applyChangesBtn');
            const originalText = btn.textContent;
            btn.textContent = 'Applied!';
            btn.style.background = 'linear-gradient(135deg, #27ae60 0%, #229954 100%)';
            setTimeout(() => {
                btn.textContent = originalText;
                btn.style.background = 'linear-gradient(135deg, #27ae60 0%, #229954 100%)';
            }, 1500);
            
            console.log('✅ Applied level changes:', currentLevelConfig);
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ UPDATE TIMER MODE CONFIG
          ║ Updates timer mode configuration when user changes dropdown in design sidebar.
          ║ Immediately applies the new timer mode to current level configuration and UI.
          ╚═══════════════════════════════════════════════════════════════════════════*/
        function updateTimerModeConfig() {
            // Update current level config with new timer mode
            const timerModeSelect = document.getElementById('timerMode');
            currentLevelConfig.timerMode = timerModeSelect.value;
            
            // Update game state if game manager exists
            if (window.gameManager && window.gameManager.gameState) {
                window.gameManager.gameState.timerMode = timerModeSelect.value;
                
                // Initialize timer based on mode
                if (timerModeSelect.value === 'countdown') {
                    // Set countdown timer to start value
                    const startTime = currentLevelConfig.timerStart || 60;
                    window.gameManager.gameState.gameTime = startTime;
                    
                    // Update timer display immediately
                    const timerElement = document.getElementById('gameTimer');
                    if (timerElement) {
                        const minutes = Math.floor(startTime / 60);
                        const seconds = startTime % 60;
                        timerElement.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                    }
                } else if (timerModeSelect.value === 'elapsed') {
                    // Reset to 0 for elapsed timer
                    window.gameManager.gameState.gameTime = 0;
                    
                    // Update timer display immediately
                    const timerElement = document.getElementById('gameTimer');
                    if (timerElement) {
                        timerElement.textContent = '0:00';
                    }
                }
            }
            
            // Update timer UI to reflect new mode
            const modeIndicator = document.getElementById('timerModeIndicator');
            if (modeIndicator && timerModeSelect.value === 'countdown') {
                modeIndicator.className = 'timer-mode-indicator timer-mode-countdown';
                modeIndicator.textContent = '⏳';
            } else if (modeIndicator && timerModeSelect.value === 'elapsed') {
                modeIndicator.className = 'timer-mode-indicator timer-mode-elapsed';
                modeIndicator.textContent = '⏱';
            } else if (modeIndicator && timerModeSelect.value === 'none') {
                modeIndicator.className = 'timer-mode-indicator timer-mode-elapsed';
                modeIndicator.textContent = '⚪';
            }
            
            console.log('🕒 Updated timer mode to:', timerModeSelect.value);
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ UPDATE GAME UI
          ║ Updates the game's UI elements to reflect current level configuration.
          ║ Updates level display and other HUD elements based on design settings.
          ╚═══════════════════════════════════════════════════════════════════════════*/
        function updateGameUI() {
            const levelDisplay = document.getElementById('levelDisplay');
            if (levelDisplay) {
                levelDisplay.textContent = `World ${currentLevelConfig.world}-${currentLevelConfig.level}`;
            }
            
            console.log(`🎮 Updated game UI for World ${currentLevelConfig.world}-${currentLevelConfig.level}`);
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ RESET LEVEL (GLOBAL WRAPPER) - ENHANCED
          ║ Enhanced reset function that properly resets timer, restores shapes to dock,
          ║ and clears physics simulation. Handles both design mode and play mode resets.
          ╚═══════════════════════════════════════════════════════════════════════════*/
        function resetLevel() {
            console.log('🔄 Starting level reset...');
            
            // Clear all shapes from playfield
            if (window.gameManager && window.gameManager.physicsManager) {
                window.gameManager.physicsManager.clearAllShapes();
                console.log('🧹 Cleared physics shapes');
            }
            
            // Reset timer and game state
            if (window.gameManager && window.gameManager.gameState) {
                // Reset timer to 0:00
                window.gameManager.gameState.gameTime = 0;
                window.gameManager.gameState.endLevelTime = currentLevelConfig.endLevelDuration;
                
                // Apply current timer mode from config
                window.gameManager.gameState.timerMode = currentLevelConfig.timerMode || 'elapsed';
                
                // Update timer display
                const timerElement = document.getElementById('gameTimer');
                if (timerElement) {
                    if (currentLevelConfig.timerMode === 'countdown') {
                        // For countdown, start from configured start time
                        const startTime = currentLevelConfig.timerStart || 60;
                        window.gameManager.gameState.gameTime = startTime;
                        const minutes = Math.floor(startTime / 60);
                        const seconds = startTime % 60;
                        timerElement.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                    } else {
                        // For elapsed timer, start at 0:00
                        timerElement.textContent = '0:00';
                    }
                }
                
                // Update timer mode indicator based on current config
                const modeIndicator = document.getElementById('timerModeIndicator');
                if (modeIndicator) {
                    if (currentLevelConfig.timerMode === 'countdown') {
                        modeIndicator.className = 'timer-mode-indicator timer-mode-countdown';
                        modeIndicator.textContent = '⏳';
                    } else if (currentLevelConfig.timerMode === 'elapsed') {
                        modeIndicator.className = 'timer-mode-indicator timer-mode-elapsed';
                        modeIndicator.textContent = '⏱';
                    } else if (currentLevelConfig.timerMode === 'none') {
                        modeIndicator.className = 'timer-mode-indicator timer-mode-elapsed';
                        modeIndicator.textContent = '⚪';
                    }
                }
                
                console.log('⏰ Reset timer and game state with mode:', currentLevelConfig.timerMode);
            }
            
            // Rebuild dock with current configuration (preserves design mode settings)
            rebuildGameDock();
            
            // Force reinitialize drag and drop system after dock rebuild
            if (window.gameManager && window.gameManager.dragDropManager) {
                console.log('🔄 Drag and drop system already initialized');
                
                // Verify all shapes are interactive
                const dockShapes = document.querySelectorAll('.game-shape');
                console.log(`🎯 Found ${dockShapes.length} shapes after reset:`, 
                    Array.from(dockShapes).map(s => s.dataset.shape));
                    
                // Ensure all shapes are visible and interactive
                dockShapes.forEach(shape => {
                    shape.style.visibility = 'visible';
                    shape.classList.remove('dragging', 'ghost-active');
                });
            }
            
            // Reset additional game state elements
            if (window.gameManager) {
                // Reset shape counters
                if (window.gameManager.gameState) {
                    window.gameManager.gameState.shapesPlaced = 0;
                    window.gameManager.gameState.isGameActive = true;
                    window.gameManager.gameState.isLevelComplete = false;
                    window.gameManager.gameState.isGameOver = false;
                    
                    // Reset placed shapes array - this fixes the "placed" count not resetting
                    window.gameManager.gameState.placedShapes = [];
                    
                    // Fix #2: Reset score and coins to zero
                    window.gameManager.gameState.score = 0;
                    window.gameManager.gameState.coins = 0;
                    
                    // Update displays
                    document.getElementById('scoreText').textContent = '0';
                    document.getElementById('coinAmount').textContent = '0';
                }
                
                // Reset progress bar
                const progressBar = document.getElementById('starProgressBar');
                if (progressBar) {
                    progressBar.style.width = '0%';
                }
                
                // Reset stars
                document.querySelectorAll('.star').forEach(star => {
                    star.classList.remove('filled');
                });
                
                console.log('🎮 Reset game state elements including score and coins');
            }
            
            // Update debug info to reflect reset state
            if (window.gameManager && window.gameManager.updateDebugInfo) {
                window.gameManager.updateDebugInfo();
            }
            
            console.log('✅ Level reset completed');
        }

        // Global functions for HUD interactions
        function switchTimerMode() {
            console.log('🔄 Timer mode switch requested');
        }

        function initializeProgressBarInteraction() {
            console.log('⭐ Progress bar interaction');
        }

        function animateCoin() {
            console.log('💰 Coin animation triggered');
        }

        // Mobile Debug Toggle for Testing
        let mobileDebugMode = false;
        let originalMobileDetection = null;
        function toggleMobileDebug() {
            mobileDebugMode = !mobileDebugMode;
            const button = document.getElementById('mobileDebugButton');
            
            if (!window.gameManager?.mobileEnhancementManager) {
                console.log('❌ Mobile enhancement manager not found');
                console.log('Available gameManager properties:', Object.keys(window.gameManager || {}));
                return;
            }
            
            const mobileManager = window.gameManager.mobileEnhancementManager;
            
            if (mobileDebugMode) {
                // Store original detection result
                if (originalMobileDetection === null) {
                    originalMobileDetection = mobileManager.detectMobileDevice();
                }
                
                // Force mobile mode
                window.gameManager.dragDropManager.isMobileDevice = true;
                mobileManager.isMobileDevice = true;
                
                // Enable mouse support for testing on desktop
                mobileManager.enableMouseSupport();
                
                // Update rotation zone bounds and show zones
                mobileManager.updateRotationZoneBounds();
                mobileManager.showRotationZones();
                
                button.style.background = 'linear-gradient(135deg, #27ae60 0%, #2ecc71 100%)';
                button.title = 'Mobile Debug: ON (Click to disable)';
                console.log('📱 Mobile Debug Mode: ON - Rotation zones should be visible');
                console.log('📱 Rotation zones bounds:', {
                    left: mobileManager.rotationZones.left.bounds,
                    right: mobileManager.rotationZones.right.bounds
                });
            } else {
                // Restore original detection
                const originalDetection = originalMobileDetection || mobileManager.detectMobileDevice();
                window.gameManager.dragDropManager.isMobileDevice = originalDetection;
                mobileManager.isMobileDevice = originalDetection;
                
                // Disable mouse support
                mobileManager.disableMouseSupport();
                
                if (!originalDetection) {
                    mobileManager.hideRotationZones();
                }
                
                button.style.background = 'linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%)';
                button.title = 'Mobile Debug: OFF (Click to enable)';
                console.log('📱 Mobile Debug Mode: OFF');
            }
        }

        // Global level management functions (for console testing)
        function nextLevel() {
            if (window.gameManager) {
                window.gameManager.nextLevel();
            }
        }

        function nextWorld() {
            if (window.gameManager) {
                window.gameManager.nextWorld();
            }
        }

        function setLevel(world, level) {
            if (window.gameManager) {
                window.gameManager.setLevel(world, level);
            }
        }

        /*╔═══════════════════════════════════════════════════════════════════════════
          ║ v9: CANVAS ENHANCEMENT THEME MANAGEMENT FUNCTIONS
          ║ User interface functions for theme switching and canvas configuration
          ╚═══════════════════════════════════════════════════════════════════════════*/

        // Theme switching function called from UI
        function changeTheme() {
            const themeSelector = document.getElementById('themeSelector');
            const selectedTheme = themeSelector.value;
            
            if (window.gameManager && window.gameManager.themeManager) {
                // Premium themes cost coins (optional enhancement)
                const premiumThemes = ['neon', 'ocean', 'cosmic', 'forest'];
                const isCurrentTheme = window.currentTheme && window.currentTheme.name === selectedTheme;
                const themeCost = premiumThemes.includes(selectedTheme) ? 10 : 0;
                
                if (!isCurrentTheme && themeCost > 0 && window.gameManager.gameState.coins >= themeCost) {
                    // Spend coins for premium theme
                    window.gameManager.gameState.coins -= themeCost;
                    window.gameManager.updateCoinDisplay();
                    
                    const coinElement = document.getElementById('coinAmount');
                    window.gameManager.createFloatingText(`-${themeCost} Theme`, coinElement, '#FF6B6B');
                    window.gameManager.createFloatingText('🎨 PREMIUM!', coinElement, '#FFD700');
                    
                    console.log(`💰 Purchased premium theme "${selectedTheme}" for ${themeCost} coins`);
                } else if (!isCurrentTheme && themeCost > 0) {
                    // Not enough coins for premium theme
                    console.log(`❌ Need ${themeCost} coins for premium theme "${selectedTheme}"`);
                    const coinElement = document.getElementById('coinAmount');
                    window.gameManager.createFloatingText(`Need ${themeCost} coins!`, coinElement, '#FF6B6B');
                    window.gameManager.shakeElement(coinElement, 2);
                    return;
                }
                
                window.gameManager.themeManager.switchTheme(selectedTheme, true);
                console.log(`🎨 Theme changed to: ${selectedTheme}${themeCost > 0 ? ' (Premium)' : ''}`);
            }
        }

        // Toggle canvas enhancements on/off
        function toggleCanvasEnhancements() {
            const enableCanvas = document.getElementById('enableCanvas');
            CANVAS_CONFIG.enabled = enableCanvas.checked;
            
            console.log(`🎨 Canvas enhancements: ${CANVAS_CONFIG.enabled ? 'ON' : 'OFF'}`);
            
            // Apply change immediately
            if (window.gameManager) {
                if (CANVAS_CONFIG.enabled) {
                    // Re-initialize current theme
                    const currentTheme = window.gameManager.themeManager.getCurrentTheme();
                    window.gameManager.themeManager.switchTheme(currentTheme, false);
                } else {
                    // Reset to basic appearance
                    window.gameManager.physicsManager.backgroundGradient = null;
                }
            }
        }

        // Toggle particle effects
        function toggleParticleEffects() {
            const enableParticles = document.getElementById('enableParticles');
            CANVAS_CONFIG.useParticles = enableParticles.checked;
            
            console.log(`🎨 Particle effects: ${CANVAS_CONFIG.useParticles ? 'ON' : 'OFF'}`);
            
            if (!CANVAS_CONFIG.useParticles && window.gameManager) {
                // Clear existing particles
                window.gameManager.physicsManager.particleSystem.particles = [];
            }
        }

        // Touch offset configuration functions
        function toggleTouchOffset() {
            const enableTouchOffset = document.getElementById('enableTouchOffset');
            if (window.gameManager && window.gameManager.dragDropManager) {
                const currentOffset = window.gameManager.dragDropManager.getTouchOffset();
                window.gameManager.dragDropManager.setTouchOffset(
                    currentOffset.x, 
                    currentOffset.y, 
                    enableTouchOffset.checked
                );
                console.log(`📱 Touch offset: ${enableTouchOffset.checked ? 'ON' : 'OFF'}`);
            }
        }

        function updateTouchOffset() {
            const offsetX = parseInt(document.getElementById('touchOffsetX').value);
            const offsetY = parseInt(document.getElementById('touchOffsetY').value);
            const enabled = document.getElementById('enableTouchOffset').checked;
            
            if (window.gameManager && window.gameManager.dragDropManager) {
                window.gameManager.dragDropManager.setTouchOffset(offsetX, offsetY, enabled);
                updateTouchOffsetDisplay();
                console.log(`📱 Touch offset updated: X=${offsetX}px, Y=${offsetY}px`);
            }
        }

        function updateTouchOffsetDisplay() {
            const offsetX = document.getElementById('touchOffsetX').value;
            const offsetY = document.getElementById('touchOffsetY').value;
            
            document.getElementById('touchOffsetXValue').textContent = `${offsetX}px`;
            document.getElementById('touchOffsetYValue').textContent = `${offsetY}px`;
        }

        // Toggle shape animations  
        function toggleAnimations() {
            const enableAnimations = document.getElementById('enableAnimations');
            CANVAS_CONFIG.useAnimations = enableAnimations.checked;
            
            console.log(`🎨 Shape animations: ${CANVAS_CONFIG.useAnimations ? 'ON' : 'OFF'}`);
        }

        // Initialize theme selector UI state
        function initializeThemeUI() {
            // Set initial checkbox states
            document.getElementById('enableCanvas').checked = CANVAS_CONFIG.enabled;
            document.getElementById('enableParticles').checked = CANVAS_CONFIG.useParticles;
            document.getElementById('enableAnimations').checked = CANVAS_CONFIG.useAnimations;
            
            // Set initial theme
            document.getElementById('themeSelector').value = CANVAS_CONFIG.defaultTheme;
            
            console.log('🎨 Theme UI initialized');
        }

        // Test function to cycle through all themes (for development)
        function testAllThemes() {
            if (!window.gameManager) return;
            
            const themes = Object.keys(THEME_DEFINITIONS);
            let currentIndex = 0;
            
            const cycleTheme = () => {
                const theme = themes[currentIndex];
                window.gameManager.themeManager.switchTheme(theme, true);
                document.getElementById('themeSelector').value = theme;
                
                console.log(`🎨 Testing theme: ${theme}`);
                
                currentIndex = (currentIndex + 1) % themes.length;
                
                if (currentIndex !== 0) {
                    setTimeout(cycleTheme, 3000); // Change every 3 seconds
                }
            };
            
            cycleTheme();
        }

        // Test particle effects manually
        function testParticles() {
            if (!window.gameManager || !window.gameManager.physicsManager) {
                console.log('❌ Game not initialized yet');
                return;
            }
            
            const particleSystem = window.gameManager.physicsManager.particleSystem;
            const canvas = window.gameManager.physicsManager.canvas;
            
            console.log('🎆 Creating test particle burst!');
            
            // Create a big burst in the center of the canvas
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            particleSystem.createThemeParticles('test', centerX, centerY, 20);
            
            // Create smaller bursts around the edges
            setTimeout(() => {
                particleSystem.createThemeParticles('test', 100, 100, 10);
                particleSystem.createThemeParticles('test', canvas.width - 100, 100, 10);
                particleSystem.createThemeParticles('test', centerX, canvas.height - 100, 10);
            }, 500);
            
            console.log(`🎆 Created particle test burst! Current particle count: ${particleSystem.particles.length}`);
        }

        // =============================================================================
        // DYNAMIC COIN BONUS SYSTEM
        // =============================================================================

        function startCoinBonusSystem() {
            // Random coin bonuses every 15-30 seconds
            setInterval(() => {
                if (!gameManager || !gameManager.gameState.isGameActive) return;
                
                const randomEvent = Math.random();
                const coinElement = document.getElementById('coinAmount');
                
                if (randomEvent < 0.3) { // 30% chance
                    // Small bonus coins
                    const bonus = Math.floor(Math.random() * 3) + 1; // 1-3 coins
                    gameManager.gameState.coins += bonus;
                    gameManager.updateCoinDisplay();
                    gameManager.createFloatingText(`🎁 +${bonus}`, coinElement, '#32CD32');
                    console.log(`🎁 Random coin bonus: +${bonus}`);
                    
                } else if (randomEvent < 0.35) { // 5% chance
                    // Medium jackpot
                    const jackpot = Math.floor(Math.random() * 8) + 5; // 5-12 coins
                    gameManager.gameState.coins += jackpot;
                    gameManager.updateCoinDisplay();
                    gameManager.createCoinShower('LUCKY BONUS!', jackpot);
                    console.log(`🍀 Lucky bonus: +${jackpot} coins`);
                    
                } else if (randomEvent < 0.37) { // 2% chance  
                    // Big jackpot
                    const megaJackpot = Math.floor(Math.random() * 15) + 10; // 10-24 coins
                    gameManager.gameState.coins += megaJackpot;
                    gameManager.updateCoinDisplay();
                    gameManager.createCoinShower('MEGA JACKPOT!', megaJackpot);
                    gameManager.pulseElement(coinElement, 5);
                    console.log(`💎 MEGA JACKPOT: +${megaJackpot} coins`);
                }
            }, Math.random() * 15000 + 15000); // Every 15-30 seconds
            
            // Stability bonus system - rewards for keeping shapes stable
            setInterval(() => {
                if (!gameManager || !gameManager.gameState.isGameActive) return;
                if (gameManager.gameState.placedShapes.length === 0) return;
                
                // Check if shapes haven't fallen recently
                const timeSinceLastFall = Date.now() - (gameManager.gameState.lastFallTime || 0);
                if (timeSinceLastFall > 30000) { // 30 seconds of stability
                    const stabilityBonus = Math.floor(Math.random() * 4) + 2; // 2-5 coins
                    gameManager.gameState.coins += stabilityBonus;
                    gameManager.updateCoinDisplay();
                    
                    const coinElement = document.getElementById('coinAmount');
                    gameManager.createFloatingText(`⚖️ STABLE +${stabilityBonus}`, coinElement, '#4ECDC4');
                    console.log(`⚖️ Stability bonus: +${stabilityBonus} coins`);
                }
            }, 30000); // Check every 30 seconds
            
            console.log('🎰 Dynamic coin bonus system activated!');
        }

        // Initialize game when page loads
        let gameManager;
        
        window.addEventListener('load', () => {
            console.log('🌍 Page loaded, starting initialization...');
            console.log('🔧 Current level config:', window.currentLevelConfig);
            console.log('🎨 Shape renderer available:', !!shapeRenderer);
            
            // v9: Initialize Canvas Enhancement UI
            initializeThemeUI();
            
            // Test shape configuration
            console.log('🧪 Testing shape configs:');
            const testShapes = ['square', 'triangle', 'circle'];
            testShapes.forEach(shape => {
                const config = getShapeConfig(shape);
                console.log(`${shape} config:`, config);
            });
            
            // Initialize unified dock system using existing config
            rebuildGameDock();
            
            gameManager = new GameManager();
            
            // Initialize touch offset display values
            updateTouchOffsetDisplay();
            
            // Start dynamic coin bonus system
            startCoinBonusSystem();
            
            // Phase 2: Initialize mode toggle system
            generateDockSlots();
            updateGameUI();
            console.log('🎮 Canvas Enhancement Edition v9 - INITIALIZATION COMPLETE!');
            console.log('✅ UNIFIED SHAPE CONFIGURATION implemented');
            console.log('✅ CANVAS-BASED DOCK PREVIEWS implemented');  
            console.log('🎯 All shapes now use single physics-based appearance system');
            console.log('�️ Features: Angled platform, rotation, end-level countdown, level failure');
            console.log('🎯 Game Rules: Place 3 shapes → 5s countdown starts → don\'t let any fall!');
            console.log('🖱️ Controls: Drag shapes, R/E or ←/→ to rotate during drag');
            console.log('⌨️ Keyboard Shortcuts: 1=Square, 2=Triangle, 3=Circle, 4=Pink Cross, 5=Orange L, 6=Green Cross, 7=Barbell-1, 8=Barbell-2, 9=Diamond Barbell');
            console.log('🎨 Theme Testing: Call testAllThemes() in console to cycle through all themes');
            console.log('🎆 Particle Testing: Call testParticles() in console to see particle effects');
            console.log('🖼️ Image Texture Functions: loadShapeTexture(), loadPlatformTexture(), loadBackgroundImage(), testSampleTextures()');
            console.log('📹 Camera Shake Testing: testCameraShake(), simulateShapeFall(), cameraShake(intensity, duration)');
        });

        // =============================================================================
        // IMAGE TEXTURE HELPER FUNCTIONS
        // =============================================================================

        /**
         * Load a texture image for shapes
         * @param {string} imageUrl - URL or path to the image
         * @param {string} shapeName - Name of shape ('square', 'triangle', 'circle', etc.)
         * @param {Object} options - Texture options
         * @returns {Promise<boolean>} Success/failure
         */
        async function loadShapeTexture(imageUrl, shapeName = 'square', options = {}) {
            try {
                console.log(`🖼️ Loading texture for ${shapeName}: ${imageUrl}`);
                
                // Default texture options
                const textureConfig = {
                    url: imageUrl,
                    repeat: options.repeat || 'repeat',
                    blendMode: options.blendMode || 'source-over',
                    opacity: options.opacity || 1.0,
                    scale: options.scale || 1.0
                };

                // Add texture to current theme
                if (!window.currentTheme.shapes.textures) {
                    window.currentTheme.shapes.textures = {};
                }
                window.currentTheme.shapes.textures[shapeName] = textureConfig;

                // Load the image
                const success = await window.assetManager.loadImage(imageUrl);
                if (success) {
                    console.log(`✅ Texture loaded successfully for ${shapeName}`);
                    return true;
                } else {
                    console.warn(`❌ Failed to load texture for ${shapeName}`);
                    return false;
                }
            } catch (error) {
                console.error(`❌ Error loading texture for ${shapeName}:`, error);
                return false;
            }
        }

        /**
         * Load a texture image for platforms
         * @param {string} imageUrl - URL or path to the image
         * @param {Object} options - Texture options
         * @returns {Promise<boolean>} Success/failure
         */
        async function loadPlatformTexture(imageUrl, options = {}) {
            try {
                console.log(`🖼️ Loading platform texture: ${imageUrl}`);
                
                // Default texture options
                const textureConfig = {
                    url: imageUrl,
                    repeat: options.repeat || 'repeat',
                    blendMode: options.blendMode || 'source-over',
                    opacity: options.opacity || 1.0,
                    scale: options.scale || 1.0
                };

                // Add texture to current theme
                window.currentTheme.platform.image = textureConfig;

                // Load the image
                const success = await window.assetManager.loadImage(imageUrl);
                if (success) {
                    console.log(`✅ Platform texture loaded successfully`);
                    return true;
                } else {
                    console.warn(`❌ Failed to load platform texture`);
                    return false;
                }
            } catch (error) {
                console.error(`❌ Error loading platform texture:`, error);
                return false;
            }
        }

        /**
         * Load a background image
         * @param {string} imageUrl - URL or path to the image
         * @param {Object} options - Background options
         * @returns {Promise<boolean>} Success/failure
         */
        async function loadBackgroundImage(imageUrl, options = {}) {
            try {
                console.log(`🖼️ Loading background image: ${imageUrl}`);
                
                // Default background options
                const backgroundConfig = {
                    url: imageUrl,
                    mode: options.mode || 'cover', // 'cover', 'contain', 'stretch', 'tile'
                    opacity: options.opacity || 1.0,
                    blur: options.blur || 0,
                    brightness: options.brightness || 1.0
                };

                // Add background to current theme
                window.currentTheme.background.image = backgroundConfig;

                // Load the image
                const success = await window.assetManager.loadImage(imageUrl);
                if (success) {
                    console.log(`✅ Background image loaded successfully`);
                    return true;
                } else {
                    console.warn(`❌ Failed to load background image`);
                    return false;
                }
            } catch (error) {
                console.error(`❌ Error loading background image:`, error);
                return false;
            }
        }

        /**
         * Test sample textures with placeholder images
         */
        async function testSampleTextures() {
            console.log('🧪 Testing sample textures...');
            
            try {
                // Test background image
                await loadBackgroundImage('https://picsum.photos/1200/800?random=1', { mode: 'cover' });
                
                // Test platform texture
                await loadPlatformTexture('https://picsum.photos/200/50?random=2', { repeat: 'repeat-x' });
                
                // Test shape textures
                await loadShapeTexture('https://picsum.photos/100/100?random=3', 'square', { blendMode: 'multiply' });
                await loadShapeTexture('https://picsum.photos/100/100?random=4', 'circle', { blendMode: 'overlay' });
                await loadShapeTexture('https://picsum.photos/100/100?random=5', 'triangle', { blendMode: 'soft-light' });
                
                console.log('✅ Sample textures loaded! Drop some shapes to see the effect.');
                
            } catch (error) {
                console.error('❌ Error testing sample textures:', error);
            }
        }

        /**
         * Clear all textures and return to gradient/solid colors
         */
        function clearAllTextures() {
            console.log('🧹 Clearing all textures...');
            
            // Clear background image
            if (window.currentTheme.background.image) {
                delete window.currentTheme.background.image;
            }
            
            // Clear platform texture
            if (window.currentTheme.platform.image) {
                delete window.currentTheme.platform.image;
            }
            
            // Clear shape textures
            if (window.currentTheme.shapes.textures) {
                delete window.currentTheme.shapes.textures;
            }
            
            console.log('✅ All textures cleared - back to gradients and solid colors');
        }

        /**
         * Show texture configuration examples
         */
        function showTextureExamples() {
            console.log(`
🖼️ TEXTURE CONFIGURATION EXAMPLES:

1. Load Background Image:
   await loadBackgroundImage('path/to/background.jpg', {
       mode: 'cover',      // 'cover', 'contain', 'stretch', 'tile'
       opacity: 0.8,       // 0.0 to 1.0
       blur: 2,            // blur amount in pixels
       brightness: 1.2     // brightness multiplier
   });

2. Load Platform Texture:
   await loadPlatformTexture('path/to/wood.jpg', {
       repeat: 'repeat-x', // 'repeat', 'repeat-x', 'repeat-y', 'no-repeat'
       blendMode: 'multiply',
       opacity: 0.9,
       scale: 1.5
   });

3. Load Shape Textures:
   await loadShapeTexture('path/to/metal.jpg', 'square', {
       repeat: 'repeat',
       blendMode: 'overlay',  // Try: 'multiply', 'overlay', 'soft-light', 'hard-light'
       opacity: 0.7,
       scale: 2.0
   });

4. Test Sample Textures:
   testSampleTextures();

5. Clear All Textures:
   clearAllTextures();

6. Multiple Shape Textures:
   await loadShapeTexture('stone.jpg', 'square');
   await loadShapeTexture('fabric.jpg', 'circle');
   await loadShapeTexture('paper.jpg', 'triangle');

BLEND MODES: source-over, multiply, screen, overlay, darken, lighten, 
             color-dodge, color-burn, hard-light, soft-light, difference, exclusion

IMAGE SOURCES: Local files, URLs, data URLs, or any valid image source
            `);
        }

        // Make functions globally available
        window.loadShapeTexture = loadShapeTexture;
        window.loadPlatformTexture = loadPlatformTexture;
        window.loadBackgroundImage = loadBackgroundImage;
        window.testSampleTextures = testSampleTextures;
        window.clearAllTextures = clearAllTextures;
        window.showTextureExamples = showTextureExamples;

        // =============================================================================
        // CAMERA SHAKE TESTING FUNCTIONS
        // =============================================================================

        /**
         * Test camera shake with different intensities
         */
        function testCameraShake() {
            if (!window.gameManager || !window.gameManager.physicsManager) {
                console.log('❌ Game not initialized yet');
                return;
            }

            console.log('📹 Testing camera shake effects...');
            
            // Immediate intense shake to show it works
            console.log('🔴 INTENSE SHAKE NOW!');
            window.gameManager.physicsManager.startCameraShake(15, 1000);
            
            // Then test sequence
            setTimeout(() => {
                console.log('🔸 Light shake (intensity 5)');
                window.gameManager.physicsManager.startCameraShake(5, 600);
            }, 2000);
            
            setTimeout(() => {
                console.log('🔹 Medium shake (intensity 8)');
                window.gameManager.physicsManager.startCameraShake(8, 800);
            }, 4000);
            
            setTimeout(() => {
                console.log('🔴 Maximum shake (intensity 20)');
                window.gameManager.physicsManager.startCameraShake(20, 1000);
            }, 6500);
            
            console.log('📹 Camera shake test sequence started with immediate intense shake!');
        }

        /**
         * Simulate shape falling for camera shake
         */
        function simulateShapeFall() {
            if (!window.gameManager || !window.gameManager.physicsManager) {
                console.log('❌ Game not initialized yet');
                return;
            }

            console.log('💥 Simulating shape fall...');
            window.gameManager.physicsManager.onShapeFellOffPlatform();
            console.log('📹 Shape fall camera shake triggered!');
        }

        /**
         * Custom camera shake with user parameters
         */
        function cameraShake(intensity = 5, duration = 500) {
            if (!window.gameManager || !window.gameManager.physicsManager) {
                console.log('❌ Game not initialized yet');
                return;
            }

            window.gameManager.physicsManager.startCameraShake(intensity, duration);
            console.log(`📹 Camera shake: intensity=${intensity}, duration=${duration}ms`);
        }

        /**
         * Quick test - immediate strong shake
         */
        function shakeNow() {
            console.log('🧪 shakeNow() called - testing camera shake system...');
            
            if (!window.gameManager || !window.gameManager.physicsManager) {
                console.log('❌ Game not initialized yet');
                return;
            }
            
            console.log('✅ Game manager and physics manager found');
            window.gameManager.physicsManager.startCameraShake(20, 1000);
            console.log('💥 MAXIMUM SHAKE ACTIVATED!');
        }

        /**
         * Test camera shake by directly calling the function
         */
        function testDirectShake() {
            console.log('🧪 testDirectShake() - bypassing all collision detection...');
            
            if (!window.gameManager) {
                console.log('❌ Game not initialized yet');
                return;
            }
            
            // Directly call onShapeFell to test the entire chain
            console.log('✅ Directly calling onShapeFell...');
            window.gameManager.onShapeFell();
        }

        /**
         * Test camera shake by simulating a shape falling off screen
         */
        function testShapeFall() {
            console.log('🧪 testShapeFall() called - simulating shape fall...');
            
            if (!window.gameManager) {
                console.log('❌ Game not initialized yet');
                return;
            }
            
            console.log('✅ Game manager found, calling onShapeFell...');
            window.gameManager.onShapeFell();
            console.log('🍃 Simulated shape fall with camera shake!');
        }

        /**
         * Show camera shake examples
         */
        function showCameraShakeExamples() {
            console.log(`
📹 CAMERA SHAKE EXAMPLES:

1. Test Different Intensities:
   testCameraShake();

2. Simulate Shape Fall:
   simulateShapeFall();

3. Custom Camera Shake:
   cameraShake(7, 800);    // Intensity 7, 800ms duration
   cameraShake(3, 300);    // Light shake, 300ms
   cameraShake(10, 1000);  // Maximum intensity, 1 second

4. Intensity Guide:
   1-3:  Light shake (subtle feedback)
   4-6:  Medium shake (noticeable effect) 
   7-9:  Heavy shake (dramatic effect)
   10+:  Maximum shake (screen earthquake!)

5. Duration Guide:
   200-400ms: Quick feedback
   500-800ms: Standard effect
   1000ms+:   Extended shake

The camera shake automatically triggers when shapes fall off screen!
Try dropping a shape off the edge to see it in action.
            `);
        }

        // Make camera shake functions globally available
        window.testCameraShake = testCameraShake;
        window.simulateShapeFall = simulateShapeFall;
        window.cameraShake = cameraShake;
        window.showCameraShakeExamples = showCameraShakeExamples;

    </script>
</body>
</html>
