<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>BSH Game - Physics Puzzle Game v14 - Unified PixiJS System</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }

        html {
            overflow: hidden; /* Prevent scrolling on the game */
            height: 100%;
        }

        @import url('https://fonts.googleapis.com/css2?family=Fredoka:wght@400;500;600;700&display=swap');
        
        body {
            font-family: 'Fredoka', sans-serif;
            background: linear-gradient(135deg, #87CEEB 0%, #98FB98 100%);
            height: 100vh;
            height: 100dvh; /* Dynamic viewport height for mobile */
            overflow: hidden; /* Prevent scrolling */
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* New Responsive Game Viewport */
        .game-viewport {
            width: 100vw;
            height: 100vh;
            height: 100dvh;
            display: flex;
            flex-direction: column;
            max-width: min(100vw, 500px); /* Cap width at 500px on desktop */
            max-height: min(100vh, 889px); /* 500 * 16/9 for aspect ratio */
            margin: 0 auto;
            background: linear-gradient(135deg, #FF6B6B 0%, #4ECDC4 100%);
            position: relative;
            aspect-ratio: 9/16;
            overflow: visible; /* Allow dragged elements to extend beyond viewport */
            box-shadow: 0 0 50px rgba(0,0,0,0.3);
        }

        /* Border system for larger screens */
        @media (min-width: 501px) {
            body {
                background: linear-gradient(135deg, #87CEEB 0%, #98FB98 100%);
                padding: 20px;
            }
            
            .game-viewport {
                border-radius: 20px;
                box-shadow: 0 10px 50px rgba(0,0,0,0.4);
            }
        }

        /* Game HUD - Top Section */
        .game-hud {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: clamp(70px, 12vh, 90px); /* Responsive height */
            background: linear-gradient(135deg, #FF6B6B 0%, #4ECDC4 100%);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: clamp(6px, 2vw, 15px); /* Responsive padding */
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 100;
        }

        /* Left Section - Score and Star Meter */
        .left-section {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            color: white;
            font-weight: bold;
            justify-content: space-between;
            height: 100%;
            min-width: 0; /* Prevent flex overflow */
        }

        .score-display {
            display: flex;
            align-items: center;
            gap: clamp(4px, 1.5vw, 8px); /* Responsive gap */
            margin-bottom: 3px;
        }

        .trophy-icon {
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
            width: clamp(18px, 4vw, 24px); /* Responsive icon size */
            height: clamp(18px, 4vw, 24px);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(8px, 2vw, 12px); /* Responsive font */
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            border: 2px solid #B8860B;
            flex-shrink: 0; /* Prevent shrinking */
        }

        .score-text {
            font-size: clamp(14px, 4vw, 18px); /* Responsive font size */
            font-weight: 700;
            color: #FFE4B5;
            text-shadow: 0 2px 4px rgba(0,0,0,0.4);
            white-space: nowrap; /* Prevent text wrapping */
        }

        .star-progress-container {
            position: relative;
            width: clamp(100px, 25vw, 140px); /* Responsive width */
            height: clamp(14px, 3vw, 18px); /* Responsive height */
            background: rgba(255,255,255,0.25);
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.3);
            overflow: hidden;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.3);
            cursor: pointer; /* Indicate interactivity */
        }

        .progress-area {
            position: relative;
            width: clamp(100px, 25vw, 140px); /* Match container width */
            height: clamp(28px, 6vw, 36px); /* Responsive height for better touch */
        }

        .star-progress-container {
            margin-top: clamp(12px, 3vw, 18px); /* Responsive margin */
        }

        .star-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #8B5CF6 0%, #A855F7 50%, #C084FC 100%);
            border-radius: 7px;
            transition: width 0.8s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            box-shadow: 0 0 6px rgba(139, 92, 246, 0.6);
        }

        /* White progress markers inside the bar */
        .progress-markers {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 100%;
            pointer-events: none;
            z-index: 2;
        }

        .progress-marker {
            position: absolute;
            top: 0;
            width: 2px;
            height: 100%;
            background: rgba(255,255,255,0.8);
            border-radius: 1px;
        }

        .progress-marker:nth-child(1) {
            left: 33.33%;
            transform: translateX(-50%);
        }

        .progress-marker:nth-child(2) {
            left: 66.66%;
            transform: translateX(-50%);
        }

        .progress-marker:nth-child(3) {
            left: 90%;
            transform: translateX(-50%);
        }

        .star-markers {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 16px;
            width: 120px;
            pointer-events: none;
            z-index: 10;
        }

        .star {
            width: 14px;
            height: 14px;
            background: rgba(255,255,255,0.3);
            clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%);
            box-shadow: 0 2px 6px rgba(0,0,0,0.5);
            border: 1px solid rgba(255,255,255,0.6);
            transition: all 0.5s ease;
            position: absolute;
        }

        /* Position stars directly above the white markers */
        .star:nth-child(1) {
            left: 33.33%;
            transform: translateX(-50%);
        }

        .star:nth-child(2) {
            left: 66.66%;
            transform: translateX(-50%);
        }

        .star:nth-child(3) {
            left: 90%;
            transform: translateX(-50%);
        }

        .star.filled {
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
            border: 2px solid #B8860B;
            transform: translateX(-50%) scale(1.3);
            box-shadow: 0 0 20px rgba(255, 215, 0, 1), 0 2px 6px rgba(0,0,0,0.6);
            animation: starPulse 0.5s ease-out;
            z-index: 15;
        }

        /* Middle Section - Timer */
        .middle-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            gap: clamp(3px, 1vw, 6px); /* Responsive gap */
            min-width: 0; /* Prevent overflow */
        }

        /* Level Display */
        .level-display {
            font-size: clamp(11px, 3vw, 14px); /* Responsive font size */
            font-weight: 600;
            color: #FFE4B5;
            text-shadow: 0 1px 2px rgba(0,0,0,0.4);
            background: rgba(0,0,0,0.15);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            padding: clamp(3px, 1vw, 6px) clamp(6px, 2vw, 10px); /* Responsive padding */
            min-width: clamp(50px, 12vw, 70px); /* Responsive min-width */
            text-align: center;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
            white-space: nowrap;
        }

        .timer-container {
            background: rgba(0,0,0,0.2);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 12px;
            padding: clamp(6px, 2vw, 10px) clamp(8px, 3vw, 14px); /* Responsive padding */
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: clamp(60px, 15vw, 80px); /* Responsive min-width */
            min-height: 44px; /* Minimum touch target */
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }

        .timer-container:hover {
            background: rgba(0,0,0,0.3);
            transform: translateY(-1px);
        }

        .timer-text {
            font-size: clamp(12px, 3.5vw, 16px); /* Responsive font size */
            font-weight: 600;
            color: #FFE4B5;
            text-shadow: 0 1px 2px rgba(0,0,0,0.4);
            font-variant-numeric: tabular-nums;
            transition: all 0.3s ease;
            white-space: nowrap;
        }

        .timer-text.timer-warning {
            color: #FFA500;
            text-shadow: 0 0 10px rgba(255, 165, 0, 0.6);
        }

        .timer-text.timer-critical {
            color: #FF4444;
            text-shadow: 0 0 15px rgba(255, 68, 68, 0.8);
            animation: timerPulse 1s infinite;
        }

        @keyframes timerPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        /* Right Section - Settings, Reset, and Coins */
        .right-section {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            justify-content: space-between;
            height: 100%;
            min-width: 0; /* Prevent overflow */
        }

        .top-buttons {
            display: flex;
            gap: clamp(6px, 2vw, 10px); /* Responsive gap */
            align-items: center;
            flex-wrap: wrap; /* Allow wrapping on very small screens */
        }

        .settings-button, .reset-button {
            width: clamp(32px, 8vw, 44px); /* Responsive size with 44px max for touch */
            height: clamp(32px, 8vw, 44px);
            min-width: 44px; /* Minimum touch target */
            min-height: 44px;
            background: rgba(0,0,0,0.2);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            color: #FFE4B5;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            position: relative;
        }

        /* Theme cycling button */
        .theme-button {
            width: clamp(32px, 8vw, 44px);
            height: clamp(32px, 8vw, 44px);
            min-width: 44px;
            min-height: 44px;
            background: linear-gradient(135deg, #4ECDC4 0%, #44A08D 100%);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            color: white;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            position: relative;
            font-size: clamp(16px, 4vw, 20px);
        }

        .theme-button:hover {
            background: linear-gradient(135deg, #44A08D 0%, #4ECDC4 100%);
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(0,0,0,0.4);
        }

        .theme-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }

        .settings-button:hover, .reset-button:hover {
            background: rgba(0,0,0,0.3);
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(0,0,0,0.4);
        }

        .settings-button:active, .reset-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }

        .reset-icon {
            width: clamp(12px, 3vw, 16px); /* Responsive icon size */
            height: clamp(12px, 3vw, 16px);
            color: #FFE4B5;
            font-size: clamp(10px, 3vw, 14px); /* Responsive font */
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .pause-icon {
            width: clamp(12px, 3vw, 16px);
            height: clamp(12px, 3vw, 16px);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 2px;
        }

        .pause-bar {
            width: 3px;
            height: clamp(10px, 3vw, 14px); /* Responsive height */
            background: #FFE4B5;
            border-radius: 1px;
        }

        .coin-counter {
            display: flex;
            align-items: center;
            gap: clamp(4px, 1.5vw, 7px); /* Responsive gap */
            background: rgba(0,0,0,0.2);
            padding: clamp(4px, 1.5vw, 7px) clamp(8px, 2.5vw, 12px); /* Responsive padding */
            border-radius: 10px;
            border: 1px solid rgba(255,255,255,0.2);
            cursor: pointer;
            transition: all 0.3s ease;
            min-height: 44px; /* Minimum touch target */
            min-width: 60px; /* Minimum width for readability */
        }

        .coin-counter:hover {
            background: rgba(0,0,0,0.3);
            transform: translateY(-1px);
        }

        .coin-icon {
            width: clamp(14px, 4vw, 18px); /* Responsive icon size */
            height: clamp(14px, 4vw, 18px);
            font-size: clamp(10px, 3vw, 14px); /* Responsive font */
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .coin-amount {
            font-size: clamp(12px, 3.5vw, 16px); /* Responsive font size */
            font-weight: 600;
            color: #FFE4B5;
            text-shadow: 0 1px 2px rgba(0,0,0,0.4);
            white-space: nowrap; /* Prevent text wrapping */
        }

        /* Timer Mode Indicator */
        .timer-mode-indicator {
            position: absolute;
            top: -5px;
            right: -5px;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            font-size: 8px;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            border: 1px solid rgba(255,255,255,0.3);
        }

        .timer-mode-elapsed {
            background: linear-gradient(135deg, #8B5CF6 0%, #7C3AED 100%);
        }

        .timer-mode-countdown {
            background: linear-gradient(135deg, #EF4444 0%, #DC2626 100%);
        }

        .timer-mode-endlevel {
            background: linear-gradient(135deg, #10B981 0%, #059669 100%);
        }

        /* Docking Area - Shape Selection */
        .docking-area {
            position: absolute;
            top: clamp(70px, 12vh, 90px); /* Match HUD height */
            left: 0;
            right: 0;
            height: clamp(120px, 20vh, 160px); /* Responsive height */
            background: #34495e;
            display: grid;
            grid-template-columns: repeat(5, 1fr); /* Equal column distribution */
            grid-template-rows: repeat(2, 1fr); /* Equal row distribution */
            gap: clamp(4px, 1.5vw, 10px); /* Responsive gap */
            padding: clamp(4px, 2vw, 8px); /* Responsive padding */
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            z-index: 50;
            align-items: center;
            justify-items: center;
            overflow: visible; /* Allow shapes to extend beyond docking area */
        }

        .shape-slot {
            width: 100%;
            height: 100%;
            min-width: clamp(50px, 12vw, 70px); /* Responsive minimum size */
            min-height: clamp(50px, 12vw, 70px);
            max-width: 80px; /* Prevent too large on desktop */
            max-height: 80px;
            background: rgba(255,255,255,0.1);
            border: 2px dashed rgba(255,255,255,0.3);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            transition: all 0.3s ease;
            padding: 0;
            margin: 0;
            overflow: visible;
            box-sizing: border-box;
            cursor: pointer; /* Indicate interactivity */
        }

        .shape-slot:hover {
            background: rgba(255,255,255,0.15);
            border-color: rgba(255,255,255,0.5);
            transform: scale(1.05);
        }

        .shape-slot.empty {
            border-color: rgba(255,255,255,0.1);
            background: rgba(255,255,255,0.05);
        }

        .shape-slot.empty:hover {
            border-color: rgba(255,255,255,0.2);
            background: rgba(255,255,255,0.1);
        }

        .game-shape {
            cursor: grab;
            transition: all 0.3s ease;
            position: relative;
            z-index: 60;
            width: 100%; /* Fill slot */
            height: 100%;
            min-width: 44px; /* Minimum touch target */
            min-height: 44px;
        }

        .game-shape:active {
            cursor: grabbing;
            transform: scale(1.15); /* Slightly larger feedback on touch */
            filter: drop-shadow(0 5px 15px rgba(0,0,0,0.4));
            transition: all 0.1s ease; /* Quick response for touch */
        }

        .game-shape:hover {
            transform: scale(1.1);
            filter: drop-shadow(0 3px 10px rgba(0,0,0,0.3));
        }

        .game-shape.dragging {
            z-index: 1000;
            transform: scale(1.2); /* Slightly larger when dragging */
            filter: drop-shadow(0 8px 20px rgba(0,0,0,0.4));
        }

        /* Enhanced touch feedback for mobile */
        @media (pointer: coarse) {
            .game-shape {
                transition: all 0.2s ease; /* Longer transitions on touch devices */
            }
            
            .game-shape:active {
                transform: scale(1.2); /* Larger feedback on touch devices */
                transition: all 0.05s ease; /* Very quick response */
            }
            
            .shape-slot:active {
                background: rgba(255,255,255,0.2);
                border-color: rgba(255,255,255,0.7);
                transform: scale(1.02);
                transition: all 0.05s ease;
            }
        }
        
        /* End Level Countdown - 3 Dot Display */
        .countdown-dots {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            padding: 8px 12px;
        }

        .countdown-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: rgba(255,255,255,0.3);
            transition: all 0.3s ease;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }

        .countdown-dot.active {
            background: linear-gradient(135deg, #10B981 0%, #059669 100%);
            transform: scale(1.7);
            box-shadow: 0 0 12px rgba(16, 185, 129, 0.8);
            animation: dotPulse 0.6s ease-in-out;
        }

        .countdown-dot.completed {
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
            transform: scale(1.8);
            box-shadow: 0 0 8px rgba(255, 215, 0, 0.6);
        }

        @keyframes dotPulse {
            0%, 100% { transform: scale(1.3); }
            50% { transform: scale(1.6); }
        }

        /* Particle Effects */
        .particle {
            position: fixed;
            pointer-events: none;
            z-index: 9999;
            font-size: 14px;
            font-weight: bold;
            opacity: 1;
            animation: particleFloat 2s ease-out forwards;
        }

        @keyframes particleFloat {
            0% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
            100% {
                opacity: 0;
                transform: translateY(-40px) scale(0);
            }
        }

        @keyframes starBurst {
            0% {
                opacity: 1;
                transform: scale(0) rotate(0deg);
            }
            50% {
                opacity: 0.8;
                transform: scale(1.5) rotate(180deg);
            }
            100% {
                opacity: 0;
                transform: scale(2) rotate(360deg);
            }
        }

        .progress-animate {
            animation: progressPulse 0.8s ease-out;
        }

        @keyframes progressPulse {
            0% { transform: scaleY(1); }
            50% { transform: scaleY(1.1); box-shadow: 0 0 15px rgba(255, 215, 0, 0.6); }
            100% { transform: scaleY(1); }
        }

        /* Enhanced Star Animations */
        .star.filled {
            animation: starFill 0.5s ease-out;
        }

        @keyframes starFill {
            0% { transform: scale(0) rotate(0deg); opacity: 0; }
            50% { transform: scale(1.3) rotate(180deg); opacity: 1; }
            100% { transform: scale(1) rotate(360deg); opacity: 1; }
        }

        /* Score Text Animation */
        .score-text {
            transition: all 0.3s ease;
        }

        .score-text.score-increase {
            animation: scoreBoost 0.6s ease-out;
        }

        @keyframes scoreBoost {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); color: #FFD700; }
            100% { transform: scale(1); }
        }

        /* Coin Animation */
        .coin-amount {
            transition: all 0.3s ease;
        }

        .coin-amount.coin-increase {
            animation: coinBoost 0.6s ease-out;
        }

        @keyframes coinBoost {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); color: #FFD700; text-shadow: 0 0 10px #FFD700; }
            100% { transform: scale(1); }
        }

        /* Enhanced Coin Animations */
        @keyframes coinShower {
            0% { 
                transform: translateY(0) rotate(0deg); 
                opacity: 1; 
            }
            50% { 
                transform: translateY(-50px) rotate(180deg); 
                opacity: 0.8; 
            }
            100% { 
                transform: translateY(100px) rotate(360deg); 
                opacity: 0; 
            }
        }

        @keyframes coinPulse {
            0%, 100% { 
                transform: scale(1); 
                box-shadow: 0 0 5px rgba(255, 215, 0, 0.3); 
            }
            50% { 
                transform: scale(1.3); 
                box-shadow: 0 0 25px rgba(255, 215, 0, 0.8); 
            }
        }

        @keyframes coinShake {
            0%, 100% { transform: translateX(0); }
            10% { transform: translateX(-2px) rotate(-1deg); }
            20% { transform: translateX(2px) rotate(1deg); }
            30% { transform: translateX(-3px) rotate(-1deg); }
            40% { transform: translateX(3px) rotate(1deg); }
            50% { transform: translateX(-2px) rotate(-1deg); }
            60% { transform: translateX(2px) rotate(1deg); }
            70% { transform: translateX(-1px) rotate(-1deg); }
            80% { transform: translateX(1px) rotate(1deg); }
            90% { transform: translateX(-1px) rotate(-1deg); }
        }

        /* Particle Effects */
        .particle {
            position: fixed;
            pointer-events: none;
            font-size: 18px;
            font-weight: bold;
            z-index: 9999;
            animation: floatUp 2s ease-out forwards;
        }

        /* Level Complete Effects */
        @keyframes levelCompleteFlash {
            0%, 100% { filter: brightness(1); }
            25% { filter: brightness(1.3) saturate(1.2); }
            50% { filter: brightness(1.1) saturate(1.1); }
            75% { filter: brightness(1.2) saturate(1.15); }
        }

        /* Level Cleared Popup Modal */
        .level-cleared-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            opacity: 0;
            animation: modalFadeIn 0.5s ease-out forwards;
        }

        .level-cleared-content {
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
            transform: scale(0.5);
            animation: modalPopIn 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55) forwards;
        }

        .level-cleared-title {
            font-size: 48px;
            font-weight: bold;
            color: #8B4513;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            animation: titlePulse 1s ease-in-out infinite alternate;
        }

        .level-cleared-subtitle {
            font-size: 24px;
            color: #654321;
            margin-bottom: 30px;
            font-weight: 600;
        }

        .level-cleared-stars {
            font-size: 60px;
            margin: 20px 0;
            animation: starsSparkle 2s ease-in-out infinite;
        }

        .level-cleared-button {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            margin: 10px;
        }

        .level-cleared-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
        }

        @keyframes modalFadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes modalPopIn {
            from { 
                transform: scale(0.5) rotate(-10deg);
                opacity: 0;
            }
            to { 
                transform: scale(1) rotate(0deg);
                opacity: 1;
            }
        }

        @keyframes titlePulse {
            from { transform: scale(1); }
            to { transform: scale(1.05); }
        }

        @keyframes starsSparkle {
            0%, 100% { 
                transform: scale(1) rotate(0deg);
                filter: brightness(1);
            }
            50% { 
                transform: scale(1.1) rotate(5deg);
                filter: brightness(1.3);
            }
        }

        /* Global Drag Overlay - Ensure dragging works across entire viewport */
        #dragOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 9998;
            overflow: visible;
        }

        .ghost-shape {
            position: fixed !important;
            pointer-events: none !important;
            z-index: 10000 !important; /* Increased z-index */
            visibility: visible !important;
            opacity: 0.9 !important;
            display: block !important;
            transition: transform 0.2s ease-out !important;
        }

        /* Rotation Visual Feedback */
        /* Enhanced Mobile Touch Interactions */
        .game-shape {
            touch-action: none;
            cursor: grab;
            transition: transform 0.2s ease;
        }

        .game-shape:hover {
            transform: scale(1.05);
        }

        .game-shape:active {
            cursor: grabbing;
            transform: scale(1.1);
        }

        .game-shape.ghost-active {
            opacity: 0.3;
            transform: scale(0.9);
            transition: all 0.3s ease;
        }

        /* Touch Feedback */
        .touch-ripple {
            position: fixed;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.6);
            pointer-events: none;
            z-index: 9998;
            animation: rippleEffect 0.6s ease-out forwards;
        }

        @keyframes rippleEffect {
            0% { transform: scale(0); opacity: 1; }
            100% { transform: scale(4); opacity: 0; }
        }

        .rotation-indicator {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: bold;
            z-index: 10000;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .rotation-indicator.show {
            opacity: 1;
        }

        /* Enhanced Drag Feedback */
        .game-shape.ghost-active {
            opacity: 0.3;
            transform: scale(0.9);
            transition: all 0.3s ease;
        }

        /* Shape Visual Designs - REMOVED: Now using unified canvas-based system */
        /* All shape appearances now handled by PhysicsShapeRenderer and SHAPE_CONFIG */

        /* Canvas preview styling for dock */
        .shape-preview {
            width: 46px;
            height: 46px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .shape-preview:hover {
            filter: brightness(1.1);
            transform: scale(1.05);
        }

        /* Ghost effect for dragged shapes */
        .shape-preview.ghost-active {
            opacity: 0.3;
            transform: scale(0.9);
            transition: all 0.3s ease;
        }

        /* Game shape base styles for drag/drop functionality */
        .game-shape {
            display: block;
            position: relative;
        }

        .game-shape.ghost-active {
            opacity: 0.3;
        }

        /* Mode Toggle Inside HUD */
        .mode-toggle-switch {
            position: relative;
            width: 60px;
            height: 28px;
            background: rgba(52, 73, 94, 0.8);
            border-radius: 14px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .mode-toggle-switch.design-active {
            background: rgba(52, 152, 219, 0.8);
            border-color: #3498db;
        }

        .mode-toggle-slider {
            position: absolute;
            top: 2px;
            left: 2px;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
        }

        .mode-toggle-switch.design-active .mode-toggle-slider {
            transform: translateX(28px);
        }

        .mode-toggle-labels {
            position: absolute;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            white-space: nowrap;
            color: rgba(255, 255, 255, 0.8);
        }

        /* Design Mode Sidebar */
        .design-sidebar {
            position: fixed;
            top: 0;
            left: -350px;
            width: 350px;
            height: 100vh;
            background: linear-gradient(180deg, #2c3e50 0%, #34495e 100%);
            box-shadow: 5px 0 20px rgba(0,0,0,0.3);
            transition: left 0.4s ease;
            z-index: 999;
            overflow-y: auto;
            color: white;
        }

        .design-sidebar.active {
            left: 0;
        }

        .design-mode .game-viewport {
            margin-left: 350px;
            transition: margin-left 0.4s ease;
        }

        .sidebar-header {
            padding: 20px;
            background: rgba(0,0,0,0.2);
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .sidebar-title {
            font-size: 16px;
            font-weight: bold;
            color: #3498db;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .sidebar-section {
            padding: 15px 20px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .config-group {
            margin-bottom: 12px;
        }

        .config-label {
            display: block;
            font-size: 13px;
            font-weight: 500;
            margin-bottom: 5px;
            color: #bdc3c7;
        }

        .config-input, .config-select {
            width: 100%;
            padding: 8px 12px;
            background: rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 6px;
            color: white;
            font-size: 14px;
        }

        .config-input:focus, .config-select:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 5px rgba(52, 152, 219, 0.3);
        }

        .config-sub-group {
            margin-left: 20px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .config-sub-group .config-label {
            min-width: 100px;
            margin-bottom: 0;
            font-size: 12px;
        }

        .config-sub-group input[type="range"] {
            flex: 1;
            margin: 0;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
        }

        .range-value {
            min-width: 50px;
            text-align: right;
            font-size: 12px;
            color: #FFE4B5;
            font-weight: 600;
            background: rgba(0,0,0,0.2);
            padding: 2px 6px;
            border-radius: 4px;
        }

        .config-btn {
            width: 100%;
            padding: 10px;
            background: linear-gradient(135deg, #27ae60 0%, #229954 100%);
            color: white;
            border: none;
            border-radius: 6px;
            font-weight: bold;
            cursor: pointer;
            margin-top: 8px;
            transition: all 0.3s ease;
        }

        .config-btn:hover {
            background: linear-gradient(135deg, #229954 0%, #1e8449 100%);
            transform: translateY(-1px);
        }

        /* v9: Theme Selector Styles */
        .checkbox-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 8px;
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            color: #ecf0f1;
            cursor: pointer;
        }

        .checkbox-label input[type="checkbox"] {
            width: 16px;
            height: 16px;
            accent-color: #27ae60;
        }

        .theme-preview {
            width: 100%;
            height: 40px;
            border-radius: 4px;
            margin: 4px 0 8px 0;
            background: linear-gradient(135deg, #87CEEB 0%, #4ECDC4 50%, #90EE90 100%);
            border: 2px solid transparent;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .theme-preview:hover {
            border-color: #27ae60;
            transform: scale(1.02);
        }

        .theme-preview.active {
            border-color: #27ae60;
            box-shadow: 0 0 10px rgba(39, 174, 96, 0.5);
        }

        .dock-slot-config {
            background: rgba(0,0,0,0.2);
            padding: 8px;
            border-radius: 6px;
            margin-bottom: 8px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .game-canvas-container {
            position: absolute;
            top: calc(clamp(70px, 12vh, 90px) + clamp(120px, 20vh, 160px)); /* HUD + Docking height */
            left: 0;
            right: 0;
            bottom: 0; /* Use full available space */
            background: linear-gradient(135deg, #87CEEB 0%, #98FB98 100%);
            border-radius: 0;
            overflow: visible; /* Allow dragged shapes to extend beyond canvas boundaries */
        }

        #gameCanvas {
            width: 100%;
            height: 100%;
            display: block;
            background: transparent;
            cursor: crosshair;
        }

        /* Debug Info */
        .debug-info {
            position: absolute;
            bottom: clamp(5px, 2vh, 15px); /* Responsive bottom position */
            left: clamp(5px, 2vw, 15px); /* Responsive left position */
            color: white;
            font-size: clamp(10px, 2.5vw, 12px); /* Responsive font size */
            opacity: 0.7;
            font-family: monospace;
            background: rgba(0,0,0,0.7);
            padding: clamp(4px, 1.5vw, 8px); /* Responsive padding */
            border-radius: 6px;
            z-index: 100;
            max-width: 70vw; /* Prevent overflow */
            word-break: break-word;
        }

        /* Event Notifications */
        .event-notification {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: clamp(12px, 3vw, 20px) clamp(16px, 4vw, 24px); /* Responsive padding */
            border-radius: 12px;
            font-size: clamp(14px, 4vw, 18px); /* Responsive font size */
            font-weight: bold;
            z-index: 1000;
            opacity: 0;
            transition: all 0.3s ease;
            pointer-events: none;
            max-width: 80vw; /* Prevent overflow on small screens */
            min-width: 200px; /* Minimum readable width */
            text-align: center;
        }

        .event-notification.show {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1.1);
        }

        .event-notification.fall {
            background: rgba(231, 76, 60, 0.9);
            border: 2px solid #e74c3c;
        }

        .event-notification.collision {
            background: rgba(46, 204, 113, 0.9);
            border: 2px solid #2ecc71;
        }

        .event-notification.balance {
            background: rgba(52, 152, 219, 0.9);
            border: 2px solid #3498db;
        }

        /* Animations */
        @keyframes starPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.3); }
            100% { transform: scale(1.2); }
        }

        /* Test Controls (REMOVED - Debug squares eliminated) */

        /* Responsive Design - Mobile First */
        @media (max-width: 500px) {
            body {
                padding: 0;
            }
            
            .game-viewport {
                width: 100vw;
                height: 100vh;
                height: 100dvh;
                border-radius: 0;
                box-shadow: none;
                max-width: none;
                max-height: none;
                aspect-ratio: unset; /* Allow full screen on mobile */
                padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
            }
            
            .game-hud {
                height: clamp(60px, 10vh, 70px); /* Slightly smaller on mobile */
                padding: clamp(4px, 1.5vw, 8px);
            }
            
            .docking-area {
                height: clamp(100px, 18vh, 140px); /* Adjust for mobile */
                gap: clamp(3px, 1vw, 6px);
                padding: clamp(3px, 1vw, 6px);
            }
            
            .shape-slot {
                min-width: clamp(45px, 15vw, 60px); /* Optimize for mobile touch */
                min-height: clamp(45px, 15vw, 60px);
            }
            
            .game-canvas-container {
                border-radius: 0;
                top: calc(clamp(60px, 10vh, 70px) + clamp(100px, 18vh, 140px)); /* Updated for mobile HUD + docking */
            }
            
            /* Enhanced touch targets on mobile */
            .settings-button, .reset-button, .theme-button {
                min-width: 48px; /* Larger touch targets */
                min-height: 48px;
            }
            
            .timer-container {
                min-height: 48px; /* Better touch target */
            }
            
            .coin-counter {
                min-height: 48px; /* Better touch target */
                padding: 6px 10px;
            }
            
            /* Hide design mode on mobile */
            .design-sidebar {
                display: none;
            }
        }

        /* Tablet Portrait */
        @media (min-width: 501px) and (max-width: 1024px) and (orientation: portrait) {
            .game-viewport {
                max-width: 600px;
                max-height: 1067px; /* 600 * 16/9 */
            }
        }

        /* Desktop and Large Screens */
        @media (min-width: 1025px) {
            body {
                padding: 40px 20px;
            }
            
            .game-viewport {
                max-width: 500px;
                max-height: 889px; /* 500 * 16/9 */
                border-radius: 25px;
            }
        }

        /* Rotation Zones - Mobile Enhancement */
        .rotation-zone {
            position: absolute;
            width: 80px;
            height: 100%;
            top: 0;
            border: 2px dashed rgba(74, 144, 226, 0.4);
            border-radius: 10px;
            transition: all 0.3s ease;
            pointer-events: none;
            opacity: 0.3; /* Make visible for testing */
            z-index: 1000;
            display: block; /* Always visible for testing */
        }

        .rotation-zone.left {
            left: 0;
            background: linear-gradient(to right, rgba(229, 115, 115, 0.2), transparent);
            border-color: rgba(229, 115, 115, 0.4);
        }

        .rotation-zone.right {
            right: 0;
            background: linear-gradient(to left, rgba(129, 199, 132, 0.2), transparent);
            border-color: rgba(129, 199, 132, 0.4);
        }

        .rotation-zone.visible {
            display: block;
            opacity: 1;
        }

        .rotation-zone.active {
            border-color: rgba(74, 144, 226, 1);
            box-shadow: 0 0 20px rgba(74, 144, 226, 0.4);
        }

        .rotation-zone.left.active {
            background: linear-gradient(to right, rgba(229, 115, 115, 0.4), transparent);
            border-color: rgba(229, 115, 115, 1);
            box-shadow: 0 0 20px rgba(229, 115, 115, 0.4);
        }

        .rotation-zone.right.active {
            background: linear-gradient(to left, rgba(129, 199, 132, 0.4), transparent);
            border-color: rgba(129, 199, 132, 1);
            box-shadow: 0 0 20px rgba(129, 199, 132, 0.4);
        }

        .rotation-zone::before {
            content: "‚Ü∫";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2rem;
            color: rgba(255, 255, 255, 0.8);
            animation: zonePulse 2s infinite;
        }

        .rotation-zone.right::before {
            content: "‚Üª";
        }

        .rotation-zone.active::before {
            animation: zoneRotate 1s linear infinite;
            color: rgba(255, 255, 255, 1);
        }

        @keyframes zonePulse {
            0%, 100% { opacity: 0.6; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
        }

        @keyframes zoneRotate {
            from { transform: translate(-50%, -50%) rotate(0deg); }
            to { transform: translate(-50%, -50%) rotate(360deg); }
        }
        
    </style>
</head>
<body>
    <!-- Global drag overlay to prevent clipping -->
    <div id="dragOverlay"></div>
    
    <div class="game-viewport" id="gameContainer">
        <!-- Mobile Rotation Zones -->
        <div id="leftRotationZone" class="rotation-zone left"></div>
        <div id="rightRotationZone" class="rotation-zone right"></div>
            
            <!-- Game HUD -->
            <div class="game-hud">
                <div class="left-section">
                    <div class="score-display">
                        <div class="trophy-icon">üèÜ</div>
                        <span class="score-text" id="scoreText">0</span>
                    </div>
                    <div class="progress-area">
                        <div class="star-progress-container" onclick="initializeProgressBarInteraction()">
                            <div class="star-progress-bar" id="starProgressBar" style="width: 0%;"></div>
                            <div class="progress-markers">
                                <div class="progress-marker"></div>
                                <div class="progress-marker"></div>
                                <div class="progress-marker"></div>
                            </div>
                        </div>
                        <div class="star-markers">
                            <div class="star"></div>
                            <div class="star"></div>
                            <div class="star"></div>
                        </div>
                    </div>
                </div>

                <div class="middle-section">
                    <div class="level-display" id="levelDisplay">World 1-1</div>
                    <div class="timer-container" id="timerContainer" onclick="switchTimerMode()">
                        <span class="timer-text" id="gameTimer">0:00</span>
                        <div class="timer-mode-indicator timer-mode-elapsed" id="timerModeIndicator">‚è±</div>
                    </div>
                </div>

                <div class="right-section">
                    <div class="top-buttons">
                        <!-- Commented out pause button for mode toggle -->
                        <!-- <div class="settings-button" id="pauseButton">
                            <div class="pause-icon">
                                <div class="pause-bar"></div>
                                <div class="pause-bar"></div>
                            </div>
                        </div> -->
                        
                        <!-- Theme cycling button -->
                        <div class="theme-button" id="themeButton" onclick="cycleThemes()" title="Cycle Theme">
                            <div class="theme-icon">üé®</div>
                        </div>
                        
                        <!-- Phase 2: Mode Toggle Switch -->
                        <div class="mode-toggle-switch" id="modeToggleSwitch" onclick="toggleModeSwitch()">
                            <div class="mode-toggle-slider">üéÆ</div>
                            <div class="mode-toggle-labels">Play/Design</div>
                        </div>
                        
                        <div class="reset-button" id="resetButton" onclick="resetLevel()">
                            <div class="reset-icon">‚ü≤</div>
                        </div>
                        
                        <div class="reset-button" id="mobileDebugButton" onclick="toggleMobileDebug()" style="background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%);">
                            <div class="reset-icon">üì±</div>
                        </div>
                    </div>
                    <div class="coin-counter" id="coinCounter" onclick="animateCoin()">
                        <div class="coin-icon">üí∞</div>
                        <span class="coin-amount" id="coinAmount">0</span>
                    </div>
                </div>
            </div>

            <!-- Docking Area -->
            <div class="docking-area" id="dockingArea">
                <div class="shape-slot" id="slot-square">
                    <div class="game-shape shape-square" data-shape="square" id="shape-square"></div>
                </div>
                <div class="shape-slot" id="slot-triangle">
                    <div class="game-shape shape-triangle" data-shape="triangle" id="shape-triangle"></div>
                </div>
                <div class="shape-slot" id="slot-circle">
                    <div class="game-shape shape-circle" data-shape="circle" id="shape-circle"></div>
                </div>
                <div class="shape-slot" id="slot-cross2">
                    <div class="game-shape shape-cross2" data-shape="cross2" id="shape-cross2"></div>
                </div>
                <div class="shape-slot" id="slot-l">
                    <div class="game-shape shape-l" data-shape="l" id="shape-l"></div>
                </div>
                <div class="shape-slot" id="slot-cross">
                    <div class="game-shape shape-cross" data-shape="cross" id="shape-cross"></div>
                </div>
                <div class="shape-slot" id="slot-barbell-one">
                    <div class="game-shape shape-barbell-one" data-shape="barbell-one" id="shape-barbell-one"></div>
                </div>
                <div class="shape-slot" id="slot-barbell-two">
                    <div class="game-shape shape-barbell-two" data-shape="barbell-two" id="shape-barbell-two"></div>
                </div>
                <div class="shape-slot" id="slot-diamond-barbell">
                    <div class="game-shape shape-diamond-barbell" data-shape="diamond-barbell" id="shape-diamond-barbell"></div>
                </div>
            </div>

            <!-- Game Canvas Area -->
            <div class="game-canvas-container">
                <canvas id="gameCanvas"></canvas>
            </div>

            <!-- Event Notification System -->
            <div class="event-notification" id="eventNotification"></div>

            <!-- Debug Info -->
            <div class="debug-info" id="debugInfo">
                Shapes: 0/9 | Events: 0 | Collisions: 0 | FPS: 60
            </div>

            <!-- Rotation Indicator -->
            <div class="rotation-indicator" id="rotationIndicator">
                üîÑ R/E or ‚Üê/‚Üí to rotate
            </div>
    </div>

    <!-- Phase 2: Design Mode Sidebar -->
    <div class="design-sidebar" id="designSidebar">
        <div class="sidebar-header">
            <h2>üîß Level Editor</h2>
            <p>Configure level settings and dock layout</p>
        </div>

        <!-- Level Configuration -->
        <div class="sidebar-section">
            <div class="sidebar-title">üìã Level Configuration</div>
            
            <div class="config-group">
                <label class="config-label">World-Level</label>
                <input type="text" class="config-input" id="levelNumber" value="1-1" placeholder="1-1">
            </div>

            <div class="config-group">
                <label class="config-label">Timer Mode</label>
                <select class="config-select" id="timerMode" onchange="updateTimerModeConfig()">
                    <option value="none">No Timer</option>
                    <option value="elapsed" selected>Count-Up Timer</option>
                    <option value="countdown">Count-Down Timer</option>
                </select>
            </div>
            
            <div class="config-group">
                <label class="config-label">Starting Timer Value</label>
                <input type="number" class="config-input" id="timerStart" value="60" min="0" max="3600" placeholder="Seconds">
            </div>
            
            <div class="config-group">
                <label class="config-label">End-Level Countdown</label>
                <input type="number" class="config-input" id="endLevelDuration" value="5" min="3" max="15" placeholder="Seconds">
            </div>
        </div>

        <!-- v9: Theme Selection -->
        <div class="sidebar-section">
            <div class="sidebar-title">üé® Theme Selection</div>
            
            <div class="config-group">
                <label class="config-label">Visual Theme</label>
                <select class="config-select" id="themeSelector" onchange="changeTheme()">
                    <option value="classic" selected>Classic Puzzle</option>
                    <option value="wood">Wood</option>
                    <option value="stone">Stone</option>
                    <option value="metal">Metal</option>
                </select>
            </div>

            <div class="config-group">
                <label class="config-label">Canvas Enhancements</label>
                <div class="checkbox-group">
                    <label class="checkbox-label">
                        <input type="checkbox" id="enableCanvas" checked onchange="toggleCanvasEnhancements()">
                        Enable Advanced Graphics
                    </label>
                    <label class="checkbox-label">
                        <input type="checkbox" id="enableParticles" checked onchange="toggleParticleEffects()">
                        Particle Effects
                    </label>
                    <label class="checkbox-label">
                        <input type="checkbox" id="enableAnimations" checked onchange="toggleAnimations()">
                        Shape Animations
                    </label>
                </div>
            </div>

            <div class="config-group">
                <label class="config-label">PixiJS Integration (Phase 2)</label>
                <div class="checkbox-group">
                    <label class="checkbox-label">
                        <input type="checkbox" id="enablePixi" onchange="togglePixiSystem()">
                        Enable PixiJS System
                    </label>
                    <label class="checkbox-label">
                        <input type="checkbox" id="enablePixiShapes" onchange="togglePixiShapeRendering()">
                        PixiJS Shape Rendering
                    </label>
                    <!-- Phase 3: Advanced Animation Controls -->
                    <label class="checkbox-label">
                        <input type="checkbox" id="enablePixiAnimations" onchange="togglePixiAnimations()" checked>
                        PixiJS Animations
                    </label>
                </div>
                <div class="config-sub-group">
                    <label class="config-label">Enhanced Theme Selection</label>
                    <select id="enhancedThemeSelect" onchange="applyEnhancedTheme()">
                        <option value="classic" selected>Classic</option>
                        <option value="wood">Wood</option>
                        <option value="stone">Stone</option>
                        <option value="metal">Metal</option>
                    </select>
                </div>
                <div class="config-sub-group">
                    <label class="config-label">Renderer Selection</label>
                    <select id="rendererSelect" onchange="switchRenderer()">
                        <option value="auto">Auto Select</option>
                        <option value="canvas">Canvas Only</option>
                        <option value="pixi">PixiJS Only</option>
                    </select>
                </div>
                <div class="checkbox-group">
                    <label class="checkbox-label">
                        <input type="checkbox" id="pixiDebug" onchange="togglePixiDebug()">
                        Debug Mode
                    </label>
                    <label class="checkbox-label">
                        <input type="checkbox" id="pixiShowFPS" onchange="togglePixiFPS()">
                        Show FPS Counter
                    </label>
                </div>
            </div>

            <div class="config-group">
                <label class="config-label">Mobile Touch Offset</label>
                <div class="checkbox-group">
                    <label class="checkbox-label">
                        <input type="checkbox" id="enableTouchOffset" checked onchange="toggleTouchOffset()">
                        Enable Touch Offset
                    </label>
                </div>
                <div class="config-sub-group">
                    <label class="config-label">X Offset (Horizontal)</label>
                    <input type="range" id="touchOffsetX" min="-100" max="100" value="0" 
                           onchange="updateTouchOffset()" oninput="updateTouchOffsetDisplay()">
                    <span class="range-value" id="touchOffsetXValue">0px</span>
                </div>
                <div class="config-sub-group">
                    <label class="config-label">Y Offset (Vertical)</label>
                    <input type="range" id="touchOffsetY" min="-150" max="50" value="-80" 
                           onchange="updateTouchOffset()" oninput="updateTouchOffsetDisplay()">
                    <span class="range-value" id="touchOffsetYValue">-80px</span>
                </div>
            </div>
        </div>

        <!-- Dock Configuration -->
        <div class="sidebar-section">
            <div class="sidebar-title">üîß Dock Configuration</div>
            
            <div class="config-group">
                <label class="config-label">Number of Dock Slots</label>
                <input type="number" class="config-input" id="dockSlotCount" value="9" min="3" max="12" onchange="generateDockSlots()">
            </div>
            
            <div class="config-group">
                <label class="config-label">Barbell Orientation in Dock</label>
                <select class="config-select" id="barbellOrientation" onchange="updateBarbellOrientation()">
                    <option value="vertical" selected>Vertical (90¬∞)</option>
                    <option value="horizontal">Horizontal (0¬∞)</option>
                </select>
            </div>
            
            <div class="config-group">
                <label class="config-label">Shape Assignment</label>
                <div id="dockSlotsContainer">
                    <!-- Dynamic dock slots will be generated here -->
                </div>
            </div>
        </div>

        <!-- Actions -->
        <div class="sidebar-section">
            <div class="sidebar-title">‚ö° Actions</div>
            
            <button class="config-btn" id="applyChangesBtn" onclick="applyLevelChanges()">
                Apply Level Changes
            </button>
            
            <button class="config-btn" onclick="resetLevel()" style="background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);">
                Reset Level
            </button>
            
            <button class="config-btn" onclick="syncDockToDesign()" style="background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);">
                Sync Current Dock
            </button>
        </div>
    </div>



    <!-- Matter.js Physics Engine -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    
    <!-- PixiJS v7.x for Advanced Graphics -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.4.2/pixi.min.js"></script>
    
    <script>
        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë CANVAS ENHANCEMENT CONFIGURATION v9
          ‚ïë Feature flags and settings for texture, theme, and visual enhancement system
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        const CANVAS_CONFIG = {
            // Feature flags
            enabled: true,                    // Master switch for canvas enhancements
            useTextures: true,               // Enable texture system for shapes
            useThemes: true,                 // Enable theme switching
            useParticles: true,              // Enable particle effects
            useAnimations: true,             // Enable shape animations
            useBackgroundTextures: true,     // Enable background textures
            usePlatformTextures: true,       // Enable platform textures
            
            // Performance settings
            maxParticles: 50,                // Maximum particles on screen
            textureQuality: 'high',          // 'low', 'medium', 'high'
            enableLOD: true,                 // Level of detail for small shapes
            cacheTextures: true,             // Cache rendered textures
            
            // Default theme and fallback behavior
            defaultTheme: 'classic',
            fallbackToSolid: true,           // Use solid colors if textures fail
            showLoadingProgress: true,       // Show loading indicators
            
            // Debug options
            debugMode: false,                // Show texture loading info
            showBounds: false,               // Show texture boundaries
            logAssetLoading: true            // Console logging for asset loading
        };

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë PIXIJS INTEGRATION CONFIGURATION v1
          ‚ïë Feature flags and settings for PixiJS advanced graphics system
          ‚ïë Phase 1: Foundation & Setup - Non-breaking integration alongside Canvas
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        const PIXI_CONFIG = {
            // Master control - PixiJS system activation
            enabled: false,                   // Start disabled for gradual activation
            
            // Renderer settings
            renderer: 'auto',                // 'canvas', 'pixi', 'auto'
            fallbackToCanvas: true,          // Fallback to Canvas if PixiJS fails
            
            // Feature flags for gradual activation  
            features: {
                shapeRendering: false,       // Phase 2: Shape rendering migration
                animations: true,            // Phase 3: Advanced animations (enabled by default)
                tweening: false,             // Phase 4: Advanced tweening system
                enhancedText: false,         // Phase 5: Enhanced text system
                particles: false             // Phase 6: Advanced particle systems
            },
            
            // Performance settings
            performance: {
                resolution: 'auto',          // 'auto', 1, 2 (for high DPI)
                antialias: true,             // Anti-aliasing
                transparent: true,           // Transparent background
                backgroundAlpha: 0,          // Background transparency
                powerPreference: 'default'   // 'high-performance', 'low-power', 'default'
            },
            
            // Animation settings
            animations: {
                enabled: true,
                quality: 'high',             // 'low', 'medium', 'high'
                reduceMotion: false,         // Accessibility - respect user preference
                fps: 60,                     // Target framerate
                easing: 'default'            // Default easing function
            },
            
            // Particle system settings
            particles: {
                enabled: true,
                maxCount: 100,               // Maximum particles on screen
                quality: 'high',             // 'low', 'medium', 'high'
                poolSize: 200,               // Object pool size for performance
                culling: true                // Cull off-screen particles
            },
            
            // Text rendering settings
            text: {
                enhanced: true,
                animations: true,
                quality: 'high',
                fontLoading: 'async',        // 'sync', 'async'
                fallbackFont: 'Arial'
            },
            
            // Device optimization
            mobile: {
                reducedEffects: true,        // Reduce effects on mobile
                lowerParticleCounts: true,   // Fewer particles on mobile
                simplifiedAnimations: false   // Keep animations on mobile
            },
            
            // Debug options
            debug: {
                enabled: false,              // Debug mode
                showFPS: false,              // Show FPS counter
                showDrawCalls: false,        // Show draw call count
                logPerformance: false,       // Log performance metrics
                wireframe: false             // Show wireframes
            }
        };

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë V14 UNIFIED GAME CONFIGURATION
          ‚ïë Single source of truth for V14 unified PixiJS system
          ‚ïë Consolidates Canvas and PixiJS configs into one unified system
          ‚ïë No toggles, no complexity - PixiJS handles everything by default
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        const UNIFIED_GAME_CONFIG = {
            // Core engine - PixiJS only, no Canvas2D fallbacks for new features
            renderer: {
                engine: 'pixi',                    // Always PixiJS for new features
                fallbackEnabled: true,             // Keep Canvas2D fallback for compatibility
                width: 800,
                height: 500,
                antialias: true,
                transparent: false,
                resolution: Math.min(window.devicePixelRatio || 1, 2), // Cap for performance
                autoDensity: true,
                powerPreference: 'high-performance',
                backgroundColor: 0x87CEEB         // Sky blue as hex
            },
            
            // Theme system configuration
            theme: {
                enabled: true,
                defaultTheme: 'classic',          // Default theme for initialization
                transitions: true,                // Enable theme transitions
                caching: true                     // Cache theme resources
            },
            
            // Always-enabled features (no toggles in V14)
            features: {
                shapeAnimations: true,           // No toggle - always on
                particleEffects: true,           // No toggle - always on  
                advancedGraphics: true,          // No toggle - always on
                themeTextures: true,             // No toggle - always on
                smoothTransitions: true,         // No toggle - always on
                cameraShake: true,               // No toggle - always on
                shapeRendering: true,            // PixiJS shape rendering
                enhancedText: true,              // Better text rendering
                tweening: true                   // Advanced tweening
            },
            
            // Playable ad optimizations
            performance: {
                targetFPS: 60,
                maxMemoryMB: 120,
                textureCompression: true,
                assetPreloading: true,
                renderCaching: true,
                maxParticles: 75,               // Balanced for performance
                cullOffscreen: true,            // Cull off-screen objects
                objectPooling: true             // Reuse objects for performance
            },
            
            // Mobile optimization
            mobile: {
                autoDetect: true,
                reducedParticles: true,         // 50% fewer particles on mobile
                optimizedTextures: true,       // Lower res textures on mobile
                touchOptimization: true        // Touch-specific optimizations
            },
            
            // Debug settings (for development only)
            debug: {
                enabled: false,
                showFPS: false,
                showLayers: false,
                logPerformance: false,
                wireframe: false
            },
            
            // Legacy compatibility (maintain existing functionality)
            legacy: {
                preserveCanvasConfig: true,     // Keep CANVAS_CONFIG active
                preservePixiConfig: true,       // Keep PIXI_CONFIG active
                supportOldUI: true,             // Support existing UI system
                gradualMigration: true          // Enable gradual migration
            }
        };

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë THEME DEFINITIONS - VISUAL THEMES FOR THE GAME
          ‚ïë Each theme defines complete visual styling for all game elements
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        const THEME_DEFINITIONS = {
            classic: {
                name: "Classic Puzzle",
                description: "Clean, geometric shapes with simple colors",
                background: {
                    type: "gradient",
                    colors: ["#87CEEB", "#4ECDC4", "#90EE90"],
                    texture: null,
                    // Image background support
                    image: {
                        url: null,          // "path/to/background.jpg"
                        repeat: "no-repeat", // "repeat", "repeat-x", "repeat-y", "no-repeat"
                        position: "center",  // "center", "top", "bottom", "left", "right"
                        size: "cover"        // "cover", "contain", "auto", "100% 100%"
                    }
                },
                platform: {
                    texture: null,  // Will use solid color initially
                    color: "#8B4513",
                    material: "wood",
                    pattern: "solid",
                    // Platform image texture support
                    image: {
                        url: null,          // "path/to/platform-texture.jpg"
                        repeat: "repeat",    // How to repeat the texture
                        blend: "multiply",   // How to blend with base color
                        opacity: 0.8        // Texture opacity (0-1)
                    }
                },
                shapes: {
                    useTextures: false,      // Start with solid colors
                    baseTexturePath: null,
                    specialEffects: ["shadow"],
                    animations: ["bounce"],
                    // Shape texture mapping
                    textures: {
                        square: { url: null, repeat: "repeat", blend: "multiply", opacity: 0.7 },
                        circle: { url: null, repeat: "repeat", blend: "multiply", opacity: 0.7 },
                        triangle: { url: null, repeat: "repeat", blend: "multiply", opacity: 0.7 },
                        cross: { url: null, repeat: "repeat", blend: "multiply", opacity: 0.7 },
                        cross2: { url: null, repeat: "repeat", blend: "multiply", opacity: 0.7 },
                        l: { url: null, repeat: "repeat", blend: "multiply", opacity: 0.7 },
                        "barbell-one": { url: null, repeat: "repeat", blend: "multiply", opacity: 0.7 },
                        "barbell-two": { url: null, repeat: "repeat", blend: "multiply", opacity: 0.7 },
                        "diamond-barbell": { url: null, repeat: "repeat", blend: "multiply", opacity: 0.7 }
                    }
                },
                particles: {
                    style: "geometric",
                    colors: ["#FFD700", "#FF6B6B", "#4ECDC4"]
                }
            },
            
            wood: {
                name: "Wood", 
                description: "Natural wood textures and warm earth tones",
                background: {
                    type: "gradient",
                    colors: ["#8B4513", "#A0522D", "#CD853F"],
                    texture: "wood_grain",
                    // Wood background image support
                    image: {
                        url: null,          // "assets/textures/wood/background.jpg"
                        repeat: "no-repeat",
                        position: "center", 
                        size: "cover"
                    }
                },
                platform: {
                    texture: "wood_grain",
                    color: "#8B4513",
                    material: "wood",
                    pattern: "grain",
                    // Wood platform texture
                    image: {
                        url: null,          // "assets/textures/wood/platform.jpg"
                        repeat: "repeat-x",
                        blend: "multiply",
                        opacity: 0.8
                    }
                },
                shapes: {
                    useTextures: true,
                    baseTexturePath: "textures/wood/",
                    specialEffects: ["grain", "knot"],
                    animations: ["creak", "sway"],
                    textures: {
                        square: { url: null, repeat: "repeat", blend: "multiply", opacity: 0.7 },
                        circle: { url: null, repeat: "repeat", blend: "multiply", opacity: 0.7 },
                        triangle: { url: null, repeat: "repeat", blend: "multiply", opacity: 0.7 },
                        cross: { url: null, repeat: "repeat", blend: "multiply", opacity: 0.7 },
                        cross2: { url: null, repeat: "repeat", blend: "multiply", opacity: 0.7 },
                        l: { url: null, repeat: "repeat", blend: "multiply", opacity: 0.7 },
                        "barbell-one": { url: null, repeat: "repeat", blend: "multiply", opacity: 0.7 },
                        "barbell-two": { url: null, repeat: "repeat", blend: "multiply", opacity: 0.7 },
                        "diamond-barbell": { url: null, repeat: "repeat", blend: "multiply", opacity: 0.7 }
                    }
                },
                particles: {
                    style: "sawdust",
                    colors: ["#D2B48C", "#DEB887", "#F4A460"]
                }
            },
            
            stone: {
                name: "Stone",
                description: "Ancient stone structures with granite and marble textures", 
                background: {
                    type: "gradient",
                    colors: ["#2F4F4F", "#708090", "#778899"],
                    texture: null,
                    // Stone background image support
                    image: {
                        url: null,          // "textures/stone-background.jpg"
                        repeat: "no-repeat",
                        position: "center",
                        size: "cover"
                    }
                },
                platform: {
                    texture: null,
                    color: "#696969",
                    material: "granite",
                    pattern: "rough",
                    // Stone platform texture
                    image: {
                        url: null,          // "textures/granite-platform.jpg"
                        repeat: "repeat",
                        blend: "hard-light",
                        opacity: 0.9
                    }
                },
                shapes: {
                    useTextures: true,
                    baseTexturePath: "textures/stone/",
                    specialEffects: ["dust", "crack"],
                    animations: ["settle", "crumble"],
                    textures: {
                        square: { url: null, repeat: "repeat", blend: "multiply", opacity: 0.8 },
                        circle: { url: null, repeat: "repeat", blend: "multiply", opacity: 0.8 },
                        triangle: { url: null, repeat: "repeat", blend: "multiply", opacity: 0.8 },
                        cross: { url: null, repeat: "repeat", blend: "multiply", opacity: 0.8 },
                        cross2: { url: null, repeat: "repeat", blend: "multiply", opacity: 0.8 },
                        l: { url: null, repeat: "repeat", blend: "multiply", opacity: 0.8 },
                        "barbell-one": { url: null, repeat: "repeat", blend: "multiply", opacity: 0.8 },
                        "barbell-two": { url: null, repeat: "repeat", blend: "multiply", opacity: 0.8 },
                        "diamond-barbell": { url: null, repeat: "repeat", blend: "multiply", opacity: 0.8 }
                    }
                },
                particles: {
                    style: "dust", 
                    colors: ["#A9A9A9", "#D3D3D3", "#C0C0C0"]
                }
            },
            
            metal: {
                name: "Metal",
                description: "Industrial metal structures with steel and iron textures",
                background: {
                    type: "gradient",
                    colors: ["#2F4F4F", "#696969", "#708090"],
                    texture: null,
                    // Metal background image support
                    image: {
                        url: null,          // "textures/metal-background.jpg"
                        repeat: "no-repeat",
                        position: "center",
                        size: "cover"
                    }
                },
                platform: {
                    texture: null,
                    color: "#696969", 
                    material: "steel",
                    pattern: "industrial",
                    // Steel platform texture
                    image: {
                        url: null,          // "textures/steel-platform.jpg"
                        repeat: "repeat",
                        blend: "hard-light",
                        opacity: 0.9
                    }
                },
                shapes: {
                    useTextures: true,
                    baseTexturePath: "textures/metal/",
                    specialEffects: ["spark", "gleam"],
                    animations: ["clang", "shine"],
                    textures: {
                        square: { url: null, repeat: "repeat", blend: "overlay", opacity: 0.9 },
                        circle: { url: null, repeat: "repeat", blend: "overlay", opacity: 0.9 },
                        triangle: { url: null, repeat: "repeat", blend: "overlay", opacity: 0.9 },
                        cross: { url: null, repeat: "repeat", blend: "overlay", opacity: 0.9 },
                        cross2: { url: null, repeat: "repeat", blend: "overlay", opacity: 0.9 },
                        l: { url: null, repeat: "repeat", blend: "overlay", opacity: 0.9 },
                        "barbell-one": { url: null, repeat: "repeat", blend: "overlay", opacity: 0.9 },
                        "barbell-two": { url: null, repeat: "repeat", blend: "overlay", opacity: 0.9 },
                        "diamond-barbell": { url: null, repeat: "repeat", blend: "overlay", opacity: 0.9 }
                    }
                },
                particles: {
                    style: "sparks",
                    colors: ["#C0C0C0", "#FFD700", "#FF4500"]
                }
            }
        };

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë UNIFIED SHAPE CONFIGURATION - PHYSICS-FIRST APPROACH
          ‚ïë Single source of truth for ALL shape appearances and properties
          ‚ïë Eliminates dual CSS/Canvas systems in favor of physics-based rendering
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        const SHAPE_CONFIG = {
            square: {
                // Visual properties
                color: '#F39C12',
                stroke: '#E67E22',
                strokeWidth: 2,

                // Physical properties  
                width: 35,
                height: 35,
                density: 0.5,
                friction: 0.7,
                restitution: 0.2,

                // Rendering properties
                type: 'rectangle',
                borderRadius: 3
            },

            triangle: {
                color: '#9B59B6',
                stroke: '#8E44AD', 
                strokeWidth: 2,

                // Triangle vertices (relative to center)
                vertices: [
                    { x: 0, y: -15 },      // Top point
                    { x: -17.5, y: 15 },   // Bottom left
                    { x: 17.5, y: 15 }     // Bottom right
                ],
                density: 0.5,
                friction: 0.7,
                restitution: 0.2,

                type: 'polygon'
            },

            circle: {
                color: '#1ABC9C',
                stroke: '#16A085',
                strokeWidth: 2,

                radius: 17.5,
                density: 0.5,
                friction: 0.7,
                restitution: 0.2,

                type: 'circle'
            },

            cross: {
                color: '#E74C3C',         // Changed from green to red for better contrast
                stroke: '#C0392B',
                strokeWidth: 2,

                // Cross consists of two overlapping rectangles
                parts: [
                    {
                        type: 'rectangle',
                        width: 15,
                        height: 35,
                        offsetX: 0,
                        offsetY: 0
                    },
                    {
                        type: 'rectangle', 
                        width: 35,
                        height: 15,
                        offsetX: 0,
                        offsetY: 0
                    }
                ],
                density: 0.5,
                friction: 0.7,
                restitution: 0.2,

                type: 'compound'
            },

            cross2: {
                color: '#3498DB',         // Changed from pink to blue for better contrast
                stroke: '#2980B9',
                strokeWidth: 2,

                parts: [
                    {
                        type: 'rectangle',
                        width: 15,
                        height: 35,
                        offsetX: 0,
                        offsetY: 0
                    },
                    {
                        type: 'rectangle',
                        width: 35, 
                        height: 15,
                        offsetX: 0,
                        offsetY: 0
                    }
                ],
                density: 0.5,
                friction: 0.7,
                restitution: 0.2,

                type: 'compound'
            },

            l: {
                color: '#8E44AD',         // Changed from orange to purple for variety
                stroke: '#732D91',
                strokeWidth: 2,

                // L-shape consists of two rectangles
                parts: [
                    {
                        type: 'rectangle',
                        width: 15,
                        height: 35,
                        offsetX: -7.5,      // Left side
                        offsetY: 0
                    },
                    {
                        type: 'rectangle',
                        width: 15,
                        height: 15, 
                        offsetX: 7.5,       // Right extension
                        offsetY: 10         // Bottom alignment
                    }
                ],
                density: 0.5,
                friction: 0.7,
                restitution: 0.2,

                type: 'compound'
            },

            'barbell-one': {
                color: '#16A085',
                stroke: '#138D75',
                strokeWidth: 2,

                parts: [
                    {
                        type: 'rectangle',
                        width: 31,
                        height: 5,
                        offsetX: -12,
                        offsetY: 0
                    },
                    {
                        type: 'circle',
                        radius: 8,
                        offsetX: 12,
                        offsetY: 0
                    }
                ],
                density: 0.5,
                friction: 0.7,
                restitution: 0.2,

                type: 'compound'
            },

            'barbell-two': {
                color: '#D35400',
                stroke: '#BA4A00',
                strokeWidth: 2,

                parts: [
                    {
                        type: 'rectangle',
                        width: 26,
                        height: 5,
                        offsetX: 0,
                        offsetY: 0
                    },
                    {
                        type: 'circle',
                        radius: 9,
                        offsetX: -17,
                        offsetY: 0
                    },
                    {
                        type: 'circle',
                        radius: 9,
                        offsetX: 17,
                        offsetY: 0
                    }
                ],
                density: 0.5,
                friction: 0.7,
                restitution: 0.2,

                type: 'compound'
            },

            'diamond-barbell': {
                color: '#C0392B',
                stroke: '#A93226',
                strokeWidth: 2,

                parts: [
                    {
                        type: 'rectangle',
                        width: 26,
                        height: 5,
                        offsetX: -13,
                        offsetY: 0
                    },
                    {
                        type: 'diamond',
                        width: 12,
                        height: 12,
                        offsetX: 13,
                        offsetY: 0
                    }
                ],
                density: 0.5,
                friction: 0.7,
                restitution: 0.2,

                type: 'compound'
            }
        };

        // Utility functions for shape configuration
        function getShapeConfig(shapeType) {
            // V14: Commented out verbose debugging
            // console.log(`üîç Getting shape config for: ${shapeType}`);
            // console.log(`üîç window.currentTheme:`, window.currentTheme);
            // console.log(`üîç window.currentTheme?.shapes?.textures:`, window.currentTheme?.shapes?.textures);
            
            // First check if there's an active theme with shape overrides
            if (window.gameManager && 
                window.gameManager.physicsManager.rendererManager.pixiManager.themeManager) {
                
                const themeManager = window.gameManager.physicsManager.rendererManager.pixiManager.themeManager;
                const currentTheme = themeManager.themes[themeManager.currentTheme];
                
                if (currentTheme && currentTheme.shapeOverrides && currentTheme.shapeOverrides[shapeType]) {
                    // Create a copy of the base config and override with theme colors
                    const baseConfig = {...(SHAPE_CONFIG[shapeType] || {})};
                    const themeOverride = currentTheme.shapeOverrides[shapeType];
                    
                    const themedConfig = {
                        ...baseConfig,
                        color: themeOverride.color || baseConfig.color,
                        stroke: themeOverride.stroke || baseConfig.stroke
                    };
                    
                    // Check for texture information
                    if (window.currentTheme?.shapes?.textures && window.currentTheme.shapes.textures[shapeType]) {
                        themedConfig.texture = window.currentTheme.shapes.textures[shapeType];
                        console.log(`üé® Added texture to ${shapeType} config:`, themedConfig.texture);
                    }
                    
                    console.log(`üé® Using themed config for ${shapeType}:`, themedConfig);
                    return themedConfig;
                }
            }
            
            // Also check for textures in fallback case
            const baseConfig = {...(SHAPE_CONFIG[shapeType] || {})};
            if (window.currentTheme?.shapes?.textures && window.currentTheme.shapes.textures[shapeType]) {
                baseConfig.texture = window.currentTheme.shapes.textures[shapeType];
                console.log(`üé® Added texture to default ${shapeType} config:`, baseConfig.texture);
            }
            
            // Fallback to original config
            // V14: Commented out verbose config logging
            // console.log(`üì¶ Using config for ${shapeType}:`, baseConfig);
            return baseConfig;
        }

        function getAllShapeTypes() {
            return Object.keys(SHAPE_CONFIG);
        }

        function validateShapeConfig() {
            // Validation logic can be added here
            return true;
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë ASSET MANAGER - HANDLES TEXTURE LOADING AND THEME ASSETS
          ‚ïë Provides centralized asset management with fallbacks and caching
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        class AssetManager {
            constructor() {
                this.themes = {};
                this.currentTheme = CANVAS_CONFIG.defaultTheme;
                this.loadingProgress = 0;
                this.isLoaded = false;
                this.textureCache = new Map();
                this.loadingCallbacks = [];
                this.imageCache = new Map(); // Cache for loaded images
                this.loadingPromises = new Map(); // Track loading promises
            }

            async loadTheme(themeName) {
                if (!CANVAS_CONFIG.enabled || !CANVAS_CONFIG.useThemes) {
                    console.log('üì¶ Asset Manager: Canvas enhancements disabled');
                    return;
                }

                console.log(`üì¶ Loading theme: ${themeName}`);
                
                try {
                    const themeConfig = THEME_DEFINITIONS[themeName];
                    if (!themeConfig) {
                        console.error(`‚ùå Theme not found: ${themeName}`);
                        return;
                    }

                    // Initialize theme structure
                    this.themes[themeName] = {
                        config: themeConfig,
                        assets: {
                            backgroundImage: null,
                            platformImage: null,
                            shapeTextures: {}
                        },
                        loaded: false
                    };

                    // Load all images for this theme
                    await this.loadThemeImages(themeName, themeConfig);
                    
                    this.themes[themeName].loaded = true;
                    this.loadingProgress = 100;
                    this.isLoaded = true;
                    
                    console.log(`‚úÖ Theme loaded: ${themeName}`);
                    this.notifyLoadingComplete(themeName);
                    
                } catch (error) {
                    console.error(`‚ùå Failed to load theme ${themeName}:`, error);
                    this.loadingProgress = 0;
                }
            }

            async loadThemeImages(themeName, themeConfig) {
                const loadPromises = [];
                const theme = this.themes[themeName];

                // Load background image
                if (themeConfig.background.image && themeConfig.background.image.url) {
                    const bgPromise = this.loadImage(themeConfig.background.image.url)
                        .then(img => {
                            theme.assets.backgroundImage = img;
                            console.log(`üñºÔ∏è Background image loaded for ${themeName}`);
                        })
                        .catch(err => {
                            console.warn(`‚ö†Ô∏è Background image failed for ${themeName}:`, err.message);
                        });
                    loadPromises.push(bgPromise);
                }

                // Load platform image
                if (themeConfig.platform.image && themeConfig.platform.image.url) {
                    const platformPromise = this.loadImage(themeConfig.platform.image.url)
                        .then(img => {
                            theme.assets.platformImage = img;
                            console.log(`üèóÔ∏è Platform image loaded for ${themeName}`);
                        })
                        .catch(err => {
                            console.warn(`‚ö†Ô∏è Platform image failed for ${themeName}:`, err.message);
                        });
                    loadPromises.push(platformPromise);
                }

                // Load shape textures
                if (themeConfig.shapes.textures) {
                    Object.keys(themeConfig.shapes.textures).forEach(shapeType => {
                        const textureConfig = themeConfig.shapes.textures[shapeType];
                        if (textureConfig.url) {
                            const shapePromise = this.loadImage(textureConfig.url)
                                .then(img => {
                                    theme.assets.shapeTextures[shapeType] = img;
                                    console.log(`üî∂ Shape texture loaded for ${shapeType} in ${themeName}`);
                                })
                                .catch(err => {
                                    console.warn(`‚ö†Ô∏è Shape texture failed for ${shapeType} in ${themeName}:`, err.message);
                                });
                            loadPromises.push(shapePromise);
                        }
                    });
                }

                // Wait for all images to load (or fail)
                await Promise.allSettled(loadPromises);
                
                const successCount = loadPromises.length;
                console.log(`üì¶ Theme ${themeName}: Attempted to load ${successCount} images`);
            }

            async loadImage(url) {
                // Check cache first
                if (this.imageCache.has(url)) {
                    return this.imageCache.get(url);
                }

                // Check if already loading
                if (this.loadingPromises.has(url)) {
                    return this.loadingPromises.get(url);
                }

                // Create loading promise
                const loadPromise = new Promise((resolve, reject) => {
                    const img = new Image();
                    img.crossOrigin = 'anonymous'; // Enable CORS for external images
                    
                    img.onload = () => {
                        this.imageCache.set(url, img);
                        this.loadingPromises.delete(url);
                        resolve(img);
                    };
                    
                    img.onerror = () => {
                        this.loadingPromises.delete(url);
                        reject(new Error(`Failed to load image: ${url}`));
                    };
                    
                    img.src = url;
                    
                    // Set timeout for image loading
                    setTimeout(() => {
                        if (!img.complete) {
                            this.loadingPromises.delete(url);
                            reject(new Error(`Image load timeout: ${url}`));
                        }
                    }, 10000); // 10 second timeout
                });

                this.loadingPromises.set(url, loadPromise);
                return loadPromise;
            }

            // Get loaded image assets
            getBackgroundImage(themeName = null) {
                const theme = themeName ? this.getTheme(themeName) : this.getCurrentTheme();
                return theme?.assets?.backgroundImage || null;
            }

            getPlatformImage(themeName = null) {
                const theme = themeName ? this.getTheme(themeName) : this.getCurrentTheme();
                return theme?.assets?.platformImage || null;
            }

            getShapeTexture(shapeType, themeName = null) {
                const theme = themeName ? this.getTheme(themeName) : this.getCurrentTheme();
                return theme?.assets?.shapeTextures?.[shapeType] || null;
            }

            // Clear cache (useful for development)
            clearImageCache() {
                this.imageCache.clear();
                this.loadingPromises.clear();
                console.log('üßπ Image cache cleared');
            }
            
            clearThemeImages(themeName) {
                console.log(`üßπ ImageAssetManager: Clearing images for theme: ${themeName}`);
                
                // Get theme configuration
                const themeConfig = THEME_DEFINITIONS[themeName];
                if (!themeConfig) return;
                
                const themeUrls = new Set();
                
                // Add background image URL
                if (themeConfig.background?.image?.url) {
                    themeUrls.add(themeConfig.background.image.url);
                }
                
                // Add platform image URL
                if (themeConfig.platform?.image?.url) {
                    themeUrls.add(themeConfig.platform.image.url);
                }
                
                // Add shape texture URLs
                if (themeConfig.shapes?.textures) {
                    Object.values(themeConfig.shapes.textures).forEach(textureData => {
                        if (textureData?.url) {
                            themeUrls.add(textureData.url);
                        }
                    });
                }
                
                // Remove theme images from cache
                let removedCount = 0;
                for (const url of themeUrls) {
                    if (this.imageCache.has(url)) {
                        this.imageCache.delete(url);
                        removedCount++;
                    }
                    if (this.loadingPromises.has(url)) {
                        this.loadingPromises.delete(url);
                    }
                }
                
                // Clear the theme data as well
                if (this.themes[themeName]) {
                    delete this.themes[themeName];
                }
                
                console.log(`üßπ ImageAssetManager: Removed ${removedCount} images for theme: ${themeName}`);
            }

            getTheme(themeName) {
                return this.themes[themeName] || null;
            }

            getCurrentTheme() {
                return this.getTheme(this.currentTheme);
            }

            getBackgroundStyle(themeName = null) {
                const theme = themeName ? this.getTheme(themeName) : this.getCurrentTheme();
                if (!theme) return null;
                
                const bgConfig = theme.config.background;
                const bgImage = this.getBackgroundImage(themeName);
                
                return {
                    type: bgConfig.type,
                    colors: bgConfig.colors,
                    image: bgImage,
                    imageConfig: bgConfig.image || null
                };
            }

            getPlatformStyle(themeName = null) {
                const theme = themeName ? this.getTheme(themeName) : this.getCurrentTheme();
                if (!theme) return null;
                
                const platformConfig = theme.config.platform;
                const platformImage = this.getPlatformImage(themeName);
                
                return {
                    ...platformConfig,
                    image: platformImage,
                    imageConfig: platformConfig.image || null
                };
            }

            getShapeStyle(shapeType, themeName = null) {
                const theme = themeName ? this.getTheme(themeName) : this.getCurrentTheme();
                if (!theme) return null;
                
                const shapeConfig = theme.config.shapes;
                const shapeTexture = this.getShapeTexture(shapeType, themeName);
                
                if (shapeConfig.textures && shapeConfig.textures[shapeType]) {
                    return {
                        useTextures: shapeConfig.useTextures,
                        texture: shapeTexture,
                        textureConfig: shapeConfig.textures[shapeType]
                    };
                }
                
                return {
                    useTextures: false,
                    texture: null,
                    textureConfig: null
                };
            }

            getParticleStyle(themeName = null) {
                const theme = themeName ? this.getTheme(themeName) : this.getCurrentTheme();
                if (!theme) return null;
                
                return theme.config.particles;
            }

            notifyLoadingComplete(themeName) {
                this.loadingCallbacks.forEach(callback => {
                    try {
                        callback(themeName);
                    } catch (error) {
                        console.error('‚ùå Error in loading callback:', error);
                    }
                });
            }

            onThemeLoaded(callback) {
                this.loadingCallbacks.push(callback);
            }
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë PIXIJS CORE SYSTEM - PHASE 1: FOUNDATION & SETUP
          ‚ïë Non-breaking integration of PixiJS alongside existing Canvas system
          ‚ïë Provides dual-renderer architecture with automatic fallback
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        class PixiManager {
            constructor(canvas) {
                this.canvas = canvas;
                this.app = null;
                this.isInitialized = false;
                this.isActive = false;
                this.containers = new Map();
                this.errorCount = 0;
                this.maxErrors = 3;
                
                // Phase 3: Animation and Theme managers
                this.animationManager = null;
                this.themeManager = null;
                
                // Feature availability flags
                this.featuresAvailable = {
                    webgl: false,
                    canvas: false,
                    basic: false
                };
                
                console.log('üé® PixiJS Manager created (inactive)');
            }

            async initialize() {
                if (this.isInitialized) return true;
                
                console.log('üîß Starting PixiJS initialization...');
                
                try {
                    // Detect PixiJS availability
                    if (typeof PIXI === 'undefined') {
                        console.warn('‚ö†Ô∏è PixiJS not available, falling back to Canvas');
                        return false;
                    }
                    
                    console.log('‚úÖ PixiJS library detected, version:', PIXI.VERSION);

                    // Create PIXI Application with detailed logging
                    console.log('üîß Creating PIXI Application with config:', {
                        width: this.canvas.width,
                        height: this.canvas.height,
                        backgroundColor: PIXI_CONFIG.performance.backgroundAlpha,
                        transparent: PIXI_CONFIG.performance.transparent,
                        antialias: PIXI_CONFIG.performance.antialias,
                        powerPreference: PIXI_CONFIG.performance.powerPreference
                    });
                    
                    // Try Canvas renderer explicitly if WebGL fails
                    let appConfig = {
                        view: this.canvas,
                        width: this.canvas.width,
                        height: this.canvas.height,
                        backgroundColor: PIXI_CONFIG.performance.backgroundAlpha,
                        transparent: PIXI_CONFIG.performance.transparent,
                        antialias: PIXI_CONFIG.performance.antialias,
                        resolution: this.getOptimalResolution(),
                        powerPreference: PIXI_CONFIG.performance.powerPreference
                    };

                    // Try WebGL first, fall back to Canvas
                    try {
                        this.app = new PIXI.Application(appConfig);
                        console.log('‚úÖ PIXI Application created with WebGL renderer');
                    } catch (webglError) {
                        console.log('‚ö†Ô∏è WebGL failed, trying Canvas renderer:', webglError.message);
                        
                        // Force Canvas renderer
                        appConfig.forceCanvas = true;
                        try {
                            this.app = new PIXI.Application(appConfig);
                            console.log('‚úÖ PIXI Application created with Canvas renderer');
                        } catch (canvasError) {
                            console.log('‚ùå Both WebGL and Canvas failed, trying basic renderer...');
                            
                            // Last resort - create minimal renderer
                            this.app = {
                                renderer: {
                                    type: 'canvas',
                                    width: this.canvas.width,
                                    height: this.canvas.height,
                                    resolution: 1
                                },
                                stage: new PIXI.Container(),
                                view: this.canvas,
                                ticker: new PIXI.Ticker()
                            };
                            console.log('‚ö†Ô∏è Using minimal PixiJS compatibility mode');
                        }
                    }
                    
                    console.log('üîß PIXI Application created successfully');

                    // Check renderer capabilities (handle fallback cases)
                    if (this.app.renderer) {
                        this.featuresAvailable.webgl = this.app.renderer.type === PIXI.RENDERER_TYPE.WEBGL;
                        this.featuresAvailable.canvas = this.app.renderer.type === PIXI.RENDERER_TYPE.CANVAS || this.app.renderer.type === 'canvas';
                        this.featuresAvailable.basic = true;
                    } else {
                        // Minimal compatibility mode
                        this.featuresAvailable.webgl = false;
                        this.featuresAvailable.canvas = true;
                        this.featuresAvailable.basic = true;
                    }
                    
                    console.log('üîß Renderer capabilities detected:', this.featuresAvailable);

                    // Create base containers
                    this.createBaseContainers();
                    
                    // Handle resize
                    this.setupResizeHandling();

                    this.isInitialized = true;
                    console.log('‚úÖ PixiJS initialized successfully', {
                        renderer: this.featuresAvailable.webgl ? 'WebGL' : 'Canvas',
                        resolution: this.app.renderer.resolution,
                        size: `${this.app.renderer.width}x${this.app.renderer.height}`
                    });
                    
                    // Phase 3: Initialize Animation and Theme managers
                    this.animationManager = new PixiAnimationManager(this);
                    this.themeManager = new PixiThemeManager(this);
                    
                    // Update enhanced theme selector with available themes
                    this.updateEnhancedThemeSelector();
                    
                    // Enable animations if configured
                    if (PIXI_CONFIG.animations.enabled) {
                        this.animationManager.enable();
                    }
                    
                    console.log('‚úÖ Phase 3 managers initialized: Animation & Theme');
                    
                    return true;
                } catch (error) {
                    console.error('‚ùå PixiJS initialization failed:', error);
                    this.handleError(error);
                    return false;
                }
            }

            getOptimalResolution() {
                if (PIXI_CONFIG.performance.resolution === 'auto') {
                    // Use device pixel ratio but cap at 2 for performance
                    return Math.min(window.devicePixelRatio || 1, 2);
                }
                return PIXI_CONFIG.performance.resolution;
            }

            createBaseContainers() {
                // Background layer (behind physics objects)
                this.containers.set('background', new PIXI.Container());
                
                // Main game layer (physics objects)
                this.containers.set('game', new PIXI.Container());
                
                // Particle layer (effects)
                this.containers.set('particles', new PIXI.Container());
                
                // UI layer (front-most)
                this.containers.set('ui', new PIXI.Container());

                // Add containers to stage in order
                ['background', 'game', 'particles', 'ui'].forEach(name => {
                    this.app.stage.addChild(this.containers.get(name));
                });

                console.log('üì¶ PixiJS containers created: background, game, particles, ui');
            }

            setupResizeHandling() {
                const resizeObserver = new ResizeObserver(() => {
                    if (this.isActive) {
                        this.resize();
                    }
                });
                
                resizeObserver.observe(this.canvas);
                this.resizeObserver = resizeObserver;
            }

            resize() {
                if (!this.app || !this.isActive) return;
                
                try {
                    const rect = this.canvas.getBoundingClientRect();
                    
                    // Check if resize function exists (full PixiJS vs minimal mode)
                    if (this.app.renderer && typeof this.app.renderer.resize === 'function') {
                        this.app.renderer.resize(rect.width, rect.height);
                        console.log('üîÑ PixiJS resized:', rect.width, 'x', rect.height);
                    } else {
                        // Minimal compatibility mode - just update dimensions
                        if (this.app.renderer) {
                            this.app.renderer.width = rect.width;
                            this.app.renderer.height = rect.height;
                        }
                        console.log('üîÑ PixiJS compatibility mode - dimensions updated:', rect.width, 'x', rect.height);
                    }
                } catch (error) {
                    console.error('‚ùå PixiJS resize error:', error);
                    this.handleError(error);
                }
            }

            activate() {
                if (!this.isInitialized || this.isActive) return false;
                
                try {
                    // Clear canvas to let PixiJS take over
                    const ctx = this.canvas.getContext('2d');
                    if (ctx) {
                        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    }
                    
                    this.isActive = true;
                    console.log('‚úÖ PixiJS renderer activated');
                    return true;
                } catch (error) {
                    console.error('‚ùå PixiJS activation failed:', error);
                    this.handleError(error);
                    return false;
                }
            }

            deactivate() {
                if (!this.isActive) return;
                
                this.isActive = false;
                
                // Clear PixiJS stage
                if (this.app) {
                    this.app.stage.removeChildren();
                    // Recreate containers for next activation
                    this.createBaseContainers();
                }
                
                console.log('üîÑ PixiJS renderer deactivated - Canvas fallback active');
            }

            getContainer(name) {
                return this.containers.get(name);
            }

            updateEnhancedThemeSelector() {
                try {
                    const enhancedThemeSelect = document.getElementById('enhancedThemeSelect');
                    if (enhancedThemeSelect && this.themeManager) {
                        // Clear existing options
                        enhancedThemeSelect.innerHTML = '';
                        
                        // Define the allowed themes in the desired order - using material names
                        const allowedThemes = [
                            { key: 'classic', name: 'Classic' },
                            { key: 'wood', name: 'Wood' },
                            { key: 'stone', name: 'Stone' },
                            { key: 'metal', name: 'Metal' }
                        ];
                        
                        // Add only the allowed theme options
                        allowedThemes.forEach(({ key, name }) => {
                            const option = document.createElement('option');
                            option.value = key;
                            option.textContent = name;
                            if (key === 'classic') {
                                option.selected = true; // Make Classic the default
                            }
                            enhancedThemeSelect.appendChild(option);
                        });
                        
                        console.log(`üé® Updated enhanced theme selector with ${allowedThemes.length} filtered themes`);
                    }
                } catch (error) {
                    console.warn('‚ö†Ô∏è Failed to update enhanced theme selector:', error);
                }
            }

            handleError(error) {
                this.errorCount++;
                console.error(`‚ùå PixiJS Error ${this.errorCount}/${this.maxErrors}:`, error);
                
                if (this.errorCount >= this.maxErrors) {
                    console.warn('‚ö†Ô∏è Too many PixiJS errors, forcing Canvas fallback');
                    this.forceCanvasFallback();
                }
            }

            forceCanvasFallback() {
                this.deactivate();
                PIXI_CONFIG.enabled = false;
                
                // Notify any listeners that we've fallen back to Canvas
                if (window.gameManager && window.gameManager.onPixiFallback) {
                    window.gameManager.onPixiFallback();
                }
                
                console.log('üîÑ Forced Canvas fallback due to PixiJS errors');
            }

            destroy() {
                if (this.resizeObserver) {
                    this.resizeObserver.disconnect();
                }
                
                if (this.app) {
                    this.app.destroy(true);
                    this.app = null;
                }
                
                this.isInitialized = false;
                this.isActive = false;
                console.log('üóëÔ∏è PixiJS Manager destroyed');
            }
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë RENDERER MANAGER - DUAL RENDERER SYSTEM
          ‚ïë Manages Canvas and PixiJS renderers with automatic switching
          ‚ïë Provides unified interface for both rendering systems
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        class RendererManager {
            constructor(canvas) {
                this.canvas = canvas;
                this.currentRenderer = 'canvas'; // Start with canvas
                this.pixiManager = new PixiManager(canvas);
                this.canvasContext = canvas.getContext('2d');
                
                // Performance tracking
                this.performanceMetrics = {
                    fps: 60,
                    drawCalls: 0,
                    lastFrameTime: performance.now()
                };
                
                console.log('üé® Dual Renderer Manager initialized (Canvas active)');
            }

            async initialize() {
                // Always initialize Canvas (it's our fallback)
                this.initializeCanvas();
                
                // Always try to initialize PixiJS (so it's available when enabled)
                console.log('üîß RendererManager: Initializing PixiJS...');
                const pixiSuccess = await this.pixiManager.initialize();
                console.log(`üîß RendererManager: PixiJS init result: ${pixiSuccess}`);
                
                if (pixiSuccess) {
                    console.log('‚úÖ Dual renderer system ready (Canvas + PixiJS)');
                    // Start with the configured renderer
                    if (PIXI_CONFIG.enabled) {
                        this.switchRenderer('pixi');
                    }
                    return true;
                } else {
                    console.log('‚ö†Ô∏è PixiJS initialization failed, using Canvas only');
                    PIXI_CONFIG.enabled = false; // Disable if init failed
                }
                
                console.log('‚úÖ Canvas renderer ready');
                return true;
            }

            initializeCanvas() {
                // Canvas is already initialized, just ensure it's ready
                if (!this.canvasContext) {
                    this.canvasContext = this.canvas.getContext('2d');
                }
                console.log('‚úÖ Canvas renderer initialized');
            }

            switchRenderer(targetRenderer) {
                if (!this.canSwitchTo(targetRenderer)) {
                    console.warn(`‚ö†Ô∏è Cannot switch to ${targetRenderer}, staying with ${this.currentRenderer}`);
                    return false;
                }

                const previousRenderer = this.currentRenderer;

                try {
                    // Deactivate current renderer
                    if (this.currentRenderer === 'pixi') {
                        this.pixiManager.deactivate();
                    }

                    // Activate new renderer
                    if (targetRenderer === 'pixi') {
                        const success = this.pixiManager.activate();
                        if (!success) {
                            throw new Error('PixiJS activation failed');
                        }
                    }

                    this.currentRenderer = targetRenderer;
                    console.log(`üîÑ Switched renderer: ${previousRenderer} ‚Üí ${targetRenderer}`);
                    return true;

                } catch (error) {
                    console.error('‚ùå Renderer switch failed:', error);
                    
                    // Fallback to canvas
                    if (targetRenderer !== 'canvas') {
                        console.log('üîÑ Falling back to Canvas renderer');
                        this.currentRenderer = 'canvas';
                        this.pixiManager.deactivate();
                    }
                    return false;
                }
            }

            canSwitchTo(renderer) {
                switch (renderer) {
                    case 'canvas':
                        return true; // Canvas is always available
                    case 'pixi':
                        const canSwitch = PIXI_CONFIG.enabled && this.pixiManager.isInitialized;
                        if (!canSwitch) {
                            console.log(`üîç PixiJS switch check: enabled=${PIXI_CONFIG.enabled}, initialized=${this.pixiManager.isInitialized}`);
                        }
                        return canSwitch;
                    case 'auto':
                        return true; // Auto-selection is always valid
                    default:
                        return false;
                }
            }

            autoSelectRenderer() {
                if (PIXI_CONFIG.renderer === 'canvas') {
                    return this.switchRenderer('canvas');
                }
                
                if (PIXI_CONFIG.renderer === 'pixi') {
                    return this.switchRenderer('pixi');
                }
                
                // Auto mode: prefer PixiJS if available, fallback to Canvas
                if (this.canSwitchTo('pixi') && PIXI_CONFIG.enabled) {
                    return this.switchRenderer('pixi');
                } else {
                    return this.switchRenderer('canvas');
                }
            }

            getCurrentRenderer() {
                return this.currentRenderer;
            }

            isPixiActive() {
                return this.currentRenderer === 'pixi' && this.pixiManager.isActive;
            }

            getPixiContainer(name) {
                if (this.isPixiActive()) {
                    return this.pixiManager.getContainer(name);
                }
                return null;
            }

            updatePerformanceMetrics() {
                const now = performance.now();
                const deltaTime = now - this.performanceMetrics.lastFrameTime;
                this.performanceMetrics.fps = 1000 / deltaTime;
                this.performanceMetrics.lastFrameTime = now;
                
                if (PIXI_CONFIG.debug.logPerformance) {
                    console.log('üìä Performance:', {
                        renderer: this.currentRenderer,
                        fps: Math.round(this.performanceMetrics.fps),
                        drawCalls: this.performanceMetrics.drawCalls
                    });
                }
            }

            destroy() {
                this.pixiManager.destroy();
                console.log('üóëÔ∏è Renderer Manager destroyed');
            }
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë PIXIJS SHAPE SYSTEM - PHASE 2: SHAPE RENDERING MIGRATION
          ‚ïë Creates PixiJS equivalents for all existing Canvas shapes
          ‚ïë Maintains visual parity while enabling advanced graphics features
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        class PixiShapeFactory {
            static createSquare(config) {
                const graphics = new PIXI.Graphics();
                
                // Use configuration from SHAPE_CONFIG
                const { color, stroke, strokeWidth, width, height, borderRadius, texture } = config;
                
                // Check if texture is available and valid
                if (texture && texture.url) {
                    try {
                        // Create sprite with texture
                        const sprite = PIXI.Sprite.from(texture.url);
                        sprite.anchor.set(0.5);
                        sprite.width = width;
                        sprite.height = height;
                        sprite.tint = this.parseColor(color);
                        
                        // Apply texture properties
                        if (texture.opacity !== undefined) {
                            sprite.alpha = texture.opacity;
                        }
                        
                        console.log(`‚úÖ Applied texture to square: ${texture.url}`);
                        return sprite;
                    } catch (error) {
                        console.warn(`‚ö†Ô∏è Failed to load texture ${texture.url}, using color fallback:`, error);
                        // Fall through to regular graphics creation
                    }
                }
                
                // Regular graphics creation (fallback or no texture)
                graphics.lineStyle(strokeWidth, this.parseColor(stroke));
                graphics.beginFill(this.parseColor(color));
                
                if (borderRadius > 0) {
                    graphics.drawRoundedRect(-width/2, -height/2, width, height, borderRadius);
                } else {
                    graphics.drawRect(-width/2, -height/2, width, height);
                }
                
                graphics.endFill();
                return graphics;
            }

            static createCircle(config) {
                const graphics = new PIXI.Graphics();
                const { color, stroke, strokeWidth, radius, texture } = config;
                
                // Check if texture is available and valid
                if (texture && texture.url) {
                    try {
                        // Create sprite with texture
                        const sprite = PIXI.Sprite.from(texture.url);
                        sprite.anchor.set(0.5);
                        sprite.width = sprite.height = radius * 2;
                        sprite.tint = this.parseColor(color);
                        
                        // Apply texture properties
                        if (texture.opacity !== undefined) {
                            sprite.alpha = texture.opacity;
                        }
                        
                        // Make it circular using a mask
                        const mask = new PIXI.Graphics();
                        mask.beginFill(0xFFFFFF);
                        mask.drawCircle(0, 0, radius);
                        mask.endFill();
                        sprite.mask = mask;
                        
                        // Create container to hold both sprite and mask
                        const container = new PIXI.Container();
                        container.addChild(sprite);
                        container.addChild(mask);
                        
                        console.log(`‚úÖ Applied texture to circle: ${texture.url}`);
                        return container;
                    } catch (error) {
                        console.warn(`‚ö†Ô∏è Failed to load texture ${texture.url}, using color fallback:`, error);
                        // Fall through to regular graphics creation
                    }
                }
                
                // Regular graphics creation (fallback or no texture)
                graphics.lineStyle(strokeWidth, this.parseColor(stroke));
                graphics.beginFill(this.parseColor(color));
                graphics.drawCircle(0, 0, radius);
                graphics.endFill();
                
                return graphics;
            }

            static createTriangle(config) {
                const graphics = new PIXI.Graphics();
                const { color, stroke, strokeWidth, vertices, texture } = config;
                
                // Check if texture is available and valid
                if (texture && texture.url && vertices && vertices.length >= 3) {
                    try {
                        // Calculate triangle bounds for sprite sizing
                        let minX = Math.min(...vertices.map(v => v.x));
                        let maxX = Math.max(...vertices.map(v => v.x));
                        let minY = Math.min(...vertices.map(v => v.y));
                        let maxY = Math.max(...vertices.map(v => v.y));
                        
                        // Create sprite with texture
                        const sprite = PIXI.Sprite.from(texture.url);
                        sprite.anchor.set(0.5);
                        sprite.width = maxX - minX;
                        sprite.height = maxY - minY;
                        sprite.tint = this.parseColor(color);
                        
                        // Apply texture properties
                        if (texture.opacity !== undefined) {
                            sprite.alpha = texture.opacity;
                        }
                        
                        // Create triangular mask
                        const mask = new PIXI.Graphics();
                        mask.beginFill(0xFFFFFF);
                        mask.moveTo(vertices[0].x, vertices[0].y);
                        for (let i = 1; i < vertices.length; i++) {
                            mask.lineTo(vertices[i].x, vertices[i].y);
                        }
                        mask.closePath();
                        mask.endFill();
                        sprite.mask = mask;
                        
                        // Create container to hold both sprite and mask
                        const container = new PIXI.Container();
                        container.addChild(sprite);
                        container.addChild(mask);
                        
                        console.log(`‚úÖ Applied texture to triangle: ${texture.url}`);
                        return container;
                    } catch (error) {
                        console.warn(`‚ö†Ô∏è Failed to load texture ${texture.url}, using color fallback:`, error);
                        // Fall through to regular graphics creation
                    }
                }
                
                // Regular graphics creation (fallback or no texture)
                graphics.lineStyle(strokeWidth, this.parseColor(stroke));
                graphics.beginFill(this.parseColor(color));
                
                // Draw triangle using vertices from config
                if (vertices && vertices.length >= 3) {
                    graphics.moveTo(vertices[0].x, vertices[0].y);
                    for (let i = 1; i < vertices.length; i++) {
                        graphics.lineTo(vertices[i].x, vertices[i].y);
                    }
                    graphics.closePath();
                }
                
                graphics.endFill();
                return graphics;
            }

            static createCross(config) {
                const graphics = new PIXI.Graphics();
                const { color, stroke, strokeWidth, parts } = config;
                
                graphics.lineStyle(strokeWidth, this.parseColor(stroke));
                graphics.beginFill(this.parseColor(color));
                
                // Draw cross as two overlapping rectangles
                if (parts && parts.length >= 2) {
                    parts.forEach(part => {
                        const { width, height, offsetX = 0, offsetY = 0 } = part;
                        graphics.drawRect(
                            offsetX - width/2, 
                            offsetY - height/2, 
                            width, 
                            height
                        );
                    });
                }
                
                graphics.endFill();
                return graphics;
            }

            static createCross2(config) {
                // Cross2 uses same structure as cross but different dimensions
                return this.createCross(config);
            }

            static createL(config) {
                const graphics = new PIXI.Graphics();
                const { color, stroke, strokeWidth, parts } = config;
                
                // CRITICAL FIX: Set tint to white and use beginFill for proper color rendering
                graphics.tint = 0xFFFFFF; // Reset tint to white so colors render correctly
                // THEME FIX: Use only the main theme colors, ignore part-specific colors
                graphics.lineStyle(strokeWidth, this.parseColor(stroke));
                graphics.beginFill(this.parseColor(color));
                
                // Draw L-shape as multiple rectangles
                if (parts && parts.length > 0) {
                    parts.forEach(part => {
                        // THEME FIX: Remove any part-specific colors to ensure main theme colors are used
                        const cleanPart = { ...part };
                        delete cleanPart.color;
                        delete cleanPart.stroke;
                        
                        const { width, height, offsetX = 0, offsetY = 0 } = cleanPart;
                        graphics.drawRect(
                            offsetX - width/2, 
                            offsetY - height/2, 
                            width, 
                            height
                        );
                    });
                }
                
                graphics.endFill();
                return graphics;
            }

            static createBarbellOne(config) {
                const graphics = new PIXI.Graphics();
                const { color, stroke, strokeWidth, parts } = config;
                
                console.log(`üîç BarbellOne Debug:`, {
                    color, 
                    stroke, 
                    parsedColor: this.parseColor(color),
                    parsedStroke: this.parseColor(stroke)
                });
                
                // THEME FIX: Use only the main theme colors, ignore part-specific colors  
                const lineColor = this.parseColor(stroke);
                const fillColor = this.parseColor(color);
                
                console.log(`üîç Setting PixiJS colors:`, { lineColor, fillColor });
                
                // CRITICAL FIX: Set tint to white and use beginFill for proper color rendering
                graphics.tint = 0xFFFFFF; // Reset tint to white so colors render correctly
                graphics.lineStyle(strokeWidth, lineColor);
                graphics.beginFill(fillColor);
                
                // Draw barbell as combination of rectangles and circles
                if (parts && parts.length > 0) {
                    parts.forEach((part, index) => {
                        console.log(`üîç Drawing part ${index}:`, part.type);
                        // THEME FIX: Remove any part-specific colors to ensure main theme colors are used
                        const cleanPart = { ...part };
                        delete cleanPart.color;
                        delete cleanPart.stroke;
                        
                        if (cleanPart.type === 'rectangle') {
                            const { width, height, offsetX = 0, offsetY = 0 } = cleanPart;
                            graphics.drawRect(
                                offsetX - width/2, 
                                offsetY - height/2, 
                                width, 
                                height
                            );
                        } else if (cleanPart.type === 'circle') {
                            const { radius, offsetX = 0, offsetY = 0 } = cleanPart;
                            graphics.drawCircle(offsetX, offsetY, radius);
                        }
                    });
                }
                
                graphics.endFill();
                console.log(`üîç PixiJS graphics after endFill:`, {
                    tint: graphics.tint,
                    alpha: graphics.alpha,
                    visible: graphics.visible
                });
                return graphics;
            }

            static createBarbellTwo(config) {
                // Barbell-two uses same structure as barbell-one but different dimensions
                return this.createBarbellOne(config);
            }

            static createDiamondBarbell(config) {
                const graphics = new PIXI.Graphics();
                const { color, stroke, strokeWidth, parts } = config;
                
                console.log(`üîç DiamondBarbell Debug:`, {
                    color, 
                    stroke, 
                    parsedColor: this.parseColor(color),
                    parsedStroke: this.parseColor(stroke)
                });
                
                // CRITICAL FIX: Set tint to white and use beginFill for proper color rendering
                graphics.tint = 0xFFFFFF; // Reset tint to white so colors render correctly
                // THEME FIX: Use only the main theme colors, ignore part-specific colors
                graphics.lineStyle(strokeWidth, this.parseColor(stroke));
                graphics.beginFill(this.parseColor(color));
                
                // Draw diamond barbell with custom shape parts
                if (parts && parts.length > 0) {
                    parts.forEach(part => {
                        // THEME FIX: Remove any part-specific colors to ensure main theme colors are used
                        const cleanPart = { ...part };
                        delete cleanPart.color;
                        delete cleanPart.stroke;
                        
                        if (cleanPart.type === 'rectangle') {
                            const { width, height, offsetX = 0, offsetY = 0 } = cleanPart;
                            graphics.drawRect(
                                offsetX - width/2, 
                                offsetY - height/2, 
                                width, 
                                height
                            );
                        } else if (cleanPart.type === 'diamond' && cleanPart.vertices) {
                            // Draw diamond shapes
                            graphics.moveTo(cleanPart.vertices[0].x, cleanPart.vertices[0].y);
                            for (let i = 1; i < cleanPart.vertices.length; i++) {
                                graphics.lineTo(cleanPart.vertices[i].x, cleanPart.vertices[i].y);
                            }
                            graphics.closePath();
                        } else if (cleanPart.type === 'polygon' && cleanPart.vertices) {
                            // Draw diamond shapes using polygon vertices
                            graphics.moveTo(cleanPart.vertices[0].x, cleanPart.vertices[0].y);
                            for (let i = 1; i < cleanPart.vertices.length; i++) {
                                graphics.lineTo(cleanPart.vertices[i].x, cleanPart.vertices[i].y);
                            }
                            graphics.closePath();
                        }
                    });
                }
                
                graphics.endFill();
                return graphics;
            }

            // Helper method to parse color strings to hex values
            static parseColor(colorString) {
                if (typeof colorString === 'number') return colorString;
                if (colorString.startsWith('#')) {
                    return parseInt(colorString.replace('#', '0x'), 16);
                }
                // Handle other color formats if needed
                return 0x000000; // Default to black
            }

            // Main factory method
            static createShape(shapeType, config) {
                switch (shapeType) {
                    case 'square': return this.createSquare(config);
                    case 'circle': return this.createCircle(config);
                    case 'triangle': return this.createTriangle(config);
                    case 'cross': return this.createCross(config);
                    case 'cross2': return this.createCross2(config);
                    case 'l': return this.createL(config);
                    case 'barbell-one': return this.createBarbellOne(config);
                    case 'barbell-two': return this.createBarbellTwo(config);
                    case 'diamond-barbell': return this.createDiamondBarbell(config);
                    default:
                        console.warn(`‚ö†Ô∏è Unknown shape type: ${shapeType}`);
                        return this.createSquare(config); // Fallback to square
                }
            }
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë PIXIJS SHAPE RENDERER - SYNCS PIXI GRAPHICS WITH MATTER.JS PHYSICS
          ‚ïë Manages PixiJS shape graphics and keeps them synchronized with physics bodies
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        class PixiShapeRenderer {
            constructor(rendererManager) {
                this.rendererManager = rendererManager;
                this.shapes = new Map(); // Matter.js body ID -> PIXI Graphics
                this.isEnabled = false;
                
                console.log('üé® PixiJS Shape Renderer created');
            }

            enable() {
                if (!this.rendererManager.isPixiActive()) {
                    console.warn('‚ö†Ô∏è Cannot enable PixiJS shapes - PixiJS renderer not active');
                    return false;
                }
                
                this.isEnabled = true;
                console.log('‚úÖ PixiJS shape rendering enabled');
                return true;
            }

            disable() {
                this.isEnabled = false;
                this.clearAllShapes();
                console.log('üîÑ PixiJS shape rendering disabled');
            }

            createShape(body, shapeType) {
                if (!this.isEnabled || !this.rendererManager.isPixiActive()) {
                    return null;
                }

                try {
                    // Get shape configuration from SHAPE_CONFIG
                    const config = getShapeConfig(shapeType);
                    if (!config) {
                        console.warn(`‚ö†Ô∏è No configuration found for shape: ${shapeType}`);
                        return null;
                    }

                    // Create PixiJS graphics object
                    const pixiShape = PixiShapeFactory.createShape(shapeType, config);
                    
                    console.log(`üé® PixiJS shape created for ${shapeType}, checking colors...`);
                    console.log(`üé® Graphics tint:`, pixiShape.tint);
                    console.log(`üé® Graphics children:`, pixiShape.children?.length || 0);
                    
                    // Position the shape according to the physics body
                    pixiShape.x = body.position.x;
                    pixiShape.y = body.position.y;
                    pixiShape.rotation = body.angle;

                    // Add to game container
                    const gameContainer = this.rendererManager.getPixiContainer('game');
                    if (gameContainer) {
                        gameContainer.addChild(pixiShape);
                    }

                    // Store reference
                    this.shapes.set(body.id, {
                        graphics: pixiShape,
                        body: body,
                        shapeType: shapeType,
                        config: config
                    });

                    console.log(`üé® Created PixiJS shape: ${shapeType} (body ID: ${body.id})`);
                    
                    // Phase 3: Animate shape creation
                    if (this.rendererManager.pixiManager.animationManager) {
                        this.rendererManager.pixiManager.animationManager.animateShapeCreation(pixiShape);
                    }
                    
                    return pixiShape;

                } catch (error) {
                    console.error('‚ùå Error creating PixiJS shape:', error);
                    return null;
                }
            }

            updateShapes() {
                if (!this.isEnabled || !this.rendererManager.isPixiActive()) {
                    return;
                }

                // Update all shape positions and rotations to match physics bodies
                this.shapes.forEach((shapeData, bodyId) => {
                    const { graphics, body } = shapeData;
                    
                    if (graphics && body) {
                        graphics.x = body.position.x;
                        graphics.y = body.position.y;
                        graphics.rotation = body.angle;
                    }
                });
            }

            removeShape(bodyId) {
                const shapeData = this.shapes.get(bodyId);
                if (shapeData) {
                    console.log(`üóëÔ∏è Removing PixiJS shape (body ID: ${bodyId})`);
                    
                    // Phase 3: Animate destruction before removal
                    const animationManager = this.rendererManager.pixiManager.animationManager;
                    if (animationManager && animationManager.isEnabled) {
                        animationManager.animateShapeDestruction(shapeData.graphics, () => {
                            // Remove after animation completes
                            this.completeShapeRemoval(shapeData, bodyId);
                        });
                    } else {
                        // No animation, remove immediately
                        this.completeShapeRemoval(shapeData, bodyId);
                    }
                }
            }

            completeShapeRemoval(shapeData, bodyId) {
                // Remove from PixiJS container
                if (shapeData.graphics.parent) {
                    shapeData.graphics.parent.removeChild(shapeData.graphics);
                }
                
                // Destroy PixiJS graphics
                shapeData.graphics.destroy();
                
                // Remove from our tracking
                this.shapes.delete(bodyId);
                
                console.log(`‚úÖ PixiJS shape removal completed (body ID: ${bodyId})`);
            }

            clearAllShapes() {
                this.shapes.forEach((shapeData, bodyId) => {
                    this.removeShape(bodyId);
                });
                console.log('üßπ Cleared all PixiJS shapes');
            }

            // Apply theme changes to existing shapes
            applyTheme(themeName) {
                if (!this.isEnabled) return;
                
                console.log(`üé® Applying enhanced theme to PixiJS shapes: ${themeName}`);
                
                // Phase 3: Use enhanced theme manager if available
                const themeManager = this.rendererManager.pixiManager.themeManager;
                if (themeManager) {
                    themeManager.applyTheme(themeName, this);
                } else {
                    // Fallback to original theme application
                    this.legacyThemeApplication(themeName);
                }
            }

            legacyThemeApplication(themeName) {
                this.shapes.forEach((shapeData, bodyId) => {
                    const { graphics, shapeType } = shapeData;
                    
                    // Get updated configuration for theme
                    const config = getShapeConfig(shapeType);
                    if (config) {
                        // Recreate shape with new theme colors
                        const newGraphics = PixiShapeFactory.createShape(shapeType, config);
                        newGraphics.x = graphics.x;
                        newGraphics.y = graphics.y;
                        newGraphics.rotation = graphics.rotation;
                        
                        // Replace in container
                        if (graphics.parent) {
                            const container = graphics.parent;
                            container.removeChild(graphics);
                            container.addChild(newGraphics);
                        }
                        
                        // Clean up old graphics
                        graphics.destroy();
                        
                        // Update our reference
                        shapeData.graphics = newGraphics;
                        shapeData.config = config;
                    }
                });
            }

            getShapeCount() {
                return this.shapes.size;
            }

            isShapeTracked(bodyId) {
                return this.shapes.has(bodyId);
            }
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë PIXIJS ANIMATION MANAGER - Phase 3
          ‚ïë Advanced animations, tweening, and visual effects system
          ‚ïë Features: Shape creation/destruction animations, collision effects, tweening
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        class PixiAnimationManager {
            constructor(pixiManager) {
                this.pixiManager = pixiManager;
                this.app = pixiManager.app;
                this.isEnabled = false;
                
                // Animation tracking
                this.activeAnimations = new Map();
                this.animationCounter = 0;
                
                // Tween configuration
                this.tweenConfig = {
                    shapeCreation: {
                        duration: 300,        // milliseconds
                        easing: 'easeOutBounce'
                    },
                    shapeDestruction: {
                        duration: 200,
                        easing: 'easeInQuart'
                    },
                    collision: {
                        duration: 100,
                        easing: 'easeOutQuad'
                    },
                    platform: {
                        duration: 150,
                        easing: 'easeOutBack'
                    }
                };
                
                console.log('üé¨ PixiJS Animation Manager created');
            }

            enable() {
                this.isEnabled = true;
                console.log('‚úÖ PixiJS animations enabled');
                return true;
            }

            disable() {
                this.isEnabled = false;
                // Stop all active animations
                this.stopAllAnimations();
                console.log('üîÑ PixiJS animations disabled');
            }

            // Shape Creation Animation - Scale up with bounce
            animateShapeCreation(graphics, callback = null) {
                if (!this.isEnabled || !graphics) return;

                // Start from scale 0
                graphics.scale.set(0, 0);
                graphics.alpha = 0.8;

                const animationId = ++this.animationCounter;
                const startTime = performance.now();
                const config = this.tweenConfig.shapeCreation;

                const animate = (currentTime) => {
                    const elapsed = currentTime - startTime;
                    const progress = Math.min(elapsed / config.duration, 1);

                    // Bounce easing
                    const easedProgress = this.easeOutBounce(progress);
                    
                    graphics.scale.set(easedProgress, easedProgress);
                    graphics.alpha = 0.8 + (0.2 * progress);

                    if (progress < 1) {
                        this.activeAnimations.set(animationId, requestAnimationFrame(animate));
                    } else {
                        graphics.scale.set(1, 1);
                        graphics.alpha = 1;
                        this.activeAnimations.delete(animationId);
                        if (callback) callback();
                    }
                };

                this.activeAnimations.set(animationId, requestAnimationFrame(animate));
                console.log('üé¨ Started shape creation animation');
            }

            // Shape Destruction Animation - Scale down with fade
            animateShapeDestruction(graphics, callback = null) {
                if (!this.isEnabled || !graphics) {
                    if (callback) callback();
                    return;
                }

                const animationId = ++this.animationCounter;
                const startTime = performance.now();
                const config = this.tweenConfig.shapeDestruction;
                const initialScale = graphics.scale.x;

                const animate = (currentTime) => {
                    const elapsed = currentTime - startTime;
                    const progress = Math.min(elapsed / config.duration, 1);

                    // Quad easing in
                    const easedProgress = this.easeInQuart(progress);
                    
                    const scale = initialScale * (1 - easedProgress);
                    graphics.scale.set(scale, scale);
                    graphics.alpha = 1 - easedProgress;

                    if (progress < 1) {
                        this.activeAnimations.set(animationId, requestAnimationFrame(animate));
                    } else {
                        this.activeAnimations.delete(animationId);
                        if (callback) callback();
                    }
                };

                this.activeAnimations.set(animationId, requestAnimationFrame(animate));
                console.log('üé¨ Started shape destruction animation');
            }

            // Collision Flash Animation - Brief color/scale change
            animateCollisionFlash(graphics) {
                if (!this.isEnabled || !graphics) return;

                const animationId = ++this.animationCounter;
                const startTime = performance.now();
                const config = this.tweenConfig.collision;
                const originalTint = graphics.tint;
                const originalScale = graphics.scale.x;

                const animate = (currentTime) => {
                    const elapsed = currentTime - startTime;
                    const progress = Math.min(elapsed / config.duration, 1);

                    // Quad easing out
                    const easedProgress = this.easeOutQuad(progress);
                    
                    // Flash white and scale slightly
                    const tintMix = 1 - easedProgress;
                    graphics.tint = this.lerpColor(originalTint, 0xFFFFFF, tintMix * 0.5);
                    
                    const scaleBoost = 1 + (0.1 * (1 - easedProgress));
                    graphics.scale.set(originalScale * scaleBoost, originalScale * scaleBoost);

                    if (progress < 1) {
                        this.activeAnimations.set(animationId, requestAnimationFrame(animate));
                    } else {
                        graphics.tint = originalTint;
                        graphics.scale.set(originalScale, originalScale);
                        this.activeAnimations.delete(animationId);
                    }
                };

                this.activeAnimations.set(animationId, requestAnimationFrame(animate));
                console.log('‚ö° Started collision flash animation');
            }

            // Platform Landing Animation - Satisfying bounce
            animatePlatformLanding(graphics) {
                if (!this.isEnabled || !graphics) return;

                const animationId = ++this.animationCounter;
                const startTime = performance.now();
                const config = this.tweenConfig.platform;
                const originalScale = graphics.scale.x;

                const animate = (currentTime) => {
                    const elapsed = currentTime - startTime;
                    const progress = Math.min(elapsed / config.duration, 1);

                    // Back easing out (overshoot)
                    const easedProgress = this.easeOutBack(progress);
                    
                    // Squash and stretch effect
                    const scaleY = originalScale * (0.8 + 0.2 * easedProgress);
                    const scaleX = originalScale * (1.1 - 0.1 * easedProgress);
                    graphics.scale.set(scaleX, scaleY);

                    if (progress < 1) {
                        this.activeAnimations.set(animationId, requestAnimationFrame(animate));
                    } else {
                        graphics.scale.set(originalScale, originalScale);
                        this.activeAnimations.delete(animationId);
                    }
                };

                this.activeAnimations.set(animationId, requestAnimationFrame(animate));
                console.log('üèüÔ∏è Started platform landing animation');
            }

            // Stop all animations
            stopAllAnimations() {
                this.activeAnimations.forEach((animationFrame, id) => {
                    cancelAnimationFrame(animationFrame);
                });
                this.activeAnimations.clear();
                console.log('üõë Stopped all PixiJS animations');
            }

            // Easing functions
            easeOutBounce(t) {
                if (t < 1 / 2.75) {
                    return 7.5625 * t * t;
                } else if (t < 2 / 2.75) {
                    return 7.5625 * (t -= 1.5 / 2.75) * t + 0.75;
                } else if (t < 2.5 / 2.75) {
                    return 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375;
                } else {
                    return 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
                }
            }

            easeInQuart(t) {
                return t * t * t * t;
            }

            easeOutQuad(t) {
                return 1 - (1 - t) * (1 - t);
            }

            easeOutBack(t) {
                const c1 = 1.70158;
                const c3 = c1 + 1;
                return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
            }

            // Utility function for color interpolation
            lerpColor(color1, color2, t) {
                const r1 = (color1 >> 16) & 0xFF;
                const g1 = (color1 >> 8) & 0xFF;
                const b1 = color1 & 0xFF;
                
                const r2 = (color2 >> 16) & 0xFF;
                const g2 = (color2 >> 8) & 0xFF;
                const b2 = color2 & 0xFF;
                
                const r = Math.round(r1 + (r2 - r1) * t);
                const g = Math.round(g1 + (g2 - g1) * t);
                const b = Math.round(b1 + (b2 - b1) * t);
                
                return (r << 16) | (g << 8) | b;
            }

            getActiveAnimationCount() {
                return this.activeAnimations.size;
            }
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë ENHANCED THEME INTEGRATION - Phase 3 Extension  
          ‚ïë Advanced theme support with patterns, effects, and dynamic appearance
          ‚ïë Features: Color schemes, patterns, visual effects per theme
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        class PixiThemeManager {
            constructor(pixiManager) {
                this.pixiManager = pixiManager;
                this.currentTheme = 'classic';
                this.themeEffects = new Map();
                
                // Load themes dynamically from existing system
                this.loadExistingThemes();
                
                console.log('üé® Enhanced PixiJS Theme Manager created with dynamic themes');
            }

            loadExistingThemes() {
                this.themes = {};
                
                // Check if we have access to the existing theme system
                console.log('üé® Checking for existing theme system...', {
                    themeManager: !!window.themeManager,
                    themes: window.themeManager?.themes ? Object.keys(window.themeManager.themes) : 'none'
                });
                
                if (window.themeManager && window.themeManager.themes) {
                    const existingThemes = window.themeManager.themes;
                    
                    // Convert existing themes to enhanced theme format
                    Object.keys(existingThemes).forEach(themeKey => {
                        const existingTheme = existingThemes[themeKey];
                        const convertedTheme = this.convertToEnhancedTheme(themeKey, existingTheme);
                        this.themes[themeKey] = convertedTheme;
                        
                        console.log(`üé® Converted theme '${themeKey}':`, convertedTheme);
                    });
                    
                    console.log(`üé® Loaded ${Object.keys(this.themes).length} dynamic themes:`, Object.keys(this.themes));
                } else {
                    // Fallback to predefined themes if existing system not available
                    this.loadFallbackThemes();
                    console.log('üé® Using fallback themes - existing system not available');
                }
                
                // Always ensure we have fallback themes merged in
                this.ensureFallbackThemes();
            }

            convertToEnhancedTheme(themeKey, existingTheme) {
                const enhancedTheme = {
                    name: existingTheme.name || themeKey,
                    effects: {
                        glow: false,
                        shadow: false,
                        pattern: 'solid'
                    },
                    shapeOverrides: this.generateShapeColorsFromTheme(existingTheme)
                };

                // Add special effects for certain themes
                if (themeKey.includes('neon') || themeKey.includes('glow')) {
                    enhancedTheme.effects.glow = true;
                    enhancedTheme.effects.glowColor = 0x00FFFF;
                    enhancedTheme.effects.glowStrength = 2;
                }

                if (themeKey.includes('retro') || themeKey.includes('vintage')) {
                    enhancedTheme.effects.shadow = true;
                    enhancedTheme.effects.shadowOffset = 3;
                    enhancedTheme.effects.pattern = 'pixelated';
                }

                return enhancedTheme;
            }

            generateShapeColorsFromTheme(existingTheme) {
                const shapeOverrides = {};
                
                // Use theme background colors as a base palette
                if (existingTheme.background && existingTheme.background.colors) {
                    const colors = existingTheme.background.colors;
                    const shapes = ['square', 'triangle', 'circle', 'cross2', 'l', 'cross', 'barbell-one', 'barbell-two', 'diamond-barbell'];
                    
                    shapes.forEach((shape, index) => {
                        const colorIndex = index % colors.length;
                        const baseColor = colors[colorIndex];
                        const strokeColor = this.darkenHex(baseColor, 20);
                        
                        shapeOverrides[shape] = {
                            color: baseColor,
                            stroke: strokeColor
                        };
                    });
                }
                
                return shapeOverrides;
            }

            darkenHex(hex, percent) {
                // Convert hex to RGB, darken, convert back
                const num = parseInt(hex.replace('#', ''), 16);
                const amt = Math.round(2.55 * percent);
                const R = (num >> 16) - amt;
                const G = (num >> 8 & 0x00FF) - amt;
                const B = (num & 0x0000FF) - amt;
                
                return '#' + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
                        (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
                        (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
            }

            loadFallbackThemes() {
                const fallbackThemes = {
                    classic: {
                        name: 'Classic',
                        effects: {
                            glow: false,
                            shadow: false,
                            pattern: 'solid'
                        },
                        shapeOverrides: {
                            // Uses default SHAPE_CONFIG colors
                        }
                    },
                    neon: {
                        name: 'Neon Glow',
                        effects: {
                            glow: true,
                            glowColor: 0x00FFFF,
                            glowStrength: 2,
                            shadow: false,
                            pattern: 'solid'
                        },
                        shapeOverrides: {
                            square: { color: '#FF1493', stroke: '#FF69B4' },
                            triangle: { color: '#00FFFF', stroke: '#40E0D0' },
                            circle: { color: '#FFFF00', stroke: '#FFD700' },
                            cross2: { color: '#FF4500', stroke: '#FF6347' },
                            l: { color: '#9370DB', stroke: '#BA55D3' },
                            cross: { color: '#00FF00', stroke: '#32CD32' },
                            'barbell-one': { color: '#FF1493', stroke: '#FF69B4' },
                            'barbell-two': { color: '#00BFFF', stroke: '#87CEEB' },
                            'diamond-barbell': { color: '#FFD700', stroke: '#FFA500' }
                        }
                    },
                    retro: {
                        name: 'Retro Pixel',
                        effects: {
                            glow: false,
                            shadow: true,
                            shadowOffset: 3,
                            pattern: 'pixelated'
                        },
                        shapeOverrides: {
                            square: { color: '#8B4513', stroke: '#A0522D' },
                            triangle: { color: '#556B2F', stroke: '#6B8E23' },
                            circle: { color: '#2F4F4F', stroke: '#708090' },
                            cross2: { color: '#800080', stroke: '#9932CC' },
                            l: { color: '#B22222', stroke: '#DC143C' },
                            cross: { color: '#4682B4', stroke: '#5F9EA0' },
                            'barbell-one': { color: '#DAA520', stroke: '#FFD700' },
                            'barbell-two': { color: '#CD853F', stroke: '#D2B48C' },
                            'diamond-barbell': { color: '#8B0000', stroke: '#A52A2A' }
                        }
                    },
                    wood: {
                        name: 'Wood',
                        effects: {
                            glow: true,
                            glowColor: 0xA0522D,
                            glowStrength: 1.5,
                            shadow: false,
                            pattern: 'gradient'
                        },
                        shapeOverrides: {
                            square: { color: '#8B4513', stroke: '#A0522D' },
                            triangle: { color: '#D2B48C', stroke: '#DEB887' },
                            circle: { color: '#CD853F', stroke: '#DAA520' },
                            cross2: { color: '#8B4513', stroke: '#A0522D' },
                            l: { color: '#D2691E', stroke: '#F4A460' },
                            cross: { color: '#B8860B', stroke: '#DAA520' },
                            'barbell-one': { color: '#8B4513', stroke: '#A0522D' },
                            'barbell-two': { color: '#CD853F', stroke: '#D2B48C' },
                            'diamond-barbell': { color: '#DEB887', stroke: '#F5DEB3' }
                        }
                    },
                    stone: {
                        name: 'Stone',
                        effects: {
                            glow: false,
                            shadow: true,
                            shadowOffset: 2,
                            pattern: 'solid'
                        },
                        shapeOverrides: {
                            square: { color: '#708090', stroke: '#2F4F4F' },
                            triangle: { color: '#696969', stroke: '#778899' },
                            circle: { color: '#D3D3D3', stroke: '#A9A9A9' },
                            cross2: { color: '#708090', stroke: '#2F4F4F' },
                            l: { color: '#696969', stroke: '#778899' },
                            cross: { color: '#D3D3D3', stroke: '#A9A9A9' },
                            'barbell-one': { color: '#708090', stroke: '#2F4F4F' },
                            'barbell-two': { color: '#696969', stroke: '#778899' },
                            'diamond-barbell': { color: '#D3D3D3', stroke: '#A9A9A9' }
                        }
                    },
                    metal: {
                        name: 'Metal',
                        effects: {
                            glow: true,
                            glowColor: 0xC0C0C0,
                            glowStrength: 2.0,
                            shadow: false,
                            pattern: 'metallic'
                        },
                        shapeOverrides: {
                            square: { color: '#696969', stroke: '#C0C0C0' },
                            triangle: { color: '#CD7F32', stroke: '#DAA520' },
                            circle: { color: '#FFD700', stroke: '#FFA500' },
                            cross2: { color: '#696969', stroke: '#C0C0C0' },
                            l: { color: '#8B4513', stroke: '#A0522D' },
                            cross: { color: '#CD7F32', stroke: '#DAA520' },
                            'barbell-one': { color: '#696969', stroke: '#C0C0C0' },
                            'barbell-two': { color: '#696969', stroke: '#C0C0C0' },
                            'diamond-barbell': { color: '#FFD700', stroke: '#FFA500' }
                        }
                    }
                };
                
                // Add fallback themes to current themes
                Object.assign(this.themes, fallbackThemes);
            }

            ensureFallbackThemes() {
                // Always make sure we have classic themes available
                if (!this.themes.classic) {
                    this.themes.classic = {
                        name: 'Classic',
                        effects: {
                            glow: false,
                            shadow: false,
                            pattern: 'solid'
                        },
                        shapeOverrides: {}
                    };
                }

                // Add missing common themes with generated colors - using new material names
                const commonThemes = ['metal', 'stone', 'retro', 'modern'];
                commonThemes.forEach(themeName => {
                    if (!this.themes[themeName]) {
                        this.themes[themeName] = this.generateFallbackTheme(themeName);
                        console.log(`üé® Generated fallback theme: ${themeName}`);
                    }
                });
            }

            generateFallbackTheme(themeName) {
                // Direct material theme mapping (no conversion needed for material names)
                const themeMapping = {
                    'metal': 'metal',
                    'stone': 'stone', 
                    'retro': 'classic',
                    'modern': 'classic'
                };
                
                const enhancedThemeName = themeMapping[themeName] || themeName;
                
                const themeColors = {
                    metal: ['#696969', '#C0C0C0', '#808080', '#A9A9A9', '#778899'], // Metal colors
                    stone: ['#708090', '#2F4F4F', '#696969', '#778899', '#D3D3D3'], // Stone colors  
                    retro: ['#FF6347', '#FFD700', '#DA70D6', '#98FB98', '#F0E68C'],
                    modern: ['#2E8B57', '#4682B4', '#DC143C', '#FF8C00', '#9932CC']
                };

                const colors = themeColors[themeName] || themeColors.modern;
                const shapes = ['square', 'triangle', 'circle', 'cross2', 'l', 'cross', 'barbell-one', 'barbell-two', 'diamond-barbell'];
                const shapeOverrides = {};

                shapes.forEach((shape, index) => {
                    const colorIndex = index % colors.length;
                    const baseColor = colors[colorIndex];
                    const strokeColor = this.darkenHex(baseColor, 20);
                    
                    shapeOverrides[shape] = {
                        color: baseColor,
                        stroke: strokeColor
                    };
                });

                const themeDisplayNames = {
                    'forest': 'Metal',
                    'space': 'Stone',
                    'retro': 'Classic',
                    'modern': 'Classic'
                };

                return {
                    name: themeDisplayNames[themeName] || themeName.charAt(0).toUpperCase() + themeName.slice(1),
                    effects: {
                        glow: themeName === 'space',
                        shadow: themeName === 'retro',
                        pattern: 'solid'
                    },
                    shapeOverrides
                };
            }

            applyTheme(themeName, pixiShapeRenderer = null) {
                if (!this.themes[themeName]) {
                    console.warn(`‚ö†Ô∏è Theme not found: ${themeName}`);
                    return false;
                }

                this.currentTheme = themeName;
                const theme = this.themes[themeName];
                
                console.log(`üé® Applying enhanced theme: ${theme.name}`, theme.shapeOverrides);

                // Apply to existing PixiJS shapes if renderer provided
                if (pixiShapeRenderer) {
                    this.updateExistingShapes(pixiShapeRenderer, theme);
                }

                // Refresh dock shapes with new theme colors
                this.refreshDockWithTheme();

                console.log(`‚úÖ Enhanced theme applied: ${theme.name}`);
                return true;
            }

            updateExistingShapes(pixiShapeRenderer, theme) {
                if (!pixiShapeRenderer.shapes || pixiShapeRenderer.shapes.size === 0) {
                    console.log('üé® No existing PixiJS shapes to update');
                    return;
                }

                console.log(`üé® Updating ${pixiShapeRenderer.shapes.size} existing shapes with theme: ${theme.name}`);

                pixiShapeRenderer.shapes.forEach((shapeData, bodyId) => {
                    const { graphics, shapeType } = shapeData;
                    
                    if (!graphics || !graphics.parent) {
                        console.warn(`‚ö†Ô∏è Invalid shape data for body ${bodyId}`);
                        return;
                    }
                    
                    // Get fresh configuration with theme overrides
                    const freshConfig = getShapeConfig(shapeType);
                    
                    if (!freshConfig) {
                        console.warn(`‚ö†Ô∏è No configuration found for shape type: ${shapeType}`);
                        return;
                    }
                    
                    console.log(`üé® Updating ${shapeType} with colors:`, freshConfig);
                    
                    // Preserve position and physics properties
                    const preserveData = {
                        x: graphics.x,
                        y: graphics.y,
                        rotation: graphics.rotation,
                        scale: graphics.scale.clone(),
                        alpha: graphics.alpha,
                        parent: graphics.parent
                    };
                    
                    // Create new graphics with updated theme
                    const newGraphics = PixiShapeFactory.createShape(shapeType, freshConfig);
                    
                    if (!newGraphics) {
                        console.warn(`‚ö†Ô∏è Failed to create new graphics for ${shapeType}`);
                        return;
                    }
                    
                    // Apply theme effects
                    this.applyThemeEffects(newGraphics, theme);
                    
                    // Restore preserved properties
                    newGraphics.x = preserveData.x;
                    newGraphics.y = preserveData.y;
                    newGraphics.rotation = preserveData.rotation;
                    newGraphics.scale.copyFrom(preserveData.scale);
                    newGraphics.alpha = preserveData.alpha;
                    
                    // Replace in container
                    preserveData.parent.removeChild(graphics);
                    preserveData.parent.addChild(newGraphics);
                    
                    // Update the shape reference in renderer
                    shapeData.graphics = newGraphics;
                });

                console.log(`‚úÖ Updated ${pixiShapeRenderer.shapes.size} shapes with theme colors`);
            }

            refreshDockWithTheme() {
                // Force rebuild the visual dock with new theme colors
                if (typeof rebuildGameDock === 'function') {
                    console.log('üé® Refreshing dock with new theme colors...');
                    rebuildGameDock();
                } else {
                    console.warn('‚ö†Ô∏è rebuildGameDock function not available for dock refresh');
                }
            }

            applyThemeEffects(graphics, theme) {
                const effects = theme.effects;
                
                // Apply glow effect
                if (effects.glow && this.pixiManager.app.renderer) {
                    try {
                        // Simple glow simulation using filters if available
                        if (PIXI.filters && PIXI.filters.GlowFilter) {
                            const glowFilter = new PIXI.filters.GlowFilter({
                                color: effects.glowColor || 0xFFFFFF,
                                distance: 10,
                                outerStrength: effects.glowStrength || 1,
                                innerStrength: 0
                            });
                            graphics.filters = [glowFilter];
                        } else {
                            // Fallback: adjust tint for glow effect
                            graphics.tint = effects.glowColor || 0xFFFFFF;
                            graphics.alpha = 0.9;
                        }
                    } catch (error) {
                        console.warn('‚ö†Ô∏è Glow effect not available, using fallback');
                    }
                }

                // Apply shadow effect (simple offset)
                if (effects.shadow) {
                    // This would require duplicating the graphics with offset
                    // For now, we'll just add a subtle dark tint
                    graphics.tint = this.darkenColor(graphics.tint || 0xFFFFFF, 0.1);
                }
            }

            darkenColor(color, amount) {
                const r = Math.max(0, ((color >> 16) & 0xFF) * (1 - amount));
                const g = Math.max(0, ((color >> 8) & 0xFF) * (1 - amount));
                const b = Math.max(0, (color & 0xFF) * (1 - amount));
                return (Math.round(r) << 16) | (Math.round(g) << 8) | Math.round(b);
            }

            getCurrentTheme() {
                return this.currentTheme;
            }

            getAvailableThemes() {
                return Object.keys(this.themes);
            }

            getThemeInfo(themeName) {
                return this.themes[themeName] || null;
            }
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë THEME MANAGER - HANDLES THEME SWITCHING AND VISUAL UPDATES
          ‚ïë Coordinates theme changes across all game systems
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        class ThemeManager {
            constructor(assetManager, gameManager) {
                this.assetManager = assetManager;
                this.gameManager = gameManager;
                
                // V14: Support both unified and legacy configuration
                this.currentTheme = this.getDefaultTheme();
                this.isTransitioning = false;
                this.transitionCallbacks = [];
                
                // V14: Track configuration source
                this.useUnifiedConfig = typeof UNIFIED_GAME_CONFIG !== 'undefined';
                
                console.log(`üé® ThemeManager: Initialized with ${this.useUnifiedConfig ? 'unified' : 'legacy'} config, default theme: ${this.currentTheme}`);
            }
            
            // V14: Smart default theme resolution
            getDefaultTheme() {
                if (typeof UNIFIED_GAME_CONFIG !== 'undefined' && UNIFIED_GAME_CONFIG.theme) {
                    return UNIFIED_GAME_CONFIG.theme.defaultTheme;
                }
                return CANVAS_CONFIG.defaultTheme;
            }
            
            // V14: Smart theme enabled check
            isThemeSystemEnabled() {
                if (this.useUnifiedConfig && UNIFIED_GAME_CONFIG.theme) {
                    return UNIFIED_GAME_CONFIG.theme.enabled;
                }
                return CANVAS_CONFIG.enabled && CANVAS_CONFIG.useThemes;
            }

            async switchTheme(themeName, animated = true) {
                if (!this.isThemeSystemEnabled()) {
                    console.log('üé® Theme Manager: Theme switching disabled');
                    return;
                }

                if (this.isTransitioning || !THEME_DEFINITIONS[themeName]) {
                    console.log(`üé® Cannot switch to theme: ${themeName}`);
                    return;
                }

                console.log(`üé® Switching theme from ${this.currentTheme} to ${themeName}`);
                this.isTransitioning = true;

                try {
                    // Clear old theme textures before loading new ones
                    if (this.currentTheme && this.currentTheme !== themeName) {
                        console.log(`üßπ Clearing textures for old theme: ${this.currentTheme}`);
                        this.assetManager.clearThemeImages(this.currentTheme);
                        
                        // Also clear from UnifiedTextureManager if available
                        if (typeof gameManager !== 'undefined' && 
                            gameManager.physicsManager?.unifiedPixiManager?.textureManager) {
                            gameManager.physicsManager.unifiedPixiManager.textureManager.clearThemeTextures(this.currentTheme);
                        }
                    }
                    
                    // Load the new theme
                    await this.assetManager.loadTheme(themeName);
                    
                    // Update visual elements
                    this.updateBackgroundStyle(themeName);
                    this.updatePlatformStyle(themeName);
                    
                    // Phase 2: Update PixiJS shapes with new theme
                    if (PIXI_CONFIG.features.shapeRendering && this.gameManager.physicsManager.pixiShapeRenderer.isEnabled) {
                        this.gameManager.physicsManager.pixiShapeRenderer.applyTheme(themeName);
                    }
                    
                    // Refresh dock shapes with new theme colors
                    if (typeof rebuildGameDock === 'function') {
                        console.log('üé® Refreshing dock with new theme colors...');
                        rebuildGameDock();
                    }
                    
                    // Update current theme
                    this.currentTheme = themeName;
                    this.assetManager.currentTheme = themeName;
                    
                    // Notify listeners
                    this.notifyThemeChanged(themeName);
                    
                    console.log(`‚úÖ Theme switched to: ${themeName}`);
                    
                } catch (error) {
                    console.error(`‚ùå Failed to switch theme to ${themeName}:`, error);
                } finally {
                    this.isTransitioning = false;
                }
            }

            updateBackgroundStyle(themeName) {
                const bgStyle = this.assetManager.getBackgroundStyle(themeName);
                if (!bgStyle || !this.gameManager?.physicsManager) return;

                // Update the physics manager's background rendering
                if (bgStyle.type === 'gradient') {
                    this.gameManager.physicsManager.backgroundGradient = bgStyle.colors;
                    console.log(`üé® Updated background gradient for ${themeName}:`, bgStyle.colors);
                }
            }

            updatePlatformStyle(themeName) {
                const platformStyle = this.assetManager.getPlatformStyle(themeName);
                if (!platformStyle || !this.gameManager?.physicsManager) return;

                // Update platform color
                this.gameManager.physicsManager.platformColor = platformStyle.color;
                console.log(`üé® Updated platform color for ${themeName}:`, platformStyle.color);
            }

            getAvailableThemes() {
                return Object.keys(THEME_DEFINITIONS);
            }

            getCurrentTheme() {
                return this.currentTheme;
            }

            onThemeChanged(callback) {
                this.transitionCallbacks.push(callback);
            }

            notifyThemeChanged(themeName) {
                this.transitionCallbacks.forEach(callback => {
                    try {
                        callback(themeName);
                    } catch (error) {
                        console.error('‚ùå Error in theme change callback:', error);
                    }
                });
            }
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë PARTICLE SYSTEM - THEME-BASED VISUAL EFFECTS
          ‚ïë Creates and manages particle effects based on current theme
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        class ParticleSystem {
            constructor(canvas, assetManager) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.assetManager = assetManager;
                this.particles = [];
                this.maxParticles = CANVAS_CONFIG.maxParticles;
                this.ambientParticleTimer = 0;
                this.ambientParticleInterval = 1000; // Spawn ambient particle every 1 second
            }

            createThemeParticles(type, x, y, count = 5) {
                if (!CANVAS_CONFIG.enabled || !CANVAS_CONFIG.useParticles) return;

                const particleStyle = this.assetManager.getParticleStyle();
                if (!particleStyle) return;

                for (let i = 0; i < Math.min(count, this.maxParticles - this.particles.length); i++) {
                    this.particles.push(this.createParticle(particleStyle, x, y, type));
                }
            }

            createParticle(style, x, y, type) {
                const colors = style.colors;
                const color = colors[Math.floor(Math.random() * colors.length)];
                
                return {
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4 - 2,
                    life: 1.0,
                    decay: 0.02 + Math.random() * 0.02,
                    size: 2 + Math.random() * 3,
                    color: color,
                    style: style.style
                };
            }

            createAmbientParticle() {
                if (!CANVAS_CONFIG.enabled || !CANVAS_CONFIG.useParticles) return;
                if (this.particles.length >= this.maxParticles) return;

                const particleStyle = this.assetManager.getParticleStyle();
                if (!particleStyle) return;

                // Create particles from random positions around the canvas edges
                const side = Math.floor(Math.random() * 4); // 0=top, 1=right, 2=bottom, 3=left
                let x, y, vx, vy;

                switch(side) {
                    case 0: // Top
                        x = Math.random() * this.canvas.width;
                        y = -10;
                        vx = (Math.random() - 0.5) * 2;
                        vy = Math.random() * 2 + 1;
                        break;
                    case 1: // Right  
                        x = this.canvas.width + 10;
                        y = Math.random() * this.canvas.height;
                        vx = -Math.random() * 2 - 1;
                        vy = (Math.random() - 0.5) * 2;
                        break;
                    case 2: // Bottom
                        x = Math.random() * this.canvas.width;
                        y = this.canvas.height + 10;
                        vx = (Math.random() - 0.5) * 2;
                        vy = -Math.random() * 2 - 1;
                        break;
                    case 3: // Left
                        x = -10;
                        y = Math.random() * this.canvas.height;
                        vx = Math.random() * 2 + 1;
                        vy = (Math.random() - 0.5) * 2;
                        break;
                }

                const colors = particleStyle.colors;
                const color = colors[Math.floor(Math.random() * colors.length)];
                
                this.particles.push({
                    x: x,
                    y: y,
                    vx: vx,
                    vy: vy,
                    life: 1.0,
                    decay: 0.01 + Math.random() * 0.01, // Slower decay for ambient particles
                    size: 1 + Math.random() * 2, // Smaller ambient particles
                    color: color,
                    style: particleStyle.style,
                    isAmbient: true
                });
            }

            update(deltaTime) {
                if (!CANVAS_CONFIG.useParticles) return;

                // Spawn ambient background particles periodically
                this.ambientParticleTimer += deltaTime;
                if (this.ambientParticleTimer >= this.ambientParticleInterval) {
                    this.createAmbientParticle();
                    this.ambientParticleTimer = 0;
                }

                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const particle = this.particles[i];
                    
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.vy += 0.1; // Gravity
                    particle.life -= particle.decay;
                    
                    if (particle.life <= 0) {
                        this.particles.splice(i, 1);
                    }
                }
            }

            render() {
                if (!CANVAS_CONFIG.useParticles) return;

                this.particles.forEach(particle => {
                    this.ctx.save();
                    this.ctx.globalAlpha = particle.life;
                    this.ctx.fillStyle = particle.color;
                    
                    if (particle.style === 'bubbles') {
                        this.ctx.strokeStyle = particle.color;
                        this.ctx.lineWidth = 1;
                        this.ctx.beginPath();
                        this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        this.ctx.stroke();
                    } else {
                        this.ctx.beginPath();
                        this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                    
                    this.ctx.restore();
                });
            }
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë PHYSICS-BASED SHAPE RENDERER
          ‚ïë Renders shapes consistently using physics configuration
          ‚ïë Used for both dock previews and physics simulation
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        class PhysicsShapeRenderer {
            renderShapeOnCanvas(ctx, shapeType, x, y, rotation = 0, scale = 1) {
                // V14: Commented out verbose rendering logging
                // console.log(`üé® renderShapeOnCanvas: ${shapeType} at (${x},${y})`);
                const config = getShapeConfig(shapeType);
                if (!config) {
                    console.error(`‚ùå No config found for renderShapeOnCanvas: ${shapeType}`);
                    return;
                }

                // V14: Commented out verbose config logging
                // console.log(`üìê Config for ${shapeType}:`, config);

                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.scale(scale, scale);

                switch (config.type) {
                    case 'rectangle':
                        console.log(`üì¶ Drawing rectangle for ${shapeType}`);
                        this.drawRectangle(ctx, config);
                        break;
                    case 'circle':
                        console.log(`‚≠ï Drawing circle for ${shapeType}`);
                        this.drawCircle(ctx, config);
                        break;
                    case 'polygon':
                        console.log(`üî∑ Drawing polygon for ${shapeType}`);
                        this.drawPolygon(ctx, config);
                        break;
                    case 'compound':
                        console.log(`üîó Drawing compound shape for ${shapeType}`);
                        this.drawCompoundShape(ctx, config);
                        break;
                    default:
                        console.error(`‚ùå Unknown shape type: ${config.type} for ${shapeType}`);
                }

                ctx.restore();
                console.log(`‚úÖ Rendered ${shapeType}`);
            }

            createDockPreview(shapeType, size = 90) {
                // V14: Commented out verbose dock preview logging
                // console.log(`üé® createDockPreview called for: ${shapeType}, size: ${size}`);
                const config = getShapeConfig(shapeType);
                if (!config) {
                    console.error(`‚ùå No config found for shape: ${shapeType}`);
                    return null;
                }
                
                console.log(`üîç Shape config for ${shapeType}:`, config);
                
                // Use texture registry as primary source for texture detection
                const textureConfig = window.textureRegistry.getTextureConfig(shapeType);
                console.log(`üîç Texture registry config for ${shapeType}:`, textureConfig);
                
                // Check if texture is available from registry
                const hasTextureFromRegistry = textureConfig && textureConfig.hasTexture;
                
                // Fallback check for legacy system
                const hasTextureFromLegacy = config.texture && window.currentTheme?.shapes?.textures && 
                                           window.currentTheme.shapes.textures[shapeType];
                
                const hasTexture = hasTextureFromRegistry || hasTextureFromLegacy;
                
                console.log(`üîç Texture availability:`, {
                    fromRegistry: hasTextureFromRegistry,
                    fromLegacy: hasTextureFromLegacy,
                    finalDecision: hasTexture,
                    registryReady: window.textureRegistry.ready,
                    currentTheme: window.textureRegistry.currentTheme
                });
                
                if (hasTexture) {
                    console.log(`üé® Creating PixiJS preview for ${shapeType} with texture`);
                    return this.createPixiDockPreview(shapeType, config, size);
                } else {
                    console.log(`üé® Creating Canvas preview for ${shapeType} (no texture available)`);
                    return this.createCanvasDockPreview(shapeType, config, size);
                }
            }

            createPixiDockPreview(shapeType, config, size = 90) {
                // Create a canvas element to hold the PixiJS view
                const container = document.createElement('div');
                container.className = 'shape-preview pixi-preview';
                container.dataset.shape = shapeType;
                container.style.width = `${size}px`;
                container.style.height = `${size}px`;
                container.style.position = 'relative';
                container.style.border = '2px solid #DAA520';
                container.style.boxShadow = '0 0 8px rgba(218, 165, 32, 0.5)';
                container.style.borderRadius = '4px';
                container.style.overflow = 'hidden';
                container.title = `${shapeType} - Textured (${config.texture})`;

                try {
                    // Create a mini PixiJS application for this preview
                    const previewApp = new PIXI.Application({
                        width: size,
                        height: size,
                        backgroundColor: 0xf8f9fa,
                        antialias: true,
                        resolution: window.devicePixelRatio || 1,
                        autoDensity: true
                    });

                    // Create the textured shape
                    const pixiShape = PixiShapeFactory.createShape(shapeType, config);
                    if (pixiShape) {
                        // Position in center and scale appropriately
                        pixiShape.x = size / 2;
                        pixiShape.y = size / 2;
                        
                        // Scale down to fit in preview
                        const scale = 1.9;
                        pixiShape.scale.set(scale);

                        // Handle barbell rotation
                        if (shapeType && shapeType.includes('barbell')) {
                            const barbellOrientationSelect = document.getElementById('barbellOrientation');
                            if (barbellOrientationSelect && barbellOrientationSelect.value === 'vertical') {
                                pixiShape.rotation = Math.PI / 2;
                                console.log(`üîÑ Applied vertical rotation to PixiJS preview: ${shapeType}`);
                            }
                        }

                        previewApp.stage.addChild(pixiShape);
                        console.log(`‚úÖ PixiJS textured preview created for: ${shapeType}`);
                    } else {
                        console.warn(`‚ö†Ô∏è Failed to create PixiJS shape for: ${shapeType}`);
                        // Fallback to canvas rendering
                        return this.createCanvasDockPreview(shapeType, config, size);
                    }

                    // Add the PixiJS canvas to our container
                    container.appendChild(previewApp.view);
                    
                    // Store reference for cleanup
                    container._pixiApp = previewApp;
                    
                    return container;
                    
                } catch (error) {
                    console.error(`‚ùå Error creating PixiJS preview for ${shapeType}:`, error);
                    // Fallback to canvas rendering
                    return this.createCanvasDockPreview(shapeType, config, size);
                }
            }

            createCanvasDockPreview(shapeType, config, size = 90) {
                // Use larger canvas to accommodate full-size shape rendering
                const canvas = document.createElement('canvas');
                canvas.width = size;
                canvas.height = size;
                canvas.className = `shape-preview`;
                canvas.dataset.shape = shapeType;

                const ctx = canvas.getContext('2d');
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';

                // Use texture registry for consistent texture detection
                const textureConfig = window.textureRegistry.getTextureConfig(shapeType);
                const hasTextureFromRegistry = textureConfig && textureConfig.hasTexture;
                
                // Fallback check for legacy system
                const hasTextureFromLegacy = config.texture && window.currentTheme?.shapes?.textures && 
                                           window.currentTheme.shapes.textures[shapeType];
                
                const hasTexture = hasTextureFromRegistry || hasTextureFromLegacy;
                
                if (hasTexture) {
                    console.log(`üé® Canvas preview for ${shapeType} - texture available via ${hasTextureFromRegistry ? 'registry' : 'legacy'}`);
                    // Add a subtle texture indicator border
                    canvas.style.border = '2px solid #DAA520';
                    canvas.style.boxShadow = '0 0 8px rgba(218, 165, 32, 0.5)';
                    canvas.title = `${shapeType} - Textured`;
                } else {
                    console.log(`üé® Canvas preview for ${shapeType} - using themed colors only`);
                    canvas.style.border = '1px solid #ccc';
                    canvas.title = `${shapeType} - Themed colors`;
                }

                // Use 2x scale for full-size display, matching 2x physics scale (30‚Üí60)
                const scale = 1.9;
                console.log(`üìê Shape ${shapeType}: using enlarged scale=${scale} for full-size display`);
                
                // Check barbell orientation setting for dock preview rotation
                let rotation = 0;
                if (shapeType && shapeType.includes('barbell')) {
                    const barbellOrientationSelect = document.getElementById('barbellOrientation');
                    if (barbellOrientationSelect && barbellOrientationSelect.value === 'vertical') {
                        rotation = Math.PI / 2; // 90 degrees for vertical orientation
                        console.log(`üîÑ Applying vertical rotation (90¬∞) to ${shapeType}`);
                    }
                }
                
                // Render the shape in the center of the preview canvas
                this.renderShapeOnCanvas(ctx, shapeType, size / 2, size / 2, rotation, scale);
                
                console.log(`‚úÖ Canvas preview created for: ${shapeType} with scale ${scale}, rotation ${(rotation * 180 / Math.PI).toFixed(0)}¬∞`);
                return canvas;
            }

            drawRectangle(ctx, config) {
                const { width, height, color, stroke, strokeWidth } = config;
                
                // Check if texture is available from config
                if (config.hasTexture && config.texture) {
                    // Try to render with texture if available
                    this.drawWithTexture(ctx, config, () => {
                        ctx.fillRect(-width / 2, -height / 2, width, height);
                    });
                    
                    // Add stroke
                    ctx.strokeStyle = stroke;
                    ctx.lineWidth = strokeWidth;
                    ctx.strokeRect(-width / 2, -height / 2, width, height);
                } else {
                    // Fallback to color-based rendering
                    ctx.fillStyle = color;
                    ctx.strokeStyle = stroke;
                    ctx.lineWidth = strokeWidth;

                    ctx.fillRect(-width / 2, -height / 2, width, height);
                    ctx.strokeRect(-width / 2, -height / 2, width, height);
                }
            }

            drawCircle(ctx, config) {
                const { radius, color, stroke, strokeWidth } = config;
                
                // Check if texture is available from config
                if (config.hasTexture && config.texture) {
                    // Try to render with texture if available
                    this.drawWithTexture(ctx, config, () => {
                        ctx.beginPath();
                        ctx.arc(0, 0, radius, 0, Math.PI * 2);
                        ctx.fill();
                    });
                    
                    // Add stroke
                    ctx.strokeStyle = stroke;
                    ctx.lineWidth = strokeWidth;
                    ctx.beginPath();
                    ctx.arc(0, 0, radius, 0, Math.PI * 2);
                    ctx.stroke();
                } else {
                    // Fallback to color-based rendering
                    ctx.fillStyle = color;
                    ctx.strokeStyle = stroke;
                    ctx.lineWidth = strokeWidth;

                    ctx.beginPath();
                    ctx.arc(0, 0, radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                }
            }

            drawPolygon(ctx, config) {
                const { vertices, color, stroke, strokeWidth } = config;
                
                // Check if texture is available from config
                if (config.hasTexture && config.texture) {
                    // Try to render with texture if available
                    this.drawWithTexture(ctx, config, () => {
                        ctx.beginPath();
                        ctx.moveTo(vertices[0].x, vertices[0].y);
                        for (let i = 1; i < vertices.length; i++) {
                            ctx.lineTo(vertices[i].x, vertices[i].y);
                        }
                        ctx.closePath();
                        ctx.fill();
                    });
                    
                    // Add stroke
                    ctx.strokeStyle = stroke;
                    ctx.lineWidth = strokeWidth;
                    ctx.beginPath();
                    ctx.moveTo(vertices[0].x, vertices[0].y);
                    for (let i = 1; i < vertices.length; i++) {
                        ctx.lineTo(vertices[i].x, vertices[i].y);
                    }
                    ctx.closePath();
                    ctx.stroke();
                } else {
                    // Fallback to color-based rendering
                    ctx.fillStyle = color;
                    ctx.strokeStyle = stroke;
                    ctx.lineWidth = strokeWidth;

                    ctx.beginPath();
                    ctx.moveTo(vertices[0].x, vertices[0].y);
                    for (let i = 1; i < vertices.length; i++) {
                        ctx.lineTo(vertices[i].x, vertices[i].y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                }
            }

            drawCompoundShape(ctx, config) {
                for (const part of config.parts) {
                    ctx.save();
                    ctx.translate(part.offsetX || 0, part.offsetY || 0);

                    // THEME FIX: Use theme colors from main config instead of part-specific colors
                    // This ensures compound shapes inherit theme colors properly
                    const partConfig = {
                        ...config,
                        ...part,
                        // Override part colors with theme-aware colors from main config
                        color: config.color,      // Use theme color instead of part.color
                        stroke: config.stroke     // Use theme stroke instead of part.stroke
                    };

                    switch (part.type) {
                        case 'rectangle':
                            this.drawRectangle(ctx, partConfig);
                            break;
                        case 'circle':
                            this.drawCircle(ctx, partConfig);
                            break;
                        case 'diamond':
                            this.drawDiamond(ctx, partConfig);
                            break;
                    }
                    ctx.restore();
                }
            }

            drawDiamond(ctx, config) {
                // For dock preview consistency, render diamond exactly as physics will:
                // as a rotated rectangle to match the planck.Box(..., Math.PI/4) creation
                const { width, height, color, stroke, strokeWidth } = config;
                
                ctx.save();
                // Apply the same rotation that's used in physics fixture creation
                ctx.rotate(Math.PI / 4);
                
                // Check if texture is available from config
                if (config.hasTexture && config.texture) {
                    // Try to render with texture if available
                    this.drawWithTexture(ctx, config, () => {
                        ctx.fillRect(-width / 2, -height / 2, width, height);
                    });
                    
                    // Add stroke
                    ctx.strokeStyle = stroke;
                    ctx.lineWidth = strokeWidth;
                    ctx.strokeRect(-width / 2, -height / 2, width, height);
                } else {
                    // Fallback to color-based rendering
                    ctx.fillStyle = color;
                    ctx.strokeStyle = stroke;
                    ctx.lineWidth = strokeWidth;

                    ctx.fillRect(-width / 2, -height / 2, width, height);
                    ctx.strokeRect(-width / 2, -height / 2, width, height);
                }
                
                ctx.restore();
            }

            // Helper method for texture-aware drawing
            drawWithTexture(ctx, config, drawCallback) {
                // For now, use color-based rendering as fallback
                // TODO: Implement actual texture rendering when texture system is ready
                ctx.fillStyle = config.color;
                
                // Apply texture-like visual effect for textured shapes
                if (config.hasTexture) {
                    // Create a subtle pattern or visual indicator for textured shapes
                    ctx.save();
                    ctx.globalAlpha = 0.8; // Slight transparency to indicate texture
                    drawCallback();
                    ctx.restore();
                    
                    // Add subtle texture indicator
                    ctx.save();
                    ctx.fillStyle = '#DAA520'; // Gold color to indicate texture
                    ctx.globalAlpha = 0.2;
                    drawCallback();
                    ctx.restore();
                } else {
                    drawCallback();
                }
            }
        }

        // Global shape renderer instance
        const shapeRenderer = new PhysicsShapeRenderer();

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë UNIFIED DOCK SYSTEM
          ‚ïë Replaces CSS-based dock with canvas-rendered previews matching physics
          ‚ïë Maintains existing functionality while implementing unified appearance
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        function rebuildGameDock() {
            console.log('üîß rebuildGameDock() called');
            const dockingArea = document.getElementById('dockingArea');
            if (!dockingArea) {
                console.error('‚ùå dockingArea not found!');
                return;
            }

            // Get current dock shapes from level config or fallback to all shapes
            const dockShapes = window.currentLevelConfig ? window.currentLevelConfig.dockShapes : getAllShapeTypes();
            console.log('üì¶ Building dock with shapes:', dockShapes);
            console.log('üì¶ Current level config exists:', !!window.currentLevelConfig);
            console.log('üì¶ Shape renderer available:', !!shapeRenderer);
            
            // Clear and rebuild dock with canvas previews
            // First cleanup any existing PixiJS applications
            const existingPreviews = dockingArea.querySelectorAll('.pixi-preview');
            existingPreviews.forEach(preview => {
                if (preview._pixiApp) {
                    console.log('üßπ Cleaning up PixiJS preview application');
                    preview._pixiApp.destroy(true);
                    preview._pixiApp = null;
                }
            });
            
            dockingArea.innerHTML = '';
            console.log('üßπ Cleared existing dock content');
            
            dockShapes.forEach((shapeType, index) => {
                // V14: Commented out verbose dock creation logging
                // console.log(`üèóÔ∏è Creating slot ${index + 1} for: ${shapeType}`);
                const slotDiv = document.createElement('div');
                slotDiv.className = 'shape-slot'; // Ensure no 'empty' class on fresh slots
                slotDiv.id = `slot-${shapeType}`;

                if (shapeType && shapeRenderer) {
                    // Create full-size canvas preview using unified renderer
                    const canvasPreview = shapeRenderer.createDockPreview(shapeType, 90);
                    if (canvasPreview) {
                        canvasPreview.id = `shape-${shapeType}`;
                        canvasPreview.dataset.shape = shapeType;
                        canvasPreview.className = 'game-shape shape-preview';
                        canvasPreview.style.visibility = 'visible'; // Ensure visibility is reset
                        slotDiv.appendChild(canvasPreview);
                        console.log(`‚úÖ Created canvas preview for: ${shapeType}`);
                    } else {
                        console.error(`‚ùå Failed to create canvas preview for: ${shapeType}`);
                        // Create a temporary colored div fallback
                        const fallback = document.createElement('div');
                        fallback.className = 'game-shape shape-preview';
                        fallback.dataset.shape = shapeType;
                        fallback.id = `shape-${shapeType}`;
                        fallback.style.width = '50px';
                        fallback.style.height = '50px';
                        fallback.style.backgroundColor = getShapeConfig(shapeType)?.color || '#95A5A6';
                        fallback.style.border = '2px solid #7F8C8D';
                        fallback.style.borderRadius = '4px';
                        fallback.style.visibility = 'visible';
                        fallback.textContent = shapeType.charAt(0).toUpperCase();
                        slotDiv.appendChild(fallback);
                        console.log(`‚ö†Ô∏è Created fallback preview for: ${shapeType}`);
                    }
                } else {
                    console.warn(`‚ö†Ô∏è Empty slot or no renderer for: ${shapeType}`);
                    slotDiv.classList.add('empty');
                }
                
                dockingArea.appendChild(slotDiv);
                console.log(`üìç Added slot for ${shapeType} to dock`);
            });

            console.log(`‚úÖ Game dock rebuilt with ${dockShapes.length} slots total`);
        }

        // Initialize unified dock system (called after level config is ready)
        function initializeUnifiedDockSystem() {
            console.log('ÔøΩ Initializing Unified Dock System...');
            rebuildGameDock();
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë ENHANCED PHYSICS MANAGER WITH EVENT SYSTEM
          ‚ïë Phase 4.1: Implements collision detection, fall detection, and physics events
          ‚ïë Integrates physics events with game state for advanced game mechanics.
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        class PhysicsManager {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                
                // Matter.js aliases for cleaner code
                this.Engine = Matter.Engine;
                this.World = Matter.World;
                this.Bodies = Matter.Bodies;
                this.Body = Matter.Body;
                this.Events = Matter.Events;
                
                // Event tracking
                this.eventCount = 0;
                this.collisionCount = 0;
                this.fallCount = 0;
                
                // Canvas Enhancement System v9
                this.assetManager = new AssetManager();
                this.particleSystem = new ParticleSystem(canvas, this.assetManager);
                
                // Phase 1: PixiJS Integration - Dual Renderer System
                this.rendererManager = new RendererManager(canvas);
                
                // Phase 2: PixiJS Shape Rendering System
                this.pixiShapeRenderer = new PixiShapeRenderer(this.rendererManager);
                
                console.log('üéÆ PhysicsManager with dual renderer support initialized');
                
                // Theme-based rendering properties
                this.backgroundGradient = null;
                this.platformColor = '#8B4513';
                
                console.log('üé® Canvas Enhancement System initialized');
                
                // Initialize with default theme
                this.initializeDefaultTheme();
                
                // Phase 1: Initialize dual renderer system
                this.initializeRenderers();
                
                // Resize canvas to container
                this.resizeCanvas();
                
                // Create Matter.js world with physics engine
                this.engine = this.Engine.create();
                this.world = this.engine.world;
                
                // Set gravity (Matter.js uses different scale than Planck.js)
                this.engine.world.gravity.x = 0;
                this.engine.world.gravity.y = 1; // 1 pixel/frame¬≤ gravity
                
                // Track all dynamic bodies for rendering and cleanup
                this.dynamicBodies = [];
                
                // Camera shake system
                this.cameraShake = {
                    active: false,
                    intensity: 0,
                    duration: 0,
                    elapsed: 0,
                    frequencyX: 0.1,
                    frequencyY: 0.1,
                    offsetX: 0,
                    offsetY: 0
                };
                
                // Setup physics event listeners
                this.setupPhysicsEvents();
                
                // Create game platform and boundaries
                this.createPlatform();
                this.createBoundaries();
                
                // Start render loop
                this.startRenderLoop();
                
                console.log('üåç Enhanced Physics Manager with Events initialized');
            }

            // Canvas Enhancement v9: Initialize default theme
            async initializeDefaultTheme() {
                try {
                    await this.assetManager.loadTheme(CANVAS_CONFIG.defaultTheme);
                    const bgStyle = this.assetManager.getBackgroundStyle();
                    if (bgStyle && bgStyle.type === 'gradient') {
                        this.backgroundGradient = bgStyle.colors;
                    }
                    const platformStyle = this.assetManager.getPlatformStyle();
                    if (platformStyle) {
                        this.platformColor = platformStyle.color;
                    }
                    console.log(`üé® Default theme initialized: ${CANVAS_CONFIG.defaultTheme}`);
                } catch (error) {
                    console.error('‚ùå Failed to initialize default theme:', error);
                }
            }

            // Phase 1: Initialize dual renderer system
            async initializeRenderers() {
                try {
                    console.log('üé® Initializing dual renderer system...');
                    
                    // Initialize the renderer manager
                    await this.rendererManager.initialize();
                    
                    // Auto-select optimal renderer based on configuration
                    const success = this.rendererManager.autoSelectRenderer();
                    
                    if (success) {
                        const currentRenderer = this.rendererManager.getCurrentRenderer();
                        console.log(`‚úÖ Renderer system initialized with ${currentRenderer.toUpperCase()}`);
                        
                        // Phase 2: Initialize PixiJS shape rendering if enabled
                        if (PIXI_CONFIG.features.shapeRendering && currentRenderer === 'pixi') {
                            const shapeRenderingEnabled = this.pixiShapeRenderer.enable();
                            if (shapeRenderingEnabled) {
                                console.log('‚úÖ PixiJS shape rendering enabled');
                            }
                        }
                        
                        // Add feature flag controls for testing
                        this.addRendererControls();
                    } else {
                        console.warn('‚ö†Ô∏è Renderer initialization had issues, Canvas fallback active');
                    }
                    
                } catch (error) {
                    console.error('‚ùå Renderer initialization failed:', error);
                    console.log('üîÑ Falling back to Canvas-only mode');
                }
            }

            // Add renderer controls for development/testing
            addRendererControls() {
                // Add global functions for testing renderer switching
                window.switchToCanvas = () => {
                    this.rendererManager.switchRenderer('canvas');
                    console.log('üé® Switched to Canvas renderer');
                };
                
                window.switchToPixi = () => {
                    if (this.rendererManager.canSwitchTo('pixi')) {
                        this.rendererManager.switchRenderer('pixi');
                        console.log('üé® Switched to PixiJS renderer');
                    } else {
                        console.warn('‚ö†Ô∏è PixiJS renderer not available');
                    }
                };
                
                window.getCurrentRenderer = () => {
                    const current = this.rendererManager.getCurrentRenderer();
                    console.log('üé® Current renderer:', current.toUpperCase());
                    return current;
                };
                
                window.showRendererInfo = () => {
                    const current = this.rendererManager.getCurrentRenderer();
                    const pixiAvailable = this.rendererManager.canSwitchTo('pixi');
                    const shapeRenderingEnabled = PIXI_CONFIG.features.shapeRendering && this.pixiShapeRenderer.isEnabled;
                    const shapeCount = this.pixiShapeRenderer.getShapeCount();
                    
                    console.log(`
üé® RENDERER SYSTEM INFO (Phase 2):
Current: ${current.toUpperCase()}
PixiJS Available: ${pixiAvailable}
PixiJS Enabled: ${PIXI_CONFIG.enabled}
Canvas Fallback: ${PIXI_CONFIG.fallbackToCanvas}
Shape Rendering: ${shapeRenderingEnabled}
PixiJS Shape Count: ${shapeCount}

Phase 1 Commands:
- switchToCanvas()    // Switch to Canvas renderer
- switchToPixi()      // Switch to PixiJS renderer  
- getCurrentRenderer() // Show current renderer

Phase 2 Commands:
- enablePixiShapes()   // Enable PixiJS shape rendering
- disablePixiShapes()  // Disable PixiJS shape rendering
- getPixiShapeCount()  // Show PixiJS shape count
- showRendererInfo()   // Show this info
                    `);
                };
                
                // Phase 2: Add PixiJS shape rendering test functions
                window.enablePixiShapes = () => {
                    if (!this.rendererManager.isPixiActive()) {
                        console.warn('‚ö†Ô∏è PixiJS renderer must be active to enable shape rendering');
                        return false;
                    }
                    
                    PIXI_CONFIG.features.shapeRendering = true;
                    const success = this.pixiShapeRenderer.enable();
                    
                    if (success) {
                        // Recreate existing shapes
                        this.dynamicBodies.forEach(body => {
                            if (body.userData && body.userData.shapeType) {
                                this.pixiShapeRenderer.createShape(body, body.userData.shapeType);
                            }
                        });
                        
                        // Update UI
                        document.getElementById('enablePixiShapes').checked = true;
                        console.log(`‚úÖ PixiJS shape rendering enabled with ${this.dynamicBodies.length} shapes`);
                        return true;
                    }
                    return false;
                };
                
                window.disablePixiShapes = () => {
                    PIXI_CONFIG.features.shapeRendering = false;
                    this.pixiShapeRenderer.disable();
                    document.getElementById('enablePixiShapes').checked = false;
                    console.log('üîÑ PixiJS shape rendering disabled');
                };
                
                window.getPixiShapeCount = () => {
                    const count = this.pixiShapeRenderer.getShapeCount();
                    console.log(`üé® PixiJS shapes: ${count}`);
                    return count;
                };
                
                console.log('üéÆ Renderer control functions added to window object');
            }

            setupPhysicsEvents() {
                // Matter.js collision detection - when shapes start touching
                this.Events.on(this.engine, 'collisionStart', (event) => {
                    event.pairs.forEach(pair => {
                        this.handleBeginContact(pair);
                    });
                });
                
                // Matter.js collision end - when shapes stop touching  
                this.Events.on(this.engine, 'collisionEnd', (event) => {
                    event.pairs.forEach(pair => {
                        this.handleEndContact(pair);
                    });
                });
                
                console.log('üéØ Matter.js event listeners configured');
            }

            handleBeginContact(pair) {
                const bodyA = pair.bodyA;
                const bodyB = pair.bodyB;
                const userDataA = bodyA.userData || {};
                const userDataB = bodyB.userData || {};
                
                console.log(`üîç RAW COLLISION: bodyA.userData =`, userDataA, `bodyB.userData =`, userDataB);
                
                this.collisionCount++;
                this.eventCount++;
                
                // Check for shape-platform collision
                if (this.isShapePlatformCollision(userDataA, userDataB)) {
                    console.log('üéØ PLATFORM COLLISION DETECTED!');
                    this.onShapeLandedOnPlatform(bodyA, bodyB);
                }
                
                // Check for shape-shape collision
                if (this.isShapeShapeCollision(userDataA, userDataB)) {
                    console.log('üîÑ SHAPE-SHAPE COLLISION DETECTED!');
                    this.onShapeShapeCollision(bodyA, bodyB);
                }
                
                // Check for ground collision (fall detection)
                console.log('üß™ Testing ground collision...');
                if (this.isGroundCollision(userDataA, userDataB)) {
                    console.log('üî• GROUND COLLISION DETECTED! Triggering shape fall...');
                    this.onShapeFellOffPlatform(bodyA, bodyB);
                } else {
                    console.log('‚ùå Ground collision test failed');
                }
                
                console.log(`üìç Collision detected: ${userDataA.type || 'unknown'} vs ${userDataB.type || 'unknown'}`);
            }

            handleEndContact(pair) {
                // Handle when objects stop touching
                const bodyA = pair.bodyA;
                const bodyB = pair.bodyB;
                
                // Could implement "unstable" detection here
                // console.log('üì§ Contact ended');
            }

            isShapePlatformCollision(dataA, dataB) {
                const shapeTypes = ['shape', 'compound', 'rectangle', 'polygon', 'circle'];
                const isAShape = shapeTypes.includes(dataA.type);
                const isBShape = shapeTypes.includes(dataB.type);
                
                return (isAShape && dataB.type === 'platform') ||
                       (dataA.type === 'platform' && isBShape);
            }

            isShapeShapeCollision(dataA, dataB) {
                const shapeTypes = ['shape', 'compound', 'rectangle', 'polygon', 'circle'];
                const isAShape = shapeTypes.includes(dataA.type);
                const isBShape = shapeTypes.includes(dataB.type);
                
                return isAShape && isBShape;
            }

            isGroundCollision(dataA, dataB) {
                const shapeTypes = ['shape', 'compound', 'rectangle', 'polygon', 'circle'];
                const isAShape = shapeTypes.includes(dataA.type);
                const isBShape = shapeTypes.includes(dataB.type);
                
                const result = (isAShape && dataB.type === 'ground') ||
                              (dataA.type === 'ground' && isBShape);
                              
                if (result) {
                    console.log(`üéØ Ground collision detected: ${dataA.type} vs ${dataB.type} - isAShape: ${isAShape}, isBShape: ${isBShape}`);
                }
                
                return result;
            }

            onShapeLandedOnPlatform(bodyA, bodyB) {
                console.log('üéØ Shape landed on platform!');
                this.showEventNotification('Shape Landed!', 'collision');
                
                // Phase 3: Trigger platform landing animation
                this.triggerCollisionAnimation(bodyA, bodyB, 'platform');
                
                // Trigger game event
                if (window.gameManager) {
                    window.gameManager.onShapeLandedOnPlatform();
                }
            }

            onShapeShapeCollision(bodyA, bodyB) {
                console.log('üîÑ Shape collision detected!');
                this.showEventNotification('Shape Contact!', 'balance');
                
                // Phase 3: Trigger collision flash animation
                this.triggerCollisionAnimation(bodyA, bodyB, 'collision');
                
                // Trigger game event
                if (window.gameManager) {
                    window.gameManager.onShapeCollision();
                }
            }

            // Phase 3: Animation trigger helper
            triggerCollisionAnimation(bodyA, bodyB, animationType) {
                const pixiShapeRenderer = this.pixiShapeRenderer;
                const animationManager = this.rendererManager?.pixiManager?.animationManager;
                
                if (!pixiShapeRenderer || !animationManager || !animationManager.isEnabled) {
                    return;
                }

                // Find which body is the shape and animate it
                const shapeBody = this.findShapeBody(bodyA, bodyB);
                if (shapeBody) {
                    const shapeData = pixiShapeRenderer.shapes.get(shapeBody.id);
                    if (shapeData && shapeData.graphics) {
                        if (animationType === 'platform') {
                            animationManager.animatePlatformLanding(shapeData.graphics);
                        } else if (animationType === 'collision') {
                            animationManager.animateCollisionFlash(shapeData.graphics);
                        }
                    }
                }
            }

            findShapeBody(bodyA, bodyB) {
                // Return the body that represents a shape (not platform/ground/boundary)
                const userDataA = bodyA.userData || {};
                const userDataB = bodyB.userData || {};
                
                if (userDataA.shapeType && userDataA.type !== 'platform' && userDataA.type !== 'ground' && userDataA.type !== 'boundary') {
                    return bodyA;
                }
                
                if (userDataB.shapeType && userDataB.type !== 'platform' && userDataB.type !== 'ground' && userDataB.type !== 'boundary') {
                    return bodyB;
                }
                
                return null;
            }

            onShapeFellOffPlatform(bodyA, bodyB) {
                console.log('üí• Shape fell off platform!');
                this.fallCount++;
                
                this.showEventNotification('Shape Fell!', 'fall');
                
                // Trigger game event
                if (window.gameManager) {
                    window.gameManager.onShapeFell();
                }
            }

            showEventNotification(message, type) {
                const notification = document.getElementById('eventNotification');
                notification.textContent = message;
                notification.className = `event-notification ${type} show`;
                
                setTimeout(() => {
                    notification.classList.remove('show');
                }, 2000);
            }

            resizeCanvas() {
                const container = this.canvas.parentElement;
                this.canvas.width = container.clientWidth;
                this.canvas.height = container.clientHeight;
                console.log(`üìê Canvas resized to: ${this.canvas.width}x${this.canvas.height}`);
            }

            createBoundaries() {
                // Create invisible ground boundary for fall detection
                const groundY = this.canvas.height + 150; // Extended to +150 (was +50) for longer fall distance
                const groundWidth = this.canvas.width;
                
                const ground = this.Bodies.rectangle(
                    this.canvas.width / 2, 
                    groundY, 
                    groundWidth, 
                    100, 
                    {
                        isStatic: true,
                        render: { visible: false }
                    }
                );
                
                // Set user data for collision detection
                ground.userData = {
                    type: 'ground',
                    name: 'fallDetectionBoundary'
                };
                
                this.World.add(this.world, ground);
                console.log('üöß Matter.js boundaries created');
            }

            createPlatform() {
                // Restore original angled platform from v1 (-50 degrees)
                const platformX = this.canvas.width / 2 - 30;  // Pixel coordinates
                const platformY = this.canvas.height - 20;     // Moved down 100px (was -120, now -20)
                const platformWidth = 200;
                const platformHeight = 20;
                const platformAngle = -0.873; // -50 degrees
                
                // Create angled platform with Matter.js
                const platform = this.Bodies.rectangle(
                    platformX, 
                    platformY, 
                    platformWidth, 
                    platformHeight,
                    {
                        isStatic: true,
                        angle: platformAngle,
                        render: {
                            fillStyle: '#95A5A6',
                            strokeStyle: '#7F8C8D',
                            lineWidth: 2
                        },
                        friction: 0.9,
                        restitution: 0
                    }
                );
                
                // Set user data for collision detection
                platform.userData = {
                    type: 'platform',
                    visible: true,
                    color: '#95A5A6',
                    stroke: '#7F8C8D',
                    strokeWidth: 2,
                    width: platformWidth,
                    height: platformHeight
                };
                
                this.World.add(this.world, platform);
                console.log(`üèóÔ∏è Matter.js angled platform created: -50¬∞ at (${platformX}, ${platformY})`);
            }

            createCompoundShape(x, y, type, rotation = 0) {
                // Forward to unified createShape method for consistency
                return this.createShape(x, y, type, rotation);
            }

            createShape(x, y, type, rotation = 0) {
                const config = getShapeConfig(type);
                if (!config) {
                    console.error(`Unknown shape type: ${type}`);
                    return null;
                }

                // V9: Matter.js compound shape creation with perfect collision detection
                console.log(`üéØ Creating Matter.js shape: ${type} at (${x}, ${y})`);

                let body;

                // Handle compound shapes (shapes with parts) using SHAPE_CONFIG
                if (config.type === 'compound' && config.parts) {
                    body = this.createMatterCompoundShape(x, y, type, rotation, config);
                } else {
                    // Handle simple shapes with standard Matter.js bodies
                    body = this.createMatterSimpleShape(x, y, type, rotation, config);
                }

                if (body) {
                    // Set Matter.js physics properties from config
                    body.restitution = config.restitution || 0.1;      // Reduced bounce to prevent rotation changes
                    body.friction = config.friction || 0.9;       
                    body.frictionAir = 0.02;   // Reduced air resistance to maintain manual rotation
                    
                    // Stabilize rotation for a brief moment after drop
                    const originalAngularVelocity = body.angularVelocity;
                    body.angularVelocity = 0; // Stop any spinning from collision
                    
                    // After a short delay, allow normal physics
                    setTimeout(() => {
                        if (body && body.angularVelocity === 0) {
                            body.frictionAir = 0.05; // Restore normal air resistance
                        }
                    }, 100); // Brief stabilization period

                    // Set user data for collision detection and rendering
                    body.userData = {
                        type: 'shape',
                        shapeType: type,
                        ...config
                    };
                    
                    console.log(`üè∑Ô∏è Shape userData set:`, body.userData);

                    this.World.add(this.world, body);
                    this.dynamicBodies.push(body);

                    // Phase 2: Create PixiJS shape if shape rendering is enabled
                    if (PIXI_CONFIG.features.shapeRendering && this.pixiShapeRenderer.isEnabled) {
                        this.pixiShapeRenderer.createShape(body, type);
                    }

                    console.log(`‚úÖ Matter.js ${type} created successfully`);
                    return body;
                }

                console.error(`‚ùå Failed to create Matter.js shape: ${type}`);
                return null;
            }

            createMatterCompoundShape(x, y, type, rotation, config) {
                console.log(`üéØ Creating Matter.js compound shape: ${type} using SHAPE_CONFIG`);
                
                if (!config.parts || config.parts.length === 0) {
                    console.error(`‚ùå No parts defined for compound shape: ${type}`);
                    return null;
                }
                
                const bodyParts = [];
                
                // Create each part based on SHAPE_CONFIG specification
                config.parts.forEach((partConfig, index) => {
                    // Use relative positioning for compound body parts
                    const partX = x + (partConfig.offsetX || 0);
                    const partY = y + (partConfig.offsetY || 0);
                    let bodyPart = null;
                    
                    if (partConfig.type === 'rectangle') {
                        bodyPart = this.Bodies.rectangle(partX, partY, partConfig.width, partConfig.height, {
                            render: {
                                fillStyle: partConfig.color || config.color,
                                strokeStyle: partConfig.stroke || config.stroke,
                                lineWidth: config.strokeWidth || 2
                            }
                        });
                    } else if (partConfig.type === 'circle') {
                        bodyPart = this.Bodies.circle(partX, partY, partConfig.radius, {
                            render: {
                                fillStyle: partConfig.color || config.color,
                                strokeStyle: partConfig.stroke || config.stroke,
                                lineWidth: config.strokeWidth || 2
                            }
                        });
                    } else if (partConfig.type === 'diamond') {
                        // Create diamond as a rotated square
                        const size = partConfig.width || partConfig.height || 12;
                        bodyPart = this.Bodies.polygon(partX, partY, 4, size / Math.sqrt(2), {
                            angle: Math.PI / 4, // 45 degree rotation for diamond
                            render: {
                                fillStyle: partConfig.color || config.color,
                                strokeStyle: partConfig.stroke || config.stroke,
                                lineWidth: config.strokeWidth || 2
                            }
                        });
                    }
                    
                    if (bodyPart) {
                        bodyParts.push(bodyPart);
                        console.log(`‚úÖ Created ${partConfig.type} part at offset (${partConfig.offsetX}, ${partConfig.offsetY})`);
                    }
                });
                
                if (bodyParts.length === 0) {
                    console.error(`‚ùå No body parts created for compound shape: ${type}`);
                    return null;
                }
                
                // Create compound body and then rotate it smoothly
                const compoundBody = this.Body.create({
                    parts: bodyParts
                });
                
                // Apply rotation after creation to prevent snapping
                if (rotation !== 0) {
                    this.Body.setAngle(compoundBody, rotation);
                }
                
                // CRITICAL: Set userData on compound body AND all parts
                const userData = {
                    type: 'compound',
                    shapeType: type,
                    ...config
                };
                
                compoundBody.userData = userData;
                
                // Also set userData on all parts so collision detection works
                bodyParts.forEach(part => {
                    part.userData = userData;
                });
                
                console.log(`üè∑Ô∏è Compound shape userData set on main body and ${bodyParts.length} parts:`, userData);
                console.log(`‚úÖ Matter.js compound shape ${type} created with ${bodyParts.length} parts, rotated ${(rotation * 180 / Math.PI).toFixed(1)}¬∞`);
                return compoundBody;
            }

            createMatterSimpleShape(x, y, type, rotation, config) {
                console.log(`üéØ Creating Matter.js simple shape: ${type}`);
                
                let body = null;

                // Create shape based on type
                if (type === 'square') {
                    body = this.Bodies.rectangle(x, y, config.width || 50, config.height || 50, {
                        angle: rotation,
                        render: {
                            fillStyle: config.color || '#FFD700',
                            strokeStyle: config.stroke || '#FFA500',
                            lineWidth: config.strokeWidth || 2
                        }
                    });
                } else if (type === 'triangle') {
                    // Create triangle using polygon but fix the default orientation
                    // Matter.js Bodies.polygon(x, y, 3, radius) creates triangle with different default rotation
                    const sides = 3;
                    const radius = 20; // Match approximate size of our config vertices
                    
                    // Add Math.PI/2 (90 degrees) to align with our triangle config (point up)
                    const adjustedRotation = rotation + Math.PI/2;
                    
                    body = this.Bodies.polygon(x, y, sides, radius, {
                        angle: adjustedRotation,
                        render: {
                            fillStyle: config.color || '#9B59B6',
                            strokeStyle: config.stroke || '#8E44AD',
                            lineWidth: config.strokeWidth || 2
                        }
                    });
                    
                    console.log(`üî∫ Triangle created with 90¬∞ adjustment, final rotation ${(adjustedRotation * 180 / Math.PI).toFixed(1)}¬∞`);
                } else if (type === 'circle') {
                    body = this.Bodies.circle(x, y, config.radius || 25, {
                        render: {
                            fillStyle: config.color || '#1ABC9C',
                            strokeStyle: config.stroke || '#16A085',
                            lineWidth: config.strokeWidth || 2
                        }
                    });
                }

                if (body) {
                    // Set userData on simple shape body  
                    body.userData = {
                        type: config.type || 'rectangle', // Use config type (rectangle, polygon, circle)
                        shapeType: type,
                        ...config
                    };
                    console.log(`üè∑Ô∏è Simple shape userData set:`, body.userData);
                }

                console.log(`‚úÖ Matter.js simple shape ${type} created`);
                return body;
            }

            startRenderLoop() {
                let lastTime = 0;
                const render = (currentTime) => {
                    const deltaTime = currentTime - lastTime;
                    lastTime = currentTime;
                    
                    // Update camera shake
                    this.updateCameraShake(deltaTime);
                    
                    // Step Matter.js physics simulation
                    this.Engine.update(this.engine, 1000 / 60); // 60 FPS
                    
                    // Clear canvas
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    
                    // v9: Enhanced rendering with themes (no camera shake transforms needed)
                    this.renderBackground();
                    this.renderWorld();
                    this.particleSystem.update(16); // ~16ms per frame at 60fps
                    this.particleSystem.render();
                    
                    // Phase 2: Update PixiJS shapes to match physics bodies
                    if (PIXI_CONFIG.features.shapeRendering && this.pixiShapeRenderer.isEnabled) {
                        this.pixiShapeRenderer.updateShapes();
                    }
                    
                    requestAnimationFrame(render);
                };
                render(performance.now());
                console.log('üé¨ Matter.js render loop with Canvas Enhancement and Camera Shake started');
            }

            // v9: Enhanced background rendering with theme support
            renderBackground() {
                if (!CANVAS_CONFIG.enabled || !CANVAS_CONFIG.useBackgroundTextures) {
                    return; // Use default CSS background
                }

                const backgroundStyle = this.assetManager.getBackgroundStyle();
                if (!backgroundStyle) return;

                // Check if we have a background image
                if (backgroundStyle.image && backgroundStyle.imageConfig) {
                    this.renderBackgroundImage(backgroundStyle);
                } else if (backgroundStyle.colors && backgroundStyle.colors.length >= 2) {
                    this.renderBackgroundGradient(backgroundStyle);
                }
                
                // Add texture overlay if configured
                this.renderBackgroundTexture();
            }

            // Render background image
            renderBackgroundImage(backgroundStyle) {
                const image = backgroundStyle.image;
                const config = backgroundStyle.imageConfig;
                
                this.ctx.save();
                
                // Apply image based on configuration
                switch(config.size) {
                    case 'cover':
                        this.drawImageCover(image);
                        break;
                    case 'contain':
                        this.drawImageContain(image);
                        break;
                    case 'auto':
                        this.ctx.drawImage(image, 0, 0);
                        break;
                    default: // "100% 100%" or similar
                        this.ctx.drawImage(image, 0, 0, this.canvas.width, this.canvas.height);
                }
                
                // If there are gradient colors too, overlay them with reduced opacity
                if (backgroundStyle.colors && backgroundStyle.colors.length >= 2) {
                    this.ctx.globalAlpha = 0.3; // Reduce opacity for overlay
                    this.renderBackgroundGradient(backgroundStyle);
                }
                
                this.ctx.restore();
            }

            // Helper to draw image with 'cover' behavior
            drawImageCover(image) {
                const canvasRatio = this.canvas.width / this.canvas.height;
                const imageRatio = image.width / image.height;
                
                let drawWidth, drawHeight, drawX, drawY;
                
                if (imageRatio > canvasRatio) {
                    // Image is wider than canvas ratio
                    drawHeight = this.canvas.height;
                    drawWidth = drawHeight * imageRatio;
                    drawX = (this.canvas.width - drawWidth) / 2;
                    drawY = 0;
                } else {
                    // Image is taller than canvas ratio
                    drawWidth = this.canvas.width;
                    drawHeight = drawWidth / imageRatio;
                    drawX = 0;
                    drawY = (this.canvas.height - drawHeight) / 2;
                }
                
                this.ctx.drawImage(image, drawX, drawY, drawWidth, drawHeight);
            }

            // Helper to draw image with 'contain' behavior
            drawImageContain(image) {
                const canvasRatio = this.canvas.width / this.canvas.height;
                const imageRatio = image.width / image.height;
                
                let drawWidth, drawHeight, drawX, drawY;
                
                if (imageRatio > canvasRatio) {
                    // Fit to canvas width
                    drawWidth = this.canvas.width;
                    drawHeight = drawWidth / imageRatio;
                    drawX = 0;
                    drawY = (this.canvas.height - drawHeight) / 2;
                } else {
                    // Fit to canvas height
                    drawHeight = this.canvas.height;
                    drawWidth = drawHeight * imageRatio;
                    drawX = (this.canvas.width - drawWidth) / 2;
                    drawY = 0;
                }
                
                this.ctx.drawImage(image, drawX, drawY, drawWidth, drawHeight);
            }

            // Render gradient background (extracted from previous method)
            renderBackgroundGradient(backgroundStyle) {
                const colors = backgroundStyle.colors;
                if (!colors || colors.length < 2) return;

                // Create linear gradient background
                const gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
                
                // Distribute colors evenly across gradient
                const colorStep = 1 / (colors.length - 1);
                colors.forEach((color, index) => {
                    gradient.addColorStop(index * colorStep, color);
                });
                
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            }

            // v9: Add subtle texture to background
            renderBackgroundTexture() {
                const currentTheme = this.assetManager.getCurrentTheme();
                if (!currentTheme) return;
                
                this.ctx.save();
                this.ctx.globalAlpha = 0.1;
                
                // Add theme-specific background patterns
                switch(currentTheme.config.platform.material) {
                    case 'wood':
                        this.renderWoodTexture();
                        break;
                    case 'metal':
                        this.renderMetalTexture();
                        break;
                    case 'coral':
                        this.renderCoralTexture();
                        break;
                    default:
                        this.renderGeometricTexture();
                }
                
                this.ctx.restore();
            }

            renderWoodTexture() {
                // Simple wood grain effect
                this.ctx.strokeStyle = '#8B4513';
                this.ctx.lineWidth = 0.5;
                for (let i = 0; i < 20; i++) {
                    const y = (this.canvas.height / 20) * i;
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.canvas.width, y + Math.sin(i) * 5);
                    this.ctx.stroke();
                }
            }

            renderMetalTexture() {
                // Diagonal line pattern
                this.ctx.strokeStyle = '#708090';
                this.ctx.lineWidth = 0.3;
                for (let i = -this.canvas.width; i < this.canvas.width + this.canvas.height; i += 10) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(i, 0);
                    this.ctx.lineTo(i + this.canvas.height, this.canvas.height);
                    this.ctx.stroke();
                }
            }

            renderCoralTexture() {
                // Organic bubble pattern
                this.ctx.fillStyle = '#2E8B57';
                for (let i = 0; i < 50; i++) {
                    const x = Math.random() * this.canvas.width;
                    const y = Math.random() * this.canvas.height;
                    const radius = Math.random() * 3 + 1;
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, radius, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }

            renderGeometricTexture() {
                // Simple dot pattern
                this.ctx.fillStyle = '#cccccc';
                for (let x = 10; x < this.canvas.width; x += 20) {
                    for (let y = 10; y < this.canvas.height; y += 20) {
                        this.ctx.beginPath();
                        this.ctx.arc(x, y, 1, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                }
            }

            // =============================================================================
            // CAMERA SHAKE SYSTEM
            // =============================================================================

            /**
             * Trigger camera shake effect
             * @param {number} intensity - Shake intensity (1-10)
             * @param {number} duration - Duration in milliseconds
             */
            startCameraShake(intensity = 5, duration = 500) {
                console.log(`üö® startCameraShake called with intensity=${intensity}, duration=${duration}ms`);
                
                this.cameraShake.active = true;
                this.cameraShake.intensity = intensity;
                this.cameraShake.duration = duration;
                this.cameraShake.elapsed = 0;
                this.cameraShake.frequencyX = 0.1 + Math.random() * 0.1; // Randomize frequency
                this.cameraShake.frequencyY = 0.1 + Math.random() * 0.1;
                
                console.log(`‚úÖ Camera shake activated - state:`, this.cameraShake);
                console.log(`üéØ Canvas element:`, this.canvas);
                
                // Immediate test shake to verify it works
                this.canvas.style.transform = `translate(${intensity}px, ${intensity}px)`;
                setTimeout(() => {
                    this.canvas.style.transform = 'translate(0px, 0px)';
                }, 100);
                
                console.log(`üìπ Camera shake started: intensity=${intensity}, duration=${duration}ms`);
            }

            /**
             * Update camera shake effect - applies shake directly to canvas element
             * @param {number} deltaTime - Time since last update
             */
            updateCameraShake(deltaTime) {
                if (!this.cameraShake.active) {
                    // Reset canvas position when not shaking
                    this.canvas.style.transform = 'translate(0px, 0px)';
                    return;
                }

                console.log(`üîÑ updateCameraShake: elapsed=${this.cameraShake.elapsed}, duration=${this.cameraShake.duration}, intensity=${this.cameraShake.intensity}`);

                this.cameraShake.elapsed += deltaTime;

                if (this.cameraShake.elapsed >= this.cameraShake.duration) {
                    // Shake finished
                    this.cameraShake.active = false;
                    this.canvas.style.transform = 'translate(0px, 0px)';
                    console.log('‚úÖ Camera shake completed');
                    return;
                }

                // Calculate shake progress (1.0 at start, 0.0 at end)
                const progress = 1.0 - (this.cameraShake.elapsed / this.cameraShake.duration);
                const currentIntensity = this.cameraShake.intensity * progress * progress; // Quadratic falloff

                // Generate shake offset using sine waves with different frequencies
                const time = this.cameraShake.elapsed * 0.01; // Convert to suitable time scale
                let offsetX = Math.sin(time * this.cameraShake.frequencyX * 50) * currentIntensity;
                let offsetY = Math.sin(time * this.cameraShake.frequencyY * 47) * currentIntensity; // Different frequency for variety

                // Add random jitter for more chaotic feel
                offsetX += (Math.random() - 0.5) * currentIntensity * 0.5;
                offsetY += (Math.random() - 0.5) * currentIntensity * 0.5;

                console.log(`üì≥ Applying shake: offsetX=${offsetX.toFixed(1)}, offsetY=${offsetY.toFixed(1)}, currentIntensity=${currentIntensity.toFixed(1)}`);

                // Apply transform to canvas element
                this.canvas.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
            }

            /**
             * Apply camera shake to canvas transform (legacy method - now unused)
             */
            applyCameraShake() {
                // This method is no longer used - shake is applied directly to canvas element
            }

            /**
             * Reset camera shake transform (legacy method - now unused)
             */
            resetCameraShake() {
                // This method is no longer used - shake is applied directly to canvas element
            }

            renderWorld() {
                // Render all Matter.js bodies in the world
                const bodies = this.world.bodies;
                for (let i = 0; i < bodies.length; i++) {
                    this.renderBody(bodies[i]);
                }
            }

            renderBody(body) {
                // Skip rendering invisible bodies
                if (body.render && body.render.visible === false) return;
                
                // V9: Render Matter.js body parts directly (no coordinate transformation)
                if (body.parts && body.parts.length > 1) {
                    // Compound body - render each part separately
                    for (let i = 1; i < body.parts.length; i++) { // Skip first part (it's the parent)
                        this.renderMatterPart(body.parts[i], body);
                    }
                } else {
                    // Simple body - render directly
                    this.renderMatterPart(body, body);
                }
            }

            renderMatterPart(part, parentBody) {
                // Get render properties from Matter.js body
                const render = part.render || {};
                const userData = parentBody.userData || {};
                
                // Skip invisible parts
                if (render.visible === false) return;
                
                // v9: Theme-based color selection
                let fillColor = render.fillStyle || userData.color || '#95A5A6';
                let strokeColor = render.strokeStyle || userData.stroke || '#7F8C8D';
                
                // Apply theme colors for platform
                if (userData.type === 'platform' && this.platformColor) {
                    fillColor = this.platformColor;
                    strokeColor = this.darkenColor(this.platformColor, 20);
                }
                
                // v9: Check for image textures
                const shouldUseTexture = CANVAS_CONFIG.enabled && CANVAS_CONFIG.useBackgroundTextures;
                let textureImage = null;
                let textureConfig = null;
                
                if (shouldUseTexture) {
                    if (userData.type === 'platform') {
                        const platformStyle = this.assetManager.getPlatformStyle();
                        textureImage = platformStyle?.image;
                        textureConfig = platformStyle?.imageConfig;
                    } else if (userData.shapeType) {
                        const shapeStyle = this.assetManager.getShapeStyle(userData.shapeType);
                        textureImage = shapeStyle?.texture;
                        textureConfig = shapeStyle?.textureConfig;
                    }
                }
                
                // Set drawing style
                this.ctx.fillStyle = fillColor;
                this.ctx.strokeStyle = strokeColor;
                this.ctx.lineWidth = render.lineWidth || userData.strokeWidth || 2;
                
                // Render based on shape type
                if (part.circleRadius !== undefined && part.circleRadius > 0) {
                    // Circle - use part's own position (already in world coordinates)
                    this.renderCircleWithTexture(part, textureImage, textureConfig);
                } else if (part.vertices && part.vertices.length > 0) {
                    // Polygon (including rectangles) - vertices are in world coordinates
                    this.renderPolygonWithTexture(part, textureImage, textureConfig);
                } else {
                    console.log(`‚ö†Ô∏è Unknown body type - circleRadius: ${part.circleRadius}, vertices: ${part.vertices ? part.vertices.length : 'none'} for ${userData.type || 'unknown'}`);
                }
            }

            renderCircleWithTexture(part, textureImage, textureConfig) {
                this.ctx.save();
                
                // Create circular clipping path
                this.ctx.beginPath();
                this.ctx.arc(part.position.x, part.position.y, part.circleRadius, 0, Math.PI * 2);
                
                if (textureImage && textureConfig) {
                    // Fill with texture
                    this.ctx.clip();
                    this.applyTextureToShape(part.position.x - part.circleRadius, 
                                           part.position.y - part.circleRadius,
                                           part.circleRadius * 2, 
                                           part.circleRadius * 2,
                                           textureImage, textureConfig);
                } else {
                    // Fill with solid color
                    this.ctx.fill();
                }
                
                // Restore for stroke
                this.ctx.restore();
                
                // Draw stroke
                this.ctx.beginPath();
                this.ctx.arc(part.position.x, part.position.y, part.circleRadius, 0, Math.PI * 2);
                this.ctx.stroke();
            }

            renderPolygonWithTexture(part, textureImage, textureConfig) {
                const vertices = part.vertices;
                
                this.ctx.save();
                
                // Create polygon clipping path
                this.ctx.beginPath();
                this.ctx.moveTo(vertices[0].x, vertices[0].y);
                for (let i = 1; i < vertices.length; i++) {
                    this.ctx.lineTo(vertices[i].x, vertices[i].y);
                }
                this.ctx.closePath();
                
                if (textureImage && textureConfig) {
                    // Get bounding box for texture positioning
                    const bounds = this.getPolygonBounds(vertices);
                    
                    // Fill with texture
                    this.ctx.clip();
                    this.applyTextureToShape(bounds.x, bounds.y, bounds.width, bounds.height,
                                           textureImage, textureConfig);
                } else {
                    // Fill with solid color
                    this.ctx.fill();
                }
                
                // Restore for stroke
                this.ctx.restore();
                
                // Draw stroke
                this.ctx.beginPath();
                this.ctx.moveTo(vertices[0].x, vertices[0].y);
                for (let i = 1; i < vertices.length; i++) {
                    this.ctx.lineTo(vertices[i].x, vertices[i].y);
                }
                this.ctx.closePath();
                this.ctx.stroke();
            }

            applyTextureToShape(x, y, width, height, image, textureConfig) {
                if (!image) return;
                
                this.ctx.save();
                
                // Apply blend mode
                if (textureConfig.blend && textureConfig.blend !== 'normal') {
                    this.ctx.globalCompositeOperation = textureConfig.blend;
                }
                
                // Apply opacity
                if (textureConfig.opacity !== undefined) {
                    this.ctx.globalAlpha = textureConfig.opacity;
                }
                
                // Handle texture repeat patterns
                switch(textureConfig.repeat) {
                    case 'repeat':
                        this.drawRepeatedTexture(x, y, width, height, image);
                        break;
                    case 'repeat-x':
                        this.drawRepeatedTextureX(x, y, width, height, image);
                        break;
                    case 'repeat-y':
                        this.drawRepeatedTextureY(x, y, width, height, image);
                        break;
                    case 'no-repeat':
                    default:
                        this.ctx.drawImage(image, x, y, width, height);
                        break;
                }
                
                this.ctx.restore();
            }

            drawRepeatedTexture(x, y, width, height, image) {
                const pattern = this.ctx.createPattern(image, 'repeat');
                if (pattern) {
                    this.ctx.fillStyle = pattern;
                    this.ctx.fillRect(x, y, width, height);
                } else {
                    // Fallback: manual tiling
                    this.manualTileTexture(x, y, width, height, image);
                }
            }

            drawRepeatedTextureX(x, y, width, height, image) {
                const aspectRatio = image.width / image.height;
                const tileHeight = height;
                const tileWidth = tileHeight * aspectRatio;
                
                for (let tx = x; tx < x + width; tx += tileWidth) {
                    const drawWidth = Math.min(tileWidth, x + width - tx);
                    this.ctx.drawImage(image, 0, 0, image.width * (drawWidth / tileWidth), image.height,
                                     tx, y, drawWidth, tileHeight);
                }
            }

            drawRepeatedTextureY(x, y, width, height, image) {
                const aspectRatio = image.width / image.height;
                const tileWidth = width;
                const tileHeight = tileWidth / aspectRatio;
                
                for (let ty = y; ty < y + height; ty += tileHeight) {
                    const drawHeight = Math.min(tileHeight, y + height - ty);
                    this.ctx.drawImage(image, 0, 0, image.width, image.height * (drawHeight / tileHeight),
                                     x, ty, tileWidth, drawHeight);
                }
            }

            manualTileTexture(x, y, width, height, image) {
                const tileWidth = image.width;
                const tileHeight = image.height;
                
                for (let ty = y; ty < y + height; ty += tileHeight) {
                    for (let tx = x; tx < x + width; tx += tileWidth) {
                        const drawWidth = Math.min(tileWidth, x + width - tx);
                        const drawHeight = Math.min(tileHeight, y + height - ty);
                        
                        this.ctx.drawImage(image, 0, 0, 
                                         image.width * (drawWidth / tileWidth), 
                                         image.height * (drawHeight / tileHeight),
                                         tx, ty, drawWidth, drawHeight);
                    }
                }
            }

            getPolygonBounds(vertices) {
                let minX = Infinity, minY = Infinity;
                let maxX = -Infinity, maxY = -Infinity;
                
                vertices.forEach(vertex => {
                    minX = Math.min(minX, vertex.x);
                    minY = Math.min(minY, vertex.y);
                    maxX = Math.max(maxX, vertex.x);
                    maxY = Math.max(maxY, vertex.y);
                });
                
                return {
                    x: minX,
                    y: minY,
                    width: maxX - minX,
                    height: maxY - minY
                };
            }

            getEventStats() {
                return {
                    events: this.eventCount,
                    collisions: this.collisionCount,
                    falls: this.fallCount
                };
            }

            darkenColor(color, amount = 30) {
                // v9: Enhanced color darkening with configurable amount
                if (!color) return '#7F8C8D';
                
                // Convert hex to RGB and darken by specified amount
                const hex = color.replace('#', '');
                const r = Math.max(0, parseInt(hex.substr(0, 2), 16) - amount);
                const g = Math.max(0, parseInt(hex.substr(2, 2), 16) - amount);
                const b = Math.max(0, parseInt(hex.substr(4, 2), 16) - amount);
                
                return `rgb(${r}, ${g}, ${b})`;
            }

            /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
              ‚ïë CLEAR ALL SHAPES
              ‚ïë Removes all dynamic bodies (shapes) from the physics world while preserving
              ‚ïë static bodies (platform, walls). Used for level resets and shape management.
              ‚ïë Essential for providing a fresh start without recreating the entire world.
              ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
            clearAllShapes() {
                // Remove all dynamic bodies from Matter.js world
                this.dynamicBodies.forEach(body => {
                    this.World.remove(this.world, body);
                });
                this.dynamicBodies = [];
                
                // Phase 2: Clear PixiJS shapes as well
                if (PIXI_CONFIG.features.shapeRendering && this.pixiShapeRenderer.isEnabled) {
                    this.pixiShapeRenderer.clearAllShapes();
                }
                
                console.log('üßπ Cleared all shapes from playfield');
            }

            cleanup() {
                // Remove all dynamic bodies from Matter.js world
                this.dynamicBodies.forEach(body => {
                    this.World.remove(this.world, body);
                });
                this.dynamicBodies = [];
                
                // Phase 2: Clear PixiJS shapes as well
                if (PIXI_CONFIG.features.shapeRendering && this.pixiShapeRenderer.isEnabled) {
                    this.pixiShapeRenderer.clearAllShapes();
                }
                
                // Reset event counters
                this.eventCount = 0;
                this.collisionCount = 0;
                this.fallCount = 0;
                
                console.log('üßπ Matter.js physics cleanup complete');
            }
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë ENHANCED DRAG AND DROP MANAGER WITH ROTATION
          ‚ïë Task 4.2b: Adds rotation functionality during drag and drop operations
          ‚ïë Maintains existing drag & drop functionality while adding rotation controls
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        class DragDropManager {
            constructor(physicsManager, gameManager) {
                this.physicsManager = physicsManager;
                this.gameManager = gameManager;
                this.isDragging = false;
                this.draggedElement = null;
                this.draggedShapeType = null;
                this.ghostElement = null;
                
                // Touch offset configuration for mobile devices
                this.touchOffset = {
                    x: 0,      // Horizontal offset (positive = right, negative = left)
                    y: -80,    // Vertical offset (positive = down, negative = up)
                    enabled: true // Enable/disable offset system
                };
                
                // Rotation system
                this.currentRotation = 0; // Current rotation in radians
                this.rotationStep = Math.PI / 6; // 30 degrees per step
                
                // Throttling for smooth dragging - reduce jerkiness
                this.lastMoveTime = 0;
                this.moveThrottleMs = 16; // ~60fps throttling
                this.pendingMove = null;
                
                // Track if drag started from dock
                this.dragStartedFromDock = false;
                
                this.setupEventListeners();
                console.log('üñ±Ô∏è Streamlined Drag & Drop Manager with touch offset support initialized');
            }

            setupEventListeners() {
                // Mouse events - use throttled movement for smoother dragging
                document.addEventListener('mousedown', (e) => this.handlePointerDown(e));
                document.addEventListener('mousemove', (e) => this.throttledHandlePointerMove(e));
                document.addEventListener('mouseup', (e) => this.handlePointerUp(e));
                
                // Touch events for mobile support
                document.addEventListener('touchstart', (e) => this.handleTouchStart(e), { passive: false });
                document.addEventListener('touchmove', (e) => this.handleTouchMove(e), { passive: false });
                document.addEventListener('touchend', (e) => this.handleTouchEnd(e), { passive: false });
                
                // Keyboard controls
                document.addEventListener('keydown', (e) => this.handleRotationKey(e));
                
                console.log('üñ±Ô∏è Drag & Drop Manager initialized with touch support');
            }
            
            // Throttled mouse movement to reduce jerkiness
            throttledHandlePointerMove(e) {
                if (!this.isDragging) return;
                
                const now = performance.now();
                if (now - this.lastMoveTime < this.moveThrottleMs) {
                    // Store the most recent event for later processing
                    this.pendingMove = e;
                    return;
                }
                
                this.lastMoveTime = now;
                this.handlePointerMove(e);
                
                // Process any pending move after throttle delay
                if (this.pendingMove && this.pendingMove !== e) {
                    setTimeout(() => {
                        if (this.pendingMove && this.isDragging) {
                            this.handlePointerMove(this.pendingMove);
                            this.pendingMove = null;
                        }
                    }, this.moveThrottleMs);
                }
            }

            handleRotationKey(e) {
                if (!this.isDragging) return;
                
                switch(e.key) {
                    case 'r':
                    case 'R':
                    case 'ArrowRight':
                        this.rotateShape(this.rotationStep); // Rotate clockwise
                        e.preventDefault();
                        break;
                    case 'e':
                    case 'E':
                    case 'ArrowLeft':
                        this.rotateShape(-this.rotationStep); // Rotate counter-clockwise
                        e.preventDefault();
                        break;
                }
            }

            rotateShape(deltaRotation) {
                this.currentRotation += deltaRotation;
                
                // Sound effect integration point
                this.gameManager.playSound('shapeRotation');
                
                if (this.ghostElement) {
                    // Apply both scale, centering translation, and rotation to the ghost element
                    this.ghostElement.style.transform = `translate(-50%, -50%) scale(1.1) rotate(${this.currentRotation}rad)`;
                }
                
                // Update rotation indicator with current angle
                const degrees = Math.round(this.currentRotation * 180 / Math.PI);
                this.updateRotationIndicator(degrees);
                
                console.log(`üîÑ Shape rotated: ${degrees}¬∞`);
            }

            handlePointerDown(pointer) {
                const element = document.elementFromPoint(pointer.clientX, pointer.clientY);
                
                if (element && element.classList.contains('game-shape')) {
                    // Check if drag started from docking area
                    this.dragStartedFromDock = element.closest('.docking-area') !== null;
                    console.log(`üñ±Ô∏è Starting drag, from dock: ${this.dragStartedFromDock}`);
                    this.startDrag(element, pointer);
                }
            }

            startDrag(element, pointer) {
                this.isDragging = true;
                this.draggedElement = element;
                this.draggedShapeType = element.dataset.shape;
                
                // Initialize rotation based on shape type and dock settings
                if (this.draggedShapeType && this.draggedShapeType.includes('barbell')) {
                    // For barbells, preserve dock orientation setting
                    const barbellOrientationSelect = document.getElementById('barbellOrientation');
                    if (barbellOrientationSelect && barbellOrientationSelect.value === 'vertical') {
                        this.currentRotation = Math.PI / 2; // 90 degrees for vertical barbells
                        console.log(`üîÑ Starting barbell drag with vertical dock orientation (90¬∞)`);
                    } else {
                        this.currentRotation = 0; // Horizontal for barbells
                        console.log(`üîÑ Starting barbell drag with horizontal dock orientation (0¬∞)`);
                    }
                } else {
                    // For non-barbell shapes, always start at 0
                    this.currentRotation = 0;
                }
                
                // Add visual feedback with ghost effect
                element.classList.add('ghost-active');
                
                // Show rotation indicator
                this.showRotationIndicator();
                
                // Update rotation indicator with initial rotation
                this.updateRotationIndicator(Math.round(this.currentRotation * 180 / Math.PI));
                
                // Create ghost element for dragging
                this.createGhostElement(element, pointer);
                
                console.log(`üü¢ Started dragging: ${this.draggedShapeType} with initial rotation ${(this.currentRotation * 180 / Math.PI).toFixed(1)}¬∞ (R/E or ‚Üê/‚Üí to rotate)`);
            }

            createGhostElement(element, pointer) {
                // Create ghost element like Planck version - using CSS transform rotation
                this.ghostElement = this.createGhostPreview(this.draggedShapeType, 90);
                
                // Add ghost-shape class for CSS styling
                this.ghostElement.classList.add('ghost-shape');
                
                // Apply comprehensive ghost styling to prevent clipping
                this.ghostElement.style.position = 'fixed';
                this.ghostElement.style.pointerEvents = 'none';
                this.ghostElement.style.zIndex = '10000'; // Higher z-index to ensure visibility
                this.ghostElement.style.filter = 'drop-shadow(0 5px 15px rgba(0,0,0,0.3))';
                this.ghostElement.style.visibility = 'visible';
                this.ghostElement.style.opacity = '0.9';
                this.ghostElement.style.display = 'block';
                
                // Use CSS transform with consistent centering, scale, and rotation
                const initialTransform = `translate(-50%, -50%) scale(1.1) rotate(${this.currentRotation}rad)`;
                this.ghostElement.style.transform = initialTransform;
                console.log(`üëª Ghost element created with CSS rotation: ${(this.currentRotation * 180 / Math.PI).toFixed(1)}¬∞`);
                
                // Position at pointer
                this.updateGhostPosition(pointer);
                
                // Append to drag overlay instead of document.body to prevent clipping
                const dragOverlay = document.getElementById('dragOverlay');
                if (dragOverlay) {
                    dragOverlay.appendChild(this.ghostElement);
                    console.log(`üëª Ghost element created in drag overlay for ${this.draggedShapeType}`);
                } else {
                    document.body.appendChild(this.ghostElement);
                    console.log(`üëª Ghost element created in document body for ${this.draggedShapeType} (fallback)`);
                }
            }

            createGhostPreview(shapeType, size) {
                // Create canvas element for ghost preview (no rotation - handled by CSS transform)
                const canvas = document.createElement('canvas');
                canvas.width = size;
                canvas.height = size;
                canvas.className = 'shape-preview ghost-preview';
                canvas.dataset.shape = shapeType;

                const ctx = canvas.getContext('2d');
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';

                // Use same scale as dock preview for consistency  
                const scale = 1.9;
                
                // Render with no rotation - rotation handled by CSS transform like Planck version
                shapeRenderer.renderShapeOnCanvas(ctx, shapeType, size / 2, size / 2, 0, scale);
                
                console.log(`üëª Ghost preview created for: ${shapeType} with scale ${scale}, rotation handled by CSS`);
                return canvas;
            }

            // Streamlined rotation method (like Planck version)
            rotateShape(delta) {
                this.currentRotation += delta;
                if (this.ghostElement) {
                    // Update CSS transform with consistent centering, scale, and rotation
                    this.ghostElement.style.transform = `translate(-50%, -50%) scale(1.1) rotate(${this.currentRotation}rad)`;
                }
                this.updateRotationIndicator(Math.round(this.currentRotation * 180 / Math.PI));
                if (this.gameManager && this.gameManager.playSound) {
                    this.gameManager.playSound('shapeRotation');
                }
            }

            updateGhostPosition(pointer) {
                if (this.ghostElement) {
                    let x = pointer.clientX;
                    let y = pointer.clientY;
                    
                    // Apply touch offset if dragging from dock and offset is enabled
                    if (this.dragStartedFromDock && this.touchOffset.enabled) {
                        x += this.touchOffset.x;
                        y += this.touchOffset.y;
                    }
                    
                    // Set position using left/top
                    this.ghostElement.style.left = `${x}px`;
                    this.ghostElement.style.top = `${y}px`;
                    
                    // Preserve scale (1.1 during drag) and rotation with centering
                    this.ghostElement.style.transform = `translate(-50%, -50%) scale(1.1) rotate(${this.currentRotation}rad)`;
                }
            }

            handlePointerMove(pointer) {
                if (this.isDragging && this.ghostElement) {
                    // Streamlined: Only update ghost position for optimal performance
                    this.updateGhostPosition(pointer);
                }
            }

            handlePointerUp(pointer) {
                if (!this.isDragging) return;
                
                // Check if dropped in game area
                const gameCanvas = document.getElementById('gameCanvas');
                const canvasRect = gameCanvas.getBoundingClientRect();
                
                // Calculate the actual drop position from ghost element if it exists
                let dropX, dropY;
                if (this.ghostElement) {
                    // Get ghost element's center position
                    const ghostRect = this.ghostElement.getBoundingClientRect();
                    dropX = ghostRect.left + ghostRect.width / 2;
                    dropY = ghostRect.top + ghostRect.height / 2;
                } else {
                    // Fallback to pointer position
                    dropX = pointer.clientX;
                    dropY = pointer.clientY;
                }
                
                if (dropX >= canvasRect.left && 
                    dropX <= canvasRect.right &&
                    dropY >= canvasRect.top && 
                    dropY <= canvasRect.bottom) {
                    
                    // Calculate position relative to canvas using ghost position
                    const x = dropX - canvasRect.left;
                    const y = dropY - canvasRect.top;
                    
                    // Use current rotation as-is (it already includes barbell orientation from dock/ghost)
                    const totalRotation = this.currentRotation;
                    console.log(`üîÑ Physics: Using current rotation ${(totalRotation * 180 / Math.PI).toFixed(1)}¬∞ for ${this.draggedShapeType}`);
                    
                    // Log rotation for debugging
                    console.log(`üîç DEBUG: Dropping ${this.draggedShapeType} with total rotation: ${totalRotation} radians (${(totalRotation * 180 / Math.PI).toFixed(1)}¬∞)`);
                    
                    // Create physics shape at drop position with total rotation
                    this.physicsManager.createCompoundShape(x, y, this.draggedShapeType, totalRotation);
                    
                    // Update game state
                    this.gameManager.onShapePlaced(this.draggedShapeType);
                    
                    // Mark this slot as empty since shape was successfully placed
                    this.markSlotAsEmpty(this.draggedElement);
                    
                    console.log(`üéØ Shape dropped: ${this.draggedShapeType} at (${x}, ${y}) with ${(totalRotation * 180 / Math.PI).toFixed(0)}¬∞ total rotation`);
                } else {
                    // Shape was not dropped in game area, restore it to dock
                    this.restoreShapeToDock();
                    console.log(`‚Ü©Ô∏è Shape returned to dock: ${this.draggedShapeType}`);
                }
                
                this.endDrag();
            }

            markSlotAsEmpty(shapeElement) {
                // Remove the shape from dock and mark slot as empty
                const slot = shapeElement.parentElement;
                shapeElement.remove();
                slot.classList.add('empty');
                
                console.log(`üì¶ Dock slot emptied: ${this.draggedShapeType}`);
            }

            restoreShapeToDock() {
                // Restore the shape visibility in the dock
                if (this.draggedElement) {
                    this.draggedElement.style.visibility = 'visible';
                }
            }

            showRotationIndicator() {
                const indicator = document.getElementById('rotationIndicator');
                if (indicator) {
                    indicator.classList.add('show');
                }
            }

            hideRotationIndicator() {
                const indicator = document.getElementById('rotationIndicator');
                if (indicator) {
                    indicator.classList.remove('show');
                }
            }

            updateRotationIndicator(angle) {
                const indicator = document.getElementById('rotationIndicator');
                if (indicator) {
                    indicator.textContent = `üîÑ Rotation: ${angle}¬∞`;
                }
            }

            /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
              ‚ïë STREAMLINED DRAG MANAGEMENT (KEYBOARD ONLY)
              ‚ïë Removed mobile gestures and auto-rotation for optimal performance
              ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/

            // Simplified cleanup method (no auto-rotation timers to clear)
            stopMobileRotation() {
                // Keep method for compatibility, but no timers to clear
            }

            endDrag() {
                if (this.draggedElement) {
                    this.draggedElement.classList.remove('ghost-active');
                    
                    // If shape is still in dock (not removed), restore visibility
                    if (this.draggedElement.parentElement) {
                        this.draggedElement.style.visibility = 'visible';
                    }
                }
                
                if (this.ghostElement) {
                    // Remove from drag overlay if it exists, otherwise from document.body
                    const dragOverlay = document.getElementById('dragOverlay');
                    if (dragOverlay && dragOverlay.contains(this.ghostElement)) {
                        dragOverlay.removeChild(this.ghostElement);
                    } else if (this.ghostElement.parentNode) {
                        this.ghostElement.parentNode.removeChild(this.ghostElement);
                    }
                    this.ghostElement = null;
                }
                
                // Hide rotation indicator
                this.hideRotationIndicator();
                
                this.isDragging = false;
                this.draggedElement = null;
                this.draggedShapeType = null;
                this.currentRotation = 0;
                this.dragStartedFromDock = false;
            }

            // Configuration method for touch offset
            setTouchOffset(x, y, enabled = true) {
                this.touchOffset.x = x;
                this.touchOffset.y = y;
                this.touchOffset.enabled = enabled;
                console.log(`üì± Touch offset updated: x=${x}, y=${y}, enabled=${enabled}`);
            }

            // Get current touch offset settings
            getTouchOffset() {
                return { ...this.touchOffset };
            }

            // Touch event handlers for mobile support
            handleTouchStart(event) {
                if (event.touches.length !== 1) return;
                
                const touch = event.touches[0];
                
                // Add haptic feedback if supported
                if (navigator.vibrate && touch.target.closest('.game-shape')) {
                    navigator.vibrate(50); // Light haptic feedback
                }
                
                // Convert touch to mouse-like event
                const mouseEvent = new MouseEvent('mousedown', {
                    clientX: touch.clientX,
                    clientY: touch.clientY,
                    button: 0
                });
                
                this.handlePointerDown(mouseEvent);
                event.preventDefault();
            }
            
            handleTouchMove(event) {
                if (event.touches.length !== 1 || !this.isDragging) return;
                
                const touch = event.touches[0];
                
                // Convert touch to mouse-like event
                const mouseEvent = new MouseEvent('mousemove', {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
                
                this.throttledHandlePointerMove(mouseEvent);
                event.preventDefault();
            }
            
            handleTouchEnd(event) {
                if (!this.isDragging) return;
                
                const touch = event.changedTouches[0];
                
                // Light haptic feedback on drop if supported
                if (navigator.vibrate) {
                    navigator.vibrate(25); // Subtle feedback on drop
                }
                
                // Convert touch to mouse-like event
                const mouseEvent = new MouseEvent('mouseup', {
                    clientX: touch.clientX,
                    clientY: touch.clientY,
                    button: 0
                });
                
                this.handlePointerUp(mouseEvent);
                event.preventDefault();
            }
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë MOBILE ENHANCEMENT MANAGER 
          ‚ïë Adds mobile touch support and rotation zones while preserving mouse/keyboard
          ‚ïë Detects mobile devices and provides touch-optimized interactions
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        class MobileEnhancementManager {
            constructor(dragDropManager) {
                this.dragDropManager = dragDropManager;
                this.isMobileDevice = this.detectMobileDevice();
                this.touchStartTime = 0;
                this.touchThreshold = 10; // Minimum movement for drag
                this.rotationTimer = null;
                this.rotationInterval = 1000; // 1 second intervals for mobile rotation
                this.rotationIncrement = Math.PI / 4; // 45 degrees for mobile
                
                // Rotation zones
                this.rotationZones = {
                    left: {
                        element: document.getElementById('leftRotationZone'),
                        direction: -1, // CCW
                        active: false,
                        bounds: null
                    },
                    right: {
                        element: document.getElementById('rightRotationZone'), 
                        direction: 1, // CW
                        active: false,
                        bounds: null
                    }
                };
                
                if (this.isMobileDevice) {
                    this.setupTouchEnhancements();
                    console.log('üì± Mobile enhancements activated');
                } else {
                    console.log('üñ•Ô∏è Desktop mode - mobile enhancements disabled');
                }
            }
            
            detectMobileDevice() {
                return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                       (navigator.maxTouchPoints && navigator.maxTouchPoints > 2) ||
                       window.innerWidth <= 768;
            }
            
            setupTouchEnhancements() {
                // Add touch event listeners for mobile-specific rotation zone features
                document.addEventListener('touchstart', (e) => this.handleTouchStart(e), { passive: false });
                document.addEventListener('touchmove', (e) => this.handleTouchMove(e), { passive: false });
                document.addEventListener('touchend', (e) => this.handleTouchEnd(e), { passive: false });
                
                // Update rotation zone bounds
                this.updateRotationZoneBounds();
                window.addEventListener('resize', () => this.updateRotationZoneBounds());
                
                // Hook into DragDropManager to add mobile features
                this.originalStartDrag = this.dragDropManager.startDrag.bind(this.dragDropManager);
                this.dragDropManager.startDrag = (element, event) => {
                    this.originalStartDrag(element, event);
                    this.showRotationZones();
                };
                
                this.originalEndDrag = this.dragDropManager.endDrag.bind(this.dragDropManager);
                this.dragDropManager.endDrag = () => {
                    this.hideRotationZones();
                    this.stopRotationTimer();
                    this.originalEndDrag();
                };
            }
            
            // Enable mouse events for debugging on desktop
            enableMouseSupport() {
                if (this.mouseEventsAdded) return;
                
                // Hook into DragDropManager mouse events for rotation zones
                const originalHandlePointerMove = this.dragDropManager.handlePointerMove.bind(this.dragDropManager);
                this.dragDropManager.handlePointerMove = (event) => {
                    originalHandlePointerMove(event);
                    
                    // Check rotation zones if dragging
                    if (this.dragDropManager.isDragging && this.isMobileDevice) {
                        this.checkRotationZones(event.clientX, event.clientY);
                    }
                };
                
                this.mouseEventsAdded = true;
                console.log('üñ±Ô∏è Mouse support enabled for rotation zones');
            }
            
            disableMouseSupport() {
                // Note: This would require storing original methods to restore them
                // For now, we'll just flag that mouse support was added
                this.mouseEventsAdded = false;
                console.log('üñ±Ô∏è Mouse support disabled for rotation zones');
            }
            
            updateRotationZoneBounds() {
                const canvas = document.getElementById('gameCanvas');
                const canvasRect = canvas.getBoundingClientRect();
                
                this.rotationZones.left.bounds = {
                    left: canvasRect.left,
                    right: canvasRect.left + 80,
                    top: canvasRect.top,
                    bottom: canvasRect.bottom
                };
                
                this.rotationZones.right.bounds = {
                    left: canvasRect.right - 80,
                    right: canvasRect.right,
                    top: canvasRect.top,
                    bottom: canvasRect.bottom
                };
            }
            
            handleTouchStart(event) {
                if (event.touches.length !== 1) return;
                
                const touch = event.touches[0];
                const element = document.elementFromPoint(touch.clientX, touch.clientY);
                
                // Only handle rotation zones here - let DragDropManager handle shape dragging
                this.checkRotationZones(touch.clientX, touch.clientY);
                
                this.touchStartTime = Date.now();
            }
            
            handleTouchMove(event) {
                if (!this.dragDropManager.isDragging) return;
                if (event.touches.length !== 1) return;
                
                const touch = event.touches[0];
                
                // Check rotation zones with haptic feedback
                const wasInZone = this.currentRotationZone;
                this.checkRotationZones(touch.clientX, touch.clientY);
                
                // Haptic feedback when entering rotation zone
                if (this.currentRotationZone && !wasInZone && navigator.vibrate) {
                    navigator.vibrate(30); // Light feedback when entering rotation zone
                }
                
                event.preventDefault();
            }

            handleTouchEnd(event) {
                // Rotation handling on touch end
                if (this.currentRotationZone && this.dragDropManager.isDragging) {
                    const rotationDirection = this.currentRotationZone === 'left' ? -1 : 1;
                    this.dragDropManager.rotateShape(rotationDirection * this.dragDropManager.rotationStep);
                    
                    // Stronger haptic feedback for rotation
                    if (navigator.vibrate) {
                        navigator.vibrate([50, 50, 50]); // Pattern for rotation feedback
                    }
                }
                
                this.hideRotationZones();
                this.stopRotationTimer();
                this.currentRotationZone = null;
                
                event.preventDefault();
            }            checkRotationZones(x, y) {
                let inZone = null;
                
                // Debug logging
                console.log(`üìç Checking rotation zones at (${x}, ${y})`);
                
                // Check left zone
                if (this.isPointInZone(x, y, this.rotationZones.left.bounds)) {
                    inZone = 'left';
                    console.log('üìç In LEFT rotation zone');
                }
                // Check right zone
                else if (this.isPointInZone(x, y, this.rotationZones.right.bounds)) {
                    inZone = 'right';
                    console.log('üìç In RIGHT rotation zone');
                }
                
                // Handle zone entry/exit
                if (inZone && !this.rotationZones[inZone].active) {
                    this.enterRotationZone(inZone);
                } else if (!inZone) {
                    this.exitAllRotationZones();
                }
            }
            
            isPointInZone(x, y, bounds) {
                return bounds && x >= bounds.left && x <= bounds.right && 
                       y >= bounds.top && y <= bounds.bottom;
            }
            
            enterRotationZone(zoneName) {
                const zone = this.rotationZones[zoneName];
                if (!zone || !zone.element) return;
                
                // Exit other zones first
                this.exitAllRotationZones();
                
                // Activate this zone
                zone.active = true;
                zone.element.classList.add('active');
                
                // Start rotation timer
                this.rotationTimer = setInterval(() => {
                    if (this.dragDropManager.isDragging) {
                        this.dragDropManager.currentRotation += zone.direction * this.rotationIncrement;
                        
                        // Update ghost element rotation
                        if (this.dragDropManager.ghostElement) {
                            this.dragDropManager.ghostElement.style.transform = 
                                `translate(-50%, -50%) scale(1.1) rotate(${this.dragDropManager.currentRotation}rad)`;
                        }
                        
                        // Haptic feedback
                        this.playHapticFeedback();
                    }
                }, this.rotationInterval);
                
                console.log(`üì± Entered ${zoneName} rotation zone`);
            }
            
            exitAllRotationZones() {
                Object.keys(this.rotationZones).forEach(zoneName => {
                    const zone = this.rotationZones[zoneName];
                    if (zone.active && zone.element) {
                        zone.active = false;
                        zone.element.classList.remove('active');
                    }
                });
                
                this.stopRotationTimer();
            }
            
            stopRotationTimer() {
                if (this.rotationTimer) {
                    clearInterval(this.rotationTimer);
                    this.rotationTimer = null;
                }
            }
            
            showRotationZones() {
                if (!this.isMobileDevice) return;
                
                Object.values(this.rotationZones).forEach(zone => {
                    if (zone.element) {
                        zone.element.classList.add('visible');
                    }
                });
            }
            
            hideRotationZones() {
                Object.values(this.rotationZones).forEach(zone => {
                    if (zone.element) {
                        zone.element.classList.remove('visible', 'active');
                    }
                });
            }
            
            playHapticFeedback() {
                if (navigator.vibrate) {
                    navigator.vibrate(50); // Short vibration
                }
            }
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë ENHANCED GAME STATE WITH END-LEVEL COUNTDOWN
          ‚ïë Task 4.2c: Implements end-level countdown timer and level failure conditions
          ‚ïë Level fails if any piece falls off screen before countdown expires
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        class GameState {
            constructor() {
                this.shapes = [];
                this.placedShapes = [];
                this.isGameActive = true;
                this.isCountdownActive = false;
                this.countdownTime = 3;
                
                // HUD State
                this.level = 1;
                this.score = 0;
                this.coins = 0;
                this.progress = 0; // 0-100%
                
                // Timer System
                this.timerMode = 'elapsed'; // 'elapsed', 'countdown', 'endlevel'
                this.gameTime = 0; // Elapsed seconds
                this.endLevelTime = currentLevelConfig.endLevelDuration; // End level countdown duration from config
                this.endLevelDots = 0;
                
                // Physics Event Tracking
                this.shapeCollisions = 0;
                this.platformLandings = 0;
                this.shapeFalls = 0;
                this.stability = 100; // Stability percentage
                
                // End-Level State
                this.endLevelStarted = false;
                this.levelFailed = false;
                this.levelCompleted = false;
            }

            startEndLevelCountdown() {
                this.endLevelStarted = true;
                this.timerMode = 'endlevel';
                this.endLevelTime = currentLevelConfig.endLevelDuration; // Use configured duration
                this.isCountdownActive = true;
                
                console.log(`‚è∞ End-level countdown started: ${currentLevelConfig.endLevelDuration} seconds`);
            }

            checkLevelFailure() {
                // Level fails if any shape falls during end-level countdown
                if (this.endLevelStarted && !this.levelCompleted && this.shapeFalls > 0) {
                    this.levelFailed = true;
                    this.isGameActive = false;
                    return true;
                }
                return false;
            }

            resetLevel() {
                this.shapes = [];
                this.placedShapes = [];
                this.isGameActive = true;
                this.isCountdownActive = false;
                this.countdownTime = 3;
                this.gameTime = 0;
                this.timerMode = 'elapsed';
                this.endLevelTime = currentLevelConfig.endLevelDuration;
                this.endLevelDots = 0;
                
                // Reset score and coins to zero for fresh start
                this.score = 0;
                this.coins = 0;
                this.progress = 0;
                
                // Reset physics event tracking
                this.shapeCollisions = 0;
                this.platformLandings = 0;
                this.shapeFalls = 0;
                this.stability = 100;
                
                // Reset end-level state
                this.endLevelStarted = false;
                this.levelFailed = false;
                this.levelCompleted = false;
                
                console.log('üîÑ Game state reset for new level');
            }

            addPlacedShape(shapeType) {
                this.placedShapes.push({
                    type: shapeType,
                    timestamp: Date.now()
                });
                
                const totalShapes = currentLevelConfig.dockShapes.length;
                console.log(`üìä Shape placed: ${shapeType} (${this.placedShapes.length}/${totalShapes})`);
            }

            recordPhysicsEvent(eventType) {
                switch(eventType) {
                    case 'collision':
                        this.shapeCollisions++;
                        break;
                    case 'landing':
                        this.platformLandings++;
                        break;
                    case 'fall':
                        this.shapeFalls++;
                        this.stability = Math.max(0, this.stability - 10); // Reduce stability on falls
                        
                        // Check if this fall causes level failure
                        if (this.checkLevelFailure()) {
                            console.log('üí• LEVEL FAILED: Shape fell during end-level countdown!');
                        }
                        break;
                }
            }
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë ENHANCED GAME MANAGER WITH PHYSICS EVENT INTEGRATION
          ‚ïë Phase 4.1: Integrates physics events with game logic and UI updates
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        class GameManager {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.physicsManager = new PhysicsManager(this.canvas);
                this.gameState = new GameState();
                this.dragDropManager = new DragDropManager(this.physicsManager, this);
                this.mobileEnhancementManager = new MobileEnhancementManager(this.dragDropManager);
                
                // v9: Canvas Enhancement System
                this.themeManager = new ThemeManager(this.physicsManager.assetManager, this);
                
                // Level management (Super Mario Bros style)
                this.currentWorld = 1;
                this.currentLevel = 1;
                
                // Make this globally available for physics events
                window.gameManager = this;
                
                this.setupUI();
                this.setupEventListeners();
                
                console.log('üéÆ Enhanced Game Manager with Physics Events initialized');
            }

            setupUI() {
                // Initialize HUD displays
                this.updateScoreDisplay();
                this.updateCoinDisplay();
                this.updateLevelDisplay();
                this.updateStars(0);
                this.updateDebugInfo();
                
                // Initialize HUD timer system
                this.timerInterval = setInterval(() => this.updateTimer(), 1000);
                
                // Event listeners are handled by onclick in HTML - no need for duplicate listener
                console.log('üéÆ GameManager initialized with unified reset system');
            }

            setupEventListeners() {
                // Keyboard controls for testing (fallback)
                document.addEventListener('keydown', (e) => {
                    if (!this.gameState.isGameActive) return;
                    
                    const centerX = this.canvas.width / 2;
                    const dropY = 100;
                    
                    switch(e.key) {
                        case '1':
                            this.physicsManager.createShape(centerX, dropY, 'square');
                            this.onShapePlaced('square');
                            break;
                        case '2':
                            this.physicsManager.createShape(centerX, dropY, 'triangle');
                            this.onShapePlaced('triangle');
                            break;
                        case '3':
                            this.physicsManager.createShape(centerX, dropY, 'circle');
                            this.onShapePlaced('circle');
                            break;
                        case '4':
                            this.physicsManager.createShape(centerX, dropY, 'cross2');
                            this.onShapePlaced('cross2');
                            break;
                        case '5':
                            this.physicsManager.createShape(centerX, dropY, 'l');
                            this.onShapePlaced('l');
                            break;
                        case '6':
                            this.physicsManager.createShape(centerX, dropY, 'cross');
                            this.onShapePlaced('cross');
                            break;
                        case '7':
                            this.physicsManager.createShape(centerX, dropY, 'barbell-one');
                            this.onShapePlaced('barbell-one');
                            break;
                        case '8':
                            this.physicsManager.createShape(centerX, dropY, 'barbell-two');
                            this.onShapePlaced('barbell-two');
                            break;
                        case '9':
                            this.physicsManager.createShape(centerX, dropY, 'diamond-barbell');
                            this.onShapePlaced('diamond-barbell');
                            break;
                    }
                });
            }

            // UI Update Methods
            updateScoreDisplay() {
                const scoreElement = document.getElementById('scoreText');
                if (scoreElement) {
                    scoreElement.textContent = this.gameState.score.toLocaleString();
                    
                    // Add animation for score increase
                    scoreElement.classList.add('score-increase');
                    setTimeout(() => {
                        scoreElement.classList.remove('score-increase');
                    }, 600);
                }
            }

            updateCoinDisplay() {
                const coinElement = document.getElementById('coinAmount');
                if (coinElement) {
                    coinElement.textContent = this.gameState.coins.toString();
                    
                    // Add animation for coin increase
                    coinElement.classList.add('coin-increase');
                    setTimeout(() => {
                        coinElement.classList.remove('coin-increase');
                    }, 600);
                }
            }

            updateLevelDisplay() {
                const levelElement = document.getElementById('levelDisplay');
                if (levelElement) {
                    levelElement.textContent = `World ${this.currentWorld}-${this.currentLevel}`;
                }
            }

            // Level progression methods
            nextLevel() {
                this.currentLevel++;
                this.updateLevelDisplay();
                console.log(`üèÅ Advanced to World ${this.currentWorld}-${this.currentLevel}`);
            }

            nextWorld() {
                this.currentWorld++;
                this.currentLevel = 1;
                this.updateLevelDisplay();
                console.log(`üåç Advanced to World ${this.currentWorld}-${this.currentLevel}`);
            }

            setLevel(world, level) {
                this.currentWorld = world;
                this.currentLevel = level;
                this.updateLevelDisplay();
                console.log(`üìç Set level to World ${this.currentWorld}-${this.currentLevel}`);
            }

            // Physics Event Handlers
            onShapeLandedOnPlatform() {
                console.log('üéØ GameManager: Shape landed on platform - triggering camera shake!');
                this.gameState.recordPhysicsEvent('landing');
                
                // Track consecutive landings for streak bonuses
                this.gameState.consecutiveLandings = (this.gameState.consecutiveLandings || 0) + 1;
                this.gameState.lastAction = 'landing';
                
                // Base rewards
                let scoreBonus = 50;
                let coinBonus = 1;
                
                // Streak multipliers
                if (this.gameState.consecutiveLandings >= 5) {
                    coinBonus += 5; // +5 coins for 5+ streak
                    scoreBonus += 100;
                    this.createCoinShower('LANDING MASTER!', 5);
                } else if (this.gameState.consecutiveLandings >= 3) {
                    coinBonus += 2; // +2 coins for 3+ streak
                    scoreBonus += 50;
                    this.createFloatingText(`üî• ${this.gameState.consecutiveLandings}x STREAK!`, 
                        document.getElementById('coinAmount'), '#FF6B35');
                }
                
                this.gameState.score += scoreBonus;
                this.gameState.coins += coinBonus;
                this.updateScoreDisplay();
                this.updateCoinDisplay();
                
                // Sound effect integration point
                this.playSound('shapeLanding');
                
                // Create enhanced particle effects
                if (this.physicsManager && this.physicsManager.particleSystem) {
                    const canvasRect = this.physicsManager.canvas.getBoundingClientRect();
                    const platformY = canvasRect.height * 0.85;
                    const x = Math.random() * canvasRect.width * 0.6 + canvasRect.width * 0.2;
                    const particleCount = Math.min(12 + this.gameState.consecutiveLandings * 2, 24);
                    this.physicsManager.particleSystem.createThemeParticles('landing', x, platformY, particleCount);
                }
                
                // Enhanced visual feedback
                const scoreElement = document.getElementById('scoreText');
                const coinElement = document.getElementById('coinAmount');
                
                this.createFloatingText(`+${scoreBonus}`, scoreElement, '#10B981');
                this.createFloatingText(`+${coinBonus}`, coinElement, '#FFD700');
                
                // Extra visual effects for big bonuses
                if (coinBonus > 3) {
                    this.createFloatingText('üí∞üí∞üí∞', coinElement, '#FFD700');
                    this.pulseElement(coinElement, 3);
                }
                
                console.log(`üéØ Landing streak: ${this.gameState.consecutiveLandings}, Coins: +${coinBonus}`);
            }

            onShapeCollision() {
                console.log('üîÑ GameManager: Shape collision - triggering camera shake!');
                this.gameState.recordPhysicsEvent('collision');
                
                // Reset landing streak on collision
                this.gameState.consecutiveLandings = 0;
                
                // Track collision chains for bonus coins
                this.gameState.recentCollisions = (this.gameState.recentCollisions || 0) + 1;
                
                // Base rewards
                let scoreBonus = 25;
                let coinBonus = 0;
                
                // Collision-based coin rewards
                if (this.gameState.recentCollisions % 1 === 0) { // Every collision now gives coins!
                    coinBonus = 1;
                    
                    // Bonus for rapid collisions
                    if (this.gameState.recentCollisions >= 3) {
                        coinBonus += 2; // +2 extra for collision chains
                        scoreBonus += 25;
                        this.createFloatingText('üí• CHAIN REACTION!', document.getElementById('scoreText'), '#FF6B35');
                    }
                }
                
                // Random coin jackpots (5% chance)
                if (Math.random() < 0.05) {
                    const jackpot = Math.floor(Math.random() * 10) + 5; // 5-14 coins
                    coinBonus += jackpot;
                    this.createCoinShower('JACKPOT!', jackpot);
                    
                    // Small celebratory shake for big jackpots
                    if (jackpot >= 10 && this.physicsManager) {
                        this.physicsManager.startCameraShake(4, 300);
                    }
                }
                
                this.gameState.score += scoreBonus;
                this.gameState.coins += coinBonus;
                
                // Sound effect integration point
                this.playSound('shapeCollision');
                
                // Create enhanced particle effects
                if (this.physicsManager && this.physicsManager.particleSystem) {
                    const canvasRect = this.physicsManager.canvas.getBoundingClientRect();
                    const x = Math.random() * canvasRect.width * 0.8 + canvasRect.width * 0.1;
                    const y = Math.random() * canvasRect.height * 0.6 + canvasRect.height * 0.2;
                    const particleCount = Math.min(8 + this.gameState.recentCollisions, 20);
                    this.physicsManager.particleSystem.createThemeParticles('collision', x, y, particleCount);
                }
                
                this.updateScoreDisplay();
                if (coinBonus > 0) {
                    this.updateCoinDisplay();
                    const coinElement = document.getElementById('coinAmount');
                    this.createFloatingText(`+${coinBonus}`, coinElement, '#FFD700');
                }
                
                // Add visual feedback for collision bonuses
                const scoreElement = document.getElementById('scoreText');
                this.createFloatingText(`+${scoreBonus}`, scoreElement, '#4ECDC4');
                
                // Reset collision counter after a pause
                setTimeout(() => {
                    if (this.gameState.lastAction !== 'collision') {
                        this.gameState.recentCollisions = 0;
                    }
                }, 2000);
                
                this.gameState.lastAction = 'collision';
                
                console.log(`üîÑ Collision chain: ${this.gameState.recentCollisions}, Coins: +${coinBonus}`);
            }

            onShapeFell() {
                console.log('üí• GameManager: Shape fell - triggering camera shake!');
                this.gameState.recordPhysicsEvent('fall');
                
                // Track fall time for stability bonuses
                this.gameState.lastFallTime = Date.now();
                
                // Reset all streaks on fall
                this.gameState.consecutiveLandings = 0;
                this.gameState.recentCollisions = 0;
                
                // Dramatic penalties based on current coin count
                let scorePenalty = 100;
                let coinPenalty = 3; // Increased base penalty
                
                // Scale penalties with current wealth (more coins = bigger penalty)
                if (this.gameState.coins >= 50) {
                    coinPenalty += 7; // -10 coins total for wealthy players
                    scorePenalty += 200;
                    this.createFloatingText('üí∏ MAJOR LOSS!', document.getElementById('coinAmount'), '#FF4444');
                } else if (this.gameState.coins >= 20) {
                    coinPenalty += 2; // -5 coins total
                    scorePenalty += 100;
                }
                
                // Apply penalties with minimums
                this.gameState.score = Math.max(0, this.gameState.score - scorePenalty);
                this.gameState.coins = Math.max(0, this.gameState.coins - coinPenalty);
                
                this.updateScoreDisplay();
                this.updateCoinDisplay();
                
                // Dramatic visual effects
                const coinElement = document.getElementById('coinAmount');
                const scoreElement = document.getElementById('scoreText');
                
                this.createFloatingText(`-${coinPenalty}`, coinElement, '#FF6B6B');
                this.createFloatingText(`-${scorePenalty}`, scoreElement, '#FF6B6B');
                
                // Shake effect for major losses
                if (coinPenalty >= 5) {
                    this.shakeElement(coinElement, 5);
                    this.createFloatingText('üíÄüíÄÔøΩ', coinElement, '#FF4444');
                }
                
                // Camera shake effect for dramatic falls - RANDOM INTENSITY
                const randomIntensity = Math.floor(Math.random() * 10) + 10; // Random 10-19 intensity
                const duration = 800;
                console.log(`üî• ATTEMPTING CAMERA SHAKE: intensity=${randomIntensity}, duration=${duration}ms`);
                
                if (this.physicsManager) {
                    console.log('‚úÖ PhysicsManager found, calling startCameraShake...');
                    this.physicsManager.startCameraShake(randomIntensity, duration);
                } else {
                    console.log('‚ùå PhysicsManager not found!');
                }
                
                // Sound effect integration point
                this.playSound('shapeFall');
                
                console.log(`üí• FALL PENALTY: -${coinPenalty} coins, -${scorePenalty} points`);
                
                // Check if level failed due to fall during countdown
                if (this.gameState.levelFailed) {
                    this.onLevelFailed();
                    return;
                }
                
                // Check if this should trigger game over (outside of end-level countdown)
                if (!this.gameState.endLevelStarted && this.gameState.shapeFalls >= 3) {
                    this.onGameOver();
                }
            }

            onShapePlaced(shapeType) {
                this.gameState.addPlacedShape(shapeType);
                this.updateDebugInfo();
                
                // Update score
                this.gameState.score += 100;
                document.getElementById('scoreText').textContent = this.gameState.score.toLocaleString();
                
                // Update progress bar using current dock configuration
                const totalShapes = currentLevelConfig.dockShapes.length;
                const progress = (this.gameState.placedShapes.length / totalShapes) * 100;
                document.getElementById('starProgressBar').style.width = progress + '%';
                
                // Update stars based on progress
                this.updateStars(this.gameState.placedShapes.length);
                
                // Check for level completion (start end-level countdown)
                if (this.gameState.placedShapes.length >= totalShapes) {
                    console.log(`üéØ All ${totalShapes} shapes placed! Starting end-level countdown...`);
                    
                    // Coin reward for successfully placing all shapes
                    this.gameState.coins += 5;
                    this.updateCoinDisplay();
                    
                    // Show coin reward particle
                    const coinElement = document.getElementById('coinAmount');
                    this.createFloatingText('+5 All Shapes!', coinElement, '#FFD700');
                    
                    this.gameState.startEndLevelCountdown();
                    this.physicsManager.showEventNotification('End-Level Countdown!', 'balance');
                }
            }

            updateStars(shapesPlaced) {
                const stars = document.querySelectorAll('.star');
                const totalShapes = currentLevelConfig.dockShapes.length;
                const progressPercent = (shapesPlaced / totalShapes) * 100;
                
                // Star thresholds: 33.33%, 66.66%, 100%
                const starThresholds = [33.33, 66.66, 100];
                
                stars.forEach((star, index) => {
                    const threshold = starThresholds[index];
                    const shouldBeFilled = progressPercent >= threshold;
                    
                    if (shouldBeFilled && !star.classList.contains('filled')) {
                        // Star should be filled and isn't yet
                        const wasEmpty = !star.classList.contains('filled');
                        star.classList.add('filled');
                        
                        // Add particle effect for newly filled star
                        if (wasEmpty) {
                            setTimeout(() => {
                                this.createFloatingText('‚≠ê', star, '#FFD700');
                            }, 100);
                        }
                    } else if (!shouldBeFilled && star.classList.contains('filled')) {
                        // Star should not be filled but is
                        star.classList.remove('filled');
                    }
                });
                
                // Update progress bar with animation using current dock configuration
                const progressBar = document.getElementById('starProgressBar');
                
                // Smooth progress bar animation
                progressBar.style.transition = 'width 0.5s ease-out';
                progressBar.style.width = progressPercent + '%';
                
                if (shapesPlaced > 0) {
                    this.animateProgressBar(progressBar);
                }
            }

            updateTimer() {
                if (!this.gameState.isGameActive) return;
                
                const timerElement = document.getElementById('gameTimer');
                
                switch(this.gameState.timerMode) {
                    case 'elapsed':
                        this.updateElapsedTimer(timerElement);
                        break;
                    case 'countdown':
                        this.updateCountdownTimer(timerElement);
                        break;
                    case 'endlevel':
                        this.updateEndLevelTimer(timerElement);
                        break;
                }
            }

            updateElapsedTimer(element) {
                const minutes = Math.floor(this.gameState.gameTime / 60);
                const seconds = this.gameState.gameTime % 60;
                element.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                this.gameState.gameTime++;
                
                // Remove any warning classes
                element.classList.remove('timer-warning', 'timer-critical');
            }

            updateCountdownTimer(element) {
                // Use gameTime for countdown timer (starts from configured time and counts down)
                const minutes = Math.floor(this.gameState.gameTime / 60);
                const seconds = this.gameState.gameTime % 60;
                element.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                
                // Remove previous warning classes
                element.classList.remove('timer-warning', 'timer-critical');
                
                // Add warning effects based on time remaining
                if (this.gameState.gameTime <= 5 && this.gameState.gameTime > 0) {
                    element.classList.add('timer-critical');
                } else if (this.gameState.gameTime <= 10) {
                    element.classList.add('timer-warning');
                }
                
                // Countdown: decrease time
                this.gameState.gameTime--;
                
                // Check if countdown reached zero
                if (this.gameState.gameTime < 0) {
                    this.gameState.gameTime = 0; // Prevent negative display
                    element.textContent = '0:00';
                    
                    // Trigger game over due to time up
                    console.log('‚è∞ Countdown timer reached zero - Game Over!');
                    this.onGameTimeUp();
                }
            }

            updateEndLevelTimer(element) {
                // Create 3-dot display if it doesn't exist
                if (!element.querySelector('.countdown-dots')) {
                    console.log('üî¥ Creating dramatic 3-dot countdown display...');
                    element.innerHTML = '';
                    const dotsContainer = document.createElement('div');
                    dotsContainer.className = 'countdown-dots';
                    
                    for (let i = 0; i < 3; i++) {
                        const dot = document.createElement('div');
                        dot.className = 'countdown-dot';
                        dot.id = `countdown-dot-${i}`;
                        dotsContainer.appendChild(dot);
                    }
                    
                    element.appendChild(dotsContainer);
                    this.gameState.endLevelDots = 0;
                    console.log('‚úÖ 3-dot countdown display created!');
                }
                
                // Update dots based on time remaining using configured duration
                const totalDuration = currentLevelConfig.endLevelDuration;
                const timeElapsed = totalDuration - this.gameState.endLevelTime;
                const dotsToShow = Math.min(3, Math.ceil((timeElapsed / totalDuration) * 3));
                console.log(`üîµ Updating dots: ${dotsToShow} active dots, ${this.gameState.endLevelTime}s remaining (total: ${totalDuration}s)`);
                
                for (let i = 0; i < 3; i++) {
                    const dot = document.getElementById(`countdown-dot-${i}`);
                    if (dot) {
                        if (i < dotsToShow) {
                            if (i === dotsToShow - 1 && this.gameState.endLevelTime > 0) {
                                dot.className = 'countdown-dot active';
                            } else {
                                dot.className = 'countdown-dot completed';
                            }
                        } else {
                            dot.className = 'countdown-dot';
                        }
                    }
                }
                
                this.gameState.endLevelTime--;
                
                if (this.gameState.endLevelTime < 0) {
                    console.log('üèÜ End level countdown complete! Level finished!');
                    this.triggerLevelCompleteEffects();
                    this.onLevelComplete();
                }
            }

            updateDebugInfo() {
                const debugInfo = document.getElementById('debugInfo');
                const physicsStats = this.physicsManager.getEventStats();
                const totalShapes = currentLevelConfig.dockShapes.length;
                
                // Fix #4: Count available shapes properly - shapes that are visible and not being dragged
                const availableShapes = document.querySelectorAll('.game-shape:not(.dragging)').length;
                
                debugInfo.textContent = `Placed: ${this.gameState.placedShapes.length}/${totalShapes} | Dock: ${availableShapes}/${totalShapes} | Events: ${physicsStats.events} | FPS: 60`;
            }

            onGameTimeUp() {
                this.gameState.isGameActive = false;
                console.log('‚è∞ Time Up! Level Failed!');
            }

            onGameOver() {
                this.gameState.isGameActive = false;
                console.log('üíÄ Game Over! Too many shapes fell.');
            }

            /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
              ‚ïë SHOW LEVEL CLEARED POPUP
              ‚ïë Displays a celebratory popup modal when the level is successfully cleared.
              ‚ïë Includes animated title, stars, and button to continue or replay level.
              ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
            showLevelClearedPopup() {
                // Create modal overlay
                const modal = document.createElement('div');
                modal.className = 'level-cleared-modal';
                modal.id = 'levelClearedModal';
                
                // Create modal content
                const content = document.createElement('div');
                content.className = 'level-cleared-content';
                
                // Title
                const title = document.createElement('div');
                title.className = 'level-cleared-title';
                title.textContent = 'Level Cleared!';
                
                // Subtitle with score info
                const subtitle = document.createElement('div');
                subtitle.className = 'level-cleared-subtitle';
                subtitle.textContent = `Score: ${this.gameState.score} | Coins: ${this.gameState.coins}`;
                
                // Animated stars
                const stars = document.createElement('div');
                stars.className = 'level-cleared-stars';
                stars.textContent = '‚≠ê ‚≠ê ‚≠ê';
                
                // Continue button
                const continueBtn = document.createElement('button');
                continueBtn.className = 'level-cleared-button';
                continueBtn.textContent = 'Continue';
                continueBtn.onclick = () => this.closeLevelClearedPopup();
                
                // Replay button
                const replayBtn = document.createElement('button');
                replayBtn.className = 'level-cleared-button';
                replayBtn.textContent = 'Replay Level';
                replayBtn.style.background = 'linear-gradient(135deg, #2196F3 0%, #1976D2 100%)';
                replayBtn.onclick = () => {
                    this.closeLevelClearedPopup();
                    resetLevel();
                };
                
                // Assemble modal
                content.appendChild(title);
                content.appendChild(subtitle);
                content.appendChild(stars);
                content.appendChild(continueBtn);
                content.appendChild(replayBtn);
                modal.appendChild(content);
                
                // Add to page
                document.body.appendChild(modal);
                
                console.log('üéâ Level Cleared popup displayed!');
            }

            closeLevelClearedPopup() {
                const modal = document.getElementById('levelClearedModal');
                if (modal) {
                    modal.style.animation = 'modalFadeIn 0.3s ease-out reverse';
                    setTimeout(() => {
                        modal.remove();
                    }, 300);
                }
            }

            /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
              ‚ïë TRIGGER LEVEL COMPLETE EFFECTS
              ‚ïë Creates spectacular visual effects when level is completed successfully.
              ‚ïë Includes cascading star effects, screen flash, and celebration particles.
              ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
            triggerLevelCompleteEffects() {
                // Flash effect for completion
                const screen = document.querySelector('.screen');
                screen.style.animation = 'levelCompleteFlash 1s ease-out';
                setTimeout(() => {
                    screen.style.animation = '';
                }, 1000);
                
                // Cascade star effects
                const stars = document.querySelectorAll('.star');
                stars.forEach((star, index) => {
                    setTimeout(() => {
                        star.style.animation = 'starBurst 0.8s ease-out';
                        this.createFloatingText('‚òÖ', star, '#FFD700');
                    }, index * 150);
                });
                
                // Multiple celebration particles
                setTimeout(() => {
                    const scoreElement = document.getElementById('scoreText');
                    const coinElement = document.getElementById('coinAmount');
                    
                    this.createFloatingText('üéâ', scoreElement, '#FF6B6B');
                    this.createFloatingText('üéä', coinElement, '#4ECDC4');
                    
                    setTimeout(() => {
                        this.createFloatingText('üèÜ', scoreElement, '#FFD700');
                    }, 300);
                }, 500);
            }

            onLevelComplete() {
                this.gameState.isGameActive = false;
                this.gameState.levelCompleted = true;
                console.log('üéØ Level Complete! Score: ' + this.gameState.score);
                
                // Sound effect integration point
                this.playSound('levelComplete');
                
                // Bonus points for completion with particle effects
                this.gameState.score += 500;
                this.gameState.coins += 25; // Increased completion bonus
                
                // Show Level Cleared popup immediately
                this.showLevelClearedPopup();
                
                // Advance to next level after a delay
                setTimeout(() => {
                    this.nextLevel();
                }, 3000); // Increased delay to account for popup
                
                // Create floating text for completion bonus
                const scoreElement = document.getElementById('scoreText');
                this.createFloatingText('+500', scoreElement, '#FFD700');
                
                const coinElement = document.getElementById('coinAmount');
                this.createFloatingText('+25 Complete!', coinElement, '#4ECDC4');
                
                // Stability bonus
                const stabilityBonus = Math.floor(this.gameState.stability * 2);
                this.gameState.score += stabilityBonus;
                
                // Stability coin bonus for high stability (80%+)
                if (this.gameState.stability >= 80) {
                    const coinBonus = Math.floor(this.gameState.stability / 10);
                    this.gameState.coins += coinBonus;
                    
                    setTimeout(() => {
                        this.createFloatingText(`+${coinBonus} Stability`, coinElement, '#10B981');
                    }, 750);
                }
                
                if (stabilityBonus > 0) {
                    setTimeout(() => {
                        this.createFloatingText(`+${stabilityBonus} Stability`, scoreElement, '#10B981');
                    }, 500);
                }
                
                // Update display
                this.updateScoreDisplay();
                this.updateCoinDisplay();
                
                // All stars should be filled with animation
                this.updateStars(3);
                const progressBar = document.getElementById('starProgressBar');
                this.animateProgressBar(progressBar);
                
                this.physicsManager.showEventNotification('Level Complete!', 'collision');
            }

            onLevelFailed() {
                this.gameState.isGameActive = false;
                console.log('üíÄ Level Failed! Shape fell during countdown.');
                this.physicsManager.showEventNotification('Level Failed!', 'fall');
            }

            resetLevel() {
                console.log('üîÑ Resetting level...');
                
                // Clear all dynamic physics bodies
                this.physicsManager.cleanup();
                
                // Recreate the platform and boundaries
                this.physicsManager.createPlatform();
                this.physicsManager.createBoundaries();
                
                // Reset game state
                this.gameState.resetLevel();
                
                // Restore all shapes to docking area
                this.restoreAllShapesToDock();
                
                // Reset HUD to initial values
                this.updateScoreDisplay();
                this.updateCoinDisplay();
                document.getElementById('starProgressBar').style.width = '0%';
                document.getElementById('gameTimer').textContent = '0:00';
                
                // Reset timer mode to elapsed
                const modeIndicator = document.getElementById('timerModeIndicator');
                modeIndicator.className = 'timer-mode-indicator timer-mode-elapsed';
                modeIndicator.textContent = '‚è±';
                
                // Reset all stars
                document.querySelectorAll('.star').forEach(star => {
                    star.classList.remove('filled');
                });
                
                // Update debug info
                this.updateDebugInfo();
                
                console.log('‚úÖ Level reset complete');
            }

            /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
              ‚ïë CREATE FLOATING TEXT PARTICLE
              ‚ïë Generates animated floating text particles for visual feedback. Creates
              ‚ïë temporary DOM elements positioned relative to target elements that float
              ‚ïë upward and fade out. Used for score/coin increase notifications.
              ‚ïë Parameters: text - Text to display, element - Reference element, color - Text color
              ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
            createFloatingText(text, element, color = '#FFD700') {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.textContent = text;
                particle.style.color = color;
                
                const rect = element.getBoundingClientRect();
                particle.style.left = (rect.left + rect.width / 2) + 'px';
                particle.style.top = rect.top + 'px';
                
                document.body.appendChild(particle);
                
                setTimeout(() => {
                    if (particle.parentNode) {
                        document.body.removeChild(particle);
                    }
                }, 2000);
            }

            /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
              ‚ïë CREATE COIN SHOWER EFFECT
              ‚ïë Creates a spectacular shower of coin particles for major achievements.
              ‚ïë Multiple floating coins rain down from the coin counter element.
              ‚ïë Used for jackpots, streaks, and other exciting coin-earning events.
              ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
            createCoinShower(message, coinCount) {
                const coinElement = document.getElementById('coinAmount');
                const rect = coinElement.getBoundingClientRect();
                
                // Create the main message
                this.createFloatingText(message, coinElement, '#FFD700');
                
                // Create shower of individual coins
                for (let i = 0; i < Math.min(coinCount, 15); i++) {
                    setTimeout(() => {
                        const coin = document.createElement('div');
                        coin.className = 'particle';
                        coin.textContent = 'üí∞';
                        coin.style.fontSize = '20px';
                        coin.style.left = (rect.left + Math.random() * rect.width) + 'px';
                        coin.style.top = rect.top + 'px';
                        coin.style.transform = `translate(${(Math.random() - 0.5) * 200}px, ${Math.random() * -100}px)`;
                        coin.style.opacity = '0';
                        coin.style.transition = 'all 2s ease-out';
                        
                        document.body.appendChild(coin);
                        
                        // Animate the coin
                        setTimeout(() => {
                            coin.style.transform += ` translateY(${Math.random() * 200 + 100}px)`;
                            coin.style.opacity = '1';
                        }, 50);
                        
                        // Remove after animation
                        setTimeout(() => {
                            if (coin.parentNode) {
                                document.body.removeChild(coin);
                            }
                        }, 2500);
                    }, i * 100); // Stagger the coins
                }
            }

            /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
              ‚ïë PULSE ELEMENT EFFECT
              ‚ïë Makes an element pulse with a glowing effect to draw attention.
              ‚ïë Used for significant coin increases and achievements.
              ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
            pulseElement(element, pulses = 3) {
                let count = 0;
                const originalTransform = element.style.transform;
                const originalBoxShadow = element.style.boxShadow;
                
                const pulse = () => {
                    if (count >= pulses) {
                        element.style.transform = originalTransform;
                        element.style.boxShadow = originalBoxShadow;
                        return;
                    }
                    
                    element.style.transform = 'scale(1.2)';
                    element.style.boxShadow = '0 0 20px #FFD700';
                    element.style.transition = 'all 0.2s ease-in-out';
                    
                    setTimeout(() => {
                        element.style.transform = 'scale(1)';
                        element.style.boxShadow = originalBoxShadow;
                        count++;
                        setTimeout(pulse, 300);
                    }, 200);
                };
                
                pulse();
            }

            /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
              ‚ïë SHAKE ELEMENT EFFECT
              ‚ïë Makes an element shake violently to show dramatic losses or penalties.
              ‚ïë Used when players lose significant amounts of coins.
              ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
            shakeElement(element, intensity = 3) {
                const originalTransform = element.style.transform;
                let shakeCount = 0;
                const maxShakes = intensity * 4; // More shakes for higher intensity
                
                const shake = () => {
                    if (shakeCount >= maxShakes) {
                        element.style.transform = originalTransform;
                        element.style.transition = '';
                        return;
                    }
                    
                    const x = (Math.random() - 0.5) * intensity * 4;
                    const y = (Math.random() - 0.5) * intensity * 4;
                    element.style.transform = `translate(${x}px, ${y}px)`;
                    element.style.transition = 'none';
                    
                    shakeCount++;
                    setTimeout(shake, 50);
                };
                
                shake();
            }

            /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
              ‚ïë ANIMATE PROGRESS BAR
              ‚ïë Provides visual feedback when the progress bar fills. Adds temporary 
              ‚ïë animation class that causes the bar to pulse/glow, then removes it.
              ‚ïë Enhances the user experience when star progress increases.
              ‚ïë Parameters: progressBar - The progress bar DOM element to animate
              ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
            animateProgressBar(progressBar) {
                progressBar.classList.add('progress-animate');
                setTimeout(() => progressBar.classList.remove('progress-animate'), 800);
            }

            /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
              ‚ïë SOUND SYSTEM INTEGRATION POINTS
              ‚ïë Placeholder functions for easy sound effect integration. These functions
              ‚ïë can be enhanced later with actual audio implementation using Web Audio API
              ‚ïë or HTML5 audio elements. Currently logs sound events for development.
              ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
            playSound(soundType) {
                // Integration point for sound effects
                // Future enhancement: Load and play actual audio files
                console.log(`üîä Sound: ${soundType}`);
                
                switch (soundType) {
                    case 'shapeLanding':
                        // Soft landing sound - positive feedback
                        break;
                    case 'shapeCollision':
                        // Click/tap sound - interaction feedback  
                        break;
                    case 'shapeRotation':
                        // Quick whoosh sound - rotation feedback
                        break;
                    case 'coinEarned':
                        // Coin pickup sound - reward feedback
                        break;
                    case 'starFilled':
                        // Bright ding sound - progress feedback
                        break;
                    case 'levelComplete':
                        // Victory fanfare - completion feedback
                        break;
                    case 'levelFailed':
                        // Disappointment sound - failure feedback
                        break;
                    case 'endLevelCountdown':
                        // Ticking sound - tension building
                        break;
                    default:
                        console.log(`Unknown sound type: ${soundType}`);
                }
            }

            restoreAllShapesToDock() {
                // Restore all nine shapes to their dock positions
                const shapes = [
                    { id: 'shape-square', type: 'square', slot: 'slot-square' },
                    { id: 'shape-triangle', type: 'triangle', slot: 'slot-triangle' },
                    { id: 'shape-circle', type: 'circle', slot: 'slot-circle' },
                    { id: 'shape-cross2', type: 'cross2', slot: 'slot-cross2' },
                    { id: 'shape-l', type: 'l', slot: 'slot-l' },
                    { id: 'shape-cross', type: 'cross', slot: 'slot-cross' },
                    { id: 'shape-barbell-one', type: 'barbell-one', slot: 'slot-barbell-one' },
                    { id: 'shape-barbell-two', type: 'barbell-two', slot: 'slot-barbell-two' },
                    { id: 'shape-diamond-barbell', type: 'diamond-barbell', slot: 'slot-diamond-barbell' }
                ];
                
                shapes.forEach(shapeInfo => {
                    const slot = document.getElementById(shapeInfo.slot);
                    if (slot) {
                        slot.classList.remove('empty');
                        
                        // Remove any existing shape in the slot
                        const existingShape = slot.querySelector('.game-shape');
                        if (existingShape) {
                            existingShape.remove();
                        }
                        
                        // Create new shape element
                        const shapeElement = document.createElement('div');
                        shapeElement.className = `game-shape shape-${shapeInfo.type}`;
                        shapeElement.dataset.shape = shapeInfo.type;
                        shapeElement.id = shapeInfo.id;
                        
                        slot.appendChild(shapeElement);
                    }
                });
                
                console.log('üîÑ All 9 shapes restored to docking area');
            }
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë PHASE 2: MODE TOGGLE SYSTEM - LEVEL EDITOR FUNCTIONALITY
          ‚ïë Implements the level editor mode toggle system allowing users to switch
          ‚ïë between Play Mode (normal gameplay) and Design Mode (level configuration).
          ‚ïë Includes dock configuration, timer settings, and level parameters.
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/

        // Level configuration state
        let currentMode = 'play';
        let currentLevelConfig = {
            world: 1,
            level: 1,
            timerMode: 'elapsed',
            timerStart: 60,
            endLevelDuration: 5,
            dockSlots: 9,
            barbellOrientation: 'vertical',
            dockShapes: ['square', 'triangle', 'circle', 'cross2', 'l', 'cross', 'barbell-one', 'barbell-two', 'diamond-barbell']
        };

        // Make level config globally available for dock system
        window.currentLevelConfig = currentLevelConfig;

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë TOGGLE MODE SWITCH FUNCTION
          ‚ïë New toggle switch function that switches between Play Mode and Design Mode
          ‚ïë using a compact toggle switch in the HUD instead of separate buttons.
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        function toggleModeSwitch() {
            const toggleSwitch = document.getElementById('modeToggleSwitch');
            const slider = toggleSwitch.querySelector('.mode-toggle-slider');
            
            if (currentMode === 'play') {
                toggleMode('design');
                toggleSwitch.classList.add('design-active');
                slider.textContent = 'üîß';
            } else {
                toggleMode('play');
                toggleSwitch.classList.remove('design-active');
                slider.textContent = 'üéÆ';
            }
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë TOGGLE MODE FUNCTION (UPDATED)
          ‚ïë Updated to work with new toggle switch instead of separate buttons.
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        function toggleMode(mode) {
            const gameContainer = document.getElementById('gameContainer');
            const designSidebar = document.getElementById('designSidebar');
            
            if (mode === 'design') {
                gameContainer.classList.add('design-mode');
                designSidebar.classList.add('active');
                currentMode = 'design';
                
                console.log('üîß Entered Design Mode - Level Editor Active');
                
                // Sync current dock configuration to design sidebar
                syncDockToDesign();
                generateDockSlots();
            } else {
                gameContainer.classList.remove('design-mode');
                designSidebar.classList.remove('active');
                currentMode = 'play';
                
                console.log('üéÆ Entered Play Mode - Game Active');
                
                // Apply any design changes to the play dock
                rebuildGameDock();
            }
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë SYNC DOCK TO DESIGN
          ‚ïë Reads the current dock configuration from the game and updates the design
          ‚ïë sidebar to match. Ensures design mode reflects the actual game state.
          ‚ïë Used when entering design mode to show current level configuration.
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        function syncDockToDesign() {
            const currentShapes = [];
            const dockingArea = document.getElementById('dockingArea');
            
            if (dockingArea) {
                const shapes = dockingArea.querySelectorAll('.game-shape');
                shapes.forEach(shape => {
                    const shapeType = shape.getAttribute('data-shape');
                    if (shapeType) {
                        currentShapes.push(shapeType);
                    }
                });
                
                if (currentShapes.length > 0) {
                    currentLevelConfig.dockShapes = currentShapes;
                    currentLevelConfig.dockSlots = currentShapes.length;
                    
                    // Update UI controls
                    const slotCountInput = document.getElementById('dockSlotCount');
                    if (slotCountInput) {
                        slotCountInput.value = currentShapes.length;
                    }
                }
            }
            
            console.log('üîÑ Synced current dock to design:', currentLevelConfig.dockShapes);
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë GENERATE DOCK SLOTS
          ‚ïë Creates the dynamic dock slot configuration UI in the design sidebar.
          ‚ïë Generates dropdown selectors for each dock slot allowing shape assignment.
          ‚ïë Preserves existing shape assignments when slot count changes.
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        function generateDockSlots() {
            const dockContainer = document.getElementById('dockSlotsContainer');
            const slotCount = parseInt(document.getElementById('dockSlotCount').value);
            
            if (!dockContainer) return;
            
            dockContainer.innerHTML = '';
            
            // Ensure we have enough shapes in the configuration
            const allShapes = ['square', 'triangle', 'circle', 'l', 'cross', 'cross2', 
                              'barbell-one', 'barbell-two', 'diamond-barbell'];
            
            // Preserve existing shapes or use defaults
            if (currentLevelConfig.dockShapes.length !== slotCount) {
                const newShapes = [];
                for (let i = 0; i < slotCount; i++) {
                    if (i < currentLevelConfig.dockShapes.length) {
                        newShapes.push(currentLevelConfig.dockShapes[i]);
                    } else {
                        newShapes.push(allShapes[i % allShapes.length]);
                    }
                }
                currentLevelConfig.dockShapes = newShapes;
            }
            
            // Generate configuration UI for each slot
            for (let i = 0; i < slotCount; i++) {
                const slotDiv = document.createElement('div');
                slotDiv.className = 'dock-slot-config';
                const selectedShape = currentLevelConfig.dockShapes[i];
                
                slotDiv.innerHTML = `
                    <div style="font-weight: bold; margin-bottom: 3px;">Slot ${i + 1}</div>
                    <select onchange="updateDockShape(${i}, this.value)" style="width: 100%; background: rgba(0,0,0,0.3); color: white; border: 1px solid rgba(255,255,255,0.3); padding: 2px;">
                        <option value="square" ${selectedShape === 'square' ? 'selected' : ''}>Square</option>
                        <option value="triangle" ${selectedShape === 'triangle' ? 'selected' : ''}>Triangle</option>
                        <option value="circle" ${selectedShape === 'circle' ? 'selected' : ''}>Circle</option>
                        <option value="l" ${selectedShape === 'l' ? 'selected' : ''}>L-Shape</option>
                        <option value="cross" ${selectedShape === 'cross' ? 'selected' : ''}>Green Cross</option>
                        <option value="cross2" ${selectedShape === 'cross2' ? 'selected' : ''}>Pink Cross</option>
                        <option value="barbell-one" ${selectedShape === 'barbell-one' ? 'selected' : ''}>One-Ended Barbell</option>
                        <option value="barbell-two" ${selectedShape === 'barbell-two' ? 'selected' : ''}>Two-Ended Barbell</option>
                        <option value="diamond-barbell" ${selectedShape === 'diamond-barbell' ? 'selected' : ''}>Diamond Barbell</option>
                    </select>
                `;
                dockContainer.appendChild(slotDiv);
            }
            
            currentLevelConfig.dockSlots = slotCount;
            console.log('üéõÔ∏è Generated dock slots configuration:', slotCount);
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë UPDATE DOCK SHAPE
          ‚ïë Updates a specific dock slot's shape assignment in the level configuration.
          ‚ïë Called when user changes shape selection in design sidebar dropdown.
          ‚ïë Parameters: slotIndex - Index of slot to update, shape - New shape type
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        function updateDockShape(slotIndex, shape) {
            if (slotIndex < currentLevelConfig.dockShapes.length) {
                currentLevelConfig.dockShapes[slotIndex] = shape;
                console.log(`üîÑ Updated slot ${slotIndex + 1} to ${shape}`);
            }
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë UPDATE BARBELL ORIENTATION
          ‚ïë Changes the barbell orientation in the dock (vertical vs horizontal).
          ‚ïë Applies CSS classes to the docking area to control barbell display.
          ‚ïë Called when user changes barbell orientation setting in design sidebar.
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        function updateBarbellOrientation() {
            const orientation = document.getElementById('barbellOrientation').value;
            currentLevelConfig.barbellOrientation = orientation;
            
            // Rebuild the dock to apply rotation changes to barbell previews
            rebuildGameDock();
            
            console.log(`üîÑ Updated barbell orientation to ${orientation} - dock rebuilt with rotated previews`);
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë APPLY LEVEL CHANGES
          ‚ïë Applies all design sidebar configuration changes to the active game.
          ‚ïë Updates level info, timer settings, and rebuilds the dock layout.
          ‚ïë Provides visual feedback to confirm changes were applied.
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        function applyLevelChanges() {
            // Save current configuration from sidebar
            const worldLevelValue = document.getElementById('levelNumber').value;
            const parts = worldLevelValue.split('-');
            currentLevelConfig.world = parseInt(parts[0]) || 1;
            currentLevelConfig.level = parseInt(parts[1]) || 1;
            currentLevelConfig.timerMode = document.getElementById('timerMode').value;
            currentLevelConfig.timerStart = parseInt(document.getElementById('timerStart').value);
            currentLevelConfig.endLevelDuration = parseInt(document.getElementById('endLevelDuration').value);
            
            // Update game UI
            updateGameUI();
            
            // Apply timer changes if countdown mode is selected
            if (currentLevelConfig.timerMode === 'countdown' && window.gameManager && window.gameManager.gameState) {
                const startTime = currentLevelConfig.timerStart || 60;
                window.gameManager.gameState.gameTime = startTime;
                
                // Update timer display
                const timerElement = document.getElementById('gameTimer');
                if (timerElement) {
                    const minutes = Math.floor(startTime / 60);
                    const seconds = startTime % 60;
                    timerElement.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                }
                
                console.log('‚è≥ Applied countdown timer start value:', startTime);
            }
            
            // Rebuild dock with new configuration
            rebuildGameDock();
            
            // Show feedback
            const btn = document.getElementById('applyChangesBtn');
            const originalText = btn.textContent;
            btn.textContent = 'Applied!';
            btn.style.background = 'linear-gradient(135deg, #27ae60 0%, #229954 100%)';
            setTimeout(() => {
                btn.textContent = originalText;
                btn.style.background = 'linear-gradient(135deg, #27ae60 0%, #229954 100%)';
            }, 1500);
            
            console.log('‚úÖ Applied level changes:', currentLevelConfig);
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë UPDATE TIMER MODE CONFIG
          ‚ïë Updates timer mode configuration when user changes dropdown in design sidebar.
          ‚ïë Immediately applies the new timer mode to current level configuration and UI.
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        function updateTimerModeConfig() {
            // Update current level config with new timer mode
            const timerModeSelect = document.getElementById('timerMode');
            currentLevelConfig.timerMode = timerModeSelect.value;
            
            // Update game state if game manager exists
            if (window.gameManager && window.gameManager.gameState) {
                window.gameManager.gameState.timerMode = timerModeSelect.value;
                
                // Initialize timer based on mode
                if (timerModeSelect.value === 'countdown') {
                    // Set countdown timer to start value
                    const startTime = currentLevelConfig.timerStart || 60;
                    window.gameManager.gameState.gameTime = startTime;
                    
                    // Update timer display immediately
                    const timerElement = document.getElementById('gameTimer');
                    if (timerElement) {
                        const minutes = Math.floor(startTime / 60);
                        const seconds = startTime % 60;
                        timerElement.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                    }
                } else if (timerModeSelect.value === 'elapsed') {
                    // Reset to 0 for elapsed timer
                    window.gameManager.gameState.gameTime = 0;
                    
                    // Update timer display immediately
                    const timerElement = document.getElementById('gameTimer');
                    if (timerElement) {
                        timerElement.textContent = '0:00';
                    }
                }
            }
            
            // Update timer UI to reflect new mode
            const modeIndicator = document.getElementById('timerModeIndicator');
            if (modeIndicator && timerModeSelect.value === 'countdown') {
                modeIndicator.className = 'timer-mode-indicator timer-mode-countdown';
                modeIndicator.textContent = '‚è≥';
            } else if (modeIndicator && timerModeSelect.value === 'elapsed') {
                modeIndicator.className = 'timer-mode-indicator timer-mode-elapsed';
                modeIndicator.textContent = '‚è±';
            } else if (modeIndicator && timerModeSelect.value === 'none') {
                modeIndicator.className = 'timer-mode-indicator timer-mode-elapsed';
                modeIndicator.textContent = '‚ö™';
            }
            
            console.log('üïí Updated timer mode to:', timerModeSelect.value);
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë UPDATE GAME UI
          ‚ïë Updates the game's UI elements to reflect current level configuration.
          ‚ïë Updates level display and other HUD elements based on design settings.
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        function updateGameUI() {
            const levelDisplay = document.getElementById('levelDisplay');
            if (levelDisplay) {
                levelDisplay.textContent = `World ${currentLevelConfig.world}-${currentLevelConfig.level}`;
            }
            
            console.log(`üéÆ Updated game UI for World ${currentLevelConfig.world}-${currentLevelConfig.level}`);
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë THEME CYCLING (GLOBAL WRAPPER) - SIMPLIFIED
          ‚ïë Simple theme cycling that uses the existing dropdown functionality.
          ‚ïë Just cycles through the dropdown options and triggers changeTheme().
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        function cycleThemes() {
            console.log('üé® Theme cycling requested from HUD button');
            
            try {
                const themeSelector = document.getElementById('themeSelector');
                if (!themeSelector) {
                    console.error('‚ùå Theme selector not found');
                    return;
                }
                
                // Get all available options
                const options = Array.from(themeSelector.options);
                const currentIndex = themeSelector.selectedIndex;
                
                // Calculate next index (cycle back to 0 if at end)
                const nextIndex = (currentIndex + 1) % options.length;
                
                // Set the new value and trigger the change event
                themeSelector.selectedIndex = nextIndex;
                const newTheme = themeSelector.value;
                
                console.log(`üé® Cycling to theme: ${newTheme}`);
                
                // Trigger the existing changeTheme function
                changeTheme();
                
            } catch (error) {
                console.error('‚ùå Failed to cycle themes:', error);
            }
        }
        
        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë RESET LEVEL (GLOBAL WRAPPER) - ENHANCED
          ‚ïë Enhanced reset function that properly resets timer, restores shapes to dock,
          ‚ïë and clears physics simulation. Handles both design mode and play mode resets.
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        function resetLevel() {
            console.log('üîÑ Starting level reset...');
            
            // Clear all shapes from playfield
            if (window.gameManager && window.gameManager.physicsManager) {
                window.gameManager.physicsManager.clearAllShapes();
                console.log('üßπ Cleared physics shapes');
            }
            
            // Reset timer and game state
            if (window.gameManager && window.gameManager.gameState) {
                // Reset timer to 0:00
                window.gameManager.gameState.gameTime = 0;
                window.gameManager.gameState.endLevelTime = currentLevelConfig.endLevelDuration;
                
                // Apply current timer mode from config
                window.gameManager.gameState.timerMode = currentLevelConfig.timerMode || 'elapsed';
                
                // Update timer display
                const timerElement = document.getElementById('gameTimer');
                if (timerElement) {
                    if (currentLevelConfig.timerMode === 'countdown') {
                        // For countdown, start from configured start time
                        const startTime = currentLevelConfig.timerStart || 60;
                        window.gameManager.gameState.gameTime = startTime;
                        const minutes = Math.floor(startTime / 60);
                        const seconds = startTime % 60;
                        timerElement.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                    } else {
                        // For elapsed timer, start at 0:00
                        timerElement.textContent = '0:00';
                    }
                }
                
                // Update timer mode indicator based on current config
                const modeIndicator = document.getElementById('timerModeIndicator');
                if (modeIndicator) {
                    if (currentLevelConfig.timerMode === 'countdown') {
                        modeIndicator.className = 'timer-mode-indicator timer-mode-countdown';
                        modeIndicator.textContent = '‚è≥';
                    } else if (currentLevelConfig.timerMode === 'elapsed') {
                        modeIndicator.className = 'timer-mode-indicator timer-mode-elapsed';
                        modeIndicator.textContent = '‚è±';
                    } else if (currentLevelConfig.timerMode === 'none') {
                        modeIndicator.className = 'timer-mode-indicator timer-mode-elapsed';
                        modeIndicator.textContent = '‚ö™';
                    }
                }
                
                console.log('‚è∞ Reset timer and game state with mode:', currentLevelConfig.timerMode);
            }
            
            // Rebuild dock with current configuration (preserves design mode settings)
            rebuildGameDock();
            
            // Force reinitialize drag and drop system after dock rebuild
            if (window.gameManager && window.gameManager.dragDropManager) {
                console.log('üîÑ Drag and drop system already initialized');
                
                // Verify all shapes are interactive
                const dockShapes = document.querySelectorAll('.game-shape');
                console.log(`üéØ Found ${dockShapes.length} shapes after reset:`, 
                    Array.from(dockShapes).map(s => s.dataset.shape));
                    
                // Ensure all shapes are visible and interactive
                dockShapes.forEach(shape => {
                    shape.style.visibility = 'visible';
                    shape.classList.remove('dragging', 'ghost-active');
                });
            }
            
            // Reset additional game state elements
            if (window.gameManager) {
                // Reset shape counters
                if (window.gameManager.gameState) {
                    window.gameManager.gameState.shapesPlaced = 0;
                    window.gameManager.gameState.isGameActive = true;
                    window.gameManager.gameState.isLevelComplete = false;
                    window.gameManager.gameState.isGameOver = false;
                    
                    // Reset placed shapes array - this fixes the "placed" count not resetting
                    window.gameManager.gameState.placedShapes = [];
                    
                    // Fix #2: Reset score and coins to zero
                    window.gameManager.gameState.score = 0;
                    window.gameManager.gameState.coins = 0;
                    
                    // Update displays
                    document.getElementById('scoreText').textContent = '0';
                    document.getElementById('coinAmount').textContent = '0';
                }
                
                // Reset progress bar
                const progressBar = document.getElementById('starProgressBar');
                if (progressBar) {
                    progressBar.style.width = '0%';
                }
                
                // Reset stars
                document.querySelectorAll('.star').forEach(star => {
                    star.classList.remove('filled');
                });
                
                console.log('üéÆ Reset game state elements including score and coins');
            }
            
            // Update debug info to reflect reset state
            if (window.gameManager && window.gameManager.updateDebugInfo) {
                window.gameManager.updateDebugInfo();
            }
            
            console.log('‚úÖ Level reset completed');
        }

        // Global functions for HUD interactions
        function switchTimerMode() {
            console.log('üîÑ Timer mode switch requested');
        }

        function initializeProgressBarInteraction() {
            console.log('‚≠ê Progress bar interaction');
        }

        function animateCoin() {
            console.log('üí∞ Coin animation triggered');
        }

        // Mobile Debug Toggle for Testing
        let mobileDebugMode = false;
        let originalMobileDetection = null;
        function toggleMobileDebug() {
            mobileDebugMode = !mobileDebugMode;
            const button = document.getElementById('mobileDebugButton');
            
            if (!window.gameManager?.mobileEnhancementManager) {
                console.log('‚ùå Mobile enhancement manager not found');
                console.log('Available gameManager properties:', Object.keys(window.gameManager || {}));
                return;
            }
            
            const mobileManager = window.gameManager.mobileEnhancementManager;
            
            if (mobileDebugMode) {
                // Store original detection result
                if (originalMobileDetection === null) {
                    originalMobileDetection = mobileManager.detectMobileDevice();
                }
                
                // Force mobile mode
                window.gameManager.dragDropManager.isMobileDevice = true;
                mobileManager.isMobileDevice = true;
                
                // Enable mouse support for testing on desktop
                mobileManager.enableMouseSupport();
                
                // Update rotation zone bounds and show zones
                mobileManager.updateRotationZoneBounds();
                mobileManager.showRotationZones();
                
                button.style.background = 'linear-gradient(135deg, #27ae60 0%, #2ecc71 100%)';
                button.title = 'Mobile Debug: ON (Click to disable)';
                console.log('üì± Mobile Debug Mode: ON - Rotation zones should be visible');
                console.log('üì± Rotation zones bounds:', {
                    left: mobileManager.rotationZones.left.bounds,
                    right: mobileManager.rotationZones.right.bounds
                });
            } else {
                // Restore original detection
                const originalDetection = originalMobileDetection || mobileManager.detectMobileDevice();
                window.gameManager.dragDropManager.isMobileDevice = originalDetection;
                mobileManager.isMobileDevice = originalDetection;
                
                // Disable mouse support
                mobileManager.disableMouseSupport();
                
                if (!originalDetection) {
                    mobileManager.hideRotationZones();
                }
                
                button.style.background = 'linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%)';
                button.title = 'Mobile Debug: OFF (Click to enable)';
                console.log('üì± Mobile Debug Mode: OFF');
            }
        }

        // Global level management functions (for console testing)
        function nextLevel() {
            if (window.gameManager) {
                window.gameManager.nextLevel();
            }
        }

        function nextWorld() {
            if (window.gameManager) {
                window.gameManager.nextWorld();
            }
        }

        function setLevel(world, level) {
            if (window.gameManager) {
                window.gameManager.setLevel(world, level);
            }
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë v9: CANVAS ENHANCEMENT THEME MANAGEMENT FUNCTIONS
          ‚ïë User interface functions for theme switching and canvas configuration
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/

        // Theme switching function called from UI
        function changeTheme() {
            const themeSelector = document.getElementById('themeSelector');
            const selectedTheme = themeSelector.value;
            
            // Synchronize both dropdowns to use the same values
            const enhancedThemeSelect = document.getElementById('enhancedThemeSelect');
            if (enhancedThemeSelect) {
                enhancedThemeSelect.value = selectedTheme;
                // Apply the enhanced theme with texture loading
                applyEnhancedTheme();
            }
            
            if (window.gameManager && window.gameManager.themeManager) {
                // Material themes are free - no premium themes
                const isCurrentTheme = window.currentTheme && window.currentTheme.name === selectedTheme;
                
                if (!isCurrentTheme) {
                    // All material themes are free
                    const coinElement = document.getElementById('coinAmount');
                    window.gameManager.createFloatingText(`-${themeCost} Theme`, coinElement, '#FF6B6B');
                    window.gameManager.createFloatingText('üé® PREMIUM!', coinElement, '#FFD700');
                    
                    console.log(`üí∞ Purchased premium theme "${selectedTheme}" for ${themeCost} coins`);
                } else if (!isCurrentTheme && themeCost > 0) {
                    // Not enough coins for premium theme
                    console.log(`‚ùå Need ${themeCost} coins for premium theme "${selectedTheme}"`);
                    const coinElement = document.getElementById('coinAmount');
                    window.gameManager.createFloatingText(`Need ${themeCost} coins!`, coinElement, '#FF6B6B');
                    window.gameManager.shakeElement(coinElement, 2);
                    return;
                }
                
                window.gameManager.themeManager.switchTheme(selectedTheme, true);
                console.log(`üé® Theme changed to: ${selectedTheme}${themeCost > 0 ? ' (Premium)' : ''}`);
            }
        }

        // Toggle canvas enhancements on/off
        function toggleCanvasEnhancements() {
            const enableCanvas = document.getElementById('enableCanvas');
            CANVAS_CONFIG.enabled = enableCanvas.checked;
            
            console.log(`üé® Canvas enhancements: ${CANVAS_CONFIG.enabled ? 'ON' : 'OFF'}`);
            
            // Apply change immediately
            if (window.gameManager) {
                if (CANVAS_CONFIG.enabled) {
                    // Re-initialize current theme
                    const currentTheme = window.gameManager.themeManager.getCurrentTheme();
                    window.gameManager.themeManager.switchTheme(currentTheme, false);
                } else {
                    // Reset to basic appearance
                    window.gameManager.physicsManager.backgroundGradient = null;
                }
            }
        }

        // Toggle particle effects
        function toggleParticleEffects() {
            const enableParticles = document.getElementById('enableParticles');
            CANVAS_CONFIG.useParticles = enableParticles.checked;
            
            console.log(`üé® Particle effects: ${CANVAS_CONFIG.useParticles ? 'ON' : 'OFF'}`);
            
            if (!CANVAS_CONFIG.useParticles && window.gameManager) {
                // Clear existing particles
                window.gameManager.physicsManager.particleSystem.particles = [];
            }
        }

        // Touch offset configuration functions
        function toggleTouchOffset() {
            const enableTouchOffset = document.getElementById('enableTouchOffset');
            if (window.gameManager && window.gameManager.dragDropManager) {
                const currentOffset = window.gameManager.dragDropManager.getTouchOffset();
                window.gameManager.dragDropManager.setTouchOffset(
                    currentOffset.x, 
                    currentOffset.y, 
                    enableTouchOffset.checked
                );
                console.log(`üì± Touch offset: ${enableTouchOffset.checked ? 'ON' : 'OFF'}`);
            }
        }

        function updateTouchOffset() {
            const offsetX = parseInt(document.getElementById('touchOffsetX').value);
            const offsetY = parseInt(document.getElementById('touchOffsetY').value);
            const enabled = document.getElementById('enableTouchOffset').checked;
            
            if (window.gameManager && window.gameManager.dragDropManager) {
                window.gameManager.dragDropManager.setTouchOffset(offsetX, offsetY, enabled);
                updateTouchOffsetDisplay();
                console.log(`üì± Touch offset updated: X=${offsetX}px, Y=${offsetY}px`);
            }
        }

        function updateTouchOffsetDisplay() {
            const offsetX = document.getElementById('touchOffsetX').value;
            const offsetY = document.getElementById('touchOffsetY').value;
            
            document.getElementById('touchOffsetXValue').textContent = `${offsetX}px`;
            document.getElementById('touchOffsetYValue').textContent = `${offsetY}px`;
        }

        // Toggle shape animations  
        function toggleAnimations() {
            const enableAnimations = document.getElementById('enableAnimations');
            CANVAS_CONFIG.useAnimations = enableAnimations.checked;
            
            console.log(`üé® Shape animations: ${CANVAS_CONFIG.useAnimations ? 'ON' : 'OFF'}`);
        }

        // Initialize theme selector UI state
        function initializeThemeUI() {
            // Set initial checkbox states
            document.getElementById('enableCanvas').checked = CANVAS_CONFIG.enabled;
            document.getElementById('enableParticles').checked = CANVAS_CONFIG.useParticles;
            document.getElementById('enableAnimations').checked = CANVAS_CONFIG.useAnimations;
            
            // Set initial theme
            document.getElementById('themeSelector').value = CANVAS_CONFIG.defaultTheme;
            
            console.log('üé® Theme UI initialized');
        }

        // Test function to cycle through all themes (for development)
        function testAllThemes() {
            if (!window.gameManager) return;
            
            const themes = Object.keys(THEME_DEFINITIONS);
            let currentIndex = 0;
            
            const cycleTheme = () => {
                const theme = themes[currentIndex];
                window.gameManager.themeManager.switchTheme(theme, true);
                document.getElementById('themeSelector').value = theme;
                
                console.log(`üé® Testing theme: ${theme}`);
                
                currentIndex = (currentIndex + 1) % themes.length;
                
                if (currentIndex !== 0) {
                    setTimeout(cycleTheme, 3000); // Change every 3 seconds
                }
            };
            
            cycleTheme();
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë PIXIJS CONTROL FUNCTIONS - PHASE 1
          ‚ïë UI controls for PixiJS system configuration and testing
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        
        // Toggle PixiJS system on/off
        function togglePixiSystem() {
            const enablePixi = document.getElementById('enablePixi');
            PIXI_CONFIG.enabled = enablePixi.checked;
            
            console.log(`üé® PixiJS system: ${PIXI_CONFIG.enabled ? 'ON' : 'OFF'}`);
            
            // Apply change immediately if game is running
            if (window.gameManager && window.gameManager.physicsManager.rendererManager) {
                if (PIXI_CONFIG.enabled) {
                    // Try to switch to PixiJS if available
                    window.gameManager.physicsManager.rendererManager.autoSelectRenderer();
                } else {
                    // Force Canvas mode
                    window.gameManager.physicsManager.rendererManager.switchRenderer('canvas');
                }
                
                // Update renderer selector
                const rendererSelect = document.getElementById('rendererSelect');
                const currentRenderer = window.gameManager.physicsManager.rendererManager.getCurrentRenderer();
                rendererSelect.value = PIXI_CONFIG.enabled ? PIXI_CONFIG.renderer : 'canvas';
            }
        }

        // Switch renderer based on selection
        function switchRenderer() {
            const rendererSelect = document.getElementById('rendererSelect');
            const selectedRenderer = rendererSelect.value;
            
            if (!window.gameManager || !window.gameManager.physicsManager.rendererManager) {
                console.warn('‚ö†Ô∏è Game not initialized yet');
                return;
            }
            
            const rendererManager = window.gameManager.physicsManager.rendererManager;
            
            // Update PixiJS configuration
            PIXI_CONFIG.renderer = selectedRenderer;
            
            // Switch renderer
            let success = false;
            if (selectedRenderer === 'auto') {
                success = rendererManager.autoSelectRenderer();
            } else {
                success = rendererManager.switchRenderer(selectedRenderer);
            }
            
            if (success) {
                const currentRenderer = rendererManager.getCurrentRenderer();
                console.log(`‚úÖ Switched to: ${currentRenderer.toUpperCase()}`);
                
                // Update PixiJS enable checkbox based on result
                const enablePixi = document.getElementById('enablePixi');
                enablePixi.checked = currentRenderer === 'pixi' || PIXI_CONFIG.enabled;
            } else {
                console.warn('‚ö†Ô∏è Renderer switch failed');
            }
        }

        // Toggle PixiJS debug mode
        function togglePixiDebug() {
            const pixiDebug = document.getElementById('pixiDebug');
            PIXI_CONFIG.debug.enabled = pixiDebug.checked;
            
            console.log(`üîç PixiJS debug mode: ${PIXI_CONFIG.debug.enabled ? 'ON' : 'OFF'}`);
            
            // Show additional debug info when enabled
            if (PIXI_CONFIG.debug.enabled && window.gameManager) {
                showRendererInfo();
            }
        }

        // Toggle PixiJS FPS counter
        function togglePixiFPS() {
            const pixiShowFPS = document.getElementById('pixiShowFPS');
            PIXI_CONFIG.debug.showFPS = pixiShowFPS.checked;
            
            console.log(`üìä PixiJS FPS counter: ${PIXI_CONFIG.debug.showFPS ? 'ON' : 'OFF'}`);
            
            // TODO: Phase 3 - Implement FPS counter display
        }

        // Toggle PixiJS shape rendering (Phase 2)
        function togglePixiShapeRendering() {
            const enablePixiShapes = document.getElementById('enablePixiShapes');
            PIXI_CONFIG.features.shapeRendering = enablePixiShapes.checked;
            
            console.log(`üé® PixiJS shape rendering: ${PIXI_CONFIG.features.shapeRendering ? 'ON' : 'OFF'}`);
            
            if (!window.gameManager || !window.gameManager.physicsManager.pixiShapeRenderer) {
                console.warn('‚ö†Ô∏è Game not initialized yet');
                return;
            }
            
            const pixiShapeRenderer = window.gameManager.physicsManager.pixiShapeRenderer;
            const rendererManager = window.gameManager.physicsManager.rendererManager;
            
            if (PIXI_CONFIG.features.shapeRendering) {
                // Enable PixiJS shape rendering - auto-enable PixiJS if needed
                if (!rendererManager.isPixiActive()) {
                    console.log('üîÑ Enabling PixiJS system for shape rendering...');
                    
                    // Auto-enable PixiJS system
                    PIXI_CONFIG.enabled = true;
                    const enablePixi = document.getElementById('enablePixi');
                    if (enablePixi) enablePixi.checked = true;
                    
                    // Switch to PixiJS renderer
                    const switchSuccess = rendererManager.switchRenderer('pixi');
                    if (!switchSuccess) {
                        console.error('‚ùå Failed to activate PixiJS - shape rendering unavailable');
                        enablePixiShapes.checked = false;
                        PIXI_CONFIG.features.shapeRendering = false;
                        return;
                    }
                }
                
                // Now enable PixiJS shape rendering
                const success = pixiShapeRenderer.enable();
                if (success) {
                    console.log('‚úÖ PixiJS shape rendering enabled');
                    
                    // Recreate existing shapes in PixiJS
                    const dynamicBodies = window.gameManager.physicsManager.dynamicBodies;
                    dynamicBodies.forEach(body => {
                        if (body.userData && body.userData.shapeType) {
                            pixiShapeRenderer.createShape(body, body.userData.shapeType);
                        }
                    });
                    
                    console.log(`üé® Recreated ${dynamicBodies.length} shapes in PixiJS`);
                } else {
                    console.error('‚ùå Failed to enable PixiJS shape rendering');
                    enablePixiShapes.checked = false;
                    PIXI_CONFIG.features.shapeRendering = false;
                }
            } else {
                // Disable PixiJS shape rendering
                pixiShapeRenderer.disable();
                console.log('üîÑ PixiJS shape rendering disabled');
            }
        }

        // Phase 3: Toggle PixiJS Animations
        function togglePixiAnimations() {
            const enablePixiAnimations = document.getElementById('enablePixiAnimations');
            PIXI_CONFIG.animations.enabled = enablePixiAnimations.checked;
            
            console.log(`üé¨ PixiJS animations: ${PIXI_CONFIG.animations.enabled ? 'ON' : 'OFF'}`);
            
            // Apply to animation manager if available
            if (window.gameManager && window.gameManager.physicsManager.rendererManager.pixiManager.animationManager) {
                const animationManager = window.gameManager.physicsManager.rendererManager.pixiManager.animationManager;
                
                if (PIXI_CONFIG.animations.enabled) {
                    animationManager.enable();
                } else {
                    animationManager.disable();
                }
            }
        }

        // Initialize and synchronize both theme dropdowns
        function initializeThemeSync() {
            const visualThemeSelect = document.getElementById('themeSelector');
            const enhancedThemeSelect = document.getElementById('enhancedThemeSelect');
            
            if (visualThemeSelect && enhancedThemeSelect) {
                // Ensure both dropdowns have the same default value
                const defaultTheme = 'classic';
                visualThemeSelect.value = defaultTheme;
                enhancedThemeSelect.value = defaultTheme;
                
                console.log(`üîÑ Initialized both theme dropdowns to: ${defaultTheme}`);
            }
            
            // Initialize theme button icon
            console.log('üé® Theme button initialized');
        }

        // Unified theme change handler
        function handleThemeChange(selectedTheme, source = 'visual') {
            console.log(`üé® Theme change requested: ${selectedTheme} from ${source} dropdown`);
            
            // Clear previous theme textures globally before applying new theme
            clearPreviousThemeTextures();
            
            // Apply theme colors to SHAPE_CONFIG for proper fallback colors
            applyThemeColorsToShapeConfig(selectedTheme);
            
            const visualThemeSelect = document.getElementById('themeSelector');
            const enhancedThemeSelect = document.getElementById('enhancedThemeSelect');
            
            // Synchronize both dropdowns
            if (visualThemeSelect && visualThemeSelect.value !== selectedTheme) {
                visualThemeSelect.value = selectedTheme;
            }
            if (enhancedThemeSelect && enhancedThemeSelect.value !== selectedTheme) {
                enhancedThemeSelect.value = selectedTheme;
            }
            
            // Apply the theme changes first (background, platform colors)
            if (window.gameManager && window.gameManager.themeManager) {
                window.gameManager.themeManager.switchTheme(selectedTheme, true);
                console.log(`üé® Applied visual theme: ${selectedTheme}`);
            }
            
            // Apply enhanced theme with textures
            applyMaterialTheme(selectedTheme);
        }
        
        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë CLEAR PREVIOUS THEME TEXTURES - GLOBAL TEXTURE UNLOADING
          ‚ïë Clears all texture data from previous themes to prevent texture persistence.
          ‚ïë This ensures clean transitions between all themes (Wood‚ÜíStone, Metal‚ÜíClassic, etc.)
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        function clearPreviousThemeTextures() {
            console.log('üßπ Clearing previous theme textures globally');
            
            try {
                // Clear window.currentTheme texture data
                if (window.currentTheme) {
                    if (window.currentTheme.shapes && window.currentTheme.shapes.textures) {
                        delete window.currentTheme.shapes.textures;
                        console.log('üßπ Cleared window.currentTheme.shapes.textures');
                    }
                    if (window.currentTheme.background && window.currentTheme.background.image) {
                        delete window.currentTheme.background.image;
                        console.log('üßπ Cleared window.currentTheme.background.image');
                    }
                    if (window.currentTheme.platform && window.currentTheme.platform.image) {
                        delete window.currentTheme.platform.image;
                        console.log('üßπ Cleared window.currentTheme.platform.image');
                    }
                }
                
                // Clear textureManager loaded textures
                if (window.textureManager && window.textureManager.loadedTextures.size > 0) {
                    console.log(`üßπ Clearing ${window.textureManager.loadedTextures.size} loaded textures from textureManager`);
                    window.textureManager.loadedTextures.clear();
                    
                    // Clear texture references from SHAPE_CONFIG
                    Object.keys(SHAPE_CONFIG).forEach(shapeType => {
                        if (SHAPE_CONFIG[shapeType].texture) {
                            delete SHAPE_CONFIG[shapeType].texture;
                        }
                    });
                    console.log('üßπ Cleared texture references from SHAPE_CONFIG');
                }
                
                console.log('‚úÖ Previous theme textures cleared successfully');
                
            } catch (error) {
                console.error('‚ùå Error clearing previous theme textures:', error);
            }
        }
        
        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë APPLY THEME COLORS TO SHAPE CONFIG
          ‚ïë Applies the appropriate theme colors to SHAPE_CONFIG after texture clearing.
          ‚ïë Ensures shapes show correct fallback colors for each theme.
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        function applyThemeColorsToShapeConfig(themeName) {
            console.log(`üé® Applying ${themeName} theme colors to SHAPE_CONFIG`);
            
            try {
                // Define theme-specific color palettes
                const themeColors = {
                    classic: {
                        square: { color: '#F39C12', stroke: '#E67E22' },
                        triangle: { color: '#9B59B6', stroke: '#8E44AD' },
                        circle: { color: '#1ABC9C', stroke: '#16A085' },
                        cross2: { color: '#3498DB', stroke: '#2980B9' },
                        l: { color: '#8E44AD', stroke: '#732D91' },
                        cross: { color: '#E74C3C', stroke: '#C0392B' },
                        'barbell-one': { color: '#16A085', stroke: '#138D75' },
                        'barbell-two': { color: '#D35400', stroke: '#BA4A00' },
                        'diamond-barbell': { color: '#C0392B', stroke: '#A93226' }
                    },
                    stone: {
                        square: { color: '#708090', stroke: '#2F4F4F' },
                        triangle: { color: '#696969', stroke: '#708090' },
                        circle: { color: '#778899', stroke: '#2F4F4F' },
                        cross2: { color: '#D3D3D3', stroke: '#708090' },
                        l: { color: '#696969', stroke: '#2F4F4F' },
                        cross: { color: '#708090', stroke: '#2F4F4F' },
                        'barbell-one': { color: '#778899', stroke: '#696969' },
                        'barbell-two': { color: '#D3D3D3', stroke: '#708090' },
                        'diamond-barbell': { color: '#2F4F4F', stroke: '#708090' }
                    },
                    metal: {
                        square: { color: '#696969', stroke: '#C0C0C0' },
                        triangle: { color: '#808080', stroke: '#696969' },
                        circle: { color: '#A9A9A9', stroke: '#C0C0C0' },
                        cross2: { color: '#778899', stroke: '#696969' },
                        l: { color: '#C0C0C0', stroke: '#808080' },
                        cross: { color: '#696969', stroke: '#C0C0C0' },
                        'barbell-one': { color: '#A9A9A9', stroke: '#778899' },
                        'barbell-two': { color: '#808080', stroke: '#696969' },
                        'diamond-barbell': { color: '#C0C0C0', stroke: '#A9A9A9' }
                    },
                    wood: {
                        square: { color: '#D2691E', stroke: '#8B4513' },
                        triangle: { color: '#CD853F', stroke: '#A0522D' },
                        circle: { color: '#DEB887', stroke: '#D2691E' },
                        cross2: { color: '#F4A460', stroke: '#CD853F' },
                        l: { color: '#8B4513', stroke: '#A0522D' },
                        cross: { color: '#CD7F32', stroke: '#DAA520' },
                        'barbell-one': { color: '#D2691E', stroke: '#8B4513' },
                        'barbell-two': { color: '#CD853F', stroke: '#A0522D' },
                        'diamond-barbell': { color: '#DAA520', stroke: '#B8860B' }
                    }
                };
                
                const colors = themeColors[themeName] || themeColors.classic;
                
                // Apply colors to SHAPE_CONFIG
                Object.keys(colors).forEach(shapeType => {
                    if (SHAPE_CONFIG[shapeType]) {
                        SHAPE_CONFIG[shapeType].color = colors[shapeType].color;
                        SHAPE_CONFIG[shapeType].stroke = colors[shapeType].stroke;
                    }
                });
                
                console.log(`‚úÖ Applied ${themeName} theme colors to ${Object.keys(colors).length} shapes`);
                
            } catch (error) {
                console.error(`‚ùå Error applying ${themeName} theme colors:`, error);
            }
        }

        // Updated changeTheme function
        function changeTheme() {
            const themeSelector = document.getElementById('themeSelector');
            const selectedTheme = themeSelector.value;
            handleThemeChange(selectedTheme, 'visual');
        }

        // Updated applyEnhancedTheme function  
        function applyEnhancedTheme() {
            const enhancedThemeSelect = document.getElementById('enhancedThemeSelect');
            const selectedTheme = enhancedThemeSelect.value;
            handleThemeChange(selectedTheme, 'enhanced');
        }

        // Material theme application with texture loading
        function applyMaterialTheme(selectedTheme) {
            console.log(`üé® Applying material theme: ${selectedTheme}`);
            
            // Initialize window.currentTheme if not exists
            if (!window.currentTheme) {
                window.currentTheme = {
                    name: selectedTheme,
                    shapes: {},
                    platform: {},
                    background: {}
                };
            }
            window.currentTheme.name = selectedTheme;
            
            // Handle classic theme separately
            if (selectedTheme === 'classic') {
                // Apply classic visual theme
                if (window.gameManager && window.gameManager.themeManager) {
                    window.gameManager.themeManager.switchTheme('classic', true);
                    console.log(`üé® Applied classic visual theme`);
                }
                
                // Apply classic enhanced theme if available
                if (window.gameManager && window.gameManager.physicsManager.rendererManager.pixiManager.themeManager) {
                    const themeManager = window.gameManager.physicsManager.rendererManager.pixiManager.themeManager;
                    if (themeManager.switchTheme) {
                        themeManager.switchTheme('classic');
                        console.log(`üé® Applied classic enhanced theme`);
                    }
                }
                return;
            }
            
            // For material themes (wood, stone, metal), add delay to ensure visual theme loads first
            setTimeout(() => {
                if (window.textureManager) {
                    console.log(`üñºÔ∏è Loading textures for ${selectedTheme} theme (after visual theme)`);
                    window.textureManager.applyTextureTheme(selectedTheme).then(() => {
                        console.log(`‚úÖ Textures loaded for ${selectedTheme} theme`);
                        
                        // Apply enhanced theme with textures AFTER visual theme is done
                        if (window.gameManager && window.gameManager.physicsManager.rendererManager.pixiManager.themeManager) {
                            const themeManager = window.gameManager.physicsManager.rendererManager.pixiManager.themeManager;
                            if (themeManager.switchTheme) {
                                themeManager.switchTheme(selectedTheme);
                                console.log(`üé® Applied ${selectedTheme} enhanced theme with textures (final step)`);
                            }
                        }
                        
                        // Refresh dock to show textures immediately
                        if (window.gameManager && window.gameManager.dockManager) {
                            window.gameManager.dockManager.refreshDock();
                            console.log(`üîÑ Refreshed dock with ${selectedTheme} textures (final step)`);
                        }
                    }).catch(error => {
                        console.error(`‚ùå Error loading ${selectedTheme} textures:`, error);
                    });
                } else {
                    console.warn(`‚ö†Ô∏è TextureManager not available for ${selectedTheme} theme`);
                }
            }, 200); // Delay to ensure visual theme completes first
        }

        // Initialize theme synchronization on page load
        document.addEventListener('DOMContentLoaded', function() {
            initializeThemeSync();
        });
        // Initialize PixiJS control states
        function initializePixiControls() {
            try {
                // Set initial control states based on configuration
                document.getElementById('enablePixi').checked = PIXI_CONFIG.enabled;
                document.getElementById('enablePixiShapes').checked = PIXI_CONFIG.features.shapeRendering;
                document.getElementById('rendererSelect').value = PIXI_CONFIG.renderer;
                document.getElementById('pixiDebug').checked = PIXI_CONFIG.debug.enabled;
                document.getElementById('pixiShowFPS').checked = PIXI_CONFIG.debug.showFPS;
                
                // Phase 3: Initialize animation controls
                document.getElementById('enablePixiAnimations').checked = PIXI_CONFIG.animations.enabled;
                document.getElementById('enhancedThemeSelect').value = 'classic';
                
                console.log('‚úÖ PixiJS control states initialized (Phase 3)');
            } catch (error) {
                console.error('‚ùå Failed to initialize PixiJS controls:', error);
            }
        }

        // Test particle effects manually
        function testParticles() {
            if (!window.gameManager || !window.gameManager.physicsManager) {
                console.log('‚ùå Game not initialized yet');
                return;
            }
            
            const particleSystem = window.gameManager.physicsManager.particleSystem;
            const canvas = window.gameManager.physicsManager.canvas;
            
            console.log('üéÜ Creating test particle burst!');
            
            // Create a big burst in the center of the canvas
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            particleSystem.createThemeParticles('test', centerX, centerY, 20);
            
            // Create smaller bursts around the edges
            setTimeout(() => {
                particleSystem.createThemeParticles('test', 100, 100, 10);
                particleSystem.createThemeParticles('test', canvas.width - 100, 100, 10);
                particleSystem.createThemeParticles('test', centerX, canvas.height - 100, 10);
            }, 500);
            
            console.log(`üéÜ Created particle test burst! Current particle count: ${particleSystem.particles.length}`);
        }

        // =============================================================================
        // DYNAMIC COIN BONUS SYSTEM
        // =============================================================================

        function startCoinBonusSystem() {
            // Random coin bonuses every 15-30 seconds
            setInterval(() => {
                if (!gameManager || !gameManager.gameState.isGameActive) return;
                
                const randomEvent = Math.random();
                const coinElement = document.getElementById('coinAmount');
                
                if (randomEvent < 0.3) { // 30% chance
                    // Small bonus coins
                    const bonus = Math.floor(Math.random() * 3) + 1; // 1-3 coins
                    gameManager.gameState.coins += bonus;
                    gameManager.updateCoinDisplay();
                    gameManager.createFloatingText(`üéÅ +${bonus}`, coinElement, '#32CD32');
                    console.log(`üéÅ Random coin bonus: +${bonus}`);
                    
                } else if (randomEvent < 0.35) { // 5% chance
                    // Medium jackpot
                    const jackpot = Math.floor(Math.random() * 8) + 5; // 5-12 coins
                    gameManager.gameState.coins += jackpot;
                    gameManager.updateCoinDisplay();
                    gameManager.createCoinShower('LUCKY BONUS!', jackpot);
                    console.log(`üçÄ Lucky bonus: +${jackpot} coins`);
                    
                } else if (randomEvent < 0.37) { // 2% chance  
                    // Big jackpot
                    const megaJackpot = Math.floor(Math.random() * 15) + 10; // 10-24 coins
                    gameManager.gameState.coins += megaJackpot;
                    gameManager.updateCoinDisplay();
                    gameManager.createCoinShower('MEGA JACKPOT!', megaJackpot);
                    gameManager.pulseElement(coinElement, 5);
                    console.log(`üíé MEGA JACKPOT: +${megaJackpot} coins`);
                }
            }, Math.random() * 15000 + 15000); // Every 15-30 seconds
            
            // Stability bonus system - rewards for keeping shapes stable
            setInterval(() => {
                if (!gameManager || !gameManager.gameState.isGameActive) return;
                if (gameManager.gameState.placedShapes.length === 0) return;
                
                // Check if shapes haven't fallen recently
                const timeSinceLastFall = Date.now() - (gameManager.gameState.lastFallTime || 0);
                if (timeSinceLastFall > 30000) { // 30 seconds of stability
                    const stabilityBonus = Math.floor(Math.random() * 4) + 2; // 2-5 coins
                    gameManager.gameState.coins += stabilityBonus;
                    gameManager.updateCoinDisplay();
                    
                    const coinElement = document.getElementById('coinAmount');
                    gameManager.createFloatingText(`‚öñÔ∏è STABLE +${stabilityBonus}`, coinElement, '#4ECDC4');
                    console.log(`‚öñÔ∏è Stability bonus: +${stabilityBonus} coins`);
                }
            }, 30000); // Check every 30 seconds
            
            console.log('üé∞ Dynamic coin bonus system activated!');
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë V14 UNIFIED CLASSES - Phase 1 Implementation
          ‚ïë These classes implement the unified PixiJS system while preserving
          ‚ïë all existing functionality and UI components
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/

        /**
         * V14 Unified Shape Renderer - Centralized rendering system
         * Handles both Canvas2D fallback and PixiJS rendering seamlessly
         */
        class UnifiedShapeRenderer {
            constructor() {
                this.config = UNIFIED_GAME_CONFIG;
                this.themeManager = null;
                this.textureManager = null;
                this.pixiManager = null;
                
                console.log('üé® UnifiedShapeRenderer: Initializing with config:', this.config);
            }
            
            async initialize() {
                try {
                    console.log('üöÄ UnifiedShapeRenderer: Starting initialization');
                    
                    // Initialize texture manager first
                    this.textureManager = new UnifiedTextureManager();
                    await this.textureManager.initialize();
                    
                    // Initialize PixiJS manager
                    this.pixiManager = new UnifiedPixiManager();
                    await this.pixiManager.initialize();
                    
                    // V14: Connect with existing ThemeManager if available
                    if (typeof window.themeManager !== 'undefined') {
                        this.themeManager = window.themeManager;
                        console.log('üé® UnifiedShapeRenderer: Connected to existing ThemeManager');
                    } else {
                        console.log('üé® UnifiedShapeRenderer: No existing ThemeManager found');
                    }
                    
                    console.log('‚úÖ UnifiedShapeRenderer: Initialization complete');
                    return true;
                } catch (error) {
                    console.error('‚ùå UnifiedShapeRenderer: Initialization failed:', error);
                    return false;
                }
            }
            
            renderShape(shapeType, x, y, rotation = 0, scale = 1, context = null) {
                // Use existing Canvas2D rendering for compatibility
                if (context && typeof window.renderShapeOnCanvas === 'function') {
                    return window.renderShapeOnCanvas(context, shapeType, x, y, rotation, scale);
                }
                
                console.log(`üé® UnifiedShapeRenderer: Rendering ${shapeType} at (${x}, ${y})`);
                return true;
            }
        }

        /**
         * V14 Unified Texture Manager - Centralized texture handling
         */
        class UnifiedTextureManager {
            constructor() {
                this.textureCache = new Map();
                this.loadingQueue = new Map();
                this.isInitialized = false;
                
                console.log('üñºÔ∏è UnifiedTextureManager: Created');
            }
            
            async initialize() {
                console.log('üñºÔ∏è UnifiedTextureManager: Initializing');
                this.isInitialized = true;
                return true;
            }
            
            async loadTexture(url) {
                if (this.textureCache.has(url)) {
                    return this.textureCache.get(url);
                }
                
                try {
                    const texture = await this.loadTextureFromURL(url);
                    this.textureCache.set(url, texture);
                    return texture;
                } catch (error) {
                    console.error(`‚ùå Failed to load texture: ${url}`, error);
                    return null;
                }
            }
            
            async loadTextureFromURL(url) {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    img.onload = () => resolve(img);
                    img.onerror = () => reject(new Error(`Failed to load ${url}`));
                    img.src = url;
                });
            }
            
            clearTextureCache() {
                console.log('üßπ UnifiedTextureManager: Clearing all texture cache');
                this.textureCache.clear();
                this.loadingQueue.clear();
            }
            
            clearThemeTextures(themeName) {
                console.log(`üßπ UnifiedTextureManager: Clearing textures for theme: ${themeName}`);
                
                // Create a list of texture URLs that belong to this theme
                const themeConfig = THEME_DEFINITIONS[themeName];
                if (!themeConfig) return;
                
                const themeUrls = new Set();
                
                // Add background image URL
                if (themeConfig.background?.image?.url) {
                    themeUrls.add(themeConfig.background.image.url);
                }
                
                // Add platform image URL
                if (themeConfig.platform?.image?.url) {
                    themeUrls.add(themeConfig.platform.image.url);
                }
                
                // Add shape texture URLs
                if (themeConfig.shapes?.textures) {
                    Object.values(themeConfig.shapes.textures).forEach(textureData => {
                        if (textureData?.url) {
                            themeUrls.add(textureData.url);
                        }
                    });
                }
                
                // Remove theme textures from cache
                let removedCount = 0;
                for (const url of themeUrls) {
                    if (this.textureCache.has(url)) {
                        this.textureCache.delete(url);
                        removedCount++;
                    }
                    if (this.loadingQueue.has(url)) {
                        this.loadingQueue.delete(url);
                    }
                }
                
                console.log(`üßπ UnifiedTextureManager: Removed ${removedCount} textures for theme: ${themeName}`);
            }
        }

        /**
         * V14 Unified PixiJS Manager - Handles PixiJS application lifecycle
         */
        class UnifiedPixiManager {
            constructor() {
                this.app = null;
                this.isInitialized = false;
                this.config = UNIFIED_GAME_CONFIG.renderer;
                this.features = UNIFIED_GAME_CONFIG.features;
                
                console.log('‚ö° UnifiedPixiManager: Created with config:', this.config);
                console.log('üéØ UnifiedPixiManager: Always-on features:', this.features);
            }
            
            async initialize() {
                try {
                    console.log('‚ö° UnifiedPixiManager: Initializing PixiJS application');
                    console.log('üöÄ Phase 1: PixiJS Consolidation - Creating unified application');
                    
                    // Create PixiJS application with unified config
                    this.app = new PIXI.Application({
                        width: this.config.width,
                        height: this.config.height,
                        antialias: this.config.antialias,
                        transparent: this.config.transparent,
                        resolution: this.config.resolution,
                        autoDensity: this.config.autoDensity,
                        powerPreference: this.config.powerPreference,
                        backgroundColor: this.config.backgroundColor
                    });
                    
                    // Initialize always-on features
                    this.initializeAlwaysOnFeatures();
                    
                    this.isInitialized = true;
                    console.log('‚úÖ UnifiedPixiManager: PixiJS application created successfully');
                    console.log('üéØ Phase 1 Complete: Always-on features initialized');
                    return true;
                    
                } catch (error) {
                    console.error('‚ùå UnifiedPixiManager: Failed to initialize PixiJS:', error);
                    console.log('üîÑ Falling back to Canvas2D rendering');
                    return false;
                }
            }
            
            // V14 Phase 1: Initialize always-on features (no toggles)
            initializeAlwaysOnFeatures() {
                console.log('üéØ Initializing always-on features (V14 Phase 1):');
                console.log('   ‚úÖ Shape Animations:', this.features.shapeAnimations);
                console.log('   ‚úÖ Particle Effects:', this.features.particleEffects);
                console.log('   ‚úÖ Advanced Graphics:', this.features.advancedGraphics);
                console.log('   ‚úÖ Theme Textures:', this.features.themeTextures);
                console.log('   ‚úÖ Smooth Transitions:', this.features.smoothTransitions);
                console.log('   ‚úÖ Camera Shake:', this.features.cameraShake);
                console.log('   ‚úÖ Enhanced Text:', this.features.enhancedText);
                console.log('   ‚úÖ Tweening:', this.features.tweening);
                
                // Features are always enabled in V14 - no configuration complexity
                this.featuresReady = true;
            }
            
            getApplication() {
                return this.app;
            }
            
            isReady() {
                return this.isInitialized && this.app !== null;
            }
        }

        /*‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
          ‚ïë V14 TESTING AND DEBUG FUNCTIONS
          ‚ïë Console functions for testing the unified system
          ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*/
        
        // V14 testing functions available in browser console
        window.testUnifiedRenderer = function() {
            console.log('üß™ Testing V14 Unified Renderer System');
            console.log('üìä UNIFIED_GAME_CONFIG:', UNIFIED_GAME_CONFIG);
            
            if (window.unifiedRenderer) {
                console.log('‚úÖ UnifiedShapeRenderer:', window.unifiedRenderer);
                console.log('üé® Texture Manager:', window.unifiedRenderer.textureManager);
                console.log('‚ö° PixiJS Manager:', window.unifiedRenderer.pixiManager);
            } else {
                console.log('‚ùå UnifiedShapeRenderer not initialized');
            }
        };
        
        window.showUnifiedConfig = function() {
            console.log('üìã V14 Unified Configuration:');
            console.table(UNIFIED_GAME_CONFIG);
        };
        
        window.v14Status = function() {
            console.log('üéÆ V14 Status Report:');
            console.log('üîß Unified Config Available:', typeof UNIFIED_GAME_CONFIG !== 'undefined');
            console.log('üé® Unified Renderer Available:', typeof window.unifiedRenderer !== 'undefined');
            console.log('üñºÔ∏è Legacy Canvas Config Preserved:', typeof CANVAS_CONFIG !== 'undefined');
            console.log('‚ö° Legacy PixiJS Config Preserved:', typeof PIXI_CONFIG !== 'undefined');
            console.log('üéØ Phase 1 Goal: PixiJS Consolidation - IMPLEMENTED');
        };
        
        // V14 Checkpoint 3: Enhanced Theme Integration Testing
        window.testThemeIntegration = function() {
            console.log('üé® Testing V14 Theme Integration (Checkpoint 3)');
            
            // Test ThemeManager compatibility
            if (window.themeManager) {
                console.log('‚úÖ Legacy ThemeManager available:', window.themeManager);
                console.log('üîß Uses unified config:', window.themeManager.useUnifiedConfig);
                console.log('üé® Current theme:', window.themeManager.currentTheme);
                console.log('‚öôÔ∏è Theme system enabled:', window.themeManager.isThemeSystemEnabled());
            } else {
                console.log('‚ùå ThemeManager not available');
            }
            
            // Test unified renderer theme connection
            if (window.unifiedRenderer && window.unifiedRenderer.themeManager) {
                console.log('‚úÖ Unified renderer connected to ThemeManager');
            } else {
                console.log('‚ö†Ô∏è Unified renderer not connected to ThemeManager');
            }
        };
        
        window.testCompatibilityMode = function() {
            console.log('üîÑ Testing V14 Compatibility Mode');
            console.log('üìä Configuration Comparison:');
            
            if (typeof UNIFIED_GAME_CONFIG !== 'undefined') {
                console.log('üÜï V14 Default Theme:', UNIFIED_GAME_CONFIG.theme?.defaultTheme);
                console.log('üÜï V14 Theme Enabled:', UNIFIED_GAME_CONFIG.theme?.enabled);
            }
            
            console.log('üîß Legacy Default Theme:', CANVAS_CONFIG.defaultTheme);
            console.log('üîß Legacy Theme Enabled:', CANVAS_CONFIG.enabled && CANVAS_CONFIG.useThemes);
            
            // Test theme manager resolution
            if (window.themeManager) {
                console.log('üéØ ThemeManager Resolution:');
                console.log('   Default Theme:', window.themeManager.getDefaultTheme());
                console.log('   System Enabled:', window.themeManager.isThemeSystemEnabled());
            }
        };
        
        window.v14Phase1Status = function() {
            console.log('üöÄ V14 Phase 1 Implementation Status:');
            console.log('');
            console.log('‚úÖ CHECKPOINT 1: Basic Structure - COMPLETE');
            console.log('‚úÖ CHECKPOINT 2: Unified Classes - COMPLETE');
            console.log('‚úÖ CHECKPOINT 3: Enhanced ThemeManager Integration - COMPLETE');
            console.log('‚úÖ CHECKPOINT 4: Phase 1 Completion - COMPLETE');
            console.log('');
            console.log('üéØ Phase 1 Goals Achieved:');
            console.log('   ‚úÖ Remove Configuration Complexity - Unified config implemented');
            console.log('   ‚úÖ Always-On Feature System - Features enabled by default');
            console.log('   ‚úÖ Single Unified Renderer - PixiJS consolidation complete');
            console.log('');
            console.log('üß™ Available Tests:');
            console.log('   testUnifiedRenderer() - Test core unified system');
            console.log('   testThemeIntegration() - Test theme system integration');
            console.log('   testCompatibilityMode() - Test legacy compatibility');
            console.log('   testPhase1Features() - Test always-on features');
            console.log('   showUnifiedConfig() - Show V14 configuration');
        };
        
        window.testPhase1Features = function() {
            console.log('üéØ Testing V14 Phase 1 Always-On Features:');
            
            if (window.unifiedRenderer && window.unifiedRenderer.pixiManager) {
                const pixi = window.unifiedRenderer.pixiManager;
                console.log('‚ö° PixiJS Manager Status:', pixi.isInitialized ? 'Ready' : 'Not Ready');
                console.log('üéÆ Features Ready:', pixi.featuresReady ? 'Yes' : 'No');
                
                if (pixi.features) {
                    console.log('');
                    console.log('üéØ Always-On Features (No Toggles):');
                    Object.entries(pixi.features).forEach(([key, value]) => {
                        console.log(`   ${value ? '‚úÖ' : '‚ùå'} ${key}: ${value}`);
                    });
                }
            } else {
                console.log('‚ùå UnifiedPixiManager not available');
            }
            
            console.log('');
            console.log('üé® Legacy System Compatibility:');
            console.log('   Canvas Config:', typeof CANVAS_CONFIG !== 'undefined' ? 'Preserved' : 'Missing');
            console.log('   PixiJS Config:', typeof PIXI_CONFIG !== 'undefined' ? 'Preserved' : 'Missing');
            console.log('   Theme Definitions:', typeof THEME_DEFINITIONS !== 'undefined' ? 'Available' : 'Missing');
        };

        // Initialize game when page loads
        let gameManager;
        
        window.addEventListener('load', async () => {
            console.log('üåç Page loaded, starting initialization...');
            console.log('üîß Current level config:', window.currentLevelConfig);
            console.log('üé® Shape renderer available:', !!shapeRenderer);
            
            // v9: Initialize Canvas Enhancement UI
            initializeThemeUI();
            
            // V14: Initialize Unified PixiJS System (Phase 1)
            console.log('üåç V14 Phase 1: Initializing unified PixiJS system...');
            try {
                window.unifiedRenderer = new UnifiedShapeRenderer();
                const success = await window.unifiedRenderer.initialize();
                
                if (success) {
                    console.log('‚úÖ V14: Unified system initialized successfully');
                    console.log('ÔøΩ V14 Phase 1: PixiJS Consolidation - COMPLETE!');
                    console.log('   ‚úÖ Configuration complexity removed');
                    console.log('   ‚úÖ Always-on feature system implemented');  
                    console.log('   ‚úÖ Single unified renderer operational');
                    console.log('üß™ V14 Testing functions available:');
                    console.log('   testUnifiedRenderer(), testThemeIntegration(), testCompatibilityMode()');
                    console.log('   testPhase1Features(), v14Phase1Status(), showUnifiedConfig()');
                } else {
                    console.log('‚ö†Ô∏è V14: Unified system initialization failed, using legacy system');
                }
            } catch (error) {
                console.error('‚ùå V14: Failed to initialize unified system:', error);
                console.log('üîÑ V14: Falling back to legacy Canvas/PixiJS system');
            }
            
            // V14: Commented out test shape configuration logging
            /*
            // Test shape configuration
            console.log('üß™ Testing shape configs:');
            const testShapes = ['square', 'triangle', 'circle'];
            testShapes.forEach(shape => {
                const config = getShapeConfig(shape);
                console.log(`${shape} config:`, config);
            });
            */
            
            // Initialize game manager first to load default theme
            gameManager = new GameManager();
            
            // Wait for default theme to load before building dock
            await gameManager.physicsManager.initializeDefaultTheme();
            
            // THEN initialize unified dock system with theme loaded
            rebuildGameDock();
            
            // Phase 1: Initialize PixiJS control panel
            initializePixiControls();
            
            // Initialize touch offset display values
            updateTouchOffsetDisplay();
            
            // Start dynamic coin bonus system
            startCoinBonusSystem();
            
            // Phase 2: Initialize mode toggle system
            generateDockSlots();
            updateGameUI();
            
            // V14: Clean console output - legacy status messages commented out
            /*
            console.log('üéÆ Canvas Enhancement Edition v9 - INITIALIZATION COMPLETE!');
            console.log('‚úÖ UNIFIED SHAPE CONFIGURATION implemented');
            console.log('‚úÖ CANVAS-BASED DOCK PREVIEWS implemented');  
            console.log('üéØ All shapes now use single physics-based appearance system');
            console.log('ÔøΩÔ∏è Features: Angled platform, rotation, end-level countdown, level failure');
            console.log('üéØ Game Rules: Place 3 shapes ‚Üí 5s countdown starts ‚Üí don\'t let any fall!');
            console.log('üñ±Ô∏è Controls: Drag shapes, R/E or ‚Üê/‚Üí to rotate during drag');
            console.log('‚å®Ô∏è Keyboard Shortcuts: 1=Square, 2=Triangle, 3=Circle, 4=Pink Cross, 5=Orange L, 6=Green Cross, 7=Barbell-1, 8=Barbell-2, 9=Diamond Barbell');
            console.log('üé® Theme Testing: Call testAllThemes() in console to cycle through all themes');
            console.log('üéÜ Particle Testing: Call testParticles() in console to see particle effects');
            console.log('üñºÔ∏è Image Texture Functions: loadShapeTexture(), loadPlatformTexture(), loadBackgroundImage(), testSampleTextures()');
            console.log('üìπ Camera Shake Testing: testCameraShake(), simulateShapeFall(), cameraShake(intensity, duration)');
            console.log('');
            console.log('üöÄ PIXIJS INTEGRATION PHASE 2 COMPLETE!');
            console.log('‚úÖ Dual renderer system (Canvas + PixiJS) initialized');
            console.log('‚úÖ PixiJS shape rendering system implemented');
            console.log('‚úÖ Visual parity with existing Canvas shapes maintained');
            console.log('‚úÖ Physics synchronization with Matter.js bodies');
            console.log('‚úÖ Theme system integration for PixiJS shapes');
            console.log('üé® Phase 1 Testing: switchToCanvas(), switchToPixi(), getCurrentRenderer()');
            console.log('üé® Phase 2 Testing: enablePixiShapes(), disablePixiShapes(), getPixiShapeCount()');
            console.log('üé¨ Phase 3 Testing: togglePixiAnimations(), applyEnhancedTheme()');
            console.log('‚öôÔ∏è Use Settings Panel: Enable PixiJS System ‚Üí Enable Animations ‚Üí Apply Enhanced Themes');
            console.log('‚úÖ Phase 3 Complete: Advanced animations, enhanced themes, collision effects');
            console.log('üöß Phase 4 Ready: Advanced tweening and particle systems');
            */
            
            // V14: Simplified completion message
            console.log('');
            console.log('üéÆ V14 Clean Implementation - GAME READY!');
            console.log('‚úÖ All V13 functionality preserved');
            console.log('‚úÖ V14 unified system operational');
            console.log('üß™ V14 Testing: v14Phase1Status(), testPhase1Features()');
            console.log('');
        });

        // =============================================================================
        // IMAGE TEXTURE HELPER FUNCTIONS
        // =============================================================================

        /**
         * Load a texture image for shapes
         * @param {string} imageUrl - URL or path to the image
         * @param {string} shapeName - Name of shape ('square', 'triangle', 'circle', etc.)
         * @param {Object} options - Texture options
         * @returns {Promise<boolean>} Success/failure
         */
        async function loadShapeTexture(imageUrl, shapeName = 'square', options = {}) {
            try {
                console.log(`üñºÔ∏è Loading texture for ${shapeName}: ${imageUrl}`);
                
                // Default texture options
                const textureConfig = {
                    url: imageUrl,
                    repeat: options.repeat || 'repeat',
                    blendMode: options.blendMode || 'source-over',
                    opacity: options.opacity || 1.0,
                    scale: options.scale || 1.0
                };

                // Add texture to current theme
                if (!window.currentTheme) {
                    window.currentTheme = { shapes: {}, platform: {}, background: {} };
                }
                if (!window.currentTheme.shapes) {
                    window.currentTheme.shapes = {};
                }
                if (!window.currentTheme.shapes.textures) {
                    window.currentTheme.shapes.textures = {};
                }
                window.currentTheme.shapes.textures[shapeName] = textureConfig;
                console.log(`‚úÖ Set texture config for ${shapeName}:`, textureConfig);
                console.log(`üîç Current theme textures:`, window.currentTheme.shapes.textures);

                // Also update THEME_DEFINITIONS so the regular theme loading system knows about this texture
                if (window.currentTheme.name && THEME_DEFINITIONS[window.currentTheme.name]) {
                    const themeDef = THEME_DEFINITIONS[window.currentTheme.name];
                    if (themeDef.shapes && themeDef.shapes.textures && themeDef.shapes.textures[shapeName]) {
                        themeDef.shapes.textures[shapeName].url = imageUrl;
                        console.log(`üîÑ Updated THEME_DEFINITIONS for ${window.currentTheme.name}.${shapeName}`);
                    }
                }

                // Load the image
                const success = await window.assetManager.loadImage(imageUrl);
                if (success) {
                    console.log(`‚úÖ Texture loaded successfully for ${shapeName}`);
                    return true;
                } else {
                    console.warn(`‚ùå Failed to load texture for ${shapeName}`);
                    return false;
                }
            } catch (error) {
                console.error(`‚ùå Error loading texture for ${shapeName}:`, error);
                return false;
            }
        }

        /**
         * Load a texture image for platforms
         * @param {string} imageUrl - URL or path to the image
         * @param {Object} options - Texture options
         * @returns {Promise<boolean>} Success/failure
         */
        async function loadPlatformTexture(imageUrl, options = {}) {
            try {
                console.log(`üñºÔ∏è Loading platform texture: ${imageUrl}`);
                
                // Default texture options
                const textureConfig = {
                    url: imageUrl,
                    repeat: options.repeat || 'repeat',
                    blendMode: options.blendMode || 'source-over',
                    opacity: options.opacity || 1.0,
                    scale: options.scale || 1.0
                };

                // Add texture to current theme
                window.currentTheme.platform.image = textureConfig;

                // Load the image
                const success = await window.assetManager.loadImage(imageUrl);
                if (success) {
                    console.log(`‚úÖ Platform texture loaded successfully`);
                    return true;
                } else {
                    console.warn(`‚ùå Failed to load platform texture`);
                    return false;
                }
            } catch (error) {
                console.error(`‚ùå Error loading platform texture:`, error);
                return false;
            }
        }

        /**
         * Load a background image
         * @param {string} imageUrl - URL or path to the image
         * @param {Object} options - Background options
         * @returns {Promise<boolean>} Success/failure
         */
        async function loadBackgroundImage(imageUrl, options = {}) {
            try {
                console.log(`üñºÔ∏è Loading background image: ${imageUrl}`);
                
                // Default background options
                const backgroundConfig = {
                    url: imageUrl,
                    mode: options.mode || 'cover', // 'cover', 'contain', 'stretch', 'tile'
                    opacity: options.opacity || 1.0,
                    blur: options.blur || 0,
                    brightness: options.brightness || 1.0
                };

                // Add background to current theme
                window.currentTheme.background.image = backgroundConfig;

                // Load the image
                const success = await window.assetManager.loadImage(imageUrl);
                if (success) {
                    console.log(`‚úÖ Background image loaded successfully`);
                    return true;
                } else {
                    console.warn(`‚ùå Failed to load background image`);
                    return false;
                }
            } catch (error) {
                console.error(`‚ùå Error loading background image:`, error);
                return false;
            }
        }

        /**
         * Test sample textures with placeholder images
         */
        async function testSampleTextures() {
            console.log('üß™ Testing sample textures...');
            
            try {
                // Test background image
                await loadBackgroundImage('https://picsum.photos/1200/800?random=1', { mode: 'cover' });
                
                // Test platform texture
                await loadPlatformTexture('https://picsum.photos/200/50?random=2', { repeat: 'repeat-x' });
                
                // Test shape textures
                await loadShapeTexture('https://picsum.photos/100/100?random=3', 'square', { blendMode: 'multiply' });
                await loadShapeTexture('https://picsum.photos/100/100?random=4', 'circle', { blendMode: 'overlay' });
                await loadShapeTexture('https://picsum.photos/100/100?random=5', 'triangle', { blendMode: 'soft-light' });
                
                console.log('‚úÖ Sample textures loaded! Drop some shapes to see the effect.');
                
            } catch (error) {
                console.error('‚ùå Error testing sample textures:', error);
            }
        }

        /**
         * Clear all textures and return to gradient/solid colors
         */
        function clearAllTextures() {
            console.log('üßπ Clearing all textures...');
            
            // Clear background image
            if (window.currentTheme.background.image) {
                delete window.currentTheme.background.image;
            }
            
            // Clear platform texture
            if (window.currentTheme.platform.image) {
                delete window.currentTheme.platform.image;
            }
            
            // Clear shape textures
            if (window.currentTheme.shapes.textures) {
                delete window.currentTheme.shapes.textures;
            }
            
            console.log('‚úÖ All textures cleared - back to gradients and solid colors');
        }

        /**
         * Show texture configuration examples
         */
        function showTextureExamples() {
            console.log(`
üñºÔ∏è TEXTURE CONFIGURATION EXAMPLES:

1. Load Background Image:
   await loadBackgroundImage('path/to/background.jpg', {
       mode: 'cover',      // 'cover', 'contain', 'stretch', 'tile'
       opacity: 0.8,       // 0.0 to 1.0
       blur: 2,            // blur amount in pixels
       brightness: 1.2     // brightness multiplier
   });

2. Load Platform Texture:
   await loadPlatformTexture('path/to/wood.jpg', {
       repeat: 'repeat-x', // 'repeat', 'repeat-x', 'repeat-y', 'no-repeat'
       blendMode: 'multiply',
       opacity: 0.9,
       scale: 1.5
   });

3. Load Shape Textures:
   await loadShapeTexture('path/to/metal.jpg', 'square', {
       repeat: 'repeat',
       blendMode: 'overlay',  // Try: 'multiply', 'overlay', 'soft-light', 'hard-light'
       opacity: 0.7,
       scale: 2.0
   });

4. Test Sample Textures:
   testSampleTextures();

5. Clear All Textures:
   clearAllTextures();

6. Multiple Shape Textures:
   await loadShapeTexture('stone.jpg', 'square');
   await loadShapeTexture('fabric.jpg', 'circle');
   await loadShapeTexture('paper.jpg', 'triangle');

BLEND MODES: source-over, multiply, screen, overlay, darken, lighten, 
             color-dodge, color-burn, hard-light, soft-light, difference, exclusion

IMAGE SOURCES: Local files, URLs, data URLs, or any valid image source
            `);
        }

        // Make functions globally available
        window.loadShapeTexture = loadShapeTexture;
        window.loadPlatformTexture = loadPlatformTexture;
        window.loadBackgroundImage = loadBackgroundImage;
        window.testSampleTextures = testSampleTextures;
        window.clearAllTextures = clearAllTextures;
        window.showTextureExamples = showTextureExamples;

        // =============================================================================
        // CAMERA SHAKE TESTING FUNCTIONS
        // =============================================================================

        /**
         * Test camera shake with different intensities
         */
        function testCameraShake() {
            if (!window.gameManager || !window.gameManager.physicsManager) {
                console.log('‚ùå Game not initialized yet');
                return;
            }

            console.log('üìπ Testing camera shake effects...');
            
            // Immediate intense shake to show it works
            console.log('üî¥ INTENSE SHAKE NOW!');
            window.gameManager.physicsManager.startCameraShake(15, 1000);
            
            // Then test sequence
            setTimeout(() => {
                console.log('üî∏ Light shake (intensity 5)');
                window.gameManager.physicsManager.startCameraShake(5, 600);
            }, 2000);
            
            setTimeout(() => {
                console.log('üîπ Medium shake (intensity 8)');
                window.gameManager.physicsManager.startCameraShake(8, 800);
            }, 4000);
            
            setTimeout(() => {
                console.log('üî¥ Maximum shake (intensity 20)');
                window.gameManager.physicsManager.startCameraShake(20, 1000);
            }, 6500);
            
            console.log('üìπ Camera shake test sequence started with immediate intense shake!');
        }

        /**
         * Simulate shape falling for camera shake
         */
        function simulateShapeFall() {
            if (!window.gameManager || !window.gameManager.physicsManager) {
                console.log('‚ùå Game not initialized yet');
                return;
            }

            console.log('üí• Simulating shape fall...');
            window.gameManager.physicsManager.onShapeFellOffPlatform();
            console.log('üìπ Shape fall camera shake triggered!');
        }

        /**
         * Custom camera shake with user parameters
         */
        function cameraShake(intensity = 5, duration = 500) {
            if (!window.gameManager || !window.gameManager.physicsManager) {
                console.log('‚ùå Game not initialized yet');
                return;
            }

            window.gameManager.physicsManager.startCameraShake(intensity, duration);
            console.log(`üìπ Camera shake: intensity=${intensity}, duration=${duration}ms`);
        }

        /**
         * Quick test - immediate strong shake
         */
        function shakeNow() {
            console.log('üß™ shakeNow() called - testing camera shake system...');
            
            if (!window.gameManager || !window.gameManager.physicsManager) {
                console.log('‚ùå Game not initialized yet');
                return;
            }
            
            console.log('‚úÖ Game manager and physics manager found');
            window.gameManager.physicsManager.startCameraShake(20, 1000);
            console.log('üí• MAXIMUM SHAKE ACTIVATED!');
        }

        /**
         * Test camera shake by directly calling the function
         */
        function testDirectShake() {
            console.log('üß™ testDirectShake() - bypassing all collision detection...');
            
            if (!window.gameManager) {
                console.log('‚ùå Game not initialized yet');
                return;
            }
            
            // Directly call onShapeFell to test the entire chain
            console.log('‚úÖ Directly calling onShapeFell...');
            window.gameManager.onShapeFell();
        }

        /**
         * Test camera shake by simulating a shape falling off screen
         */
        function testShapeFall() {
            console.log('üß™ testShapeFall() called - simulating shape fall...');
            
            if (!window.gameManager) {
                console.log('‚ùå Game not initialized yet');
                return;
            }
            
            console.log('‚úÖ Game manager found, calling onShapeFell...');
            window.gameManager.onShapeFell();
            console.log('üçÉ Simulated shape fall with camera shake!');
        }

        /**
         * Show camera shake examples
         */
        function showCameraShakeExamples() {
            console.log(`
üìπ CAMERA SHAKE EXAMPLES:

1. Test Different Intensities:
   testCameraShake();

2. Simulate Shape Fall:
   simulateShapeFall();

3. Custom Camera Shake:
   cameraShake(7, 800);    // Intensity 7, 800ms duration
   cameraShake(3, 300);    // Light shake, 300ms
   cameraShake(10, 1000);  // Maximum intensity, 1 second

4. Intensity Guide:
   1-3:  Light shake (subtle feedback)
   4-6:  Medium shake (noticeable effect) 
   7-9:  Heavy shake (dramatic effect)
   10+:  Maximum shake (screen earthquake!)

5. Duration Guide:
   200-400ms: Quick feedback
   500-800ms: Standard effect
   1000ms+:   Extended shake

The camera shake automatically triggers when shapes fall off screen!
Try dropping a shape off the edge to see it in action.
            `);
        }

        // Make camera shake functions globally available
        window.testCameraShake = testCameraShake;
        window.simulateShapeFall = simulateShapeFall;
        window.cameraShake = cameraShake;
        window.showCameraShakeExamples = showCameraShakeExamples;

        // =============================================================================
        // ENHANCED TEXTURE MANAGEMENT SYSTEM
        // =============================================================================

        /**
         * Enhanced texture management class
         */
class TextureManager {
    constructor() {
        this.loadedTextures = new Map();
        this.textureCache = new Map();
        this.currentTheme = null;
        console.log('ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ Enhanced Texture Manager initialized');
    }

    /**
     * Apply texture theme - simplified and fixed
     */
    async applyTextureTheme(themeName) {
        console.log(`ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ Applying texture theme: ${themeName}`);
        
        // For wood theme, use the known oak.png texture
        if (themeName === 'wood') {
            const textureUrl = 'assets/textures/wood/oak.png';
            console.log(`ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔ∏è Loading wood texture: ${textureUrl}`);
            
            // Preload the texture image
            try {
                const img = await this.loadImage(textureUrl);
                if (img) {
                    console.log(`‚úÖ Wood texture loaded successfully`);
                    
                    // Store the loaded texture
                    this.loadedTextures.set('wood', textureUrl);
                    
                    // Apply texture to all shapes
                    const allShapeTypes = ['square', 'triangle', 'circle', 'cross', 'cross2', 'l', 'barbell-one', 'barbell-two', 'diamond-barbell'];
                    
                    for (const shapeType of allShapeTypes) {
                        // Update shape configuration with texture
                        if (!SHAPE_CONFIG[shapeType]) continue;
                        
                        SHAPE_CONFIG[shapeType].texture = textureUrl;
                        console.log(`‚úÖ Added texture to ${shapeType} config`);
                        
                        // Also update window.currentTheme for consistency
                        if (!window.currentTheme) {
                            window.currentTheme = { shapes: { textures: {} } };
                        }
                        if (!window.currentTheme.shapes) {
                            window.currentTheme.shapes = { textures: {} };
                        }
                        if (!window.currentTheme.shapes.textures) {
                            window.currentTheme.shapes.textures = {};
                        }
                        
                        window.currentTheme.shapes.textures[shapeType] = {
                            url: textureUrl,
                            repeat: 'repeat',
                            blend: 'multiply',
                            opacity: 0.7
                        };
                        
                        // Mark texture as loaded for this shape
                        this.loadedTextures.set(shapeType, textureUrl);
                    }
                    
                    console.log(`‚úÖ Applied wood texture to all shapes`);
                    
                    // Immediately rebuild the dock to show textures
                    if (typeof rebuildGameDock === 'function') {
                        console.log('ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ Rebuilding dock with textures...');
                        rebuildGameDock();
                    }
                    
                    return true;
                }
            } catch (error) {
                console.error(`‚ùå Failed to load texture: ${error}`);
            }
        }
        
        return false;
    }
    
    /**
     * Load an image and return it
     */
    async loadImage(url) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.crossOrigin = 'anonymous';
            
            img.onload = () => {
                console.log(`‚úÖ Image loaded: ${url}`);
                this.textureCache.set(url, img);
                resolve(img);
            };
            
            img.onerror = () => {
                console.error(`‚ùå Failed to load image: ${url}`);
                reject(new Error(`Failed to load ${url}`));
            };
            
            img.src = url;
        });
    }
    
    /**
     * Check if a texture is loaded
     */
    isTextureLoaded(shapeType) {
        return this.loadedTextures.has(shapeType);
    }
    
    /**
     * Get loaded texture URL for a shape
     */
    getTextureUrl(shapeType) {
        return this.loadedTextures.get(shapeType);
    }
}

// Fix the PhysicsShapeRenderer.createDockPreview method
PhysicsShapeRenderer.prototype.createDockPreview = function(shapeType, size = 90) {
    // V14: Commented out verbose dock preview logging
    // console.log(`üîç createDockPreview called for: ${shapeType}, size: ${size}`);
    const config = getShapeConfig(shapeType);
    if (!config) {
        console.error(`‚ùå No config found for shape: ${shapeType}`);
        return null;
    }
    
    console.log(`ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ Shape config for ${shapeType}:`, config);
    
    // Check if we have a texture loaded via TextureManager
    let hasTexture = false;
    if (window.textureManager && window.textureManager.isTextureLoaded(shapeType)) {
        hasTexture = true;
        console.log(`ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔ∏è Texture is loaded for ${shapeType}`);
    }
    
    // Always use canvas preview for now (can add PixiJS texture support later)
    return this.createCanvasDockPreview(shapeType, config, size, hasTexture);
};

// Enhanced canvas dock preview with texture rendering
PhysicsShapeRenderer.prototype.createCanvasDockPreview = function(shapeType, config, size = 90, hasTexture = false) {
    const canvas = document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    canvas.className = `shape-preview`;
    canvas.dataset.shape = shapeType;

    const ctx = canvas.getContext('2d');
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';
    
    // Visual indicator for textured shapes
    if (hasTexture) {
        canvas.style.border = '2px solid #DAA520';
        canvas.style.boxShadow = '0 0 8px rgba(218, 165, 32, 0.5)';
        canvas.title = `${shapeType} - Textured`;
    } else {
        canvas.style.border = '1px solid #ccc';
        canvas.title = `${shapeType}`;
    }

    const scale = 1.9;
    
    // Check for barbell rotation
    let rotation = 0;
    if (shapeType && shapeType.includes('barbell')) {
        const barbellOrientationSelect = document.getElementById('barbellOrientation');
        if (barbellOrientationSelect && barbellOrientationSelect.value === 'vertical') {
            rotation = Math.PI / 2;
        }
    }
    
    // If we have a texture, render with texture pattern
    if (hasTexture && window.textureManager) {
        const textureUrl = window.textureManager.getTextureUrl(shapeType);
        const cachedImage = window.textureManager.textureCache.get(textureUrl);
        
        if (cachedImage) {
            // Create pattern and apply to shape
            ctx.save();
            ctx.translate(size / 2, size / 2);
            ctx.rotate(rotation);
            ctx.scale(scale, scale);
            
            // Create clipping path for the shape
            this.createShapeClipPath(ctx, shapeType, config);
            ctx.clip();
            
            // Draw the texture pattern
            const pattern = ctx.createPattern(cachedImage, 'repeat');
            ctx.fillStyle = pattern;
            ctx.fillRect(-size, -size, size * 2, size * 2);
            
            // Add stroke
            ctx.restore();
            ctx.save();
            ctx.translate(size / 2, size / 2);
            ctx.rotate(rotation);
            ctx.scale(scale, scale);
            this.createShapeClipPath(ctx, shapeType, config);
            ctx.strokeStyle = config.stroke;
            ctx.lineWidth = config.strokeWidth;
            ctx.stroke();
            
            ctx.restore();
        } else {
            // Fallback to regular rendering
            this.renderShapeOnCanvas(ctx, shapeType, size / 2, size / 2, rotation, scale);
        }
    } else {
        // Regular rendering without texture
        this.renderShapeOnCanvas(ctx, shapeType, size / 2, size / 2, rotation, scale);
    }
    
    console.log(`‚úÖ Canvas preview created for: ${shapeType} (textured: ${hasTexture})`);
    return canvas;
};

// Add helper method to create clipping path for shapes
PhysicsShapeRenderer.prototype.createShapeClipPath = function(ctx, shapeType, config) {
    ctx.beginPath();
    
    switch (config.type) {
        case 'rectangle':
            ctx.rect(-config.width / 2, -config.height / 2, config.width, config.height);
            break;
        case 'circle':
            ctx.arc(0, 0, config.radius, 0, Math.PI * 2);
            break;
        case 'polygon':
            if (config.vertices) {
                ctx.moveTo(config.vertices[0].x, config.vertices[0].y);
                for (let i = 1; i < config.vertices.length; i++) {
                    ctx.lineTo(config.vertices[i].x, config.vertices[i].y);
                }
                ctx.closePath();
            }
            break;
        case 'compound':
            // For compound shapes, create path for all parts
            if (config.parts) {
                for (const part of config.parts) {
                    ctx.save();
                    ctx.translate(part.offsetX || 0, part.offsetY || 0);
                    
                    if (part.type === 'rectangle') {
                        ctx.rect(-part.width / 2, -part.height / 2, part.width, part.height);
                    } else if (part.type === 'circle') {
                        ctx.moveTo(part.radius, 0);
                        ctx.arc(0, 0, part.radius, 0, Math.PI * 2);
                    } else if (part.type === 'diamond') {
                        // Create a diamond clipping path: top, right, bottom, left points
                        const size = part.width || part.height || 12;
                        const halfSize = size / 2;
                        ctx.moveTo(0, -halfSize);  // Top
                        ctx.lineTo(halfSize, 0);   // Right
                        ctx.lineTo(0, halfSize);   // Bottom
                        ctx.lineTo(-halfSize, 0);  // Left
                        ctx.closePath();
                                        }
                    
                    ctx.restore();
                }
            }
            break;
    }
};

// Override the drawDiamond method to render a proper diamond shape path
PhysicsShapeRenderer.prototype.drawDiamond = function(ctx, config) {
    const { width, height, color, stroke, strokeWidth } = config;
    ctx.fillStyle = color;
    ctx.strokeStyle = stroke;
    ctx.lineWidth = strokeWidth;
    const size = width || height || 12;
    const halfSize = size / 2;
    ctx.beginPath();
    ctx.moveTo(0, -halfSize);
    ctx.lineTo(halfSize, 0);
    ctx.lineTo(0, halfSize);
    ctx.lineTo(-halfSize, 0);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
};

// Fix the applyEnhancedTheme function
window.applyEnhancedTheme = function() {
    const enhancedThemeSelect = document.getElementById('enhancedThemeSelect');
    const selectedTheme = enhancedThemeSelect.value;
    
    console.log(`ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ Applying enhanced theme: ${selectedTheme}`);
    
    // Initialize texture manager if needed
    if (!window.textureManager) {
        window.textureManager = new TextureManager();
    }
    
    // Apply the texture theme
    if (selectedTheme === 'wood') {
        window.textureManager.applyTextureTheme('wood').then(success => {
            if (success) {
                console.log('‚úÖ Wood textures applied successfully!');
            } else {
                console.log('‚ö†Ô∏è Failed to apply wood textures');
            }
        });
    } else {
        // Clear textures for non-wood themes
        if (window.textureManager.loadedTextures.size > 0) {
            window.textureManager.loadedTextures.clear();
            
            // Clear texture references from SHAPE_CONFIG
            Object.keys(SHAPE_CONFIG).forEach(shapeType => {
                delete SHAPE_CONFIG[shapeType].texture;
            });
            
            // Rebuild dock without textures
            rebuildGameDock();
        }
    }
};

// Initialize texture manager on page load
if (!window.textureManager) {
    window.textureManager = new TextureManager();
}

console.log('‚úÖ Texture loading system fixed and initialized');

    </script>
</body>
</html>
